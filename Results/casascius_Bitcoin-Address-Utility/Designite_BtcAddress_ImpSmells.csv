Implementation smell,Namespace,Class,File,Method,Description
Long Method,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The method has 102 lines of code.
Long Method,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The method has 193 lines of code.
Long Method,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The method has 101 lines of code.
Long Method,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The method has 509 lines of code.
Long Method,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The method has 325 lines of code.
Long Method,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The method has 215 lines of code.
Long Method,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The method has 108 lines of code.
Long Method,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The method has 183 lines of code.
Long Method,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The method has 166 lines of code.
Long Method,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The method has 106 lines of code.
Long Method,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The method has 219 lines of code.
Long Method,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The method has 130 lines of code.
Long Method,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The method has 120 lines of code.
Long Method,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The method has 529 lines of code.
Long Method,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The method has 397 lines of code.
Long Method,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The method has 205 lines of code.
Complex Method,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,btnCombine_Click,Cyclomatic complexity of the method is 8
Complex Method,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,DisplayKeyCollectionItem,Cyclomatic complexity of the method is 9
Complex Method,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,btnGenerateAddresses_Click,Cyclomatic complexity of the method is 11
Complex Method,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,btnPrintWallet_Click,Cyclomatic complexity of the method is 8
Complex Method,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,Cyclomatic complexity of the method is 17
Complex Method,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,button1_Click,Cyclomatic complexity of the method is 12
Complex Method,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,Cyclomatic complexity of the method is 9
Complex Method,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,Cyclomatic complexity of the method is 15
Complex Method,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,Cyclomatic complexity of the method is 18
Complex Method,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,Cyclomatic complexity of the method is 8
Complex Method,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,Cyclomatic complexity of the method is 15
Complex Method,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,Cyclomatic complexity of the method is 14
Complex Method,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,Cyclomatic complexity of the method is 13
Complex Method,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,CombineAndReduce,Cyclomatic complexity of the method is 9
Complex Method,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,KillFactors,Cyclomatic complexity of the method is 12
Complex Method,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,InterpretBatch,Cyclomatic complexity of the method is 9
Complex Method,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,btnGenerateAddresses_Click,Cyclomatic complexity of the method is 11
Complex Method,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,Cyclomatic complexity of the method is 14
Complex Method,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,btnDecrypt_Click,Cyclomatic complexity of the method is 8
Long Parameter List,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The method has 5 parameters. Parameters: identifier30' networkbyte' flagbyte' z' hash160
Long Parameter List,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,parseEitherCode,The method has 5 parameters. Parameters: thecode' notvalid' notvalid2' invbytes' head
Long Parameter List,CryptSharp.Utility,Pbkdf2,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Pbkdf2.cs,Pbkdf2,The method has 5 parameters. Parameters: key' salt' iterations' computeHmacCallback' hmacLength
Long Parameter List,CryptSharp.Utility,Pbkdf2,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Pbkdf2.cs,ComputeKey,The method has 6 parameters. Parameters: key' salt' iterations' computeHmacCallback' hmacLength' output
Long Parameter List,CryptSharp.Utility,Pbkdf2,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Pbkdf2.cs,Reopen,The method has 5 parameters. Parameters: key' salt' iterations' computeHmacCallback' hmacLength
Long Parameter List,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The method has 6 parameters. Parameters: rounds' input' inputOffset' output' outputOffset' x
Long Parameter List,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,ComputeKey,The method has 7 parameters. Parameters: key' salt' cost' blockSize' parallel' maxThreads' output
Long Parameter List,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,GetEffectivePbkdf2Salt,The method has 6 parameters. Parameters: key' salt' cost' blockSize' parallel' maxThreads
Long Parameter List,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,GetStream,The method has 6 parameters. Parameters: key' salt' cost' blockSize' parallel' maxThreads
Long Parameter List,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,MFcrypt,The method has 6 parameters. Parameters: P' S' cost' blockSize' parallel' maxThreads
Long Parameter List,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,ThreadSMixCalls,The method has 6 parameters. Parameters: B0' MFLen' cost' blockSize' parallel' maxThreads
Long Parameter List,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,SMix,The method has 6 parameters. Parameters: B' Boffset' Bp' Bpoffset' N' r
Long Parameter List,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The method has 9 parameters. Parameters: B' Boffset' Bp' Bpoffset' x' y' scratch1' scratch2' r
Long Identifier,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,,The length of the parameter spaceBetweenHexBytesToolStripMenuItem is 37.
Long Identifier,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,,The length of the parameter compressPublicKeyToolStripMenuItem is 34.
Long Identifier,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,,The length of the parameter uncompressPublicKeyToolStripMenuItem is 36.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter printPaperWalletsToolStripMenuItem is 34.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter printBanknoteVouchersToolStripMenuItem is 38.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter addressUtilityToolStripMenuItem is 31.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter base58CalculatorToolStripMenuItem is 33.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter mofNCalculatorToolStripMenuItem is 31.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter saveAddressListToolStripMenuItem is 32.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter enterAnAddressToolStripMenuItem is 31.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter deleteSelectedItemsToolStripMenuItem is 36.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter printTwoFactorCoinInsertsToolStripMenuItem is 42.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter twoFactorBitcoinToolsToolStripMenuItem is 38.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter intermediateGeneratorToolStripMenuItem is 38.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter confirmationCodeValidatorToolStripMenuItem is 42.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter keyDecrypterToolStripMenuItem1 is 30.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter printPhysicalBitcoinInsertsDenseToolStripMenuItem is 49.
Long Identifier,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,,The length of the parameter saveAddressListWithPrivKeyToolStripMenuItem is 43.
Long Statement,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The length of the statement  "                printHeight = base.DefaultPageSettings.PaperSize.Height - base.DefaultPageSettings.Margins.Top - base.DefaultPageSettings.Margins.Bottom; " is 137.
Long Statement,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The length of the statement  "                printWidth = base.DefaultPageSettings.PaperSize.Width - base.DefaultPageSettings.Margins.Left - base.DefaultPageSettings.Margins.Right; " is 135.
Long Statement,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The length of the statement  "                        e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F); " is 130.
Long Statement,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The length of the statement  "                        e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F); " is 129.
Long Statement,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The length of the statement  "                    e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F); " is 125.
Long Statement,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The length of the statement  "                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F); " is 156.
Long Statement,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The length of the statement  "                        e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F); " is 161.
Long Statement,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The length of the statement  "                    e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F); " is 130.
Long Statement,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The length of the statement  "                    e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter); " is 145.
Long Statement,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The length of the statement  "                    e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black' " is 143.
Long Statement,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,btnCombine_Click,The length of the statement  "                MessageBox.Show("Input key #1 is not a valid Public Key or Private Key Hex"' "Can't combine"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 138.
Long Statement,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,btnCombine_Click,The length of the statement  "                MessageBox.Show("Input key #2 is not a valid Public Key or Private Key Hex"' "Can't combine"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 138.
Long Statement,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,btnCombine_Click,The length of the statement  "                MessageBox.Show("Can't combine a compressed key with an uncompressed key."' "Can't combine"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 137.
Long Statement,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,btnCombine_Click,The length of the statement  "                    "of one part from each side.  Continue anyway?"' "Duplicate Key Warning"' MessageBoxButtons.OKCancel' MessageBoxIcon.Warning) != DialogResult.OK) { " is 147.
Long Statement,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,btnCombine_Click,The length of the statement  "                KeyPair kpcombined = new KeyPair(Util.Force32Bytes(ecombined.ToByteArrayUnsigned())' compressed: kp1.IsCompressedPoint); " is 120.
Long Statement,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,btnCombine_Click,The length of the statement  "                ECPoint combined = rdoAdd.Checked ? point.Add(priv.GetECPoint()) : point.Multiply(new BigInteger(1' priv.PrivateKeyBytes)); " is 123.
Long Statement,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(KeyCombiner)); " is 131.
Long Statement,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,UpdateByteCounts,The length of the statement  "            lblByteCounts.Text = "Bytes: " + Util.HexStringToBytes(txtHex.Text).Length + "  Base58 length: " + txtBase58.Text.Length; " is 121.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,btnPrivWIFToHex_Click,The length of the statement  "                object interpretation = StringInterpreter.Interpret(txtPrivWIF.Text' compressed: compressToolStripMenuItem.Checked' addressType: this.AddressTypeByte); " is 151.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,btnAddressToPubHash_Click,The length of the statement  "                        if (MessageBox.Show("Address is not valid.  Attempt to correct?"' "Invalid address"' MessageBoxButtons.YesNo) == DialogResult.Yes) { " is 132.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,whatIsASHAcodeToolStripMenuItem_Click,The length of the statement  "            MessageBox.Show("A Mini Private Key is a Bitcoin address generated from a short 30-character string of text.  The advantage is that the text representation of the private key is shorter' and easier to use in " + " is 211.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,whatIsASHAcodeToolStripMenuItem_Click,The length of the statement  "                "The private key is simply the SHA256 hash of the string.  SHAcodes start with the letter 'S' and include a 7-bit typo check."); " is 128.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,lblWhyNot_Click,The length of the statement  "            MessageBox.Show("Bitcoins are vulnerable to theft from hackers when sent to addresses generated from short or non-complex passphrases.  A longer one' or one that uses a good " + " is 177.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,lblWhyNot_Click,The length of the statement  "              "mix of uppercase' lowercase' numbers' and symbols is recommended."' "Security Warning"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 139.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Form1)); " is 125.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The length of the statement  "            this.spaceBetweenHexBytesToolStripMenuItem.Click += new System.EventHandler(this.spaceBetweenHexBytesToolStripMenuItem_Click); " is 126.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The length of the statement  "            this.compressPublicKeyToolStripMenuItem.Click += new System.EventHandler(this.compressPublicKeyToolStripMenuItem_Click); " is 120.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The length of the statement  "            this.uncompressPublicKeyToolStripMenuItem.Click += new System.EventHandler(this.uncompressPublicKeyToolStripMenuItem_Click); " is 124.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The length of the statement  "            this.lblNotSafe.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(192))))' ((int)(((byte)(0))))' ((int)(((byte)(0))))); " is 126.
Long Statement,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The length of the statement  "            this.lblWhyNot.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Underline' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 161.
Long Statement,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,MofNcalc_Load,The length of the statement  "            MessageBox.Show("This feature is experimental' a proof of concept' and the key format will probably be revised heavily before this ever makes it into production.  Don't rely on it to secure large numbers of Bitcoins.  If you use it' " + " is 236.
Long Statement,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,MofNcalc_Load,The length of the statement  "                "make sure you keep a copy of this version of the utility in case the m-of-n format is changed before being accepted as any kind of standard."' "Warning"' MessageBoxButtons.OK' MessageBoxIcon.Warning); " is 201.
Long Statement,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,btnGenerateAddresses_Click,The length of the statement  "                        MessageBox.Show("Please provide some random characters.  Just hit different keys on the keyboard until the box is full. " + " is 123.
Long Statement,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,btnGenerateAddresses_Click,The length of the statement  "                    string msg = "You have generated " + Addresses.Count + " addresses' which will be discarded if you continue.  Continue?"; " is 121.
Long Statement,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,btnGenerateAddresses_Click,The length of the statement  "                    if (MessageBox.Show(msg' "Continue with generation?"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) != DialogResult.Yes) return; " is 131.
Long Statement,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,btnGenerateAddresses_Click,The length of the statement  "                    string msg = "You have not changed the passphrase since the last time you generated addresses' so you will be generating the same addresses as last time.  Continue?"; " is 166.
Long Statement,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,btnGenerateAddresses_Click,The length of the statement  "                    if (MessageBox.Show(msg' "Continue with generation?"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) != DialogResult.Yes) return; " is 131.
Long Statement,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,btnGenerateAddresses_Click,The length of the statement  "                        if (MessageBox.Show("Passphrases must be highly unique and very long to be secure against hackers' who try trillions of random passwords in hopes of " + " is 152.
Long Statement,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,btnGenerateAddresses_Click,The length of the statement  "                            "finding coins to steal.  Use a Random Wallet if you are not 100% sure about what you're doing.  Continue?"' ""' MessageBoxButtons.OKCancel' MessageBoxIcon.Exclamation) " is 168.
Long Statement,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,btnEncode_Click,The length of the statement  "                Bip38Intermediate intermediate = new Bip38Intermediate(txtPassphrase.Text' Bip38Intermediate.Interpretation.Passphrase); " is 120.
Long Statement,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(PpecKeygen)); " is 130.
Long Statement,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The length of the statement  "            this.txtPassphrase.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 146.
Long Statement,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The length of the statement  "            this.txtPassphraseCode.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 150.
Long Statement,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The length of the statement  "            this.linkLabel1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 146.
Long Statement,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The length of the statement  "                printHeight = base.DefaultPageSettings.PaperSize.Height - base.DefaultPageSettings.Margins.Top - base.DefaultPageSettings.Margins.Bottom; " is 137.
Long Statement,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The length of the statement  "                printWidth = base.DefaultPageSettings.PaperSize.Width - base.DefaultPageSettings.Margins.Left - base.DefaultPageSettings.Margins.Right; " is 135.
Long Statement,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The length of the statement  "                    e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY); " is 120.
Long Statement,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,button1_Click,The length of the statement  "                    if (MessageBox.Show("Your passphrase is too short (< 20 characters). If you generate this wallet it may be easily compromised. Are you sure you'd like to use this passphrase?"' "Passphrase too short"' MessageBoxButtons.YesNo) == DialogResult.No) " is 245.
Long Statement,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,button1_Click,The length of the statement  "                    if (MessageBox.Show("Your passphrase is too simple. If you generate this wallet it may be easily compromised. Are you sure you'd like to use this passphrase?"' "Passphrase too simple"' MessageBoxButtons.YesNo) == DialogResult.No) " is 229.
Long Statement,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,button1_Click,The length of the statement  "                    wallet.AppendLine("Paper Bitcoin Wallet.  Keep private' do not lose' do not allow anyone to make a copy.  Anyone with the passphrase or private keys can steal your funds.\r\n"); " is 177.
Long Statement,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,button1_Click,The length of the statement  "                    wallet.AppendLine("Freely give out the Bitcoin address.  The private key after each address is the key needed to unlock funds sent to the Bitcoin address.\r\n"); " is 161.
Long Statement,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,lblFormula_DoubleClick,The length of the statement  "            lblFormula.Text = "Generation formula: PrivKey = SHA256(n + \"/\" + passphrase + \"/\" + n + \"/BITCOIN) where n = \"1\" thru \"10\""; " is 134.
Long Statement,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Walletgen)); " is 129.
Long Statement,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The length of the statement  "                printHeight = base.DefaultPageSettings.PaperSize.Height - base.DefaultPageSettings.Margins.Top - base.DefaultPageSettings.Margins.Bottom; " is 137.
Long Statement,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The length of the statement  "                printWidth = base.DefaultPageSettings.PaperSize.Width - base.DefaultPageSettings.Margins.Left - base.DefaultPageSettings.Margins.Right; " is 135.
Long Statement,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The length of the statement  "                    e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F); " is 125.
Long Statement,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The length of the statement  "                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F); " is 156.
Long Statement,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The length of the statement  "                        e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F); " is 161.
Long Statement,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The length of the statement  "                    e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F); " is 130.
Long Statement,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The length of the statement  "                    e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter); " is 145.
Long Statement,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,ValidateBase58,The length of the statement  "                    return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software."); " is 123.
Long Statement,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,ValidateBase58,The length of the statement  "                    return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software."); " is 123.
Long Statement,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The length of the statement  "                throw new ArgumentException("This is an encryption-only intermediate code because it was not created from a passphrase.  An intermediate must have been created from passphrase to be used for decryption");" is 204.
Long Statement,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The length of the statement  "            if (desiredByteCount != 32 && desiredByteCount != 33) throw new ApplicationException("desiredByteCount must be 32 or 33"); " is 122.
Long Statement,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PassphraseTooSimple,The length of the statement  "            // let mini private keys through - they won't contain words' they are nonsense characters' so their entropy is a bit better per character " is 137.
Long Statement,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The length of the statement  "                        return "This code has an identifier that conflicts with one of the earlier codes provided and cannot be used.  It may not belong to the set."; " is 142.
Long Statement,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,CombineAndReduce,The length of the statement  "                        neweq.leftside.Add(new coefficient(topco.multiplier * topmultiplier - bottomco.multiplier * bottommultiplier' topco.vindex)); " is 125.
Long Statement,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,MFcrypt,The length of the statement  "            if (cost <= 0 || (cost & (cost - 1)) != 0) { throw new ArgumentOutOfRangeException("cost"' "Cost must be a positive power of 2."); } " is 132.
Long Statement,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,AddressGen_FormClosing,The length of the statement  "                if (MessageBox.Show("Cancel and abandon generation in progress?"' "Abort generation"' MessageBoxButtons.YesNo) == System.Windows.Forms.DialogResult.No) { " is 153.
Long Statement,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,btnGenerateAddresses_Click,The length of the statement  "                    "wallet or know what one is used for' it is recommended you choose one of the other options.  An inappropriate seed can result " + " is 130.
Long Statement,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,btnGenerateAddresses_Click,The length of the statement  "                        "codes to the clipboard' and try again.  Address Generator automatically detects valid intermediate codes and ignores " + " is 121.
Long Statement,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,ScanClipboardForIntermediateCodes,The length of the statement  "            List<Bip38Intermediate> intermediates = new List<Bip38Intermediate>(from c in objects where c is Bip38Intermediate select c as Bip38Intermediate); " is 146.
Long Statement,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,timer1_Tick,The length of the statement  "                    } else if (MessageBox.Show("Keep the " + GeneratedItems.Count + " generated keys?"' "Cancel generation"' MessageBoxButtons.YesNo) == System.Windows.Forms.DialogResult.No) { " is 172.
Long Statement,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AddressGen)); " is 130.
Long Statement,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The length of the statement  "            this.txtTextInput.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 145.
Long Statement,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AddSingleAddress)); " is 136.
Long Statement,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The length of the statement  "            this.textBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 144.
Long Statement,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The length of the statement  "            this.btnOK.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 144.
Long Statement,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The length of the statement  "            this.btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 148.
Long Statement,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The length of the statement  "                MessageBox.Show("Confirmation code is required."' "Confirmation code required"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 130.
Long Statement,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The length of the statement  "                MessageBox.Show("This is not a valid confirmation code."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 137.
Long Statement,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The length of the statement  "                                "encrypted private key.  Decryption was attempted but the passphrase couldn't decrypt it"' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 170.
Long Statement,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The length of the statement  "                MessageBox.Show("This is not a valid confirmation code."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 137.
Long Statement,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The length of the statement  "                        MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 162.
Long Statement,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The length of the statement  "                MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 162.
Long Statement,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Bip38ConfValidator)); " is 138.
Long Statement,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The length of the statement  "            this.lblAddressHeader.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 163.
Long Statement,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The length of the statement  "            this.lblAddressItself.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 163.
Long Statement,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The length of the statement  "            this.lblResult.Font = new System.Drawing.Font("Microsoft Sans Serif"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 156.
Long Statement,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,btnDecrypt_Click,The length of the statement  "                MessageBox.Show("Enter an encrypted key and its passphrase."' "Entries Required"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 132.
Long Statement,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,btnDecrypt_Click,The length of the statement  "                        "Do you want to open the Confirmation Code Validator?"' "Invalid private key"' MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation); " is 132.
Long Statement,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,btnDecrypt_Click,The length of the statement  "                    "Please verify the private key was properly typed." + containsL' "Invalid private key"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 138.
Long Statement,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,btnDecrypt_Click,The length of the statement  "                    var r = MessageBox.Show("Does the key you entered belong to the following address?: " + (encrypted as KeyPair).AddressBase58' " is 125.
Long Statement,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,btnDecrypt_Click,The length of the statement  "                            "Would you like to open it in the Address Utility screen to see its various forms?"' "Key is not encrypted"' MessageBoxButtons.YesNo' MessageBoxIcon.Information); " is 162.
Long Statement,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,btnDecrypt_Click,The length of the statement  "                        MessageBox.Show("The passphrase or secondary key is incorrect.  Please verify it was properly typed."' "Second entry is not a valid private key"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 196.
Long Statement,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,btnDecrypt_Click,The length of the statement  "                MessageBox.Show("Keys successfully combined using EC multiplication."' "EC multiplication successful"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 153.
Long Statement,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,btnDecrypt_Click,The length of the statement  "                    MessageBox.Show("The two key entries have the same public hash.  The results you see might be wrong."' "Duplicate key hash"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 175.
Long Statement,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,btnDecrypt_Click,The length of the statement  "                MessageBox.Show("This is not a private key.  It looks like an address or a public key.  Private keys usually start with 5' 6' or S."' "Not a private key"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 205.
Long Statement,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,btnDecrypt_Click,The length of the statement  "                MessageBox.Show("This is not a private key that this program can decrypt."' "Not a recognized private key"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 158.
Long Statement,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(DecryptKey)); " is 130.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,EscrowTools_Load,The length of the statement  "@"{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\sa200\sl276\slmult1\lang9\b\f0\fs28 How Three-Party Escrow Works\fs22\par" + crlf + " is 142.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,EscrowTools_Load,The length of the statement  "@"Escrow\b0  allows two people to transact in Bitcoin while leaving their funds visible to everybody and accessible to nobody until somebody releases them.  It allows the payer or the payee to release funds to one another' and also lets a third person decide for them if the two can't agree.  The third person never has access to take the funds' and is only needed to release the funds if the original two can't agree who gets them.  Whoever gets a copy of all three ""invitations"" gets access to the funds.\par" + crlf + " is 522.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,EscrowTools_Load,The length of the statement  "@"\b First\b0 ' Eddie creates a pair of Escrow Invitation codes.  This is a matched pair of codes representing a single invitation.  These codes can be used by someone else in a future transaction to give Eddie the authority to act as the escrow agent.  He gives one code to Alice and the other to Bob' and keeps a copy for himself.\par" + crlf + " is 346.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,EscrowTools_Load,The length of the statement  "@"\b Second\b0 ' Bob creates a Payment Invitation and gives it only to Alice' but keeps a copy for himself.  When Alice and Bob use the escrow tool to combine their individual Escrow Invitation codes with the Payment Invitation' they'll get the same Bitcoin address.  Alice and Bob must agree they have generated the same address.\par" + crlf + " is 344.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,EscrowTools_Load,The length of the statement  "@"\b Third'\b0  Alice sends Bitcoins to that address.  Now' nobody can get them until someone releases them.\par" + crlf + " is 122.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,EscrowTools_Load,The length of the statement  "@"\b Alice\b0  can release the Bitcoins to Bob by giving a copy of her Escrow Invitation code to Bob (so that he now has both halves' as well as his Payment Invitation).  He'll use the ""Collect Your Funds"" tab to enter all three' and will receive the private key needed to claim the funds.  The private key can be imported into a Bitcoin client or web wallet.\par" + crlf + " is 375.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,EscrowTools_Load,The length of the statement  "@"\b Eddie\b0  can also force the payment to be awarded to Alice or Bob by giving them both Escrow Invitation codes.  Eddie can't claim the payment himself because he would also need the Payment Invitation' which he doesn't have.\par" + crlf + " is 243.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,linkLabel1_LinkClicked,The length of the statement  ""BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE' THERE IS NO WARRANTY FOR THE SOFTWARE' TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE SOFTWARE \"AS IS\" WITHOUT WARRANTY OF ANY KIND' EITHER EXPRESSED OR IMPLIED' INCLUDING' BUT NOT LIMITED TO' THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE' YOU ASSUME THE COST OF ALL NECESSARY SERVICING' REPAIR' OR CORRECTION.\r\n\r\n" + " is 614.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,linkLabel1_LinkClicked,The length of the statement  ""IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER' OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE' BE LIABLE TO YOU FOR DAMAGES' INCLUDING ANY GENERAL' SPECIAL' INCIDENTAL' OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE)' EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."' " is 631.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,btnPayerDone_Click,The length of the statement  "                    MessageBox.Show("The Payment Invitation Code appears to have been generated from the same Escrow Invitation Code you entered' " + " is 129.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,btnPayerDone_Click,The length of the statement  "                        "produced by your trading partner."' "Are you verifying the wrong thing?"' MessageBoxButtons.OK' MessageBoxIcon.Warning); " is 121.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(EscrowTools)); " is 131.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The length of the statement  "            this.tabControl1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 147.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The length of the statement  "            this.linkLabel1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 149.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The length of the statement  "            this.richTextBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 148.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The length of the statement  "            this.txtPayerAddress.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 148.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The length of the statement  "            this.txtPayerCode2.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 146.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The length of the statement  "            this.txtPayerCode1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 146.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The length of the statement  "            this.btnEscrowPrint.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 150.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The length of the statement  "            this.btnEscrowSave.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right))); " is 149.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The length of the statement  "            this.txtEscrowForPayee.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 150.
Long Statement,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The length of the statement  "            this.txtEscrowForPayer.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 150.
Long Statement,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(KeyCollectionView)); " is 137.
Long Statement,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The length of the statement  "            this.intermediateGeneratorToolStripMenuItem.Click += new System.EventHandler(this.intermediateGeneratorToolStripMenuItem_Click); " is 128.
Long Statement,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The length of the statement  "            this.confirmationCodeValidatorToolStripMenuItem.Click += new System.EventHandler(this.confirmationCodeValidatorToolStripMenuItem_Click); " is 136.
Long Statement,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The length of the statement  "            this.printBanknoteVouchersToolStripMenuItem.Click += new System.EventHandler(this.printBanknoteVouchersToolStripMenuItem_Click); " is 128.
Long Statement,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The length of the statement  "            this.printTwoFactorCoinInsertsToolStripMenuItem.Click += new System.EventHandler(this.printTwoFactorCoinInsertsToolStripMenuItem_Click); " is 136.
Long Statement,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The length of the statement  "            this.printPhysicalBitcoinInsertsDenseToolStripMenuItem.Click += new System.EventHandler(this.printTwoFactorCoinInsertsToolStripMenuItem_Click); " is 143.
Long Statement,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The length of the statement  "            this.printPaperWalletsToolStripMenuItem.Click += new System.EventHandler(this.printPaperWalletsToolStripMenuItem_Click); " is 120.
Long Statement,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The length of the statement  "            this.deleteSelectedItemsToolStripMenuItem.Click += new System.EventHandler(this.deleteSelectedItemsToolStripMenuItem_Click); " is 124.
Long Statement,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The length of the statement  "            this.listView1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 145.
Long Statement,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The length of the statement  "            this.saveAddressListWithPrivKeyToolStripMenuItem.Click += new System.EventHandler(this.saveAddressListWithPrivKeyToolStripMenuItem_Click); " is 138.
Long Statement,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(PrintVouchers)); " is 133.
Long Statement,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The length of the statement  "            this.linkLabel1.Font = new System.Drawing.Font("Arial Narrow"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 152.
Long Statement,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The length of the statement  "            this.linkLabel2.Font = new System.Drawing.Font("Arial Narrow"' 8.25F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 152.
Long Statement,PC,PCPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\PCPrint.cs,OnPrintPage,The length of the statement  "                printHeight = base.DefaultPageSettings.PaperSize.Height - base.DefaultPageSettings.Margins.Top - base.DefaultPageSettings.Margins.Bottom;" is 137.
Long Statement,PC,PCPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\PCPrint.cs,OnPrintPage,The length of the statement  "                printWidth = base.DefaultPageSettings.PaperSize.Width - base.DefaultPageSettings.Margins.Left - base.DefaultPageSettings.Margins.Right;" is 135.
Long Statement,PC,PCPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\PCPrint.cs,OnPrintPage,The length of the statement  "            e.Graphics.MeasureString(_text.Substring(RemoveZeros(ref curChar))' PrinterFont' new SizeF(printWidth' printHeight)' format' out chars' out lines);" is 147.
Complex Conditional,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The conditional expression  "sha256sum[0] != _asBytes[lengthWithoutChecksum] ||                  sha256sum[1] != _asBytes[lengthWithoutChecksum + 1] ||                  sha256sum[2] != _asBytes[lengthWithoutChecksum + 2] ||                  sha256sum[3] != _asBytes[lengthWithoutChecksum + 3]"  is complex.
Complex Conditional,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,ValidateBase58,The conditional expression  "bytes==null ||                   bytes.Length != 51 ||                   // check the magic                  bytes[0] != 0x64 || bytes[1] != 0x3B || bytes[2] != 0xF6 ||                  bytes[3] != 0xA8 || bytes[4] != 0x9A ||                   // check valid values for first byte of pointb                  bytes[18] < 0x02 || bytes[18] > 0x03"  is complex.
Complex Conditional,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The conditional expression  "addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]"  is complex.
Complex Conditional,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,verifyAddressHash,The conditional expression  "addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]"  is complex.
Complex Conditional,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The conditional expression  "(escrowInvitationCode.StartsWith("einva") && (privpart[31] & 0x01) == 1) ||                  (escrowInvitationCode.StartsWith("einvb") && (privpart[31] & 0x01) == 0)"  is complex.
Complex Conditional,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The conditional expression  "privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]"  is complex.
Complex Conditional,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The conditional expression  "code1 == null || code2 == null || code1 == "" || code2 == """  is complex.
Complex Conditional,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The conditional expression  "code1 == null || code2 == null || code3 == null || code1 == "" || code2 == "" || code3 == """  is complex.
Complex Conditional,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Base58Trim,The conditional expression  "(c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')"  is complex.
Complex Conditional,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,HexStringToBytes,The conditional expression  "(c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')"  is complex.
Complex Conditional,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PassphraseTooSimple,The conditional expression  "passphrase.Length < 30 && (Lowercase < 10 || Uppercase < 3 || Numbers < 2 || Symbols < 2)"  is complex.
Complex Conditional,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The conditional expression  "ins != null && ins[0] != 0x4f && (ins[1] < 0x94 || ins[1] > 0x9b)"  is complex.
Complex Conditional,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The conditional expression  "hex.Length == 36 && hex[0] == 0x02 && hex[1] == 0x05 && hex[2] <= 0x80"  is complex.
Complex Conditional,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The conditional expression  "confbytes.Length != 51 || confbytes[0] != 0x64 || confbytes[1] != 0x3B || confbytes[2] != 0xF6 ||                  confbytes[3] != 0xA8 || confbytes[4] != 0x9A || confbytes[18] < 0x02 || confbytes[18] > 0x03"  is complex.
Empty Catch Block,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,btnBlockExplorer_Click,The method has an empty catch block.
Empty Catch Block,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,cboCoinType_SelectionChangeCommitted,The method has an empty catch block.
Empty Catch Block,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The method has an empty catch block.
Empty Catch Block,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The method has an empty catch block.
Empty Catch Block,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The method has an empty catch block.
Magic Number,BtcAddress,Barcode128b,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\Barcode128b.cs,getPatternsForMessage,The following statement contains a magic number: rv.Append(patterns[104]);
Magic Number,BtcAddress,Barcode128b,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\Barcode128b.cs,getPatternsForMessage,The following statement contains a magic number: int runningChecksum = 104;
Magic Number,BtcAddress,Barcode128b,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\Barcode128b.cs,getPatternsForMessage,The following statement contains a magic number: foreach (char c in message.ToCharArray()) {                  if (c >= ' ' && c <= '~') { // chars 32 thru 126                      int sym = c - 0x20;                      rv.Append(patterns[sym]);                      runningChecksum = (runningChecksum + sym * posNumber) % 103;                      posNumber++;                  }              }
Magic Number,BtcAddress,Barcode128b,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\Barcode128b.cs,getPatternsForMessage,The following statement contains a magic number: rv.Append(patterns[106]);
Magic Number,BtcAddress,Barcode128b,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\Barcode128b.cs,GetBarcode,The following statement contains a magic number: int margininmodules = 12;
Magic Number,BtcAddress,Barcode128b,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\Barcode128b.cs,GetBarcode,The following statement contains a magic number: int heightinmodules = 30;
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,QR,C:\repos\casascius_Bitcoin-Address-Utility\Barcode\QR.cs,EncodeQRCode,The following statement contains a magic number: if (IsAlphanumeric) {                  qr.QRCodeEncodeMode = QRCodeEncoder.ENCODE_MODE.ALPHA_NUMERIC;                  if (what.Length > 154) {                      return null;                  } else if (what.Length > 67) {                      // 5L is good to 154 alphanumeric characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.L;                  } else {                      // 4Q is good to 67 alphanumeric characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              } else {                  if (what.Length > 84) {                      // We don't intend to encode any alphanumeric strings longer than confirmation codes at 75 characters                      return null;                  } else if (what.Length > 62) {                      // 5M is good to 84 characters                      qr.QRCodeVersion = 5;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 34) {                      // 4M is good to 62 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.M;                  } else if (what.Length > 32) {                      // 4H is good to 34 characters                      qr.QRCodeVersion = 4;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.H;                  } else {                      // 3Q is good to 32 characters                      qr.QRCodeVersion = 3;                      qr.QRCodeErrorCorrect = QRCodeEncoder.ERROR_CORRECTION.Q;                  }              }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: int startheight = 50;
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,CoinInsertDense,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsertDense.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 96; i++) {                  int eachheight = 60' eachwidth = 130;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                    keys.RemoveAt(0);                    int thiscodeX = startwidth + eachwidth * (i / 16);                  int thiscodeY = startheight + eachheight * (i % 16);                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                        // print some alignment marks for use in laser cutting                      if (i == 0) {                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' startheight' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 8.5F' 0.01F' 0.01F);                          e.Graphics.FillRectangle(Brushes.Black' startwidth + eachwidth * 3F' (float)startheight + (float)eachheight * 17F' 0.01F' 0.01F);                      }                          blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                    // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 80' thiscodeY + 10' 50' 50);                  }                    e.Graphics.RotateTransform(-90F);                  // transform 90 degrees changes our coordinate space so we can do sideways text.                  // must swap xy and value supplied as x parameter must be negative                  // instead of             it's now                  //        -Y                  +X                  //        |                   |                  //  -X-------+X        -Y----------+Y                  //        | PRINT             | PRINT                  //        +Y                  -X                      using (StringFormat sfright = new StringFormat()) {                      sfright.Alignment = StringAlignment.Far;                      e.Graphics.DrawString(address.Substring(0' 12) + "\r\n" + address.Substring(12' 12) + "\r\n" + address.Substring(24)' fontsmall' Brushes.Black'                          -(float)(thiscodeY + 10)'                          (float)(thiscodeX + 130)' sfright);                    }                  // get out of sideways mode                  e.Graphics.RotateTransform(90F);                    }
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtInput1.Location = new System.Drawing.Point(99' 153);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtInput1.Location = new System.Drawing.Point(99' 153);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtInput1.Size = new System.Drawing.Size(493' 42);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtInput1.Size = new System.Drawing.Size(493' 42);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtInput2.Location = new System.Drawing.Point(99' 202);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtInput2.Location = new System.Drawing.Point(99' 202);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtInput2.Size = new System.Drawing.Size(493' 42);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtInput2.Size = new System.Drawing.Size(493' 42);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputAddress.Location = new System.Drawing.Point(98' 336);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputAddress.Location = new System.Drawing.Point(98' 336);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputAddress.Size = new System.Drawing.Size(493' 20);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputAddress.Size = new System.Drawing.Size(493' 20);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputAddress.TabIndex = 2;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputPriv.Location = new System.Drawing.Point(99' 425);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputPriv.Location = new System.Drawing.Point(99' 425);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputPriv.Size = new System.Drawing.Size(493' 20);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputPriv.Size = new System.Drawing.Size(493' 20);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputPriv.TabIndex = 3;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.btnCombine.Location = new System.Drawing.Point(99' 247);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.btnCombine.Location = new System.Drawing.Point(99' 247);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.btnCombine.Size = new System.Drawing.Size(109' 41);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.btnCombine.Size = new System.Drawing.Size(109' 41);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.btnCombine.TabIndex = 4;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputPubkey.Location = new System.Drawing.Point(98' 368);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputPubkey.Location = new System.Drawing.Point(98' 368);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputPubkey.Size = new System.Drawing.Size(493' 42);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputPubkey.Size = new System.Drawing.Size(493' 42);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.txtOutputPubkey.TabIndex = 5;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(11' 156);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(11' 156);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(61' 13);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(61' 13);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 6;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(11' 205);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(11' 205);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(61' 13);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(61' 13);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 7;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(11' 330);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(11' 330);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(80' 26);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(80' 26);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 8;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(11' 368);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(11' 368);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(79' 26);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(79' 26);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 9;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(11' 419);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(11' 419);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(61' 26);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(61' 26);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 10;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(230' 247);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(230' 247);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(361' 75);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(361' 75);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.TabIndex = 11;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.rdoAdd.Location = new System.Drawing.Point(15' 43);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.rdoAdd.Location = new System.Drawing.Point(15' 43);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.rdoAdd.Size = new System.Drawing.Size(262' 17);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.rdoAdd.Size = new System.Drawing.Size(262' 17);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.rdoMul.Location = new System.Drawing.Point(15' 20);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.rdoMul.Location = new System.Drawing.Point(15' 20);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.rdoMul.Size = new System.Drawing.Size(306' 17);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.rdoMul.Size = new System.Drawing.Size(306' 17);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(12' 9);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(12' 9);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(534' 130);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(534' 130);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 12;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Location = new System.Drawing.Point(274' 45);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Location = new System.Drawing.Point(274' 45);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Size = new System.Drawing.Size(38' 13);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Size = new System.Drawing.Size(38' 13);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.TabIndex = 2;
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(604' 463);
Magic Number,BtcAddress,KeyCombiner,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCombiner.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(604' 463);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.txtHex.Location = new System.Drawing.Point(66' 35);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.txtHex.Location = new System.Drawing.Point(66' 35);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.txtHex.Size = new System.Drawing.Size(585' 20);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.txtHex.Size = new System.Drawing.Size(585' 20);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(13' 38);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(13' 38);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(26' 13);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(26' 13);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(13' 64);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(13' 64);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(43' 13);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(43' 13);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 3;
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.txtBase58.Location = new System.Drawing.Point(66' 61);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.txtBase58.Location = new System.Drawing.Point(66' 61);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.txtBase58.Size = new System.Drawing.Size(585' 20);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.txtBase58.Size = new System.Drawing.Size(585' 20);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.txtBase58.TabIndex = 2;
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.lblByteCounts.Location = new System.Drawing.Point(63' 84);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.lblByteCounts.Location = new System.Drawing.Point(63' 84);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.lblByteCounts.Size = new System.Drawing.Size(156' 13);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.lblByteCounts.Size = new System.Drawing.Size(156' 13);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.lblByteCounts.TabIndex = 4;
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(685' 24);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(685' 24);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.TabIndex = 5;
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.modeToolStripMenuItem.Size = new System.Drawing.Size(50' 20);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.modeToolStripMenuItem.Size = new System.Drawing.Size(50' 20);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.useChecksumToolStripMenuItem.Size = new System.Drawing.Size(152' 22);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.useChecksumToolStripMenuItem.Size = new System.Drawing.Size(152' 22);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(685' 123);
Magic Number,BtcAddress,Base58Calc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Base58Calc.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(685' 123);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,UpdateMinikeyDescription,The following statement contains a magic number: if (isminikey == 1) {                  lblWhyNot.Visible = false;                  lblNotSafe.Visible = true;                  lblNotSafe.Text = "Valid mini key";                  lblNotSafe.ForeColor = Color.DarkGreen;              } else if (isminikey == -1) {                  lblWhyNot.Visible = false;                  lblNotSafe.Visible = true;                  lblNotSafe.Text = "Invalid mini key";                  lblNotSafe.ForeColor = Color.Red;              } else if (txtMinikey.Text != "" && txtMinikey.Text.Length < 20 || Util.PassphraseTooSimple(txtMinikey.Text)) {                  lblWhyNot.Visible = true;                  lblNotSafe.Visible = true;                  lblNotSafe.Text = "Warning - Not Safe";                  lblNotSafe.ForeColor = Color.Red;              } else {                  lblWhyNot.Visible = false;                  lblNotSafe.Visible = false;                  lblNotSafe.Text = "Warning - Not Safe";                  lblNotSafe.ForeColor = Color.Red;              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,btnPrivHexToWIF_Click,The following statement contains a magic number: try {                  if (txtPrivHex.Text.StartsWith("\"") && txtPrivHex.Text.EndsWith("\"") && txtPrivHex.Text.Length > 2) {                      UTF8Encoding utf8 = new UTF8Encoding(false);                      byte[] str = Util.Force32Bytes(utf8.GetBytes(txtPrivHex.Text.Substring(1' txtPrivHex.Text.Length - 2)));                      txtPrivHex.Text = RemoveSpacesIf(Util.ByteArrayToString(str));                  }                  KeyPair ba = new KeyPair(txtPrivHex.Text' compressed: compressToolStripMenuItem.Checked);                    if (txtPassphrase.Text != "") {                      SetText(txtPrivWIF' new Bip38KeyPair(ba' txtPassphrase.Text).EncryptedPrivateKey);                  } else {                      SetText(txtPrivWIF' ba.PrivateKeyBase58);                    }                  SetText(txtPrivHex' ba.PrivateKeyHex);                  SetText(txtPubHex' ba.PublicKeyHex);                  SetText(txtPubHash' ba.Hash160Hex);                  SetText(txtBtcAddr' new AddressBase(ba' AddressTypeByte).AddressBase58);                            } catch (Exception ae) {                  MessageBox.Show(ae.Message);              } finally {                  ChangeFlag--;              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,btnPrivHexToWIF_Click,The following statement contains a magic number: try {                  if (txtPrivHex.Text.StartsWith("\"") && txtPrivHex.Text.EndsWith("\"") && txtPrivHex.Text.Length > 2) {                      UTF8Encoding utf8 = new UTF8Encoding(false);                      byte[] str = Util.Force32Bytes(utf8.GetBytes(txtPrivHex.Text.Substring(1' txtPrivHex.Text.Length - 2)));                      txtPrivHex.Text = RemoveSpacesIf(Util.ByteArrayToString(str));                  }                  KeyPair ba = new KeyPair(txtPrivHex.Text' compressed: compressToolStripMenuItem.Checked);                    if (txtPassphrase.Text != "") {                      SetText(txtPrivWIF' new Bip38KeyPair(ba' txtPassphrase.Text).EncryptedPrivateKey);                  } else {                      SetText(txtPrivWIF' ba.PrivateKeyBase58);                    }                  SetText(txtPrivHex' ba.PrivateKeyHex);                  SetText(txtPubHex' ba.PublicKeyHex);                  SetText(txtPubHash' ba.Hash160Hex);                  SetText(txtBtcAddr' new AddressBase(ba' AddressTypeByte).AddressBase58);                            } catch (Exception ae) {                  MessageBox.Show(ae.Message);              } finally {                  ChangeFlag--;              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,btnAddressToPubHash_Click,The following statement contains a magic number: try {                  byte[] hex = Util.Base58CheckToByteArray(txtBtcAddr.Text);                  if (hex == null || hex.Length != 21) {                      int L = txtBtcAddr.Text.Length;                      if (L >= 33 && L <= 34) {                          if (MessageBox.Show("Address is not valid.  Attempt to correct?"' "Invalid address"' MessageBoxButtons.YesNo) == DialogResult.Yes) {                              CorrectBitcoinAddress();                              return;                          }                      } else {                          MessageBox.Show("Address is not valid.");                      }                      return;                  }                  SetText(txtPubHash' RemoveSpacesIf(Util.ByteArrayToString(hex' 1' 20)));              } finally {                  ChangeFlag--;              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,btnAddressToPubHash_Click,The following statement contains a magic number: try {                  byte[] hex = Util.Base58CheckToByteArray(txtBtcAddr.Text);                  if (hex == null || hex.Length != 21) {                      int L = txtBtcAddr.Text.Length;                      if (L >= 33 && L <= 34) {                          if (MessageBox.Show("Address is not valid.  Attempt to correct?"' "Invalid address"' MessageBoxButtons.YesNo) == DialogResult.Yes) {                              CorrectBitcoinAddress();                              return;                          }                      } else {                          MessageBox.Show("Address is not valid.");                      }                      return;                  }                  SetText(txtPubHash' RemoveSpacesIf(Util.ByteArrayToString(hex' 1' 20)));              } finally {                  ChangeFlag--;              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,btnAddressToPubHash_Click,The following statement contains a magic number: try {                  byte[] hex = Util.Base58CheckToByteArray(txtBtcAddr.Text);                  if (hex == null || hex.Length != 21) {                      int L = txtBtcAddr.Text.Length;                      if (L >= 33 && L <= 34) {                          if (MessageBox.Show("Address is not valid.  Attempt to correct?"' "Invalid address"' MessageBoxButtons.YesNo) == DialogResult.Yes) {                              CorrectBitcoinAddress();                              return;                          }                      } else {                          MessageBox.Show("Address is not valid.");                      }                      return;                  }                  SetText(txtPubHash' RemoveSpacesIf(Util.ByteArrayToString(hex' 1' 20)));              } finally {                  ChangeFlag--;              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,btnAddressToPubHash_Click,The following statement contains a magic number: try {                  byte[] hex = Util.Base58CheckToByteArray(txtBtcAddr.Text);                  if (hex == null || hex.Length != 21) {                      int L = txtBtcAddr.Text.Length;                      if (L >= 33 && L <= 34) {                          if (MessageBox.Show("Address is not valid.  Attempt to correct?"' "Invalid address"' MessageBoxButtons.YesNo) == DialogResult.Yes) {                              CorrectBitcoinAddress();                              return;                          }                      } else {                          MessageBox.Show("Address is not valid.");                      }                      return;                  }                  SetText(txtPubHash' RemoveSpacesIf(Util.ByteArrayToString(hex' 1' 20)));              } finally {                  ChangeFlag--;              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,Correction,The following statement contains a magic number: for (int i = 0; i < btcaddrlen; i++) {                  for (int j = 0; j < 58; j++) {                      string attempt = btcaddr.Substring(0' i) + b58.Substring(j' 1) + btcaddr.Substring(i + 1);                      byte[] bytes = Util.Base58CheckToByteArray(attempt);                      if (bytes != null) {                          MessageBox.Show("Correction was successful.  Try your request again.");                          return attempt;                      }                  }              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,TextBox_KeyPress,The following statement contains a magic number: if (e.KeyChar == 13) {                  e.Handled = true;                  TextBox txtSender = (TextBox)sender;                  if (txtSender == txtMinikey) btnSha256ToPrivate_Click(null' null);                  if (txtSender == txtPrivWIF) btnPrivWIFToHex_Click(null' null);              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,GenerateAddresses,The following statement contains a magic number: for (int ji = 0; ji < 100000000; ji++) {                  byte[] poop = Util.ComputeSha256(salt + ji.ToString());                    byte[] ahash = null;                  do {                        // Get 'S' + 21 random base58 characters' where sha256(result + '?') starts with the byte 00 (1 in 256 possibilities)                      shacode = "S";                      for (int i = 0; i < 29; i++) {                          long x = sr.NextLong() & long.MaxValue;                          x += poop[i];                          long x58 = x % b58len;                          shacode += b58.Substring((int)x58' 1);                      }                      string shacodeq = shacode + "?";                      ahash = Util.ComputeSha256(Encoding.ASCII.GetBytes(shacodeq));                        if (ahash[0] == 0) break;                        Application.DoEvents();                  } while (true);                      string pubhex = Util.PrivHexToPubHex(Util.ByteArrayToString(Util.ComputeSha256(shacode)));                  string pubhash = Util.PubHexToPubHash(pubhex);                  string address = Util.PubHashToAddress(pubhash' "Bitcoin");                      pubhex = pubhex.Replace(" "' "");                    lock (LockObject) {                        using (StreamWriter sw1 = new StreamWriter("privkeys3.txt"' true)) {                          sw1.WriteLine("\"" + address + "\"'\"" + shacode + "\"'\"" + pubhex + "\"");                          sw1.Close();                      }                          using (StreamWriter sw1 = new StreamWriter("addresses3.txt"' true)) {                          sw1.WriteLine("\"" + address + "\"'\"" + pubhex + "\"");                          sw1.Close();                      }                  }                                    Debug.WriteLine(shacode + "=" + address);                  /*                  myaddresses.Add(address);                  myprivkeys.Add(address' shacode);                  dec++;                  if (dec == 1000) {                      dec = 0;                      Application.DoEvents();                  }                   * */              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,GenerateAddresses,The following statement contains a magic number: for (int ji = 0; ji < 100000000; ji++) {                  byte[] poop = Util.ComputeSha256(salt + ji.ToString());                    byte[] ahash = null;                  do {                        // Get 'S' + 21 random base58 characters' where sha256(result + '?') starts with the byte 00 (1 in 256 possibilities)                      shacode = "S";                      for (int i = 0; i < 29; i++) {                          long x = sr.NextLong() & long.MaxValue;                          x += poop[i];                          long x58 = x % b58len;                          shacode += b58.Substring((int)x58' 1);                      }                      string shacodeq = shacode + "?";                      ahash = Util.ComputeSha256(Encoding.ASCII.GetBytes(shacodeq));                        if (ahash[0] == 0) break;                        Application.DoEvents();                  } while (true);                      string pubhex = Util.PrivHexToPubHex(Util.ByteArrayToString(Util.ComputeSha256(shacode)));                  string pubhash = Util.PubHexToPubHash(pubhex);                  string address = Util.PubHashToAddress(pubhash' "Bitcoin");                      pubhex = pubhex.Replace(" "' "");                    lock (LockObject) {                        using (StreamWriter sw1 = new StreamWriter("privkeys3.txt"' true)) {                          sw1.WriteLine("\"" + address + "\"'\"" + shacode + "\"'\"" + pubhex + "\"");                          sw1.Close();                      }                          using (StreamWriter sw1 = new StreamWriter("addresses3.txt"' true)) {                          sw1.WriteLine("\"" + address + "\"'\"" + pubhex + "\"");                          sw1.Close();                      }                  }                                    Debug.WriteLine(shacode + "=" + address);                  /*                  myaddresses.Add(address);                  myprivkeys.Add(address' shacode);                  dec++;                  if (dec == 1000) {                      dec = 0;                      Application.DoEvents();                  }                   * */              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,label4_Click,The following statement contains a magic number: using (StreamReader sr1 = new StreamReader("privkeys3.txt")) {                  while (sr1.EndOfStream == false) {                      string line = sr1.ReadLine();                      LineNumber++;                      line = line.Replace("\""' "");                      string[] fields = line.Split(''');                      if (fields.Length == 3) {                          byte[] privkey = Util.ComputeSha256(fields[1]);                            string pubhex = Util.PrivHexToPubHex(Util.ByteArrayToString(privkey)).Replace(" "' "");                          string pubhash = Util.PubHexToPubHash(pubhex);                          string address = Util.PubHashToAddress(pubhash' "Bitcoin");                            if (address != fields[0] || pubhex != fields[2]) {                              MessageBox.Show("Validation failure on line " + LineNumber.ToString());                          }                          Records++;                          if (Records % 100 == 0) Debug.WriteLine("Records: " + Records);                      }                  }              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,label4_Click,The following statement contains a magic number: using (StreamReader sr1 = new StreamReader("privkeys3.txt")) {                  while (sr1.EndOfStream == false) {                      string line = sr1.ReadLine();                      LineNumber++;                      line = line.Replace("\""' "");                      string[] fields = line.Split(''');                      if (fields.Length == 3) {                          byte[] privkey = Util.ComputeSha256(fields[1]);                            string pubhex = Util.PrivHexToPubHex(Util.ByteArrayToString(privkey)).Replace(" "' "");                          string pubhash = Util.PubHexToPubHash(pubhex);                          string address = Util.PubHashToAddress(pubhash' "Bitcoin");                            if (address != fields[0] || pubhex != fields[2]) {                              MessageBox.Show("Validation failure on line " + LineNumber.ToString());                          }                          Records++;                          if (Records % 100 == 0) Debug.WriteLine("Records: " + Records);                      }                  }              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,label4_Click,The following statement contains a magic number: using (StreamReader sr1 = new StreamReader("privkeys3.txt")) {                  while (sr1.EndOfStream == false) {                      string line = sr1.ReadLine();                      LineNumber++;                      line = line.Replace("\""' "");                      string[] fields = line.Split(''');                      if (fields.Length == 3) {                          byte[] privkey = Util.ComputeSha256(fields[1]);                            string pubhex = Util.PrivHexToPubHex(Util.ByteArrayToString(privkey)).Replace(" "' "");                          string pubhash = Util.PubHexToPubHash(pubhex);                          string address = Util.PubHashToAddress(pubhash' "Bitcoin");                            if (address != fields[0] || pubhex != fields[2]) {                              MessageBox.Show("Validation failure on line " + LineNumber.ToString());                          }                          Records++;                          if (Records % 100 == 0) Debug.WriteLine("Records: " + Records);                      }                  }              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,label3_Click,The following statement contains a magic number: using (FileStream sr = new FileStream("wallet.dat"'FileMode.Open)) {                  byte[] b = new byte[4000000];                  int len = sr.Read(b' 0' b.Length);                  sr.Close();                    for (int i = 0; i < len - 34; i++) {                      if (b[i] == 4 && b[i + 1] == 0x20) {                          byte[] privkey = new byte[33];                          privkey[0] = 0x80;                          for (int j = 0; j < 32; j++) {                              privkey[j+1] = b[i + j + 2];                          }                          Debug.WriteLine("./bitcoind importprivkey " + Util.ByteArrayToBase58Check(privkey));                      }                  }              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,label3_Click,The following statement contains a magic number: using (FileStream sr = new FileStream("wallet.dat"'FileMode.Open)) {                  byte[] b = new byte[4000000];                  int len = sr.Read(b' 0' b.Length);                  sr.Close();                    for (int i = 0; i < len - 34; i++) {                      if (b[i] == 4 && b[i + 1] == 0x20) {                          byte[] privkey = new byte[33];                          privkey[0] = 0x80;                          for (int j = 0; j < 32; j++) {                              privkey[j+1] = b[i + j + 2];                          }                          Debug.WriteLine("./bitcoind importprivkey " + Util.ByteArrayToBase58Check(privkey));                      }                  }              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,label3_Click,The following statement contains a magic number: using (FileStream sr = new FileStream("wallet.dat"'FileMode.Open)) {                  byte[] b = new byte[4000000];                  int len = sr.Read(b' 0' b.Length);                  sr.Close();                    for (int i = 0; i < len - 34; i++) {                      if (b[i] == 4 && b[i + 1] == 0x20) {                          byte[] privkey = new byte[33];                          privkey[0] = 0x80;                          for (int j = 0; j < 32; j++) {                              privkey[j+1] = b[i + j + 2];                          }                          Debug.WriteLine("./bitcoind importprivkey " + Util.ByteArrayToBase58Check(privkey));                      }                  }              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,label3_Click,The following statement contains a magic number: using (FileStream sr = new FileStream("wallet.dat"'FileMode.Open)) {                  byte[] b = new byte[4000000];                  int len = sr.Read(b' 0' b.Length);                  sr.Close();                    for (int i = 0; i < len - 34; i++) {                      if (b[i] == 4 && b[i + 1] == 0x20) {                          byte[] privkey = new byte[33];                          privkey[0] = 0x80;                          for (int j = 0; j < 32; j++) {                              privkey[j+1] = b[i + j + 2];                          }                          Debug.WriteLine("./bitcoind importprivkey " + Util.ByteArrayToBase58Check(privkey));                      }                  }              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,label3_Click,The following statement contains a magic number: using (FileStream sr = new FileStream("wallet.dat"'FileMode.Open)) {                  byte[] b = new byte[4000000];                  int len = sr.Read(b' 0' b.Length);                  sr.Close();                    for (int i = 0; i < len - 34; i++) {                      if (b[i] == 4 && b[i + 1] == 0x20) {                          byte[] privkey = new byte[33];                          privkey[0] = 0x80;                          for (int j = 0; j < 32; j++) {                              privkey[j+1] = b[i + j + 2];                          }                          Debug.WriteLine("./bitcoind importprivkey " + Util.ByteArrayToBase58Check(privkey));                      }                  }              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,label3_Click,The following statement contains a magic number: using (FileStream sr = new FileStream("wallet.dat"'FileMode.Open)) {                  byte[] b = new byte[4000000];                  int len = sr.Read(b' 0' b.Length);                  sr.Close();                    for (int i = 0; i < len - 34; i++) {                      if (b[i] == 4 && b[i + 1] == 0x20) {                          byte[] privkey = new byte[33];                          privkey[0] = 0x80;                          for (int j = 0; j < 32; j++) {                              privkey[j+1] = b[i + j + 2];                          }                          Debug.WriteLine("./bitcoind importprivkey " + Util.ByteArrayToBase58Check(privkey));                      }                  }              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,showFieldsToolStripMenuItem_Click,The following statement contains a magic number: if (txtPubHex.Text.Length == 130 || txtPubHex.Text.Length == 66) {                  // 33 or 65 bytes' no spaces = 66 or 130 characters                  txtPubHex.Select(2' 64);              } else if (txtPubHex.Text.Length == 194 || txtPubHex.Text.Length == 98) {                  // 65 bytes + 64 spaces' or 33 bytes = 32 spaces                  txtPubHex.Select(2' 95);              } else {                  MessageBox.Show("Enter a public key first.");              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,showFieldsToolStripMenuItem_Click,The following statement contains a magic number: if (txtPubHex.Text.Length == 130 || txtPubHex.Text.Length == 66) {                  // 33 or 65 bytes' no spaces = 66 or 130 characters                  txtPubHex.Select(2' 64);              } else if (txtPubHex.Text.Length == 194 || txtPubHex.Text.Length == 98) {                  // 65 bytes + 64 spaces' or 33 bytes = 32 spaces                  txtPubHex.Select(2' 95);              } else {                  MessageBox.Show("Enter a public key first.");              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,showFieldsToolStripMenuItem_Click,The following statement contains a magic number: if (txtPubHex.Text.Length == 130 || txtPubHex.Text.Length == 66) {                  // 33 or 65 bytes' no spaces = 66 or 130 characters                  txtPubHex.Select(2' 64);              } else if (txtPubHex.Text.Length == 194 || txtPubHex.Text.Length == 98) {                  // 65 bytes + 64 spaces' or 33 bytes = 32 spaces                  txtPubHex.Select(2' 95);              } else {                  MessageBox.Show("Enter a public key first.");              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,showFieldsToolStripMenuItem_Click,The following statement contains a magic number: if (txtPubHex.Text.Length == 130 || txtPubHex.Text.Length == 66) {                  // 33 or 65 bytes' no spaces = 66 or 130 characters                  txtPubHex.Select(2' 64);              } else if (txtPubHex.Text.Length == 194 || txtPubHex.Text.Length == 98) {                  // 65 bytes + 64 spaces' or 33 bytes = 32 spaces                  txtPubHex.Select(2' 95);              } else {                  MessageBox.Show("Enter a public key first.");              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,showFieldsToolStripMenuItem_Click,The following statement contains a magic number: if (txtPubHex.Text.Length == 130 || txtPubHex.Text.Length == 66) {                  // 33 or 65 bytes' no spaces = 66 or 130 characters                  txtPubHex.Select(2' 64);              } else if (txtPubHex.Text.Length == 194 || txtPubHex.Text.Length == 98) {                  // 65 bytes + 64 spaces' or 33 bytes = 32 spaces                  txtPubHex.Select(2' 95);              } else {                  MessageBox.Show("Enter a public key first.");              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,showFieldsToolStripMenuItem_Click,The following statement contains a magic number: if (txtPubHex.Text.Length == 130 || txtPubHex.Text.Length == 66) {                  // 33 or 65 bytes' no spaces = 66 or 130 characters                  txtPubHex.Select(2' 64);              } else if (txtPubHex.Text.Length == 194 || txtPubHex.Text.Length == 98) {                  // 65 bytes + 64 spaces' or 33 bytes = 32 spaces                  txtPubHex.Select(2' 95);              } else {                  MessageBox.Show("Enter a public key first.");              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,showFieldsToolStripMenuItem_Click,The following statement contains a magic number: if (txtPubHex.Text.Length == 130 || txtPubHex.Text.Length == 66) {                  // 33 or 65 bytes' no spaces = 66 or 130 characters                  txtPubHex.Select(2' 64);              } else if (txtPubHex.Text.Length == 194 || txtPubHex.Text.Length == 98) {                  // 65 bytes + 64 spaces' or 33 bytes = 32 spaces                  txtPubHex.Select(2' 95);              } else {                  MessageBox.Show("Enter a public key first.");              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,showFieldsToolStripMenuItem_Click,The following statement contains a magic number: if (txtPubHex.Text.Length == 130 || txtPubHex.Text.Length == 66) {                  // 33 or 65 bytes' no spaces = 66 or 130 characters                  txtPubHex.Select(2' 64);              } else if (txtPubHex.Text.Length == 194 || txtPubHex.Text.Length == 98) {                  // 65 bytes + 64 spaces' or 33 bytes = 32 spaces                  txtPubHex.Select(2' 95);              } else {                  MessageBox.Show("Enter a public key first.");              }
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivWIF.Location = new System.Drawing.Point(101' 93);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivWIF.Location = new System.Drawing.Point(101' 93);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivWIF.Size = new System.Drawing.Size(557' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivWIF.Size = new System.Drawing.Size(557' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivWIF.TabIndex = 7;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(5' 96);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(5' 96);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(90' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(90' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 5;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivHex.Location = new System.Drawing.Point(101' 151);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivHex.Location = new System.Drawing.Point(101' 151);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivHex.Size = new System.Drawing.Size(557' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivHex.Size = new System.Drawing.Size(557' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivHex.TabIndex = 12;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(5' 154);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(5' 154);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(89' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(89' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 11;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(5' 212);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(5' 212);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(85' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(85' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 14;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPubHex.Location = new System.Drawing.Point(101' 209);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPubHex.Location = new System.Drawing.Point(101' 209);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPubHex.Size = new System.Drawing.Size(557' 43);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPubHex.Size = new System.Drawing.Size(557' 43);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPubHex.TabIndex = 15;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(5' 297);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(5' 297);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(91' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(91' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 18;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPubHash.Location = new System.Drawing.Point(101' 294);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPubHash.Location = new System.Drawing.Point(101' 294);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPubHash.Size = new System.Drawing.Size(557' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPubHash.Size = new System.Drawing.Size(557' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPubHash.TabIndex = 19;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(5' 355);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(5' 355);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(45' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(45' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 17;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtBtcAddr.Location = new System.Drawing.Point(101' 352);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtBtcAddr.Location = new System.Drawing.Point(101' 352);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtBtcAddr.Size = new System.Drawing.Size(557' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtBtcAddr.Size = new System.Drawing.Size(557' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtBtcAddr.TabIndex = 24;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnAddressToPubHash.Location = new System.Drawing.Point(443' 316);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnAddressToPubHash.Location = new System.Drawing.Point(443' 316);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnAddressToPubHash.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnAddressToPubHash.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnAddressToPubHash.TabIndex = 20;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPubHashToAddress.Location = new System.Drawing.Point(491' 316);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPubHashToAddress.Location = new System.Drawing.Point(491' 316);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPubHashToAddress.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPubHashToAddress.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPubHashToAddress.TabIndex = 21;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPubHexToHash.Location = new System.Drawing.Point(491' 258);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPubHexToHash.Location = new System.Drawing.Point(491' 258);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPubHexToHash.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPubHexToHash.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPubHexToHash.TabIndex = 16;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivToPub.Location = new System.Drawing.Point(491' 173);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivToPub.Location = new System.Drawing.Point(491' 173);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivToPub.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivToPub.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivToPub.TabIndex = 13;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivWIFToHex.Location = new System.Drawing.Point(491' 115);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivWIFToHex.Location = new System.Drawing.Point(491' 115);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivWIFToHex.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivWIFToHex.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivWIFToHex.TabIndex = 9;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivHexToWIF.Location = new System.Drawing.Point(443' 115);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivHexToWIF.Location = new System.Drawing.Point(443' 115);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivHexToWIF.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivHexToWIF.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnPrivHexToWIF.TabIndex = 8;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerate.Location = new System.Drawing.Point(543' 115);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerate.Location = new System.Drawing.Point(543' 115);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerate.Size = new System.Drawing.Size(114' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerate.Size = new System.Drawing.Size(114' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerate.TabIndex = 10;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnBlockExplorer.Location = new System.Drawing.Point(543' 316);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnBlockExplorer.Location = new System.Drawing.Point(543' 316);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnBlockExplorer.Size = new System.Drawing.Size(114' 29);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnBlockExplorer.Size = new System.Drawing.Size(114' 29);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnBlockExplorer.TabIndex = 23;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.cboCoinType.Location = new System.Drawing.Point(336' 320);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.cboCoinType.Location = new System.Drawing.Point(336' 320);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.cboCoinType.Size = new System.Drawing.Size(101' 21);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.cboCoinType.Size = new System.Drawing.Size(101' 21);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.cboCoinType.TabIndex = 22;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnShacode.Location = new System.Drawing.Point(543' 58);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnShacode.Location = new System.Drawing.Point(543' 58);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnShacode.Size = new System.Drawing.Size(114' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnShacode.Size = new System.Drawing.Size(114' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnShacode.TabIndex = 4;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(670' 24);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(670' 24);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.TabIndex = 25;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.toolsToolStripMenuItem.Size = new System.Drawing.Size(48' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.toolsToolStripMenuItem.Size = new System.Drawing.Size(48' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.base58CalcToolStripMenuItem.Size = new System.Drawing.Size(196' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.base58CalcToolStripMenuItem.Size = new System.Drawing.Size(196' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.keyCombinerToolStripMenuItem.Size = new System.Drawing.Size(196' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.keyCombinerToolStripMenuItem.Size = new System.Drawing.Size(196' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.mofNCalcToolStripMenuItem.Size = new System.Drawing.Size(196' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.mofNCalcToolStripMenuItem.Size = new System.Drawing.Size(196' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pPECKeygenToolStripMenuItem.Size = new System.Drawing.Size(196' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.pPECKeygenToolStripMenuItem.Size = new System.Drawing.Size(196' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.editToolStripMenuItem.Size = new System.Drawing.Size(39' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.editToolStripMenuItem.Size = new System.Drawing.Size(39' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.copyMinikeyQRMenuItem.Size = new System.Drawing.Size(327' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.copyMinikeyQRMenuItem.Size = new System.Drawing.Size(327' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.copyPrivateKeyQRMenuItem.Size = new System.Drawing.Size(327' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.copyPrivateKeyQRMenuItem.Size = new System.Drawing.Size(327' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.copyPublicHexQRMenuItem.Size = new System.Drawing.Size(327' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.copyPublicHexQRMenuItem.Size = new System.Drawing.Size(327' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.copyAddressQRMenuItem.Size = new System.Drawing.Size(327' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.copyAddressQRMenuItem.Size = new System.Drawing.Size(327' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.optionsToolStripMenuItem.Size = new System.Drawing.Size(61' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.optionsToolStripMenuItem.Size = new System.Drawing.Size(61' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.spaceBetweenHexBytesToolStripMenuItem.Size = new System.Drawing.Size(205' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.spaceBetweenHexBytesToolStripMenuItem.Size = new System.Drawing.Size(205' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.publicKeyToolStripMenuItem.Size = new System.Drawing.Size(74' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.publicKeyToolStripMenuItem.Size = new System.Drawing.Size(74' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.compressToolStripMenuItem.Size = new System.Drawing.Size(250' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.compressToolStripMenuItem.Size = new System.Drawing.Size(250' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.compressPublicKeyToolStripMenuItem.Size = new System.Drawing.Size(250' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.compressPublicKeyToolStripMenuItem.Size = new System.Drawing.Size(250' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.uncompressPublicKeyToolStripMenuItem.Size = new System.Drawing.Size(250' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.uncompressPublicKeyToolStripMenuItem.Size = new System.Drawing.Size(250' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.showFieldsToolStripMenuItem.Size = new System.Drawing.Size(250' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.showFieldsToolStripMenuItem.Size = new System.Drawing.Size(250' 22);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnSha256ToPrivate.Location = new System.Drawing.Point(491' 58);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnSha256ToPrivate.Location = new System.Drawing.Point(491' 58);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnSha256ToPrivate.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnSha256ToPrivate.Size = new System.Drawing.Size(46' 30);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.btnSha256ToPrivate.TabIndex = 3;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(5' 32);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(5' 32);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(96' 39);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(96' 39);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtMinikey.Location = new System.Drawing.Point(101' 36);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtMinikey.Location = new System.Drawing.Point(101' 36);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtMinikey.Size = new System.Drawing.Size(557' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtMinikey.Size = new System.Drawing.Size(557' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtMinikey.TabIndex = 2;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.lblNotSafe.ForeColor = System.Drawing.Color.FromArgb(((int)(((byte)(192))))' ((int)(((byte)(0))))' ((int)(((byte)(0)))));
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.lblNotSafe.Location = new System.Drawing.Point(112' 63);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.lblNotSafe.Location = new System.Drawing.Point(112' 63);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.lblNotSafe.Size = new System.Drawing.Size(93' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.lblNotSafe.Size = new System.Drawing.Size(93' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.lblNotSafe.TabIndex = 26;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.lblWhyNot.Location = new System.Drawing.Point(211' 63);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.lblWhyNot.Location = new System.Drawing.Point(211' 63);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.lblWhyNot.Size = new System.Drawing.Size(53' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.lblWhyNot.Size = new System.Drawing.Size(53' 13);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.lblWhyNot.TabIndex = 27;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(101' 115);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(101' 115);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(336' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(336' 20);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.TabIndex = 28;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(5' 112);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(5' 112);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(92' 26);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(92' 26);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.label7.TabIndex = 29;
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(670' 391);
Magic Number,BtcAddress,Form1,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(670' 391);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,btnGenerate_Click,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  TextBox t = GetPartBox(i);                  t.Text = "";                  t.BackColor = System.Drawing.Color.White;                              }
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,btnDecode_Click,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  TextBox t = GetPartBox(i);                  string p = t.Text.Trim();                    if (p == "" || (mn.PartsAccepted >= mn.PartsNeeded && mn.PartsNeeded > 0)) {                      t.BackColor = System.Drawing.Color.White;                  } else {                      string result = mn.AddKeyPart(p);                      if (result == null) {                          t.BackColor = System.Drawing.Color.LightGreen;                      } else {                          t.BackColor = System.Drawing.Color.Pink;                      }                  }              }
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart1.Location = new System.Drawing.Point(49' 40);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart1.Location = new System.Drawing.Point(49' 40);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart1.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart1.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(8' 43);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(8' 43);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(8' 69);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(8' 69);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 3;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart2.Location = new System.Drawing.Point(49' 66);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart2.Location = new System.Drawing.Point(49' 66);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart2.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart2.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart2.TabIndex = 2;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(8' 95);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(8' 95);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 5;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart3.Location = new System.Drawing.Point(49' 92);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart3.Location = new System.Drawing.Point(49' 92);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart3.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart3.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart3.TabIndex = 4;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(8' 121);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(8' 121);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 7;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart4.Location = new System.Drawing.Point(49' 118);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart4.Location = new System.Drawing.Point(49' 118);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart4.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart4.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart4.TabIndex = 6;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(8' 147);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(8' 147);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 9;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart5.Location = new System.Drawing.Point(49' 144);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart5.Location = new System.Drawing.Point(49' 144);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart5.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart5.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart5.TabIndex = 8;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(8' 173);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(8' 173);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 11;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart6.Location = new System.Drawing.Point(49' 170);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart6.Location = new System.Drawing.Point(49' 170);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart6.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart6.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart6.TabIndex = 10;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(8' 199);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(8' 199);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label7.TabIndex = 13;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart7.Location = new System.Drawing.Point(49' 196);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart7.Location = new System.Drawing.Point(49' 196);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart7.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart7.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart7.TabIndex = 12;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(8' 225);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(8' 225);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(35' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label8.TabIndex = 15;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart8.Location = new System.Drawing.Point(49' 222);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart8.Location = new System.Drawing.Point(49' 222);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart8.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart8.Size = new System.Drawing.Size(556' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPart8.TabIndex = 14;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(8' 12);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(8' 12);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(95' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(95' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label9.TabIndex = 17;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(169' 12);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label10.Location = new System.Drawing.Point(169' 12);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(103' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label10.Size = new System.Drawing.Size(103' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label10.TabIndex = 19;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsNeeded.Location = new System.Drawing.Point(109' 10);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsNeeded.Location = new System.Drawing.Point(109' 10);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsNeeded.Maximum = new decimal(new int[] {              8'              0'              0'              0});
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsNeeded.Size = new System.Drawing.Size(44' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsNeeded.Size = new System.Drawing.Size(44' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsNeeded.TabIndex = 20;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsNeeded.Value = new decimal(new int[] {              3'              0'              0'              0});
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsToGenerate.Location = new System.Drawing.Point(278' 10);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsToGenerate.Location = new System.Drawing.Point(278' 10);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsToGenerate.Maximum = new decimal(new int[] {              8'              0'              0'              0});
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsToGenerate.Size = new System.Drawing.Size(46' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsToGenerate.Size = new System.Drawing.Size(46' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsToGenerate.TabIndex = 21;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.numPartsToGenerate.Value = new decimal(new int[] {              5'              0'              0'              0});
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(12' 292);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label11.Location = new System.Drawing.Point(12' 292);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(60' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label11.Size = new System.Drawing.Size(60' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label11.TabIndex = 23;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivKey.Location = new System.Drawing.Point(78' 289);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivKey.Location = new System.Drawing.Point(78' 289);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivKey.Size = new System.Drawing.Size(527' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivKey.Size = new System.Drawing.Size(527' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtPrivKey.TabIndex = 22;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(12' 318);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(12' 318);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(45' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(45' 13);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.label12.TabIndex = 25;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtAddress.Location = new System.Drawing.Point(78' 315);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtAddress.Location = new System.Drawing.Point(78' 315);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtAddress.Size = new System.Drawing.Size(527' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtAddress.Size = new System.Drawing.Size(527' 20);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.txtAddress.TabIndex = 24;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerate.Location = new System.Drawing.Point(392' 9);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerate.Location = new System.Drawing.Point(392' 9);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerate.Size = new System.Drawing.Size(212' 25);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerate.Size = new System.Drawing.Size(212' 25);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerate.TabIndex = 26;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnDecode.Location = new System.Drawing.Point(508' 248);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnDecode.Location = new System.Drawing.Point(508' 248);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnDecode.Size = new System.Drawing.Size(96' 24);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnDecode.Size = new System.Drawing.Size(96' 24);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnDecode.TabIndex = 27;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateSpecific.Location = new System.Drawing.Point(10' 255);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateSpecific.Location = new System.Drawing.Point(10' 255);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateSpecific.Size = new System.Drawing.Size(248' 31);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateSpecific.Size = new System.Drawing.Size(248' 31);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateSpecific.TabIndex = 28;
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(618' 365);
Magic Number,BtcAddress,MofNcalc,C:\repos\casascius_Bitcoin-Address-Utility\Forms\MofNcalc.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(618' 365);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,GetUglyRandomString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(128);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,GetUglyRandomString,The following statement contains a magic number: for (int i = 0; i < 64; i++) {                  SecureRandom sr = new SecureRandom();                  int idx = sr.Next(0' 61);                  sb.Append("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".Substring(idx' 1));              }
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,GetUglyRandomString,The following statement contains a magic number: for (int i = 0; i < 64; i++) {                  SecureRandom sr = new SecureRandom();                  int idx = sr.Next(0' 61);                  sb.Append("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".Substring(idx' 1));              }
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,btnGenerateAddresses_Click,The following statement contains a magic number: if (CurrentlyGenerating == false) {                  if (rdoRandomWallet.Checked) {                      if (txtPassphrase.Text.Length < 30) {                          MessageBox.Show("Please provide some random characters.  Just hit different keys on the keyboard until the box is full. " +                              "This adds security to your paper wallet."' ""' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                          return;                      }                  }                  if (numGenCount.Value < 1) {                      MessageBox.Show("Enter the number of addresses to create."' ""' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                      return;                  }                        if (Addresses.Count > 0 && CurrentSelectionSaved==false && rdoDeterministicWallet.Checked==false) {                        string msg = "You have generated " + Addresses.Count + " addresses' which will be discarded if you continue.  Continue?";                          if (Addresses.Count == 1) msg = msg.Replace("addresses"' "address");                        if (MessageBox.Show(msg' "Continue with generation?"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) != DialogResult.Yes) return;                    }                    if (rdoDeterministicWallet.Checked && txtPassphrase.Text == CurrentPassphrase) {                      string msg = "You have not changed the passphrase since the last time you generated addresses' so you will be generating the same addresses as last time.  Continue?";                      if (MessageBox.Show(msg' "Continue with generation?"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) != DialogResult.Yes) return;                    } else {                      CurrentSelectionSaved = false;                      CurrentSelectionPrinted = false;                  }                    Addresses = new List<KeyCollectionItem>();                                      lblGenCount.Text = Addresses.Count.ToString() + " addresses have been generated.";                    TotalToGenerate = (int)numGenCount.Value;                  CurrentSequence = 1;                    if (rdoRandomWallet.Checked) {                      CurrentPassphrase = txtPassphrase.Text + GetUglyRandomString();                  } else {                      if (txtPassphrase.Text.Length < 30) {                          if (MessageBox.Show("Passphrases must be highly unique and very long to be secure against hackers' who try trillions of random passwords in hopes of " +                              "finding coins to steal.  Use a Random Wallet if you are not 100% sure about what you're doing.  Continue?"' ""' MessageBoxButtons.OKCancel' MessageBoxIcon.Exclamation)                           == DialogResult.Cancel) return;                      }                      CurrentPassphrase = txtPassphrase.Text;                  }                    CurrentlyGenerating = true;                  LockButtons(true);                  btnGenerateAddresses.Text = "Stop generating";                  timer1.Enabled = true;                } else {                  CurrentlyGenerating = false;                  LockButtons(false);                  timer1.Enabled = false;                  btnGenerateAddresses.Text = "Generate addresses";              }
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,btnGenerateAddresses_Click,The following statement contains a magic number: if (CurrentlyGenerating == false) {                  if (rdoRandomWallet.Checked) {                      if (txtPassphrase.Text.Length < 30) {                          MessageBox.Show("Please provide some random characters.  Just hit different keys on the keyboard until the box is full. " +                              "This adds security to your paper wallet."' ""' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                          return;                      }                  }                  if (numGenCount.Value < 1) {                      MessageBox.Show("Enter the number of addresses to create."' ""' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                      return;                  }                        if (Addresses.Count > 0 && CurrentSelectionSaved==false && rdoDeterministicWallet.Checked==false) {                        string msg = "You have generated " + Addresses.Count + " addresses' which will be discarded if you continue.  Continue?";                          if (Addresses.Count == 1) msg = msg.Replace("addresses"' "address");                        if (MessageBox.Show(msg' "Continue with generation?"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) != DialogResult.Yes) return;                    }                    if (rdoDeterministicWallet.Checked && txtPassphrase.Text == CurrentPassphrase) {                      string msg = "You have not changed the passphrase since the last time you generated addresses' so you will be generating the same addresses as last time.  Continue?";                      if (MessageBox.Show(msg' "Continue with generation?"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) != DialogResult.Yes) return;                    } else {                      CurrentSelectionSaved = false;                      CurrentSelectionPrinted = false;                  }                    Addresses = new List<KeyCollectionItem>();                                      lblGenCount.Text = Addresses.Count.ToString() + " addresses have been generated.";                    TotalToGenerate = (int)numGenCount.Value;                  CurrentSequence = 1;                    if (rdoRandomWallet.Checked) {                      CurrentPassphrase = txtPassphrase.Text + GetUglyRandomString();                  } else {                      if (txtPassphrase.Text.Length < 30) {                          if (MessageBox.Show("Passphrases must be highly unique and very long to be secure against hackers' who try trillions of random passwords in hopes of " +                              "finding coins to steal.  Use a Random Wallet if you are not 100% sure about what you're doing.  Continue?"' ""' MessageBoxButtons.OKCancel' MessageBoxIcon.Exclamation)                           == DialogResult.Cancel) return;                      }                      CurrentPassphrase = txtPassphrase.Text;                  }                    CurrentlyGenerating = true;                  LockButtons(true);                  btnGenerateAddresses.Text = "Stop generating";                  timer1.Enabled = true;                } else {                  CurrentlyGenerating = false;                  LockButtons(false);                  timer1.Enabled = false;                  btnGenerateAddresses.Text = "Generate addresses";              }
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(486' 12);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(486' 12);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(313' 211);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(313' 211);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnPrintWallet.Location = new System.Drawing.Point(82' 92);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnPrintWallet.Location = new System.Drawing.Point(82' 92);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnPrintWallet.Size = new System.Drawing.Size(173' 36);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnPrintWallet.Size = new System.Drawing.Size(173' 36);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnPrintWallet.TabIndex = 11;
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoWalletPrivQR.Location = new System.Drawing.Point(27' 54);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoWalletPrivQR.Location = new System.Drawing.Point(27' 54);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoWalletPrivQR.Size = new System.Drawing.Size(222' 17);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoWalletPrivQR.Size = new System.Drawing.Size(222' 17);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoWalletPubPrivQR.Location = new System.Drawing.Point(27' 31);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoWalletPubPrivQR.Location = new System.Drawing.Point(27' 31);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoWalletPubPrivQR.Size = new System.Drawing.Size(228' 17);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoWalletPubPrivQR.Size = new System.Drawing.Size(228' 17);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(12' 12);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Location = new System.Drawing.Point(12' 12);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(468' 211);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.groupBox2.Size = new System.Drawing.Size(468' 211);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.chkMiniKeys.Location = new System.Drawing.Point(288' 32);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.chkMiniKeys.Location = new System.Drawing.Point(288' 32);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.chkMiniKeys.Size = new System.Drawing.Size(117' 17);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.chkMiniKeys.Size = new System.Drawing.Size(117' 17);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.chkMiniKeys.TabIndex = 10;
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.lblGenCount.Location = new System.Drawing.Point(9' 184);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.lblGenCount.Location = new System.Drawing.Point(9' 184);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.lblGenCount.Size = new System.Drawing.Size(172' 13);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.lblGenCount.Size = new System.Drawing.Size(172' 13);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.lblGenCount.TabIndex = 7;
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateAddresses.Location = new System.Drawing.Point(288' 170);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateAddresses.Location = new System.Drawing.Point(288' 170);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateAddresses.Size = new System.Drawing.Size(173' 36);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateAddresses.Size = new System.Drawing.Size(173' 36);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateAddresses.TabIndex = 6;
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoDeterministicWallet.Location = new System.Drawing.Point(20' 77);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoDeterministicWallet.Location = new System.Drawing.Point(20' 77);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoDeterministicWallet.Size = new System.Drawing.Size(115' 17);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoDeterministicWallet.Size = new System.Drawing.Size(115' 17);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoDeterministicWallet.TabIndex = 5;
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoRandomWallet.Location = new System.Drawing.Point(20' 54);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoRandomWallet.Location = new System.Drawing.Point(20' 54);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoRandomWallet.Size = new System.Drawing.Size(153' 17);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoRandomWallet.Size = new System.Drawing.Size(153' 17);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.rdoRandomWallet.TabIndex = 4;
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(17' 31);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(17' 31);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(164' 13);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(164' 13);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 3;
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Location = new System.Drawing.Point(187' 28);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Location = new System.Drawing.Point(187' 28);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Maximum = new decimal(new int[] {              99999'              0'              0'              0});
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Size = new System.Drawing.Size(90' 20);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Size = new System.Drawing.Size(90' 20);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.TabIndex = 2;
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Value = new decimal(new int[] {              8'              0'              0'              0});
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.lblInputDescription.Location = new System.Drawing.Point(9' 129);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.lblInputDescription.Location = new System.Drawing.Point(9' 129);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.lblInputDescription.Size = new System.Drawing.Size(284' 13);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.lblInputDescription.Size = new System.Drawing.Size(284' 13);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(12' 145);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(12' 145);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(450' 20);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(450' 20);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnSortKeys.Location = new System.Drawing.Point(82' 161);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnSortKeys.Location = new System.Drawing.Point(82' 161);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnSortKeys.Size = new System.Drawing.Size(173' 36);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnSortKeys.Size = new System.Drawing.Size(173' 36);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.btnSortKeys.TabIndex = 11;
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(828' 235);
Magic Number,BtcAddress,PaperWalletPrinter,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PaperWalletPrinter.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(828' 235);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(110' 121);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(110' 121);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(710' 20);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(710' 20);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 125);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 125);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(62' 13);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(62' 13);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 142);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 142);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(90' 26);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(90' 26);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 3;
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphraseCode.Location = new System.Drawing.Point(244' 147);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphraseCode.Location = new System.Drawing.Point(244' 147);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphraseCode.Size = new System.Drawing.Size(576' 20);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphraseCode.Size = new System.Drawing.Size(576' 20);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphraseCode.TabIndex = 2;
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.btnEncode.Location = new System.Drawing.Point(110' 142);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.btnEncode.Location = new System.Drawing.Point(110' 142);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.btnEncode.Size = new System.Drawing.Size(128' 29);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.btnEncode.Size = new System.Drawing.Size(128' 29);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.btnEncode.TabIndex = 9;
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(109' 174);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(109' 174);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(524' 13);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(524' 13);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 11;
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(6' 9);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label7.Location = new System.Drawing.Point(6' 9);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(643' 104);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label7.Size = new System.Drawing.Size(643' 104);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.label7.TabIndex = 13;
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Location = new System.Drawing.Point(707' 9);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Location = new System.Drawing.Point(707' 9);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Size = new System.Drawing.Size(113' 13);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Size = new System.Drawing.Size(113' 13);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.TabIndex = 14;
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(832' 204);
Magic Number,BtcAddress,PpecKeygen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PpecKeygen.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(832' 204);
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                    int eachheight=120;                    switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }                    if (i == 999) break;                          if (PrintMode == PrintModes.PubPrivQR && i >= 8) break;                    if (PrintMode == PrintModes.PsyBanknote && i >= NotesPerPage) break;                    if (keys.Count == 0) break;                    int thiscodeX = 50;                  int thiscodeY = 50 + eachheight * i;                  if (i >= 8) {                      thiscodeX = 450;                      thiscodeY = 50 + eachheight * (i - 8);                  }                    //    T-------------------------------|                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |                               |                  //    |-------------------------------|                  //                  //    T = thiscodeX'thiscodeY                  //                      // Load the Ubuntu font directly from a file so it doesn't need to be installed on the system.                  if (UbuntuFontLoaded == false) {                      UbuntuFontLoaded = true;                      try {                          System.Drawing.Text.PrivateFontCollection pfc = new System.Drawing.Text.PrivateFontCollection();                          pfc.AddFontFile("Ubuntu-R.ttf");                      } catch { }                  }                    ubuntufont = new Font("Ubuntu"' 6);                  ubuntumid = new Font("Ubuntu"' 9);                  ubuntubig = new Font("Ubuntu"' 17);                      KeyCollectionItem k = (KeyCollectionItem)keys[0];                  keys.RemoveAt(0);                    string privkey = k.PrivateKey;                  if (PreferUnencryptedPrivateKeys) {                      if (k.EncryptedKeyPair != null && k.EncryptedKeyPair.IsUnencryptedPrivateKeyAvailable()) {                          privkey = k.EncryptedKeyPair.GetUnencryptedPrivateKey().PrivateKey;                      }                  }                    Bitmap b = QR.EncodeQRCode(privkey);                    if (PrintMode == PrintModes.PsyBanknote) {                        if (BitcoinNote == null) {                          BitcoinNote = Image.FromFile(ImageFilename);                        }                        float desiredScale = 550F;                        float scalefactor = (desiredScale / 650.0F);                      float leftOffset = (float)printWidth - desiredScale;                                              // draw the note                      e.Graphics.DrawImage(BitcoinNote'                                           leftOffset + scalefactor * (float)thiscodeX'                                           scalefactor * (float)thiscodeY' (float)650F * scalefactor'                                           (float)650F * scalefactor * (float)BitcoinNote.Height / (float)BitcoinNote.Width);                        // draw the private QR                      e.Graphics.DrawImage(b' leftOffset + scalefactor * (float)(thiscodeX + 472)'                           scalefactor * (float)(thiscodeY + 140)'                           scalefactor * 145F'                           scalefactor * 147F);                                            // draw the public QR                      Bitmap b2 = QR.EncodeQRCode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2'                          leftOffset + scalefactor * (float)(thiscodeX + 39)'                          scalefactor * (float)(thiscodeY + 90)' scalefactor * 128F' scalefactor * 128F);                        // write bitcoin address                      StringFormat sf = new StringFormat();                      //sf.FormatFlags |= StringFormatFlags.DirectionVertical | StringFormatFlags.DirectionRightToLeft;                        e.Graphics.RotateTransform(-90F);                      e.Graphics.DrawString("Bitcoin Address\r\n" + k.GetAddressBase58()' ubuntumid' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 338)'                          leftOffset + scalefactor * (float)(thiscodeX + 170)'                             sf);                        // write private key                      string whattoprint;                      if (privkey.Length > 30) {                          whattoprint = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattoprint = "\r\n" + privkey;                      }                      float xpos =  444;                      if (privkey.StartsWith("6")) {                          whattoprint = "Password Required\r\n" + whattoprint;                          xpos -=  10;                      }                        e.Graphics.DrawString(whattoprint' ubuntufont' Brushes.Black'                          -scalefactor * (float)(thiscodeY + 290)'                          leftOffset + scalefactor * (float)(thiscodeX + xpos)'                          sf);                          e.Graphics.RotateTransform(90F);                        // write denomination' if any                      if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination' ubuntubig' Brushes.Black'                              leftOffset + scalefactor * (float)(thiscodeX + 330)'                              scalefactor * (float)(thiscodeY + 310)                                                            );                      }                        if (PrintMiniKeysWith1DBarcode && k.Address is MiniKeyPair) {                          Bitmap barcode1d = Barcode128b.GetBarcode(k.PrivateKey);                          float aspect1d = (float)barcode1d.Width / (float)barcode1d.Height;                          e.Graphics.DrawImage(barcode1d' leftOffset + scalefactor * (float)(thiscodeX + 231F)'                              scalefactor * (float)(thiscodeY + 293)'                              scalefactor * 420F'                              scalefactor * 50F);                        }                    } else if (PrintMode == PrintModes.PrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with only private key QR code.  Fits 16 to a page.                      // ----------------------------------------------------------------                      e.Graphics.DrawImage(b' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address: " + k.GetAddressBase58()' fontsmall' Brushes.Black' thiscodeX + 110' thiscodeY);                        string whattowrite;                      if (privkey.Length > 30) {                          whattowrite = privkey.Substring(0' 25) + "\r\n" + privkey.Substring(25);                      } else {                          whattowrite = "\r\n" + privkey;                      }                      if (privkey.StartsWith("6")) {                          whattowrite = whattowrite + "\r\nPassword Required";                      }                          e.Graphics.DrawString(whattowrite' font' Brushes.Black' thiscodeX + 110' thiscodeY + 15);                        if ((Denomination ?? "") != "") {                          e.Graphics.DrawString(Denomination + " BTC"' fontbig' Brushes.Black' thiscodeX + 110' thiscodeY + 75);                       }                                          } else if (PrintMode == PrintModes.PubPrivQR) {                        // ----------------------------------------------------------------                      // Paper wallet with public and private QR codes.  Fits 8 to a page.                      // ----------------------------------------------------------------                        e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                      QRCodeEncoder qr2 = new QRCodeEncoder();                      qr2.QRCodeVersion = 3;                        Bitmap b2 = qr2.Encode(k.GetAddressBase58());                      e.Graphics.DrawImage(b2' thiscodeX' thiscodeY' 100' 100);                        e.Graphics.DrawString("Bitcoin address:\r\n" + k.GetAddressBase58()' font' Brushes.Black' thiscodeX + 110' thiscodeY);                        StringFormat sf = new StringFormat();                      sf.Alignment = StringAlignment.Far; // right justify                      string whattoprint = privkey;                      if (privkey.StartsWith("6")) {                          whattoprint = whattoprint + "\r\nPassword Required";                      }                        e.Graphics.DrawString("Private key:\r\n" + whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 65' sf);                    }                }
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,button1_Click,The following statement contains a magic number: if (button1.Enabled)              {                  int n = 0;                    if (Int32.TryParse(textBox2.Text' out n) == false) n = 0;                  if (n < 1 || n > 9999) {                                      MessageBox.Show("Please enter a number of addresses between 1 and 9999"' "Invalid entry");                      return;                  }                      if (txtPassphrase.Text.Length < 20)                  {                        if (MessageBox.Show("Your passphrase is too short (< 20 characters). If you generate this wallet it may be easily compromised. Are you sure you'd like to use this passphrase?"' "Passphrase too short"' MessageBoxButtons.YesNo) == DialogResult.No)                      {                          return;                      }                    }                        if (Util.PassphraseTooSimple(txtPassphrase.Text))                  {                        if (MessageBox.Show("Your passphrase is too simple. If you generate this wallet it may be easily compromised. Are you sure you'd like to use this passphrase?"' "Passphrase too simple"' MessageBoxButtons.YesNo) == DialogResult.No)                      {                          return;                      }                    }                    StringBuilder wallet = new StringBuilder();                                      bool CSVmode = cboOutputType.Text.Contains("CSV");                  bool ScriptMode = cboOutputType.Text.Contains("Import script");                  bool ShowHelpText = cboOutputType.Text.Contains("Normal");                    if (ShowHelpText) {                      wallet.AppendLine("Paper Bitcoin Wallet.  Keep private' do not lose' do not allow anyone to make a copy.  Anyone with the passphrase or private keys can steal your funds.\r\n");                        wallet.AppendLine("Passphrase was:");                      wallet.AppendLine(txtPassphrase.Text);                      wallet.AppendLine("Freely give out the Bitcoin address.  The private key after each address is the key needed to unlock funds sent to the Bitcoin address.\r\n");                    }                  progressBar1.Maximum = n;                  progressBar1.Minimum = 0;                  progressBar1.Visible = true;                  label3.Text = "Progress:";                  button1.Enabled = false;                    for (int i = 1; i <= n; i++)                  {                      Application.DoEvents();                        string privatestring;                      switch (GenerationFormula) {                          case 1:                              privatestring = txtPassphrase.Text + i.ToString();                              break;                          default:                              privatestring = i.ToString() + "/" + txtPassphrase.Text + "/" + i.ToString() + "/BITCOIN";                              break;                      }                      byte[] privatekey = Util.ComputeSha256(privatestring);                        KeyPair kp = new KeyPair(privatekey);                        string bytestring = kp.PrivateKeyHex;                      string PrivWIF = kp.PrivateKeyBase58;                      string PubHex = kp.PublicKeyHex;                      string Address = kp.AddressBase58;                        if (CSVmode) {                          wallet.AppendFormat("{0}'\"{1}\"'\"{2}\"\r\n"' i' Address' PrivWIF);                      } else if (ScriptMode) {                          wallet.AppendFormat("# {0}: {1}\"\r\n./bitcoind importprivkey {2}\r\n"' i' Address' PrivWIF);                                                                  } else {                          wallet.AppendFormat("Bitcoin Address #{0}: {1}\r\n"' i' Address);                          wallet.AppendFormat("Private Key: {0}\r\n\r\n"' PrivWIF);                      }                        progressBar1.Value = i;                  }                    txtWallet.Text = wallet.ToString();                    progressBar1.Value = 0;                  progressBar1.Visible = false;                  label3.Text = "Passphrase:";                  button1.Enabled = true;              }
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,button1_Click,The following statement contains a magic number: if (button1.Enabled)              {                  int n = 0;                    if (Int32.TryParse(textBox2.Text' out n) == false) n = 0;                  if (n < 1 || n > 9999) {                                      MessageBox.Show("Please enter a number of addresses between 1 and 9999"' "Invalid entry");                      return;                  }                      if (txtPassphrase.Text.Length < 20)                  {                        if (MessageBox.Show("Your passphrase is too short (< 20 characters). If you generate this wallet it may be easily compromised. Are you sure you'd like to use this passphrase?"' "Passphrase too short"' MessageBoxButtons.YesNo) == DialogResult.No)                      {                          return;                      }                    }                        if (Util.PassphraseTooSimple(txtPassphrase.Text))                  {                        if (MessageBox.Show("Your passphrase is too simple. If you generate this wallet it may be easily compromised. Are you sure you'd like to use this passphrase?"' "Passphrase too simple"' MessageBoxButtons.YesNo) == DialogResult.No)                      {                          return;                      }                    }                    StringBuilder wallet = new StringBuilder();                                      bool CSVmode = cboOutputType.Text.Contains("CSV");                  bool ScriptMode = cboOutputType.Text.Contains("Import script");                  bool ShowHelpText = cboOutputType.Text.Contains("Normal");                    if (ShowHelpText) {                      wallet.AppendLine("Paper Bitcoin Wallet.  Keep private' do not lose' do not allow anyone to make a copy.  Anyone with the passphrase or private keys can steal your funds.\r\n");                        wallet.AppendLine("Passphrase was:");                      wallet.AppendLine(txtPassphrase.Text);                      wallet.AppendLine("Freely give out the Bitcoin address.  The private key after each address is the key needed to unlock funds sent to the Bitcoin address.\r\n");                    }                  progressBar1.Maximum = n;                  progressBar1.Minimum = 0;                  progressBar1.Visible = true;                  label3.Text = "Progress:";                  button1.Enabled = false;                    for (int i = 1; i <= n; i++)                  {                      Application.DoEvents();                        string privatestring;                      switch (GenerationFormula) {                          case 1:                              privatestring = txtPassphrase.Text + i.ToString();                              break;                          default:                              privatestring = i.ToString() + "/" + txtPassphrase.Text + "/" + i.ToString() + "/BITCOIN";                              break;                      }                      byte[] privatekey = Util.ComputeSha256(privatestring);                        KeyPair kp = new KeyPair(privatekey);                        string bytestring = kp.PrivateKeyHex;                      string PrivWIF = kp.PrivateKeyBase58;                      string PubHex = kp.PublicKeyHex;                      string Address = kp.AddressBase58;                        if (CSVmode) {                          wallet.AppendFormat("{0}'\"{1}\"'\"{2}\"\r\n"' i' Address' PrivWIF);                      } else if (ScriptMode) {                          wallet.AppendFormat("# {0}: {1}\"\r\n./bitcoind importprivkey {2}\r\n"' i' Address' PrivWIF);                                                                  } else {                          wallet.AppendFormat("Bitcoin Address #{0}: {1}\r\n"' i' Address);                          wallet.AppendFormat("Private Key: {0}\r\n\r\n"' PrivWIF);                      }                        progressBar1.Value = i;                  }                    txtWallet.Text = wallet.ToString();                    progressBar1.Value = 0;                  progressBar1.Visible = false;                  label3.Text = "Passphrase:";                  button1.Enabled = true;              }
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,Walletgen_Shown,The following statement contains a magic number: const int phraselength = 80;
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,Walletgen_Shown,The following statement contains a magic number: for (int i = 0; i < phraselength; i++) {                  randomphrase += junk64.Substring(byte8[i] & 63' 1);              }
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,button2_Click,The following statement contains a magic number: if (dr == DialogResult.OK)              {                  PCPrint printer = new PCPrint();                  printer.PrinterSettings.PrinterName = pd.PrinterSettings.PrinterName;                  printer.PrinterFont = new Font("Verdana"' 10);                  printer.TextToPrint = txtWallet.Text;                  printer.Print();                }
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(5' 7);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(5' 7);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(672' 13);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(672' 13);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(5' 34);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(5' 34);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(547' 13);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(547' 13);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(8' 72);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(8' 72);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(720' 20);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(720' 20);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(5' 56);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(5' 56);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(65' 13);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(65' 13);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 3;
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.txtWallet.Location = new System.Drawing.Point(12' 129);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.txtWallet.Location = new System.Drawing.Point(12' 129);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.txtWallet.Size = new System.Drawing.Size(715' 474);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.txtWallet.Size = new System.Drawing.Size(715' 474);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.txtWallet.TabIndex = 3;
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(606' 95);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(606' 95);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(121' 28);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(121' 28);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.button1.TabIndex = 2;
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.lblFormula.Location = new System.Drawing.Point(15' 608);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.lblFormula.Location = new System.Drawing.Point(15' 608);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.lblFormula.Size = new System.Drawing.Size(268' 13);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.lblFormula.Size = new System.Drawing.Size(268' 13);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.lblFormula.TabIndex = 6;
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(12' 624);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(12' 624);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(661' 45);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(661' 45);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.TabIndex = 8;
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(59' 100);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(59' 100);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(107' 13);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(107' 13);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 10;
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Location = new System.Drawing.Point(9' 72);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Location = new System.Drawing.Point(9' 72);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Size = new System.Drawing.Size(719' 20);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.Size = new System.Drawing.Size(719' 20);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.progressBar1.TabIndex = 12;
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.textBox2.Location = new System.Drawing.Point(8' 96);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.textBox2.Location = new System.Drawing.Point(8' 96);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.textBox2.MaxLength = 4;
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.textBox2.Size = new System.Drawing.Size(45' 20);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.textBox2.Size = new System.Drawing.Size(45' 20);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.button2.Location = new System.Drawing.Point(678' 625);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.button2.Location = new System.Drawing.Point(678' 625);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.button2.Size = new System.Drawing.Size(62' 41);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.button2.Size = new System.Drawing.Size(62' 41);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.button2.TabIndex = 13;
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.cboOutputType.Location = new System.Drawing.Point(192' 96);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.cboOutputType.Location = new System.Drawing.Point(192' 96);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.cboOutputType.Size = new System.Drawing.Size(121' 21);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.cboOutputType.Size = new System.Drawing.Size(121' 21);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.cboOutputType.TabIndex = 14;
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(752' 678);
Magic Number,BtcAddress,Walletgen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Walletgen.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(752' 678);
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,BtcAddress,CoinInsert,C:\repos\casascius_Bitcoin-Address-Utility\Reports\CoinInsert.cs,OnPrintPage,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  int eachheight = 120;                  if (keys.Count == 0) break;                    KeyCollectionItem kci = keys[0];                  string address = kci.GetAddressBase58();                    string privkey = kci.PrivateKey;                  string confcode = "";                  if (kci.EncryptedKeyPair != null && kci.EncryptedKeyPair is Bip38KeyPair) {                      confcode = ((Bip38KeyPair)kci.EncryptedKeyPair).GetConfirmationCode() ?? "";                      //if (confcode != "") confcode = "Confirmation code:\r\n" + confcode;                  }                    keys.RemoveAt(0);                    int thiscodeX = 0; //  50;                  int thiscodeY = 50 + eachheight * i;                    // ----------------------------------------------------------------                  // Coin insert with public and private QR codes.  Fits 8 to a page.                  // ----------------------------------------------------------------                      float CircleDiameterInches = (7F / 16F); // 7/16"                    // draw the private key circle                  using (Pen blackpen = new Pen(Color.Black)) {                      blackpen.Width = (1F / 72F);                        e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                        // Over 30 characters? do a folding insert at 95% diameter away                      if (privkey.Length > 30) {                          e.Graphics.DrawEllipse(blackpen' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                          e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F + (CircleDiameterInches * 95F)' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                      }                      e.Graphics.FillEllipse(Brushes.White' thiscodeX + 30F' thiscodeY + 10F' CircleDiameterInches * 100F' CircleDiameterInches * 100F);                  }                        int[] charsPerLine = new int[] { 4' 7' 8' 7' 4' 0' 4' 7' 8' 7' 4 };                  string privkeyleft = privkey;                  // if it's going to take two circles' add hyphens                  if (privkeyleft.Length > 30) privkeyleft = privkeyleft.Substring(0' 29) + "--" + privkeyleft.Substring(29);                  string privkeytoprint = "";                  for (int c = 0; c < 11; c++) {                      if (charsPerLine[c] == 0) {                          privkeytoprint += "\r\n";                      } else {                          if (privkeyleft.Length > charsPerLine[c]) {                              privkeytoprint += privkeyleft.Substring(0' charsPerLine[c]) + "\r\n";                              privkeyleft = privkeyleft.Substring(charsPerLine[c]);                          } else {                              privkeytoprint += privkeyleft + "\r\n";                              privkeyleft = "";                          }                      }                  }                  using (StringFormat sfcenter = new StringFormat()) {                      sfcenter.Alignment = StringAlignment.Center;                      e.Graphics.DrawString(privkeytoprint' fontsmall' Brushes.Black' thiscodeX + 30F + (CircleDiameterInches * 100F / 2F)' thiscodeY + 14F' sfcenter);                  }                                            // draw the address QR code                  using (Bitmap b2 = QR.EncodeQRCode(address)) {                      e.Graphics.DrawImage(b2' thiscodeX + 100' thiscodeY' 100' 100);                  }                                e.Graphics.DrawString("Bitcoin address:\r\n" + address' font' Brushes.Black' thiscodeX + 210' thiscodeY);                    StringFormat sf = new StringFormat();                  sf.Alignment = StringAlignment.Far; // right justify                    if (confcode != "") {                      // Print the confirmation QR code                      using (Bitmap b = QR.EncodeQRCode(confcode)) {                          e.Graphics.DrawImage(b' thiscodeX + 600' thiscodeY' 100' 100);                            string whattoprint = "Confirmation code:\r\n" + confcode.Substring(0' 38) + "\r\n" + confcode.Substring(38);                            e.Graphics.DrawString(whattoprint' font' Brushes.Black' thiscodeX + 597' thiscodeY + 55' sf);                      }                  }                  }
Magic Number,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The following statement contains a magic number: if (_asBytes.Length < 4) {                  // Too short for a checksum to exist                  throw new ArgumentException("Not a valid Base58Check string' checksum is not present");              }
Magic Number,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The following statement contains a magic number: int lengthWithoutChecksum = _asBytes.Length - 4;
Magic Number,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The following statement contains a magic number: if (sha256sum[0] != _asBytes[lengthWithoutChecksum] ||                  sha256sum[1] != _asBytes[lengthWithoutChecksum + 1] ||                  sha256sum[2] != _asBytes[lengthWithoutChecksum + 2] ||                  sha256sum[3] != _asBytes[lengthWithoutChecksum + 3]) {                      throw new ArgumentException("Not a valid Base58Check string' checksum is invalid");                }
Magic Number,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The following statement contains a magic number: if (sha256sum[0] != _asBytes[lengthWithoutChecksum] ||                  sha256sum[1] != _asBytes[lengthWithoutChecksum + 1] ||                  sha256sum[2] != _asBytes[lengthWithoutChecksum + 2] ||                  sha256sum[3] != _asBytes[lengthWithoutChecksum + 3]) {                      throw new ArgumentException("Not a valid Base58Check string' checksum is invalid");                }
Magic Number,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The following statement contains a magic number: if (sha256sum[0] != _asBytes[lengthWithoutChecksum] ||                  sha256sum[1] != _asBytes[lengthWithoutChecksum + 1] ||                  sha256sum[2] != _asBytes[lengthWithoutChecksum + 2] ||                  sha256sum[3] != _asBytes[lengthWithoutChecksum + 3]) {                      throw new ArgumentException("Not a valid Base58Check string' checksum is invalid");                }
Magic Number,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The following statement contains a magic number: if (sha256sum[0] != _asBytes[lengthWithoutChecksum] ||                  sha256sum[1] != _asBytes[lengthWithoutChecksum + 1] ||                  sha256sum[2] != _asBytes[lengthWithoutChecksum + 2] ||                  sha256sum[3] != _asBytes[lengthWithoutChecksum + 3]) {                      throw new ArgumentException("Not a valid Base58Check string' checksum is invalid");                }
Magic Number,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The following statement contains a magic number: byte[] withCheck = new byte[lengthWithoutChecksum+4];
Magic Number,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The following statement contains a magic number: withCheck[lengthWithoutChecksum + 2] = sha256sum[2];
Magic Number,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The following statement contains a magic number: withCheck[lengthWithoutChecksum + 2] = sha256sum[2];
Magic Number,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The following statement contains a magic number: withCheck[lengthWithoutChecksum + 3] = sha256sum[3];
Magic Number,Casascius.Bitcoin,Base58CheckString,C:\repos\casascius_Bitcoin-Address-Utility\Model\Base58CheckString.cs,Base58CheckString,The following statement contains a magic number: withCheck[lengthWithoutChecksum + 3] = sha256sum[3];
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,Bip38Confirmation,The following statement contains a magic number: flagbyte = bytes[5];
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,Bip38Confirmation,The following statement contains a magic number: _addressHash = new byte[4];
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,Bip38Confirmation,The following statement contains a magic number: Array.Copy(bytes' 6' _addressHash' 0' 4);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,Bip38Confirmation,The following statement contains a magic number: Array.Copy(bytes' 6' _addressHash' 0' 4);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,Bip38Confirmation,The following statement contains a magic number: _ownerentropy = new byte[8];
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,Bip38Confirmation,The following statement contains a magic number: Array.Copy(bytes' 10' _ownerentropy' 0' 8);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,Bip38Confirmation,The following statement contains a magic number: Array.Copy(bytes' 10' _ownerentropy' 0' 8);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,Bip38Confirmation,The following statement contains a magic number: _encryptedpointb = new byte[33];
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,Bip38Confirmation,The following statement contains a magic number: Array.Copy(bytes' 18' _encryptedpointb' 0' 33);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,Bip38Confirmation,The following statement contains a magic number: Array.Copy(bytes' 18' _encryptedpointb' 0' 33);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,ValidateBase58,The following statement contains a magic number: if (bytes==null ||                   bytes.Length != 51 ||                   // check the magic                  bytes[0] != 0x64 || bytes[1] != 0x3B || bytes[2] != 0xF6 ||                  bytes[3] != 0xA8 || bytes[4] != 0x9A ||                   // check valid values for first byte of pointb                  bytes[18] < 0x02 || bytes[18] > 0x03) {                  return new ArgumentException("This is not a valid confirmation code.");              }
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,ValidateBase58,The following statement contains a magic number: if (bytes==null ||                   bytes.Length != 51 ||                   // check the magic                  bytes[0] != 0x64 || bytes[1] != 0x3B || bytes[2] != 0xF6 ||                  bytes[3] != 0xA8 || bytes[4] != 0x9A ||                   // check valid values for first byte of pointb                  bytes[18] < 0x02 || bytes[18] > 0x03) {                  return new ArgumentException("This is not a valid confirmation code.");              }
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,ValidateBase58,The following statement contains a magic number: if (bytes==null ||                   bytes.Length != 51 ||                   // check the magic                  bytes[0] != 0x64 || bytes[1] != 0x3B || bytes[2] != 0xF6 ||                  bytes[3] != 0xA8 || bytes[4] != 0x9A ||                   // check valid values for first byte of pointb                  bytes[18] < 0x02 || bytes[18] > 0x03) {                  return new ArgumentException("This is not a valid confirmation code.");              }
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,ValidateBase58,The following statement contains a magic number: if (bytes==null ||                   bytes.Length != 51 ||                   // check the magic                  bytes[0] != 0x64 || bytes[1] != 0x3B || bytes[2] != 0xF6 ||                  bytes[3] != 0xA8 || bytes[4] != 0x9A ||                   // check valid values for first byte of pointb                  bytes[18] < 0x02 || bytes[18] > 0x03) {                  return new ArgumentException("This is not a valid confirmation code.");              }
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,ValidateBase58,The following statement contains a magic number: if (bytes==null ||                   bytes.Length != 51 ||                   // check the magic                  bytes[0] != 0x64 || bytes[1] != 0x3B || bytes[2] != 0xF6 ||                  bytes[3] != 0xA8 || bytes[4] != 0x9A ||                   // check valid values for first byte of pointb                  bytes[18] < 0x02 || bytes[18] > 0x03) {                  return new ArgumentException("This is not a valid confirmation code.");              }
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,ValidateBase58,The following statement contains a magic number: if (bytes==null ||                   bytes.Length != 51 ||                   // check the magic                  bytes[0] != 0x64 || bytes[1] != 0x3B || bytes[2] != 0xF6 ||                  bytes[3] != 0xA8 || bytes[4] != 0x9A ||                   // check valid values for first byte of pointb                  bytes[18] < 0x02 || bytes[18] > 0x03) {                  return new ArgumentException("This is not a valid confirmation code.");              }
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: byte[] derived = new byte[64];
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: SCrypt.ComputeKey(intermediate.passpoint' addresshashplusownerentropy' 1024' 1' 1' 1' derived);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: byte[] derivedhalf2 = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: Array.Copy(derived' 32' derivedhalf2' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: Array.Copy(derived' 32' derivedhalf2' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: byte[] unencryptedpubkey = new byte[33];
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: unencryptedpubkey[0] = (byte)(_encryptedpointb[0] ^ (derived[63] & 0x01));
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: aes.KeySize = 256;
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(_encryptedpointb' 1' 16' unencryptedpubkey' 1);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(_encryptedpointb' 1' 16' unencryptedpubkey' 1);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(_encryptedpointb' 1 + 16' 16' unencryptedpubkey' 17);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(_encryptedpointb' 1 + 16' 16' unencryptedpubkey' 17);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(_encryptedpointb' 1 + 16' 16' unencryptedpubkey' 17);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(_encryptedpointb' 1 + 16' 16' unencryptedpubkey' 17);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(_encryptedpointb' 1 + 16' 16' unencryptedpubkey' 17);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(_encryptedpointb' 1 + 16' 16' unencryptedpubkey' 17);
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: for (int i = 0; i < 32; i++) unencryptedpubkey[i + 1] ^= derived[i];
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: try {                  point = ps.Curve.DecodePoint(unencryptedpubkey);                    // multiply passfactor.  Result is going to be compressed.                  ECPoint pubpoint = point.Multiply(new BigInteger(1' intermediate.passfactor));                    // Do we want it uncompressed?  then we will have to uncompress it.                  if (IsCompressedPoint==false) {                      pubpoint = ps.Curve.CreatePoint(pubpoint.X.ToBigInteger()' pubpoint.Y.ToBigInteger()' false);                  }                    // Convert to bitcoin address and check address hash.                  PublicKey generatedaddress = new PublicKey(pubpoint);                    // get addresshash                  UTF8Encoding utf8 = new UTF8Encoding(false);                  Sha256Digest sha256 = new Sha256Digest();                  byte[] generatedaddressbytes = utf8.GetBytes(generatedaddress.AddressBase58);                  sha256.BlockUpdate(generatedaddressbytes' 0' generatedaddressbytes.Length);                  byte[] addresshashfull = new byte[32];                  sha256.DoFinal(addresshashfull' 0);                  sha256.BlockUpdate(addresshashfull' 0' 32);                  sha256.DoFinal(addresshashfull' 0);                    for (int i = 0; i < 4; i++) {                      if (addresshashfull[i] != _addressHash[i]) {                          return new ArgumentException("This passphrase is wrong or does not belong to this confirmation code.");                      }                  }                    this.PublicKey = generatedaddress;              } catch {                  return new ArgumentException("This passphrase is wrong or does not belong to this confirmation code.");              }
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: try {                  point = ps.Curve.DecodePoint(unencryptedpubkey);                    // multiply passfactor.  Result is going to be compressed.                  ECPoint pubpoint = point.Multiply(new BigInteger(1' intermediate.passfactor));                    // Do we want it uncompressed?  then we will have to uncompress it.                  if (IsCompressedPoint==false) {                      pubpoint = ps.Curve.CreatePoint(pubpoint.X.ToBigInteger()' pubpoint.Y.ToBigInteger()' false);                  }                    // Convert to bitcoin address and check address hash.                  PublicKey generatedaddress = new PublicKey(pubpoint);                    // get addresshash                  UTF8Encoding utf8 = new UTF8Encoding(false);                  Sha256Digest sha256 = new Sha256Digest();                  byte[] generatedaddressbytes = utf8.GetBytes(generatedaddress.AddressBase58);                  sha256.BlockUpdate(generatedaddressbytes' 0' generatedaddressbytes.Length);                  byte[] addresshashfull = new byte[32];                  sha256.DoFinal(addresshashfull' 0);                  sha256.BlockUpdate(addresshashfull' 0' 32);                  sha256.DoFinal(addresshashfull' 0);                    for (int i = 0; i < 4; i++) {                      if (addresshashfull[i] != _addressHash[i]) {                          return new ArgumentException("This passphrase is wrong or does not belong to this confirmation code.");                      }                  }                    this.PublicKey = generatedaddress;              } catch {                  return new ArgumentException("This passphrase is wrong or does not belong to this confirmation code.");              }
Magic Number,Casascius.Bitcoin,Bip38Confirmation,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Confirmation.cs,DecryptWithPassphrase,The following statement contains a magic number: try {                  point = ps.Curve.DecodePoint(unencryptedpubkey);                    // multiply passfactor.  Result is going to be compressed.                  ECPoint pubpoint = point.Multiply(new BigInteger(1' intermediate.passfactor));                    // Do we want it uncompressed?  then we will have to uncompress it.                  if (IsCompressedPoint==false) {                      pubpoint = ps.Curve.CreatePoint(pubpoint.X.ToBigInteger()' pubpoint.Y.ToBigInteger()' false);                  }                    // Convert to bitcoin address and check address hash.                  PublicKey generatedaddress = new PublicKey(pubpoint);                    // get addresshash                  UTF8Encoding utf8 = new UTF8Encoding(false);                  Sha256Digest sha256 = new Sha256Digest();                  byte[] generatedaddressbytes = utf8.GetBytes(generatedaddress.AddressBase58);                  sha256.BlockUpdate(generatedaddressbytes' 0' generatedaddressbytes.Length);                  byte[] addresshashfull = new byte[32];                  sha256.DoFinal(addresshashfull' 0);                  sha256.BlockUpdate(addresshashfull' 0' 32);                  sha256.DoFinal(addresshashfull' 0);                    for (int i = 0; i < 4; i++) {                      if (addresshashfull[i] != _addressHash[i]) {                          return new ArgumentException("This passphrase is wrong or does not belong to this confirmation code.");                      }                  }                    this.PublicKey = generatedaddress;              } catch {                  return new ArgumentException("This passphrase is wrong or does not belong to this confirmation code.");              }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: if (interpretation == Interpretation.IntermediateCode) {                 createFromCode(fromstring);             } else {                 _ownerentropy = new byte[8];                  // Get 8 random bytes to use as salt                 SecureRandom sr = new SecureRandom();                 sr.NextBytes(_ownerentropy); 				// set lot number between 100000 and 999999' and sequence number to 1 				long x = (sr.NextLong () % 900000L + 100000L) * 4096L + (long)startingSequenceNumber; 				for (int i=7; i>=4; i--) { 					_ownerentropy[i] = (byte)(x & 0xFF); 					x >>= 8; 				}                 createFromPassphrase(fromstring' _ownerentropy' true);             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: if (interpretation == Interpretation.IntermediateCode) {                 createFromCode(fromstring);             } else {                 _ownerentropy = new byte[8];                  // Get 8 random bytes to use as salt                 SecureRandom sr = new SecureRandom();                 sr.NextBytes(_ownerentropy); 				// set lot number between 100000 and 999999' and sequence number to 1 				long x = (sr.NextLong () % 900000L + 100000L) * 4096L + (long)startingSequenceNumber; 				for (int i=7; i>=4; i--) { 					_ownerentropy[i] = (byte)(x & 0xFF); 					x >>= 8; 				}                 createFromPassphrase(fromstring' _ownerentropy' true);             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: if (interpretation == Interpretation.IntermediateCode) {                 createFromCode(fromstring);             } else {                 _ownerentropy = new byte[8];                  // Get 8 random bytes to use as salt                 SecureRandom sr = new SecureRandom();                 sr.NextBytes(_ownerentropy); 				// set lot number between 100000 and 999999' and sequence number to 1 				long x = (sr.NextLong () % 900000L + 100000L) * 4096L + (long)startingSequenceNumber; 				for (int i=7; i>=4; i--) { 					_ownerentropy[i] = (byte)(x & 0xFF); 					x >>= 8; 				}                 createFromPassphrase(fromstring' _ownerentropy' true);             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: if (interpretation == Interpretation.IntermediateCode) {                 createFromCode(fromstring);             } else {                 _ownerentropy = new byte[8];                  // Get 8 random bytes to use as salt                 SecureRandom sr = new SecureRandom();                 sr.NextBytes(_ownerentropy); 				// set lot number between 100000 and 999999' and sequence number to 1 				long x = (sr.NextLong () % 900000L + 100000L) * 4096L + (long)startingSequenceNumber; 				for (int i=7; i>=4; i--) { 					_ownerentropy[i] = (byte)(x & 0xFF); 					x >>= 8; 				}                 createFromPassphrase(fromstring' _ownerentropy' true);             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: if (ownerentropy == null || ownerentropy.Length != 8) {                 throw new ArgumentException("ownersalt is not valid");             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: _ownerentropy[7]++;
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: if (_ownerentropy[7] == 0) {                 _ownerentropy[6]++;                 if (_ownerentropy[6] == 0) {                     _ownerentropy[5]++;                     if (_ownerentropy[5] == 0) {                         _ownerentropy[4]++;                     }                 }             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: if (_ownerentropy[7] == 0) {                 _ownerentropy[6]++;                 if (_ownerentropy[6] == 0) {                     _ownerentropy[5]++;                     if (_ownerentropy[5] == 0) {                         _ownerentropy[4]++;                     }                 }             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: if (_ownerentropy[7] == 0) {                 _ownerentropy[6]++;                 if (_ownerentropy[6] == 0) {                     _ownerentropy[5]++;                     if (_ownerentropy[5] == 0) {                         _ownerentropy[4]++;                     }                 }             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: if (_ownerentropy[7] == 0) {                 _ownerentropy[6]++;                 if (_ownerentropy[6] == 0) {                     _ownerentropy[5]++;                     if (_ownerentropy[5] == 0) {                         _ownerentropy[4]++;                     }                 }             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: if (_ownerentropy[7] == 0) {                 _ownerentropy[6]++;                 if (_ownerentropy[6] == 0) {                     _ownerentropy[5]++;                     if (_ownerentropy[5] == 0) {                         _ownerentropy[4]++;                     }                 }             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: if (_ownerentropy[7] == 0) {                 _ownerentropy[6]++;                 if (_ownerentropy[6] == 0) {                     _ownerentropy[5]++;                     if (_ownerentropy[5] == 0) {                         _ownerentropy[4]++;                     }                 }             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: byte[] prefactorB = new byte[32 + _ownerentropy.Length];
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: Array.Copy(derivedBytes' 0' prefactorB' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,Bip38Intermediate,The following statement contains a magic number: Array.Copy(_ownerentropy' 0' prefactorB' 32' _ownerentropy.Length);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromCode,The following statement contains a magic number: if (ppcode.Length != 49) {                 throw new ArgumentException("This is not an intermediate passphrase code.");             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromCode,The following statement contains a magic number: for (int i = 0; i < 7; i++) {                 // skip magic check for i[8] which is allowed to be 0x53 for deprecated intermediate code                 if (magic[i] != ppcode[i]) {                     throw new ArgumentException("This is not an intermediate passphrase code.");                 }             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromCode,The following statement contains a magic number: if (ppcode[7] == 0x51) {                 this._lotSequencePresent = true;             } else if (ppcode[7] != 0x53) {                 throw new ArgumentException("This is not an intermediate passphrase code.");             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromCode,The following statement contains a magic number: if (ppcode[7] == 0x51) {                 this._lotSequencePresent = true;             } else if (ppcode[7] != 0x53) {                 throw new ArgumentException("This is not an intermediate passphrase code.");             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromCode,The following statement contains a magic number: _ownerentropy = new byte[8];
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromCode,The following statement contains a magic number: _passpoint = new byte[33];
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromCode,The following statement contains a magic number: Array.Copy(ppcode' 8' _ownerentropy' 0' 8);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromCode,The following statement contains a magic number: Array.Copy(ppcode' 8' _ownerentropy' 0' 8);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromCode,The following statement contains a magic number: Array.Copy(ppcode' 16' _passpoint' 0' 33);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromCode,The following statement contains a magic number: Array.Copy(ppcode' 16' _passpoint' 0' 33);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromPassphrase,The following statement contains a magic number: if (existingownerentropy.Length != 8) {                  throw new ArgumentException("existingownerentropy must be 8 bytes");              }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromPassphrase,The following statement contains a magic number: byte[] prefactorA = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromPassphrase,The following statement contains a magic number: SCrypt.ComputeKey(utf8.GetBytes(passphrase)' ownersalt' 16384' 8' 8' 8' prefactorA);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromPassphrase,The following statement contains a magic number: SCrypt.ComputeKey(utf8.GetBytes(passphrase)' ownersalt' 16384' 8' 8' 8' prefactorA);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromPassphrase,The following statement contains a magic number: SCrypt.ComputeKey(utf8.GetBytes(passphrase)' ownersalt' 16384' 8' 8' 8' prefactorA);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromPassphrase,The following statement contains a magic number: SCrypt.ComputeKey(utf8.GetBytes(passphrase)' ownersalt' 16384' 8' 8' 8' prefactorA);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromPassphrase,The following statement contains a magic number: if (LotSequencePresent) {                 derivedBytes = prefactorA;                 byte[] prefactorB = new byte[32 + _ownerentropy.Length];                 Array.Copy(prefactorA' 0' prefactorB' 0' 32);                 Array.Copy(_ownerentropy' 0' prefactorB' 32' _ownerentropy.Length);                 _passfactor = Util.ComputeDoubleSha256(prefactorB);             } else {                 _passfactor = prefactorA;             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromPassphrase,The following statement contains a magic number: if (LotSequencePresent) {                 derivedBytes = prefactorA;                 byte[] prefactorB = new byte[32 + _ownerentropy.Length];                 Array.Copy(prefactorA' 0' prefactorB' 0' 32);                 Array.Copy(_ownerentropy' 0' prefactorB' 32' _ownerentropy.Length);                 _passfactor = Util.ComputeDoubleSha256(prefactorB);             } else {                 _passfactor = prefactorA;             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,createFromPassphrase,The following statement contains a magic number: if (LotSequencePresent) {                 derivedBytes = prefactorA;                 byte[] prefactorB = new byte[32 + _ownerentropy.Length];                 Array.Copy(prefactorA' 0' prefactorB' 0' 32);                 Array.Copy(_ownerentropy' 0' prefactorB' 32' _ownerentropy.Length);                 _passfactor = Util.ComputeDoubleSha256(prefactorB);             } else {                 _passfactor = prefactorA;             }
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,computeCode,The following statement contains a magic number: byte[] result = new byte[49];
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,computeCode,The following statement contains a magic number: Array.Copy(magic' 0' result' 0' 8);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,computeCode,The following statement contains a magic number: result[7] = (byte)(LotSequencePresent ? 0x51 : 0x53);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,computeCode,The following statement contains a magic number: Array.Copy(_ownerentropy' 0' result' 8' 8);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,computeCode,The following statement contains a magic number: Array.Copy(_ownerentropy' 0' result' 8' 8);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,computeCode,The following statement contains a magic number: Array.Copy(_passpoint' 0' result' 16' 33);
Magic Number,Casascius.Bitcoin,Bip38Intermediate,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38Intermediate.cs,computeCode,The following statement contains a magic number: Array.Copy(_passpoint' 0' result' 16' 33);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: if ((hex[2] & 0x20) == 0x20) IsCompressedPoint = true;
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,ValidateBase58,The following statement contains a magic number: if (bytes == null) {                                  return new ArgumentException("Not a valid key");              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x42) {                  // Casascius BIP passphrase-encrypted key using scrypt                  if (bytes[2] != 0xc0 && bytes[2] != 0xe0) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x43) {                  if ((bytes[2] & 0x24) != bytes[2]) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else {                  return new ArgumentException("Not a BIP38-encoded key");              }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,ValidateBase58,The following statement contains a magic number: if (bytes == null) {                                  return new ArgumentException("Not a valid key");              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x42) {                  // Casascius BIP passphrase-encrypted key using scrypt                  if (bytes[2] != 0xc0 && bytes[2] != 0xe0) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x43) {                  if ((bytes[2] & 0x24) != bytes[2]) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else {                  return new ArgumentException("Not a BIP38-encoded key");              }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,ValidateBase58,The following statement contains a magic number: if (bytes == null) {                                  return new ArgumentException("Not a valid key");              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x42) {                  // Casascius BIP passphrase-encrypted key using scrypt                  if (bytes[2] != 0xc0 && bytes[2] != 0xe0) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x43) {                  if ((bytes[2] & 0x24) != bytes[2]) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else {                  return new ArgumentException("Not a BIP38-encoded key");              }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,ValidateBase58,The following statement contains a magic number: if (bytes == null) {                                  return new ArgumentException("Not a valid key");              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x42) {                  // Casascius BIP passphrase-encrypted key using scrypt                  if (bytes[2] != 0xc0 && bytes[2] != 0xe0) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x43) {                  if ((bytes[2] & 0x24) != bytes[2]) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else {                  return new ArgumentException("Not a BIP38-encoded key");              }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,ValidateBase58,The following statement contains a magic number: if (bytes == null) {                                  return new ArgumentException("Not a valid key");              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x42) {                  // Casascius BIP passphrase-encrypted key using scrypt                  if (bytes[2] != 0xc0 && bytes[2] != 0xe0) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x43) {                  if ((bytes[2] & 0x24) != bytes[2]) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else {                  return new ArgumentException("Not a BIP38-encoded key");              }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,ValidateBase58,The following statement contains a magic number: if (bytes == null) {                                  return new ArgumentException("Not a valid key");              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x42) {                  // Casascius BIP passphrase-encrypted key using scrypt                  if (bytes[2] != 0xc0 && bytes[2] != 0xe0) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else if (bytes.Length == 39 && bytes[0] == 1 && bytes[1] == 0x43) {                  if ((bytes[2] & 0x24) != bytes[2]) {                      return new ArgumentException("Private key is not valid or is a newer format unsupported by this version of the software.");                  }              } else {                  return new ArgumentException("Not a BIP38-encoded key");              }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x42) {                 UTF8Encoding utf8 = new UTF8Encoding(false);                 byte[] addresshash = new byte[] { hex[3]' hex[4]' hex[5]' hex[6] };                  byte[] derivedBytes = new byte[64];                 SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);                  var aes = Aes.Create();                 aes.KeySize = 256;                 aes.Mode = CipherMode.ECB;                 byte[] aeskey = new byte[32];                 Array.Copy(derivedBytes' 32' aeskey' 0' 32);                 aes.Key = aeskey;                 ICryptoTransform decryptor = aes.CreateDecryptor();                  byte[] decrypted = new byte[32];                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 7' 16' decrypted' 0);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 decryptor.TransformBlock(hex' 23' 16' decrypted' 16);                 for (int x = 0; x < 32; x++) decrypted[x] ^= derivedBytes[x];                  tempkey = new KeyPair(decrypted' compressed: IsCompressedPoint);                  Sha256Digest sha256 = new Sha256Digest();                 byte[] addrhash = new byte[32];                 byte[] addrtext = utf8.GetBytes(tempkey.AddressBase58);                 sha256.BlockUpdate(addrtext' 0' addrtext.Length);                 sha256.DoFinal(addrhash' 0);                 sha256.BlockUpdate(addrhash' 0' 32);                 sha256.DoFinal(addrhash' 0);                 if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                     return false;                 }                 _privKey = tempkey.PrivateKeyBytes;                 _pubKey = tempkey.PublicKeyBytes;                 _hash160 = tempkey.Hash160;                 return true;             } else if (hex.Length == 39 && hex[0] == 1 && hex[1] == 0x43) {                  // produce the intermediate from the passphrase                   // get ownersalt and encryptedpart2 since they are in the record                 byte[] ownersalt = new byte[8];                 Array.Copy(hex' 7' ownersalt' 0' 8);                 bool includeHashStep = (hex[2] & 4) == 4;                 Bip38Intermediate intermediate = new Bip38Intermediate(passphrase' ownersalt' includeHashStep); 				this.LotNumber = intermediate.LotNumber; 				this.SequenceNumber = intermediate.SequenceNumber;                  tempkey = decryptUsingIntermediate(intermediate' hex);                 if (verifyAddressHash(tempkey.AddressBase58' hex) == false) return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,verifyAddressHash,The following statement contains a magic number: byte[] addrhash = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,verifyAddressHash,The following statement contains a magic number: sha256.BlockUpdate(addrhash' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,verifyAddressHash,The following statement contains a magic number: if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                 return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,verifyAddressHash,The following statement contains a magic number: if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                 return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,verifyAddressHash,The following statement contains a magic number: if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                 return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,verifyAddressHash,The following statement contains a magic number: if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                 return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,verifyAddressHash,The following statement contains a magic number: if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                 return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,verifyAddressHash,The following statement contains a magic number: if (addrhash[0] != hex[3] || addrhash[1] != hex[4] || addrhash[2] != hex[5] || addrhash[3] != hex[6]) {                 return false;             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithIntermediate,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                 if (hex[i + 7] != ownersalt[i]) {                     throw new ArgumentException("Intermediate does not have same salt");                 }             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,DecryptWithIntermediate,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                 if (hex[i + 7] != ownersalt[i]) {                     throw new ArgumentException("Intermediate does not have same salt");                 }             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: byte[] encryptedpart2 = new byte[16];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(hex' 23' encryptedpart2' 0' 16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(hex' 23' encryptedpart2' 0' 16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: byte[] encryptedpart1 = new byte[16];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(hex' 15' encryptedpart1' 0' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(hex' 15' encryptedpart1' 0' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: byte[] addresshashplusownerentropy = new byte[12];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(hex' 3' addresshashplusownerentropy' 0' 4);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(hex' 3' addresshashplusownerentropy' 0' 4);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(intermediate.ownerentropy' 0' addresshashplusownerentropy' 4' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(intermediate.ownerentropy' 0' addresshashplusownerentropy' 4' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: byte[] derived = new byte[64];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: SCrypt.ComputeKey(intermediate.passpoint' addresshashplusownerentropy' 1024' 1' 1' 1' derived);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: byte[] derivedhalf2 = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(derived' 32' derivedhalf2' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(derived' 32' derivedhalf2' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: aes.KeySize = 256;
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: byte[] unencryptedpart2 = new byte[16];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: decryptor.TransformBlock(encryptedpart2' 0' 16' unencryptedpart2' 0);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: decryptor.TransformBlock(encryptedpart2' 0' 16' unencryptedpart2' 0);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                 unencryptedpart2[i] ^= derived[i + 16];             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                 unencryptedpart2[i] ^= derived[i + 16];             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(unencryptedpart2' 0' encryptedpart1' 8' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(unencryptedpart2' 0' encryptedpart1' 8' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: byte[] unencryptedpart1 = new byte[16];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: decryptor.TransformBlock(encryptedpart1' 0' 16' unencryptedpart1' 0);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: decryptor.TransformBlock(encryptedpart1' 0' 16' unencryptedpart1' 0);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                 unencryptedpart1[i] ^= derived[i];             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: byte[] seedb = new byte[24];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(unencryptedpart1' 0' seedb' 0' 16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(unencryptedpart2' 8' seedb' 16' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(unencryptedpart2' 8' seedb' 16' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: Array.Copy(unencryptedpart2' 8' seedb' 16' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: sha256.BlockUpdate(seedb' 0' 24);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: byte[] factorb = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,decryptUsingIntermediate,The following statement contains a magic number: sha256.BlockUpdate(factorb' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] addresshash = new byte[] { addrhashfull[0]' addrhashfull[1]' addrhashfull[2]' addrhashfull[3] };
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] addresshash = new byte[] { addrhashfull[0]' addrhashfull[1]' addrhashfull[2]' addrhashfull[3] };
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] derivedBytes = new byte[64];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: SCrypt.ComputeKey(utf8.GetBytes(passphrase)' addresshash' 16384' 8' 8' 8' derivedBytes);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: aes.KeySize = 256;
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] aeskey = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(derivedBytes' 32' aeskey' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(derivedBytes' 32' aeskey' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] unencrypted = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] rv = new byte[39];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(key.PrivateKeyBytes' unencrypted' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: for (int x = 0; x < 32; x++) unencrypted[x] ^= derivedBytes[x];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 0' 16' rv' 7);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 0' 16' rv' 7);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 0' 16' rv' 7);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 0' 16' rv' 7);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' rv' 23);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' rv' 23);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' rv' 23);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' rv' 23);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' rv' 23);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' rv' 23);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: rv[2] = IsCompressedPoint ? (byte)0xe0 : (byte)0xc0;
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: rv[3] = checksum[0];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: rv[4] = checksum[1];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: rv[5] = checksum[2];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: rv[5] = checksum[2];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: rv[6] = checksum[3];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: rv[6] = checksum[3];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] seedb = new byte[24];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: sha256.BlockUpdate(seedb' 0' 24);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: factorb = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: sha256.BlockUpdate(factorb' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] addresshashfull = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: sha256.BlockUpdate(addresshashfull' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] addresshashplusownerentropy = new byte[12];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(addresshashfull' 0' addresshashplusownerentropy' 0' 4);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(intermediate.ownerentropy' 0' addresshashplusownerentropy' 4' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(intermediate.ownerentropy' 0' addresshashplusownerentropy' 4' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: derived = new byte[64];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: SCrypt.ComputeKey(intermediate.passpoint' addresshashplusownerentropy' 1024' 1' 1' 1' derived);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] derivedhalf2 = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(derived' 32' derivedhalf2' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(derived' 32' derivedhalf2' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] unencryptedpart1 = new byte[16];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: for (int i = 0; i < 16; i++) {                 unencryptedpart1[i] = (byte)(seedb[i] ^ derived[i]);             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] encryptedpart1 = new byte[16];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: aes.KeySize = 256;
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencryptedpart1' 0' 16' encryptedpart1' 0);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencryptedpart1' 0' 16' encryptedpart1' 0);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] unencryptedpart2 = new byte[16];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                 unencryptedpart2[i] = (byte)(encryptedpart1[i + 8] ^ derived[i + 16]);             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                 unencryptedpart2[i] = (byte)(encryptedpart1[i + 8] ^ derived[i + 16]);             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                 unencryptedpart2[i] = (byte)(encryptedpart1[i + 8] ^ derived[i + 16]);             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                 unencryptedpart2[i + 8] = (byte)(seedb[i + 16] ^ derived[i + 24]);             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                 unencryptedpart2[i + 8] = (byte)(seedb[i + 16] ^ derived[i + 24]);             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                 unencryptedpart2[i + 8] = (byte)(seedb[i + 16] ^ derived[i + 24]);             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                 unencryptedpart2[i + 8] = (byte)(seedb[i + 16] ^ derived[i + 24]);             }
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] encryptedpart2 = new byte[16];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencryptedpart2' 0' 16' encryptedpart2' 0);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: encryptor.TransformBlock(unencryptedpart2' 0' 16' encryptedpart2' 0);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: byte[] result = new byte[39];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: result[2] = generatedaddress.IsCompressedPoint ? (byte)0x20 : (byte)0x00;
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: if (intermediate.LotSequencePresent) result[2] |= 0x04;
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(addresshashfull' 0' result' 3' 4);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(addresshashfull' 0' result' 3' 4);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(intermediate.ownerentropy' 0' result' 7' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(intermediate.ownerentropy' 0' result' 7' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(encryptedpart1' 0' result' 15' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(encryptedpart1' 0' result' 15' 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(encryptedpart2' 0' result' 23' 16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(encryptedpart2' 0' result' 23' 16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: confirmationCodeInfo = new byte[51];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: confirmationCodeInfo[2] = 0xF6;
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: confirmationCodeInfo[3] = 0xA8;
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: confirmationCodeInfo[4] = 0x9A;
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(result' 2' confirmationCodeInfo' 5' 1 + 4 + 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(result' 2' confirmationCodeInfo' 5' 1 + 4 + 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(result' 2' confirmationCodeInfo' 5' 1 + 4 + 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,Bip38KeyPair,The following statement contains a magic number: Array.Copy(result' 2' confirmationCodeInfo' 5' 1 + 4 + 8);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: confirmationCodeInfo[18] = (byte)(kppubbytes[0] ^ (derived[63] & 0x01));
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: confirmationCodeInfo[18] = (byte)(kppubbytes[0] ^ (derived[63] & 0x01));
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: byte[] unencrypted = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: for (int i = 0; i < 32; i++) unencrypted[i] = (byte)(kppubbytes[i + 1] ^ derived[i]);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: byte[] derivedhalf2 = new byte[32];
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: Array.Copy(derived' 32' derivedhalf2' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: Array.Copy(derived' 32' derivedhalf2' 0' 32);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: aes.KeySize = 256;
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 0' 16' confirmationCodeInfo' 19);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 0' 16' confirmationCodeInfo' 19);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 0' 16' confirmationCodeInfo' 19);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 0' 16' confirmationCodeInfo' 19);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' confirmationCodeInfo' 19+16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' confirmationCodeInfo' 19+16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' confirmationCodeInfo' 19+16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' confirmationCodeInfo' 19+16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' confirmationCodeInfo' 19+16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' confirmationCodeInfo' 19+16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' confirmationCodeInfo' 19+16);
Magic Number,Casascius.Bitcoin,Bip38KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bip38KeyPair.cs,GetConfirmationCode,The following statement contains a magic number: encryptor.TransformBlock(unencrypted' 16' 16' confirmationCodeInfo' 19+16);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte[] x = new byte[32];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte[] y = new byte[32];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: x[31] &= 0xFE;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: y[31] |= 0x01;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte[] hashGxy = new byte[32];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: sha256.BlockUpdate(hashGxy' 0' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: int identifier30 = ((hashGxy[0] & 0x3f) << 24) + (hashGxy[1] << 16) + (hashGxy[2] << 8) + hashGxy[3];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: int identifier30 = ((hashGxy[0] & 0x3f) << 24) + (hashGxy[1] << 16) + (hashGxy[2] << 8) + hashGxy[3];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: int identifier30 = ((hashGxy[0] & 0x3f) << 24) + (hashGxy[1] << 16) + (hashGxy[2] << 8) + hashGxy[3];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: int identifier30 = ((hashGxy[0] & 0x3f) << 24) + (hashGxy[1] << 16) + (hashGxy[2] << 8) + hashGxy[3];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: int identifier30 = ((hashGxy[0] & 0x3f) << 24) + (hashGxy[1] << 16) + (hashGxy[2] << 8) + hashGxy[3];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte[] invitationA = new byte[74];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte[] invitationB = new byte[74];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: for (int i = 7; i >= 0; i--) {                  invitationA[i] = (byte)(headA & 0xFF);                  invitationB[i] = (byte)(headB & 0xFF);                  headA >>= 8;                  headB >>= 8;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: for (int i = 7; i >= 0; i--) {                  invitationA[i] = (byte)(headA & 0xFF);                  invitationB[i] = (byte)(headB & 0xFF);                  headA >>= 8;                  headB >>= 8;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: for (int i = 7; i >= 0; i--) {                  invitationA[i] = (byte)(headA & 0xFF);                  invitationB[i] = (byte)(headB & 0xFF);                  headA >>= 8;                  headB >>= 8;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(x' 0' invitationA' 8 + 1' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(x' 0' invitationA' 8 + 1' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(y' 0' invitationB' 8 + 1' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(y' 0' invitationB' 8 + 1' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(bytesGy' 0' invitationA' 8 + 1 + 32' 33);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(bytesGy' 0' invitationA' 8 + 1 + 32' 33);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(bytesGy' 0' invitationA' 8 + 1 + 32' 33);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(bytesGx' 0' invitationB' 8 + 1 + 32' 33);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(bytesGx' 0' invitationB' 8 + 1 + 32' 33);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(bytesGx' 0' invitationB' 8 + 1 + 32' 33);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if ((escrowInvitationCode.StartsWith("einva") && (privpart[31] & 0x01) == 1) ||                  (escrowInvitationCode.StartsWith("einvb") && (privpart[31] & 0x01) == 0)) {                  throw new ArgumentException("This escrow invitation has mismatched parity.  Ask your escrow agent to " +                      "generate a new pair using the latest version of the software.");              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if ((escrowInvitationCode.StartsWith("einva") && (privpart[31] & 0x01) == 1) ||                  (escrowInvitationCode.StartsWith("einvb") && (privpart[31] & 0x01) == 0)) {                  throw new ArgumentException("This escrow invitation has mismatched parity.  Ask your escrow agent to " +                      "generate a new pair using the latest version of the software.");              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (privpart[0] == privpart[1] && privpart[1] == privpart[2] && privpart[2] == privpart[3] &&                 privpart[3] == privpart[4] && privpart[4] == privpart[5] && privpart[5] == privpart[6] &&                 privpart[6] == privpart[7] && privpart[7] == privpart[8]) {                  if (privpart[0] == 0x00 || privpart[0] == 0xFF) {                      throw new ArgumentException("This escrow invitation is invalid and cannot be used (bad private key).");                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte[] z = new byte[32];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte[] invp = new byte[74];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: for (int i = 7; i >= 0; i--) {                  invp[i] = (byte)(headP & 0xff);                  headP >>= 8;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: for (int i = 7; i >= 0; i--) {                  invp[i] = (byte)(headP & 0xff);                  headP >>= 8;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: invp[8] = networkByte;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(z' 0' invp' 8 + 1 + 1' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(z' 0' invp' 8 + 1 + 1' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (escrowInvitationCode.StartsWith("einvb")) {                  invp[8 + 1 + 1 + 32 + 20] = 0x2;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (escrowInvitationCode.StartsWith("einvb")) {                  invp[8 + 1 + 1 + 32 + 20] = 0x2;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if (escrowInvitationCode.StartsWith("einvb")) {                  invp[8 + 1 + 1 + 32 + 20] = 0x2;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(hash160' 0' invp' 8 + 1 + 1 + 32' 20);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(hash160' 0' invp' 8 + 1 + 1 + 32' 20);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(hash160' 0' invp' 8 + 1 + 1 + 32' 20);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: setAddressConfirmationCode(identifier30' networkByte' invp[8 + 1 + 1 + 32 + 20]' z' hash160);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: setAddressConfirmationCode(identifier30' networkByte' invp[8 + 1 + 1 + 32 + 20]' z' hash160);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: setAddressConfirmationCode(identifier30' networkByte' invp[8 + 1 + 1 + 32 + 20]' z' hash160);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte[] privpartz = new byte[32];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(invbytes' 8 + 1 + 1' privpartz' 0' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(invbytes' 8 + 1 + 1' privpartz' 0' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte networkByte = invbytes[8];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: bool compressedFlag = (invbytes[8+1+1+32+20] & 0x1) == 1;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: bool compressedFlag = (invbytes[8+1+1+32+20] & 0x1) == 1;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: bool compressedFlag = (invbytes[8+1+1+32+20] & 0x1) == 1;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: for (int i = 0; i < 20; i++) {                  if (addrhash160[i] != invbytes[8+1+1+32+i]) {                      throw new ArgumentException(notvalid3);                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: for (int i = 0; i < 20; i++) {                  if (addrhash160[i] != invbytes[8+1+1+32+i]) {                      throw new ArgumentException(notvalid3);                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: for (int i = 0; i < 20; i++) {                  if (addrhash160[i] != invbytes[8+1+1+32+i]) {                      throw new ArgumentException(notvalid3);                  }              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte expectedabflag = (byte)(escrowInvitationCode.StartsWith("einva") ? 2 : 0);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if ((invbytes[8+1+1+32+20] & 0x2) != expectedabflag) {                  SamePartyWarningApplies = true;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if ((invbytes[8+1+1+32+20] & 0x2) != expectedabflag) {                  SamePartyWarningApplies = true;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: if ((invbytes[8+1+1+32+20] & 0x2) != expectedabflag) {                  SamePartyWarningApplies = true;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte[] privpartz = new byte[32];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(invbytesp' 8 + 1 + 1' privpartz' 0' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: Array.Copy(invbytesp' 8 + 1 + 1' privpartz' 0' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: byte networkByte = invbytesp[8];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: bool compressedFlag = (invbytesp[8 + 1 + 1 + 32 + 20] & 0x1) == 1;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: bool compressedFlag = (invbytesp[8 + 1 + 1 + 32 + 20] & 0x1) == 1;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,EscrowCodeSet,The following statement contains a magic number: bool compressedFlag = (invbytesp[8 + 1 + 1 + 32 + 20] & 0x1) == 1;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: byte[] accbytes = new byte[74];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: for (int i=7; i>=0; i--) {                  accbytes[i] = (byte)(head & 0x7F);                  head >>= 8;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: for (int i=7; i>=0; i--) {                  accbytes[i] = (byte)(head & 0x7F);                  head >>= 8;              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: accbytes[8]=networkbyte;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: Array.Copy(Gzbytes' 0' accbytes' 8+1' 33);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: Array.Copy(Gzbytes' 0' accbytes' 8+1' 33);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: Array.Copy(hash160' 0' accbytes' 8+1+33' 20);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: Array.Copy(hash160' 0' accbytes' 8+1+33' 20);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: Array.Copy(hash160' 0' accbytes' 8+1+33' 20);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: accbytes[8+1+33+20] = flagbyte;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: accbytes[8+1+33+20] = flagbyte;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,setAddressConfirmationCode,The following statement contains a magic number: accbytes[8+1+33+20] = flagbyte;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,parseEscrowCode,The following statement contains a magic number: privpart = new byte[32];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,parseEscrowCode,The following statement contains a magic number: pubpart = new byte[33];
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,parseEscrowCode,The following statement contains a magic number: Array.Copy(invbytes' 8 + 1' privpart' 0' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,parseEscrowCode,The following statement contains a magic number: Array.Copy(invbytes' 8 + 1' privpart' 0' 32);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,parseEscrowCode,The following statement contains a magic number: Array.Copy(invbytes' 8 + 1 + 32' pubpart' 0' 33);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,parseEscrowCode,The following statement contains a magic number: Array.Copy(invbytes' 8 + 1 + 32' pubpart' 0' 33);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,parseEscrowCode,The following statement contains a magic number: Array.Copy(invbytes' 8 + 1 + 32' pubpart' 0' 33);
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,parseEitherCode,The following statement contains a magic number: if (invbytes.Length != 74) return notvalid;
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,parseEitherCode,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  head <<= 8;                  head += invbytes[i];              }
Magic Number,Casascius.Bitcoin,EscrowCodeSet,C:\repos\casascius_Bitcoin-Address-Utility\Model\EscrowCode.cs,parseEitherCode,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  head <<= 8;                  head += invbytes[i];              }
Magic Number,Casascius.Bitcoin,ExtraEntropy,C:\repos\casascius_Bitcoin-Address-Utility\Model\ExtraEntropy.cs,AddExtraEntropy,The following statement contains a magic number: lock (LockObject) {                  entropystring += what;                  if (entropystring.Length > 300) {                      entropystring = BitConverter.ToString(Util.ComputeSha256(entropystring));                  }              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,CreateFromString,The following statement contains a magic number: byte[] thehash = new byte[32];
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,Create,The following statement contains a magic number: byte[] newkey = new byte[32];
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,Create,The following statement contains a magic number: for (int i = 0; i < 32; i++) {                  long x = sr.NextLong() & long.MaxValue;                  x += poop[i];                  newkey[i] = (byte)(x & 0xff);              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,KeyPair,The following statement contains a magic number: if (bytes.Length == 32) {                  PrivateKeyBytes = bytes;                  this.IsCompressedPoint = compressed;                  this._addressType = addressType;              } else {                  throw new ArgumentException("Byte array provided to KeyPair constructor must be 32 bytes long");              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,constructWithKey,The following statement contains a magic number: if (hex.Length == 32) {                  _privKey = new byte[32];                  Array.Copy(hex' 0' _privKey' 0' 32);                  IsCompressedPoint = compressed;              } else if (hex.Length == 33 && hex[0] == 0x80) {                  // normal private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = false;              } else if (hex.Length == 34 && hex[0] == 0x80 && hex[33] == 0x01) {                  // compressed private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = true;              } else if (key.StartsWith("6")) {                  return "Key is encrypted' decrypt first.";              } else {                  return "Not a recognized private key format";              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,constructWithKey,The following statement contains a magic number: if (hex.Length == 32) {                  _privKey = new byte[32];                  Array.Copy(hex' 0' _privKey' 0' 32);                  IsCompressedPoint = compressed;              } else if (hex.Length == 33 && hex[0] == 0x80) {                  // normal private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = false;              } else if (hex.Length == 34 && hex[0] == 0x80 && hex[33] == 0x01) {                  // compressed private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = true;              } else if (key.StartsWith("6")) {                  return "Key is encrypted' decrypt first.";              } else {                  return "Not a recognized private key format";              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,constructWithKey,The following statement contains a magic number: if (hex.Length == 32) {                  _privKey = new byte[32];                  Array.Copy(hex' 0' _privKey' 0' 32);                  IsCompressedPoint = compressed;              } else if (hex.Length == 33 && hex[0] == 0x80) {                  // normal private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = false;              } else if (hex.Length == 34 && hex[0] == 0x80 && hex[33] == 0x01) {                  // compressed private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = true;              } else if (key.StartsWith("6")) {                  return "Key is encrypted' decrypt first.";              } else {                  return "Not a recognized private key format";              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,constructWithKey,The following statement contains a magic number: if (hex.Length == 32) {                  _privKey = new byte[32];                  Array.Copy(hex' 0' _privKey' 0' 32);                  IsCompressedPoint = compressed;              } else if (hex.Length == 33 && hex[0] == 0x80) {                  // normal private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = false;              } else if (hex.Length == 34 && hex[0] == 0x80 && hex[33] == 0x01) {                  // compressed private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = true;              } else if (key.StartsWith("6")) {                  return "Key is encrypted' decrypt first.";              } else {                  return "Not a recognized private key format";              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,constructWithKey,The following statement contains a magic number: if (hex.Length == 32) {                  _privKey = new byte[32];                  Array.Copy(hex' 0' _privKey' 0' 32);                  IsCompressedPoint = compressed;              } else if (hex.Length == 33 && hex[0] == 0x80) {                  // normal private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = false;              } else if (hex.Length == 34 && hex[0] == 0x80 && hex[33] == 0x01) {                  // compressed private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = true;              } else if (key.StartsWith("6")) {                  return "Key is encrypted' decrypt first.";              } else {                  return "Not a recognized private key format";              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,constructWithKey,The following statement contains a magic number: if (hex.Length == 32) {                  _privKey = new byte[32];                  Array.Copy(hex' 0' _privKey' 0' 32);                  IsCompressedPoint = compressed;              } else if (hex.Length == 33 && hex[0] == 0x80) {                  // normal private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = false;              } else if (hex.Length == 34 && hex[0] == 0x80 && hex[33] == 0x01) {                  // compressed private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = true;              } else if (key.StartsWith("6")) {                  return "Key is encrypted' decrypt first.";              } else {                  return "Not a recognized private key format";              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,constructWithKey,The following statement contains a magic number: if (hex.Length == 32) {                  _privKey = new byte[32];                  Array.Copy(hex' 0' _privKey' 0' 32);                  IsCompressedPoint = compressed;              } else if (hex.Length == 33 && hex[0] == 0x80) {                  // normal private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = false;              } else if (hex.Length == 34 && hex[0] == 0x80 && hex[33] == 0x01) {                  // compressed private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = true;              } else if (key.StartsWith("6")) {                  return "Key is encrypted' decrypt first.";              } else {                  return "Not a recognized private key format";              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,constructWithKey,The following statement contains a magic number: if (hex.Length == 32) {                  _privKey = new byte[32];                  Array.Copy(hex' 0' _privKey' 0' 32);                  IsCompressedPoint = compressed;              } else if (hex.Length == 33 && hex[0] == 0x80) {                  // normal private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = false;              } else if (hex.Length == 34 && hex[0] == 0x80 && hex[33] == 0x01) {                  // compressed private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = true;              } else if (key.StartsWith("6")) {                  return "Key is encrypted' decrypt first.";              } else {                  return "Not a recognized private key format";              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,constructWithKey,The following statement contains a magic number: if (hex.Length == 32) {                  _privKey = new byte[32];                  Array.Copy(hex' 0' _privKey' 0' 32);                  IsCompressedPoint = compressed;              } else if (hex.Length == 33 && hex[0] == 0x80) {                  // normal private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = false;              } else if (hex.Length == 34 && hex[0] == 0x80 && hex[33] == 0x01) {                  // compressed private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = true;              } else if (key.StartsWith("6")) {                  return "Key is encrypted' decrypt first.";              } else {                  return "Not a recognized private key format";              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,constructWithKey,The following statement contains a magic number: if (hex.Length == 32) {                  _privKey = new byte[32];                  Array.Copy(hex' 0' _privKey' 0' 32);                  IsCompressedPoint = compressed;              } else if (hex.Length == 33 && hex[0] == 0x80) {                  // normal private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = false;              } else if (hex.Length == 34 && hex[0] == 0x80 && hex[33] == 0x01) {                  // compressed private key                  _privKey = new byte[32];                  Array.Copy(hex' 1' _privKey' 0' 32);                  IsCompressedPoint = true;              } else if (key.StartsWith("6")) {                  return "Key is encrypted' decrypt first.";              } else {                  return "Not a recognized private key format";              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,ComputePublicKey,The following statement contains a magic number: if (IsCompressedPoint) {                  dd = ps.Curve.CreatePoint(dd.X.ToBigInteger()' dd.Y.ToBigInteger()' true);                                  return dd.GetEncoded();              } else {                  byte[] pubaddr = new byte[65];                  byte[] Y = dd.Y.ToBigInteger().ToByteArray();                  Array.Copy(Y' 0' pubaddr' 64 - Y.Length + 1' Y.Length);                  byte[] X = dd.X.ToBigInteger().ToByteArray();                  Array.Copy(X' 0' pubaddr' 32 - X.Length + 1' X.Length);                  pubaddr[0] = 4;                  return pubaddr;              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,ComputePublicKey,The following statement contains a magic number: if (IsCompressedPoint) {                  dd = ps.Curve.CreatePoint(dd.X.ToBigInteger()' dd.Y.ToBigInteger()' true);                                  return dd.GetEncoded();              } else {                  byte[] pubaddr = new byte[65];                  byte[] Y = dd.Y.ToBigInteger().ToByteArray();                  Array.Copy(Y' 0' pubaddr' 64 - Y.Length + 1' Y.Length);                  byte[] X = dd.X.ToBigInteger().ToByteArray();                  Array.Copy(X' 0' pubaddr' 32 - X.Length + 1' X.Length);                  pubaddr[0] = 4;                  return pubaddr;              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,ComputePublicKey,The following statement contains a magic number: if (IsCompressedPoint) {                  dd = ps.Curve.CreatePoint(dd.X.ToBigInteger()' dd.Y.ToBigInteger()' true);                                  return dd.GetEncoded();              } else {                  byte[] pubaddr = new byte[65];                  byte[] Y = dd.Y.ToBigInteger().ToByteArray();                  Array.Copy(Y' 0' pubaddr' 64 - Y.Length + 1' Y.Length);                  byte[] X = dd.X.ToBigInteger().ToByteArray();                  Array.Copy(X' 0' pubaddr' 32 - X.Length + 1' X.Length);                  pubaddr[0] = 4;                  return pubaddr;              }
Magic Number,Casascius.Bitcoin,KeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\KeyPair.cs,ComputePublicKey,The following statement contains a magic number: if (IsCompressedPoint) {                  dd = ps.Curve.CreatePoint(dd.X.ToBigInteger()' dd.Y.ToBigInteger()' true);                                  return dd.GetEncoded();              } else {                  byte[] pubaddr = new byte[65];                  byte[] Y = dd.Y.ToBigInteger().ToByteArray();                  Array.Copy(Y' 0' pubaddr' 64 - Y.Length + 1' Y.Length);                  byte[] X = dd.X.ToBigInteger().ToByteArray();                  Array.Copy(X' 0' pubaddr' 32 - X.Length + 1' X.Length);                  pubaddr[0] = 4;                  return pubaddr;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ByteArrayToBase58Check,The following statement contains a magic number: byte[] bb = new byte[ba.Length + 4];
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ByteArrayToBase58Check,The following statement contains a magic number: byte[] thehash = new byte[32];
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ByteArrayToBase58Check,The following statement contains a magic number: bcsha256a.BlockUpdate(thehash' 0' 32);
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ByteArrayToBase58Check,The following statement contains a magic number: for (int i = 0; i < 4; i++) bb[ba.Length + i] = thehash[i];
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicKey,The following statement contains a magic number: byte[] hex = GetHexBytes(PubHex' 64);
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicKey,The following statement contains a magic number: if (hex == null || hex.Length < 64 || hex.Length > 65) {                  throw new ApplicationException("Hex is not 64 or 65 bytes.");              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicKey,The following statement contains a magic number: if (hex == null || hex.Length < 64 || hex.Length > 65) {                  throw new ApplicationException("Hex is not 64 or 65 bytes.");              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicKey,The following statement contains a magic number: if (hex.Length == 65) {                  if (hex[0] == 0 || hex[0] == 4) {                      hex[0] = 4;                  } else {                      throw new ApplicationException("Not a valid public key");                  }              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicKey,The following statement contains a magic number: if (hex.Length == 65) {                  if (hex[0] == 0 || hex[0] == 4) {                      hex[0] = 4;                  } else {                      throw new ApplicationException("Not a valid public key");                  }              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicKey,The following statement contains a magic number: if (hex.Length == 65) {                  if (hex[0] == 0 || hex[0] == 4) {                      hex[0] = 4;                  } else {                      throw new ApplicationException("Not a valid public key");                  }              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicKey,The following statement contains a magic number: if (hex.Length == 64) {                  byte[] hex2 = new byte[65];                  Array.Copy(hex' 0' hex2' 1' 64);                  hex2[0] = 4;                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicKey,The following statement contains a magic number: if (hex.Length == 64) {                  byte[] hex2 = new byte[65];                  Array.Copy(hex' 0' hex2' 1' 64);                  hex2[0] = 4;                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicKey,The following statement contains a magic number: if (hex.Length == 64) {                  byte[] hex2 = new byte[65];                  Array.Copy(hex' 0' hex2' 1' 64);                  hex2[0] = 4;                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicKey,The following statement contains a magic number: if (hex.Length == 64) {                  byte[] hex2 = new byte[65];                  Array.Copy(hex' 0' hex2' 1' 64);                  hex2[0] = 4;                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicHash,The following statement contains a magic number: byte[] hex = GetHexBytes(PubHash' 20);
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPublicHash,The following statement contains a magic number: if (hex == null || hex.Length != 20) {                  throw new ApplicationException("Hex is not 20 bytes.");              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (desiredByteCount != 32 && desiredByteCount != 33) throw new ApplicationException("desiredByteCount must be 32 or 33");
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (desiredByteCount != 32 && desiredByteCount != 33) throw new ApplicationException("desiredByteCount must be 32 or 33");
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: byte[] hex = GetHexBytes(PrivHex' 32);
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (hex == null || hex.Length < 32 || hex.Length > 33) {                  throw new ApplicationException("Hex is not 32 or 33 bytes.");              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (hex == null || hex.Length < 32 || hex.Length > 33) {                  throw new ApplicationException("Hex is not 32 or 33 bytes.");              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (hex.Length == 33) {                  if (hex[0] == 0 || hex[0] == 0x80) {                      hex[0] = 0x80;                  } else {                      throw new ApplicationException("Not a valid private key");                  }              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (hex.Length == 32 && desiredByteCount==33) {                  byte[] hex2 = new byte[33];                  Array.Copy(hex' 0' hex2' 1' 32);                  hex2[0] = 0x80;                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (hex.Length == 32 && desiredByteCount==33) {                  byte[] hex2 = new byte[33];                  Array.Copy(hex' 0' hex2' 1' 32);                  hex2[0] = 0x80;                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (hex.Length == 32 && desiredByteCount==33) {                  byte[] hex2 = new byte[33];                  Array.Copy(hex' 0' hex2' 1' 32);                  hex2[0] = 0x80;                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (hex.Length == 32 && desiredByteCount==33) {                  byte[] hex2 = new byte[33];                  Array.Copy(hex' 0' hex2' 1' 32);                  hex2[0] = 0x80;                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (desiredByteCount==33) hex[0] = leadingbyte;
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (desiredByteCount == 32 && hex.Length == 33) {                  byte[] hex2 = new byte[33];                  Array.Copy(hex' 1' hex2' 0' 32);                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (desiredByteCount == 32 && hex.Length == 33) {                  byte[] hex2 = new byte[33];                  Array.Copy(hex' 1' hex2' 0' 32);                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (desiredByteCount == 32 && hex.Length == 33) {                  byte[] hex2 = new byte[33];                  Array.Copy(hex' 1' hex2' 0' 32);                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ValidateAndGetHexPrivateKey,The following statement contains a magic number: if (desiredByteCount == 32 && hex.Length == 33) {                  byte[] hex2 = new byte[33];                  Array.Copy(hex' 1' hex2' 0' 32);                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Base58CheckToByteArray,The following statement contains a magic number: if (bb == null || bb.Length < 4) return null;
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Base58CheckToByteArray,The following statement contains a magic number: if (IgnoreChecksum == false) {                  Sha256Digest bcsha256a = new Sha256Digest();                  bcsha256a.BlockUpdate(bb' 0' bb.Length - 4);                    byte[] checksum = new byte[32];  //sha256.ComputeHash(bb' 0' bb.Length - 4);                  bcsha256a.DoFinal(checksum' 0);                  bcsha256a.BlockUpdate(checksum' 0' 32);                  bcsha256a.DoFinal(checksum' 0);                    for (int i = 0; i < 4; i++) {                      if (checksum[i] != bb[bb.Length - 4 + i]) return null;                  }              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Base58CheckToByteArray,The following statement contains a magic number: if (IgnoreChecksum == false) {                  Sha256Digest bcsha256a = new Sha256Digest();                  bcsha256a.BlockUpdate(bb' 0' bb.Length - 4);                    byte[] checksum = new byte[32];  //sha256.ComputeHash(bb' 0' bb.Length - 4);                  bcsha256a.DoFinal(checksum' 0);                  bcsha256a.BlockUpdate(checksum' 0' 32);                  bcsha256a.DoFinal(checksum' 0);                    for (int i = 0; i < 4; i++) {                      if (checksum[i] != bb[bb.Length - 4 + i]) return null;                  }              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Base58CheckToByteArray,The following statement contains a magic number: if (IgnoreChecksum == false) {                  Sha256Digest bcsha256a = new Sha256Digest();                  bcsha256a.BlockUpdate(bb' 0' bb.Length - 4);                    byte[] checksum = new byte[32];  //sha256.ComputeHash(bb' 0' bb.Length - 4);                  bcsha256a.DoFinal(checksum' 0);                  bcsha256a.BlockUpdate(checksum' 0' 32);                  bcsha256a.DoFinal(checksum' 0);                    for (int i = 0; i < 4; i++) {                      if (checksum[i] != bb[bb.Length - 4 + i]) return null;                  }              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Base58CheckToByteArray,The following statement contains a magic number: if (IgnoreChecksum == false) {                  Sha256Digest bcsha256a = new Sha256Digest();                  bcsha256a.BlockUpdate(bb' 0' bb.Length - 4);                    byte[] checksum = new byte[32];  //sha256.ComputeHash(bb' 0' bb.Length - 4);                  bcsha256a.DoFinal(checksum' 0);                  bcsha256a.BlockUpdate(checksum' 0' 32);                  bcsha256a.DoFinal(checksum' 0);                    for (int i = 0; i < 4; i++) {                      if (checksum[i] != bb[bb.Length - 4 + i]) return null;                  }              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Base58CheckToByteArray,The following statement contains a magic number: if (IgnoreChecksum == false) {                  Sha256Digest bcsha256a = new Sha256Digest();                  bcsha256a.BlockUpdate(bb' 0' bb.Length - 4);                    byte[] checksum = new byte[32];  //sha256.ComputeHash(bb' 0' bb.Length - 4);                  bcsha256a.DoFinal(checksum' 0);                  bcsha256a.BlockUpdate(checksum' 0' 32);                  bcsha256a.DoFinal(checksum' 0);                    for (int i = 0; i < 4; i++) {                      if (checksum[i] != bb[bb.Length - 4 + i]) return null;                  }              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Base58CheckToByteArray,The following statement contains a magic number: byte[] rv = new byte[bb.Length - 4];
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Base58CheckToByteArray,The following statement contains a magic number: Array.Copy(bb' 0' rv' 0' bb.Length - 4);
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,GetHexBytes,The following statement contains a magic number: if (hex.Length > (minimum - 6) && hex.Length < minimum) {                  byte[] hex2 = new byte[minimum];                  Array.Copy(hex' 0' hex2' minimum - hex.Length' hex.Length);                  hex = hex2;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,HexStringToBytes,The following statement contains a magic number: foreach (char c in source.ToCharArray()) {                                  if (c == ' ' || c == '-' || c == ':') {                      // if we got a space' then accept it as the end if we have 1 character.                      if (gotFirstChar) {                          bytes.Add(accum);                          accum = 0;                          gotFirstChar = false;                      }                  } else if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')) {                      // get the character's value                      byte v = (byte)(c - 0x30);                      if (c >= 'A' && c <= 'F') v = (byte)(c + 0x0a - 'A');                      if (c >= 'a' && c <= 'f') v = (byte)(c + 0x0a - 'a');                        if (gotFirstChar == false) {                          gotFirstChar = true;                          accum = v;                      } else {                          accum <<= 4;                          accum += v;                          bytes.Add(accum);                          accum = 0;                          gotFirstChar = false;                      }                  } else {                      if (testingForValidHex) return null;                  }              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PrivHexToPubHex,The following statement contains a magic number: byte[] hex = ValidateAndGetHexPrivateKey(0x00' PrivHex' 33);
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PrivHexToPubKey,The following statement contains a magic number: byte[] hex = ValidateAndGetHexPrivateKey(0x00' PrivHex' 33);
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PrivKeyToPubKey,The following statement contains a magic number: if (PrivKey == null || PrivKey.Length > 32) throw new ApplicationException("Invalid private hex key");
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PubKeyToByteArray,The following statement contains a magic number: byte[] pubaddr = new byte[65];
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PubKeyToByteArray,The following statement contains a magic number: Array.Copy(Y' 0' pubaddr' 64 - Y.Length + 1' Y.Length);
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PubKeyToByteArray,The following statement contains a magic number: Array.Copy(X' 0' pubaddr' 32 - X.Length + 1' X.Length);
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PubKeyToByteArray,The following statement contains a magic number: pubaddr[0] = 4;
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PubHashToAddress,The following statement contains a magic number: byte[] hex2 = new byte[21];
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PubHashToAddress,The following statement contains a magic number: Array.Copy(hex' 0' hex2' 1' 20);
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PubHashToAddress,The following statement contains a magic number: if (AddressType == "Testnet") cointype = 111;
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PubHashToAddress,The following statement contains a magic number: if (AddressType == "Namecoin") cointype = 52;
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PubHashToAddress,The following statement contains a magic number: if (AddressType == "Litecoin") cointype = 48;
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PassphraseTooSimple,The following statement contains a magic number: if (passphrase.Length < 30 && (Lowercase < 10 || Uppercase < 3 || Numbers < 2 || Symbols < 2)) {                  return true;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PassphraseTooSimple,The following statement contains a magic number: if (passphrase.Length < 30 && (Lowercase < 10 || Uppercase < 3 || Numbers < 2 || Symbols < 2)) {                  return true;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PassphraseTooSimple,The following statement contains a magic number: if (passphrase.Length < 30 && (Lowercase < 10 || Uppercase < 3 || Numbers < 2 || Symbols < 2)) {                  return true;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PassphraseTooSimple,The following statement contains a magic number: if (passphrase.Length < 30 && (Lowercase < 10 || Uppercase < 3 || Numbers < 2 || Symbols < 2)) {                  return true;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,PassphraseTooSimple,The following statement contains a magic number: if (passphrase.Length < 30 && (Lowercase < 10 || Uppercase < 3 || Numbers < 2 || Symbols < 2)) {                  return true;              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ComputeSha256,The following statement contains a magic number: byte[] rv = new byte[32];
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,ComputeDoubleSha256,The following statement contains a magic number: byte[] rv = new byte[32];
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Force32Bytes,The following statement contains a magic number: if (inbytes.Length == 32) return inbytes;
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Force32Bytes,The following statement contains a magic number: byte[] rv = new byte[32];
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Force32Bytes,The following statement contains a magic number: if (inbytes.Length > 32) {                  Array.Copy(inbytes' inbytes.Length - 32' rv' 0' 32);              } else {                  Array.Copy(inbytes' 0' rv' 32 - inbytes.Length' inbytes.Length);              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Force32Bytes,The following statement contains a magic number: if (inbytes.Length > 32) {                  Array.Copy(inbytes' inbytes.Length - 32' rv' 0' 32);              } else {                  Array.Copy(inbytes' 0' rv' 32 - inbytes.Length' inbytes.Length);              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Force32Bytes,The following statement contains a magic number: if (inbytes.Length > 32) {                  Array.Copy(inbytes' inbytes.Length - 32' rv' 0' 32);              } else {                  Array.Copy(inbytes' 0' rv' 32 - inbytes.Length' inbytes.Length);              }
Magic Number,Casascius.Bitcoin,Util,C:\repos\casascius_Bitcoin-Address-Utility\Model\Bitcoin.cs,Force32Bytes,The following statement contains a magic number: if (inbytes.Length > 32) {                  Array.Copy(inbytes' inbytes.Length - 32' rv' 0' 32);              } else {                  Array.Copy(inbytes' 0' rv' 32 - inbytes.Length' inbytes.Length);              }
Magic Number,Casascius.Bitcoin,AddressBase,C:\repos\casascius_Bitcoin-Address-Utility\Model\Address.cs,AddressBase,The following statement contains a magic number: if (hex.Length != 21) throw new ArgumentException("Not a valid or recognized address");
Magic Number,Casascius.Bitcoin,MiniKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\MiniKeyPair.cs,CreateDeterministic,The following statement contains a magic number: string keytotry = "S" + asbase58.Substring(4' 29);
Magic Number,Casascius.Bitcoin,MiniKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\MiniKeyPair.cs,CreateDeterministic,The following statement contains a magic number: string keytotry = "S" + asbase58.Substring(4' 29);
Magic Number,Casascius.Bitcoin,MiniKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\MiniKeyPair.cs,CreateRandom,The following statement contains a magic number: char[] chars = new char[64];
Magic Number,Casascius.Bitcoin,MiniKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\MiniKeyPair.cs,CreateRandom,The following statement contains a magic number: for (int i = 0; i < 64; i++) {                  chars[i] = (char)(32 + (sr.NextInt() % 64));              }
Magic Number,Casascius.Bitcoin,MiniKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\MiniKeyPair.cs,CreateRandom,The following statement contains a magic number: for (int i = 0; i < 64; i++) {                  chars[i] = (char)(32 + (sr.NextInt() % 64));              }
Magic Number,Casascius.Bitcoin,MiniKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\MiniKeyPair.cs,CreateRandom,The following statement contains a magic number: for (int i = 0; i < 64; i++) {                  chars[i] = (char)(32 + (sr.NextInt() % 64));              }
Magic Number,Casascius.Bitcoin,MiniKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\MiniKeyPair.cs,IsValidMiniKey,The following statement contains a magic number: if (candidate.Length != 22 && candidate.Length != 26 && candidate.Length != 30) return 0;
Magic Number,Casascius.Bitcoin,MiniKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\MiniKeyPair.cs,IsValidMiniKey,The following statement contains a magic number: if (candidate.Length != 22 && candidate.Length != 26 && candidate.Length != 30) return 0;
Magic Number,Casascius.Bitcoin,MiniKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\MiniKeyPair.cs,IsValidMiniKey,The following statement contains a magic number: if (candidate.Length != 22 && candidate.Length != 26 && candidate.Length != 30) return 0;
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: if (PartsNeededToDecode > 8 || PartsToGenerate > 8) {                  throw new ApplicationException("Maximum number of parts is 8");              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: if (PartsNeededToDecode > 8 || PartsToGenerate > 8) {                  throw new ApplicationException("Maximum number of parts is 8");              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: if (desiredPrivKey != null && desiredPrivKey.Length != 32) {                  throw new ApplicationException("Desired private key must be 32 bytes");              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: byte[][] vvv = new byte[8][];
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: BigInteger[] v = new BigInteger[8];
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  byte[] b = new byte[32];                  sr.NextBytes(b' 0' 32);                  // For larger values of i' chop off some most-significant-bits to prevent overflows as they are                  // multiplied with increasingly larger factors.                  if (i >= 7) {                      b[0] &= 0x7f;                  }                  v[i] = new BigInteger(1' b);                  Debug.WriteLine(String.Format("v({0})={1}"' i' v[i].ToString()));                }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  byte[] b = new byte[32];                  sr.NextBytes(b' 0' 32);                  // For larger values of i' chop off some most-significant-bits to prevent overflows as they are                  // multiplied with increasingly larger factors.                  if (i >= 7) {                      b[0] &= 0x7f;                  }                  v[i] = new BigInteger(1' b);                  Debug.WriteLine(String.Format("v({0})={1}"' i' v[i].ToString()));                }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  byte[] b = new byte[32];                  sr.NextBytes(b' 0' 32);                  // For larger values of i' chop off some most-significant-bits to prevent overflows as they are                  // multiplied with increasingly larger factors.                  if (i >= 7) {                      b[0] &= 0x7f;                  }                  v[i] = new BigInteger(1' b);                  Debug.WriteLine(String.Format("v({0})={1}"' i' v[i].ToString()));                }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                  byte[] b = new byte[32];                  sr.NextBytes(b' 0' 32);                  // For larger values of i' chop off some most-significant-bits to prevent overflows as they are                  // multiplied with increasingly larger factors.                  if (i >= 7) {                      b[0] &= 0x7f;                  }                  v[i] = new BigInteger(1' b);                  Debug.WriteLine(String.Format("v({0})={1}"' i' v[i].ToString()));                }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: if (keybytes.Length < 32) {                  byte[] array32 = new byte[32];                  Array.Copy(keybytes' 0' array32' 32 - keybytes.Length' keybytes.Length);                  keybytes = array32;              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: if (keybytes.Length < 32) {                  byte[] array32 = new byte[32];                  Array.Copy(keybytes' 0' array32' 32 - keybytes.Length' keybytes.Length);                  keybytes = array32;              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: if (keybytes.Length < 32) {                  byte[] array32 = new byte[32];                  Array.Copy(keybytes' 0' array32' 32 - keybytes.Length' keybytes.Length);                  keybytes = array32;              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < PartsToGenerate; i++) {                  BigInteger total = new BigInteger("0");                  for (int j = 0; j < PartsNeededToDecode; j++) {                        int factor = 1;                      for (int ii = 0; ii <= i; ii++) factor = factor * (j + 1);                        BigInteger bfactor = new BigInteger(factor.ToString());                        total = total.Add(v[j].Multiply(bfactor));                  }                    Debug.WriteLine(String.Format(" pc{0}={1}"' i' total.ToString()));                  byte[] parts = new byte[39];                  parts[0] = 0x4f;                  parts[1] = (byte)(0x93 + PartsNeededToDecode);                  int parts23 = (((checksum[0] << 8) + checksum[1]) & 0x1ff);                  Debug.WriteLine("checksum " + parts23.ToString());                  parts23 += 0x6000;                  parts23 += (i << 9);                  byte[] btotal = total.ToByteArrayUnsigned();                  for (int jj = 0; jj < btotal.Length; jj++) {                      parts[jj + 4 + (35 - btotal.Length)] = btotal[jj];                  }                    parts[2] = (byte)((parts23 & 0xFF00) >> 8);                  parts[3] = (byte)(parts23 & 0xFF);                    KeyParts.Add(Util.ByteArrayToBase58Check(parts));                  decodedKeyParts.Add(parts);              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < PartsToGenerate; i++) {                  BigInteger total = new BigInteger("0");                  for (int j = 0; j < PartsNeededToDecode; j++) {                        int factor = 1;                      for (int ii = 0; ii <= i; ii++) factor = factor * (j + 1);                        BigInteger bfactor = new BigInteger(factor.ToString());                        total = total.Add(v[j].Multiply(bfactor));                  }                    Debug.WriteLine(String.Format(" pc{0}={1}"' i' total.ToString()));                  byte[] parts = new byte[39];                  parts[0] = 0x4f;                  parts[1] = (byte)(0x93 + PartsNeededToDecode);                  int parts23 = (((checksum[0] << 8) + checksum[1]) & 0x1ff);                  Debug.WriteLine("checksum " + parts23.ToString());                  parts23 += 0x6000;                  parts23 += (i << 9);                  byte[] btotal = total.ToByteArrayUnsigned();                  for (int jj = 0; jj < btotal.Length; jj++) {                      parts[jj + 4 + (35 - btotal.Length)] = btotal[jj];                  }                    parts[2] = (byte)((parts23 & 0xFF00) >> 8);                  parts[3] = (byte)(parts23 & 0xFF);                    KeyParts.Add(Util.ByteArrayToBase58Check(parts));                  decodedKeyParts.Add(parts);              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < PartsToGenerate; i++) {                  BigInteger total = new BigInteger("0");                  for (int j = 0; j < PartsNeededToDecode; j++) {                        int factor = 1;                      for (int ii = 0; ii <= i; ii++) factor = factor * (j + 1);                        BigInteger bfactor = new BigInteger(factor.ToString());                        total = total.Add(v[j].Multiply(bfactor));                  }                    Debug.WriteLine(String.Format(" pc{0}={1}"' i' total.ToString()));                  byte[] parts = new byte[39];                  parts[0] = 0x4f;                  parts[1] = (byte)(0x93 + PartsNeededToDecode);                  int parts23 = (((checksum[0] << 8) + checksum[1]) & 0x1ff);                  Debug.WriteLine("checksum " + parts23.ToString());                  parts23 += 0x6000;                  parts23 += (i << 9);                  byte[] btotal = total.ToByteArrayUnsigned();                  for (int jj = 0; jj < btotal.Length; jj++) {                      parts[jj + 4 + (35 - btotal.Length)] = btotal[jj];                  }                    parts[2] = (byte)((parts23 & 0xFF00) >> 8);                  parts[3] = (byte)(parts23 & 0xFF);                    KeyParts.Add(Util.ByteArrayToBase58Check(parts));                  decodedKeyParts.Add(parts);              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < PartsToGenerate; i++) {                  BigInteger total = new BigInteger("0");                  for (int j = 0; j < PartsNeededToDecode; j++) {                        int factor = 1;                      for (int ii = 0; ii <= i; ii++) factor = factor * (j + 1);                        BigInteger bfactor = new BigInteger(factor.ToString());                        total = total.Add(v[j].Multiply(bfactor));                  }                    Debug.WriteLine(String.Format(" pc{0}={1}"' i' total.ToString()));                  byte[] parts = new byte[39];                  parts[0] = 0x4f;                  parts[1] = (byte)(0x93 + PartsNeededToDecode);                  int parts23 = (((checksum[0] << 8) + checksum[1]) & 0x1ff);                  Debug.WriteLine("checksum " + parts23.ToString());                  parts23 += 0x6000;                  parts23 += (i << 9);                  byte[] btotal = total.ToByteArrayUnsigned();                  for (int jj = 0; jj < btotal.Length; jj++) {                      parts[jj + 4 + (35 - btotal.Length)] = btotal[jj];                  }                    parts[2] = (byte)((parts23 & 0xFF00) >> 8);                  parts[3] = (byte)(parts23 & 0xFF);                    KeyParts.Add(Util.ByteArrayToBase58Check(parts));                  decodedKeyParts.Add(parts);              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < PartsToGenerate; i++) {                  BigInteger total = new BigInteger("0");                  for (int j = 0; j < PartsNeededToDecode; j++) {                        int factor = 1;                      for (int ii = 0; ii <= i; ii++) factor = factor * (j + 1);                        BigInteger bfactor = new BigInteger(factor.ToString());                        total = total.Add(v[j].Multiply(bfactor));                  }                    Debug.WriteLine(String.Format(" pc{0}={1}"' i' total.ToString()));                  byte[] parts = new byte[39];                  parts[0] = 0x4f;                  parts[1] = (byte)(0x93 + PartsNeededToDecode);                  int parts23 = (((checksum[0] << 8) + checksum[1]) & 0x1ff);                  Debug.WriteLine("checksum " + parts23.ToString());                  parts23 += 0x6000;                  parts23 += (i << 9);                  byte[] btotal = total.ToByteArrayUnsigned();                  for (int jj = 0; jj < btotal.Length; jj++) {                      parts[jj + 4 + (35 - btotal.Length)] = btotal[jj];                  }                    parts[2] = (byte)((parts23 & 0xFF00) >> 8);                  parts[3] = (byte)(parts23 & 0xFF);                    KeyParts.Add(Util.ByteArrayToBase58Check(parts));                  decodedKeyParts.Add(parts);              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < PartsToGenerate; i++) {                  BigInteger total = new BigInteger("0");                  for (int j = 0; j < PartsNeededToDecode; j++) {                        int factor = 1;                      for (int ii = 0; ii <= i; ii++) factor = factor * (j + 1);                        BigInteger bfactor = new BigInteger(factor.ToString());                        total = total.Add(v[j].Multiply(bfactor));                  }                    Debug.WriteLine(String.Format(" pc{0}={1}"' i' total.ToString()));                  byte[] parts = new byte[39];                  parts[0] = 0x4f;                  parts[1] = (byte)(0x93 + PartsNeededToDecode);                  int parts23 = (((checksum[0] << 8) + checksum[1]) & 0x1ff);                  Debug.WriteLine("checksum " + parts23.ToString());                  parts23 += 0x6000;                  parts23 += (i << 9);                  byte[] btotal = total.ToByteArrayUnsigned();                  for (int jj = 0; jj < btotal.Length; jj++) {                      parts[jj + 4 + (35 - btotal.Length)] = btotal[jj];                  }                    parts[2] = (byte)((parts23 & 0xFF00) >> 8);                  parts[3] = (byte)(parts23 & 0xFF);                    KeyParts.Add(Util.ByteArrayToBase58Check(parts));                  decodedKeyParts.Add(parts);              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < PartsToGenerate; i++) {                  BigInteger total = new BigInteger("0");                  for (int j = 0; j < PartsNeededToDecode; j++) {                        int factor = 1;                      for (int ii = 0; ii <= i; ii++) factor = factor * (j + 1);                        BigInteger bfactor = new BigInteger(factor.ToString());                        total = total.Add(v[j].Multiply(bfactor));                  }                    Debug.WriteLine(String.Format(" pc{0}={1}"' i' total.ToString()));                  byte[] parts = new byte[39];                  parts[0] = 0x4f;                  parts[1] = (byte)(0x93 + PartsNeededToDecode);                  int parts23 = (((checksum[0] << 8) + checksum[1]) & 0x1ff);                  Debug.WriteLine("checksum " + parts23.ToString());                  parts23 += 0x6000;                  parts23 += (i << 9);                  byte[] btotal = total.ToByteArrayUnsigned();                  for (int jj = 0; jj < btotal.Length; jj++) {                      parts[jj + 4 + (35 - btotal.Length)] = btotal[jj];                  }                    parts[2] = (byte)((parts23 & 0xFF00) >> 8);                  parts[3] = (byte)(parts23 & 0xFF);                    KeyParts.Add(Util.ByteArrayToBase58Check(parts));                  decodedKeyParts.Add(parts);              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Generate,The following statement contains a magic number: for (int i = 0; i < PartsToGenerate; i++) {                  BigInteger total = new BigInteger("0");                  for (int j = 0; j < PartsNeededToDecode; j++) {                        int factor = 1;                      for (int ii = 0; ii <= i; ii++) factor = factor * (j + 1);                        BigInteger bfactor = new BigInteger(factor.ToString());                        total = total.Add(v[j].Multiply(bfactor));                  }                    Debug.WriteLine(String.Format(" pc{0}={1}"' i' total.ToString()));                  byte[] parts = new byte[39];                  parts[0] = 0x4f;                  parts[1] = (byte)(0x93 + PartsNeededToDecode);                  int parts23 = (((checksum[0] << 8) + checksum[1]) & 0x1ff);                  Debug.WriteLine("checksum " + parts23.ToString());                  parts23 += 0x6000;                  parts23 += (i << 9);                  byte[] btotal = total.ToByteArrayUnsigned();                  for (int jj = 0; jj < btotal.Length; jj++) {                      parts[jj + 4 + (35 - btotal.Length)] = btotal[jj];                  }                    parts[2] = (byte)((parts23 & 0xFF00) >> 8);                  parts[3] = (byte)(parts23 & 0xFF);                    KeyParts.Add(Util.ByteArrayToBase58Check(parts));                  decodedKeyParts.Add(parts);              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: BigInteger[] pc = new BigInteger[8];
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: for (int i = 0; i < decodedKeyParts.Count; i++) {                  byte[] g = decodedKeyParts[i];                  pc[i] = new BigInteger(1' g' 4' 35);                  // If there is an overflow' then add it in.                  if ((g[2] & 0x80) == 0x80) {                      pc[i] = pc[i].Add(new BigInteger(((int)((g[2] & 0x60) >> 5)).ToString()).ShiftLeft(280));                      Debug.WriteLine("overflow added");                    }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: for (int i = 0; i < decodedKeyParts.Count; i++) {                  byte[] g = decodedKeyParts[i];                  pc[i] = new BigInteger(1' g' 4' 35);                  // If there is an overflow' then add it in.                  if ((g[2] & 0x80) == 0x80) {                      pc[i] = pc[i].Add(new BigInteger(((int)((g[2] & 0x60) >> 5)).ToString()).ShiftLeft(280));                      Debug.WriteLine("overflow added");                    }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: for (int i = 0; i < decodedKeyParts.Count; i++) {                  byte[] g = decodedKeyParts[i];                  pc[i] = new BigInteger(1' g' 4' 35);                  // If there is an overflow' then add it in.                  if ((g[2] & 0x80) == 0x80) {                      pc[i] = pc[i].Add(new BigInteger(((int)((g[2] & 0x60) >> 5)).ToString()).ShiftLeft(280));                      Debug.WriteLine("overflow added");                    }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: for (int i = 0; i < decodedKeyParts.Count; i++) {                  byte[] g = decodedKeyParts[i];                  pc[i] = new BigInteger(1' g' 4' 35);                  // If there is an overflow' then add it in.                  if ((g[2] & 0x80) == 0x80) {                      pc[i] = pc[i].Add(new BigInteger(((int)((g[2] & 0x60) >> 5)).ToString()).ShiftLeft(280));                      Debug.WriteLine("overflow added");                    }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: for (int i = 0; i < decodedKeyParts.Count; i++) {                  byte[] g = decodedKeyParts[i];                  pc[i] = new BigInteger(1' g' 4' 35);                  // If there is an overflow' then add it in.                  if ((g[2] & 0x80) == 0x80) {                      pc[i] = pc[i].Add(new BigInteger(((int)((g[2] & 0x60) >> 5)).ToString()).ShiftLeft(280));                      Debug.WriteLine("overflow added");                    }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: for (int i = 0; i < decodedKeyParts.Count; i++) {                  byte[] g = decodedKeyParts[i];                  pc[i] = new BigInteger(1' g' 4' 35);                  // If there is an overflow' then add it in.                  if ((g[2] & 0x80) == 0x80) {                      pc[i] = pc[i].Add(new BigInteger(((int)((g[2] & 0x60) >> 5)).ToString()).ShiftLeft(280));                      Debug.WriteLine("overflow added");                    }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: for (int i = 0; i < PartsNeeded; i++) {                  byte[] got = decodedKeyParts[i];                  // extract out part number                  int partnumber0 = (byte)((got[2] & 0x0e) >> 1);                  equations.Add(new equation(i' PartsNeeded' partnumber0));              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: BigInteger[] v = new BigInteger[8];
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: if (keybytes.Length > 32) {                  // if more than 32 bytes' decoding probably went wrong! truncate to 32 bytes' but force a checksum failure                  byte[] newkey = new byte[32];                  for (int jj = 0; jj < 32; jj++) newkey[jj] = keybytes[jj];                  keybytes = newkey;                  return;              } else if (keybytes.Length < 32) {                  byte[] array32 = new byte[32];                  Array.Copy(keybytes' 0' array32' 32 - keybytes.Length' keybytes.Length);                  keybytes = array32;              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: if (keybytes.Length > 32) {                  // if more than 32 bytes' decoding probably went wrong! truncate to 32 bytes' but force a checksum failure                  byte[] newkey = new byte[32];                  for (int jj = 0; jj < 32; jj++) newkey[jj] = keybytes[jj];                  keybytes = newkey;                  return;              } else if (keybytes.Length < 32) {                  byte[] array32 = new byte[32];                  Array.Copy(keybytes' 0' array32' 32 - keybytes.Length' keybytes.Length);                  keybytes = array32;              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: if (keybytes.Length > 32) {                  // if more than 32 bytes' decoding probably went wrong! truncate to 32 bytes' but force a checksum failure                  byte[] newkey = new byte[32];                  for (int jj = 0; jj < 32; jj++) newkey[jj] = keybytes[jj];                  keybytes = newkey;                  return;              } else if (keybytes.Length < 32) {                  byte[] array32 = new byte[32];                  Array.Copy(keybytes' 0' array32' 32 - keybytes.Length' keybytes.Length);                  keybytes = array32;              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: if (keybytes.Length > 32) {                  // if more than 32 bytes' decoding probably went wrong! truncate to 32 bytes' but force a checksum failure                  byte[] newkey = new byte[32];                  for (int jj = 0; jj < 32; jj++) newkey[jj] = keybytes[jj];                  keybytes = newkey;                  return;              } else if (keybytes.Length < 32) {                  byte[] array32 = new byte[32];                  Array.Copy(keybytes' 0' array32' 32 - keybytes.Length' keybytes.Length);                  keybytes = array32;              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: if (keybytes.Length > 32) {                  // if more than 32 bytes' decoding probably went wrong! truncate to 32 bytes' but force a checksum failure                  byte[] newkey = new byte[32];                  for (int jj = 0; jj < 32; jj++) newkey[jj] = keybytes[jj];                  keybytes = newkey;                  return;              } else if (keybytes.Length < 32) {                  byte[] array32 = new byte[32];                  Array.Copy(keybytes' 0' array32' 32 - keybytes.Length' keybytes.Length);                  keybytes = array32;              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: if (keybytes.Length > 32) {                  // if more than 32 bytes' decoding probably went wrong! truncate to 32 bytes' but force a checksum failure                  byte[] newkey = new byte[32];                  for (int jj = 0; jj < 32; jj++) newkey[jj] = keybytes[jj];                  keybytes = newkey;                  return;              } else if (keybytes.Length < 32) {                  byte[] array32 = new byte[32];                  Array.Copy(keybytes' 0' array32' 32 - keybytes.Length' keybytes.Length);                  keybytes = array32;              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,Decode,The following statement contains a magic number: int mychecksum = ((checksum[0] & 1) << 8) + checksum[1];
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The following statement contains a magic number: if (ins.Length != 39) ins = null;
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The following statement contains a magic number: if (KeyParts.Count > 0) {                      // go through the list' make sure they all belong to the first on the list                  byte[] first = null;                  int needed = 0;                  for (int i = 0; i < decodedKeyParts.Count; i++) {                      byte[] b = decodedKeyParts[i];                      if (first == null) {                          first = b;                          needed = b[1] - 0x93;                          expectedChecksum = ((b[2] & 1) << 8) + b[3];                      }                        // check that bytes 2 and 3 are a match                      if ((ins[2] & 1) != (b[2] & 1) || ins[3] != b[3]) {                          return "M-of-N code is valid' but does not belong to the earlier code(s) provided.";                      }                        bool same = true;                      for (int jj = 0; jj < b.Length; jj++) {                          if (ins[jj] != b[jj]) same = false;                      }                      if (same) {                          return "Code is identical to an earlier one provided.";                      }                        if ((ins[2] & 0x0e) == (b[2] & 0x0e)) {                          return "This code has an identifier that conflicts with one of the earlier codes provided and cannot be used.  It may not belong to the set.";                      }                  }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The following statement contains a magic number: if (KeyParts.Count > 0) {                      // go through the list' make sure they all belong to the first on the list                  byte[] first = null;                  int needed = 0;                  for (int i = 0; i < decodedKeyParts.Count; i++) {                      byte[] b = decodedKeyParts[i];                      if (first == null) {                          first = b;                          needed = b[1] - 0x93;                          expectedChecksum = ((b[2] & 1) << 8) + b[3];                      }                        // check that bytes 2 and 3 are a match                      if ((ins[2] & 1) != (b[2] & 1) || ins[3] != b[3]) {                          return "M-of-N code is valid' but does not belong to the earlier code(s) provided.";                      }                        bool same = true;                      for (int jj = 0; jj < b.Length; jj++) {                          if (ins[jj] != b[jj]) same = false;                      }                      if (same) {                          return "Code is identical to an earlier one provided.";                      }                        if ((ins[2] & 0x0e) == (b[2] & 0x0e)) {                          return "This code has an identifier that conflicts with one of the earlier codes provided and cannot be used.  It may not belong to the set.";                      }                  }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The following statement contains a magic number: if (KeyParts.Count > 0) {                      // go through the list' make sure they all belong to the first on the list                  byte[] first = null;                  int needed = 0;                  for (int i = 0; i < decodedKeyParts.Count; i++) {                      byte[] b = decodedKeyParts[i];                      if (first == null) {                          first = b;                          needed = b[1] - 0x93;                          expectedChecksum = ((b[2] & 1) << 8) + b[3];                      }                        // check that bytes 2 and 3 are a match                      if ((ins[2] & 1) != (b[2] & 1) || ins[3] != b[3]) {                          return "M-of-N code is valid' but does not belong to the earlier code(s) provided.";                      }                        bool same = true;                      for (int jj = 0; jj < b.Length; jj++) {                          if (ins[jj] != b[jj]) same = false;                      }                      if (same) {                          return "Code is identical to an earlier one provided.";                      }                        if ((ins[2] & 0x0e) == (b[2] & 0x0e)) {                          return "This code has an identifier that conflicts with one of the earlier codes provided and cannot be used.  It may not belong to the set.";                      }                  }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The following statement contains a magic number: if (KeyParts.Count > 0) {                      // go through the list' make sure they all belong to the first on the list                  byte[] first = null;                  int needed = 0;                  for (int i = 0; i < decodedKeyParts.Count; i++) {                      byte[] b = decodedKeyParts[i];                      if (first == null) {                          first = b;                          needed = b[1] - 0x93;                          expectedChecksum = ((b[2] & 1) << 8) + b[3];                      }                        // check that bytes 2 and 3 are a match                      if ((ins[2] & 1) != (b[2] & 1) || ins[3] != b[3]) {                          return "M-of-N code is valid' but does not belong to the earlier code(s) provided.";                      }                        bool same = true;                      for (int jj = 0; jj < b.Length; jj++) {                          if (ins[jj] != b[jj]) same = false;                      }                      if (same) {                          return "Code is identical to an earlier one provided.";                      }                        if ((ins[2] & 0x0e) == (b[2] & 0x0e)) {                          return "This code has an identifier that conflicts with one of the earlier codes provided and cannot be used.  It may not belong to the set.";                      }                  }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The following statement contains a magic number: if (KeyParts.Count > 0) {                      // go through the list' make sure they all belong to the first on the list                  byte[] first = null;                  int needed = 0;                  for (int i = 0; i < decodedKeyParts.Count; i++) {                      byte[] b = decodedKeyParts[i];                      if (first == null) {                          first = b;                          needed = b[1] - 0x93;                          expectedChecksum = ((b[2] & 1) << 8) + b[3];                      }                        // check that bytes 2 and 3 are a match                      if ((ins[2] & 1) != (b[2] & 1) || ins[3] != b[3]) {                          return "M-of-N code is valid' but does not belong to the earlier code(s) provided.";                      }                        bool same = true;                      for (int jj = 0; jj < b.Length; jj++) {                          if (ins[jj] != b[jj]) same = false;                      }                      if (same) {                          return "Code is identical to an earlier one provided.";                      }                        if ((ins[2] & 0x0e) == (b[2] & 0x0e)) {                          return "This code has an identifier that conflicts with one of the earlier codes provided and cannot be used.  It may not belong to the set.";                      }                  }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The following statement contains a magic number: if (KeyParts.Count > 0) {                      // go through the list' make sure they all belong to the first on the list                  byte[] first = null;                  int needed = 0;                  for (int i = 0; i < decodedKeyParts.Count; i++) {                      byte[] b = decodedKeyParts[i];                      if (first == null) {                          first = b;                          needed = b[1] - 0x93;                          expectedChecksum = ((b[2] & 1) << 8) + b[3];                      }                        // check that bytes 2 and 3 are a match                      if ((ins[2] & 1) != (b[2] & 1) || ins[3] != b[3]) {                          return "M-of-N code is valid' but does not belong to the earlier code(s) provided.";                      }                        bool same = true;                      for (int jj = 0; jj < b.Length; jj++) {                          if (ins[jj] != b[jj]) same = false;                      }                      if (same) {                          return "Code is identical to an earlier one provided.";                      }                        if ((ins[2] & 0x0e) == (b[2] & 0x0e)) {                          return "This code has an identifier that conflicts with one of the earlier codes provided and cannot be used.  It may not belong to the set.";                      }                  }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The following statement contains a magic number: if (KeyParts.Count > 0) {                      // go through the list' make sure they all belong to the first on the list                  byte[] first = null;                  int needed = 0;                  for (int i = 0; i < decodedKeyParts.Count; i++) {                      byte[] b = decodedKeyParts[i];                      if (first == null) {                          first = b;                          needed = b[1] - 0x93;                          expectedChecksum = ((b[2] & 1) << 8) + b[3];                      }                        // check that bytes 2 and 3 are a match                      if ((ins[2] & 1) != (b[2] & 1) || ins[3] != b[3]) {                          return "M-of-N code is valid' but does not belong to the earlier code(s) provided.";                      }                        bool same = true;                      for (int jj = 0; jj < b.Length; jj++) {                          if (ins[jj] != b[jj]) same = false;                      }                      if (same) {                          return "Code is identical to an earlier one provided.";                      }                        if ((ins[2] & 0x0e) == (b[2] & 0x0e)) {                          return "This code has an identifier that conflicts with one of the earlier codes provided and cannot be used.  It may not belong to the set.";                      }                  }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The following statement contains a magic number: if (KeyParts.Count > 0) {                      // go through the list' make sure they all belong to the first on the list                  byte[] first = null;                  int needed = 0;                  for (int i = 0; i < decodedKeyParts.Count; i++) {                      byte[] b = decodedKeyParts[i];                      if (first == null) {                          first = b;                          needed = b[1] - 0x93;                          expectedChecksum = ((b[2] & 1) << 8) + b[3];                      }                        // check that bytes 2 and 3 are a match                      if ((ins[2] & 1) != (b[2] & 1) || ins[3] != b[3]) {                          return "M-of-N code is valid' but does not belong to the earlier code(s) provided.";                      }                        bool same = true;                      for (int jj = 0; jj < b.Length; jj++) {                          if (ins[jj] != b[jj]) same = false;                      }                      if (same) {                          return "Code is identical to an earlier one provided.";                      }                        if ((ins[2] & 0x0e) == (b[2] & 0x0e)) {                          return "This code has an identifier that conflicts with one of the earlier codes provided and cannot be used.  It may not belong to the set.";                      }                  }              }
Magic Number,Casascius.Bitcoin,MofN,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,AddKeyPart,The following statement contains a magic number: if (KeyParts.Count > 0) {                      // go through the list' make sure they all belong to the first on the list                  byte[] first = null;                  int needed = 0;                  for (int i = 0; i < decodedKeyParts.Count; i++) {                      byte[] b = decodedKeyParts[i];                      if (first == null) {                          first = b;                          needed = b[1] - 0x93;                          expectedChecksum = ((b[2] & 1) << 8) + b[3];                      }                        // check that bytes 2 and 3 are a match                      if ((ins[2] & 1) != (b[2] & 1) || ins[3] != b[3]) {                          return "M-of-N code is valid' but does not belong to the earlier code(s) provided.";                      }                        bool same = true;                      for (int jj = 0; jj < b.Length; jj++) {                          if (ins[jj] != b[jj]) same = false;                      }                      if (same) {                          return "Code is identical to an earlier one provided.";                      }                        if ((ins[2] & 0x0e) == (b[2] & 0x0e)) {                          return "This code has an identifier that conflicts with one of the earlier codes provided and cannot be used.  It may not belong to the set.";                      }                  }              }
Magic Number,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,CombineAndReduce,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                      long multiplier = 0;                      foreach (coefficient r in rightside) {                          if (r.vindex == i) multiplier += (r.multiplier * topmultiplier);                      }                        foreach (coefficient r in othereq.rightside) {                          if (r.vindex == i) multiplier -= (r.multiplier * bottommultiplier);                      }                        if (multiplier != 0) {                          neweq.rightside.Add(new coefficient(multiplier' i));                      }                  }
Magic Number,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,SolveLeft,The following statement contains a magic number: for (int i = 0; i < 8; i++) {                      if (v[i] != null && v[i].Equals(BigInteger.Zero) == false) {                          // find anything on the left that uses this value and eliminate it.                          for (int j = 0; j < leftside.Count; j++) {                              coefficient c = leftside[j];                              if (c.vindex == i) {                                  // found something - eliminate it                                  BigInteger accum = v[i];                                  accum = accum.Multiply(new BigInteger(c.multiplier.ToString()));                                  // now subtract the whole thing from both sides                                  subtractor = subtractor.Add(accum);                                  leftside.RemoveAt(j);                                  j--;                              }                          }                      }                  }
Magic Number,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,KillFactors,The following statement contains a magic number: long[] primes = new long[] { 2' 3' 5' 7' 11' 13' 17 };
Magic Number,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,KillFactors,The following statement contains a magic number: long[] primes = new long[] { 2' 3' 5' 7' 11' 13' 17 };
Magic Number,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,KillFactors,The following statement contains a magic number: long[] primes = new long[] { 2' 3' 5' 7' 11' 13' 17 };
Magic Number,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,KillFactors,The following statement contains a magic number: long[] primes = new long[] { 2' 3' 5' 7' 11' 13' 17 };
Magic Number,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,KillFactors,The following statement contains a magic number: long[] primes = new long[] { 2' 3' 5' 7' 11' 13' 17 };
Magic Number,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,KillFactors,The following statement contains a magic number: long[] primes = new long[] { 2' 3' 5' 7' 11' 13' 17 };
Magic Number,Casascius.Bitcoin,equation,C:\repos\casascius_Bitcoin-Address-Utility\Model\MofN.cs,KillFactors,The following statement contains a magic number: long[] primes = new long[] { 2' 3' 5' 7' 11' 13' 17 };
Magic Number,Casascius.Bitcoin,PublicKey,C:\repos\casascius_Bitcoin-Address-Utility\Model\PublicKey.cs,constructFromBytes,The following statement contains a magic number: if (pubKeyBytes.Length == 65) {                  if (pubKeyBytes[0] != 4) {                      return "Invalid public key' for 65-byte keys the first byte must be 0x04";                  }                } else if (pubKeyBytes.Length == 33) {                  if (pubKeyBytes[0] != 2 && pubKeyBytes[0] != 3) {                      return "Invalid public key' for 3-byte keys the first byte must be 0x02 or 0x03";                  }                  IsCompressedPoint = true;              } else {                  return "Invalid public key' must be 33 or 65 bytes";              }
Magic Number,Casascius.Bitcoin,PublicKey,C:\repos\casascius_Bitcoin-Address-Utility\Model\PublicKey.cs,constructFromBytes,The following statement contains a magic number: if (pubKeyBytes.Length == 65) {                  if (pubKeyBytes[0] != 4) {                      return "Invalid public key' for 65-byte keys the first byte must be 0x04";                  }                } else if (pubKeyBytes.Length == 33) {                  if (pubKeyBytes[0] != 2 && pubKeyBytes[0] != 3) {                      return "Invalid public key' for 3-byte keys the first byte must be 0x02 or 0x03";                  }                  IsCompressedPoint = true;              } else {                  return "Invalid public key' must be 33 or 65 bytes";              }
Magic Number,Casascius.Bitcoin,PublicKey,C:\repos\casascius_Bitcoin-Address-Utility\Model\PublicKey.cs,constructFromBytes,The following statement contains a magic number: if (pubKeyBytes.Length == 65) {                  if (pubKeyBytes[0] != 4) {                      return "Invalid public key' for 65-byte keys the first byte must be 0x04";                  }                } else if (pubKeyBytes.Length == 33) {                  if (pubKeyBytes[0] != 2 && pubKeyBytes[0] != 3) {                      return "Invalid public key' for 3-byte keys the first byte must be 0x02 or 0x03";                  }                  IsCompressedPoint = true;              } else {                  return "Invalid public key' must be 33 or 65 bytes";              }
Magic Number,Casascius.Bitcoin,PublicKey,C:\repos\casascius_Bitcoin-Address-Utility\Model\PublicKey.cs,constructFromBytes,The following statement contains a magic number: if (pubKeyBytes.Length == 65) {                  if (pubKeyBytes[0] != 4) {                      return "Invalid public key' for 65-byte keys the first byte must be 0x04";                  }                } else if (pubKeyBytes.Length == 33) {                  if (pubKeyBytes[0] != 2 && pubKeyBytes[0] != 3) {                      return "Invalid public key' for 3-byte keys the first byte must be 0x02 or 0x03";                  }                  IsCompressedPoint = true;              } else {                  return "Invalid public key' must be 33 or 65 bytes";              }
Magic Number,Casascius.Bitcoin,PublicKey,C:\repos\casascius_Bitcoin-Address-Utility\Model\PublicKey.cs,constructFromBytes,The following statement contains a magic number: if (pubKeyBytes.Length == 65) {                  if (pubKeyBytes[0] != 4) {                      return "Invalid public key' for 65-byte keys the first byte must be 0x04";                  }                } else if (pubKeyBytes.Length == 33) {                  if (pubKeyBytes[0] != 2 && pubKeyBytes[0] != 3) {                      return "Invalid public key' for 3-byte keys the first byte must be 0x02 or 0x03";                  }                  IsCompressedPoint = true;              } else {                  return "Invalid public key' must be 33 or 65 bytes";              }
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: if (hex == null) {                  throw new ArgumentException("Not a valid key");              } else if (hex.Length == 36 && hex[0] == 0x02 && hex[1] == 0x05 && hex[2] <= 0x80) {                  // Apparently valid. Read the compressed point flag.                  if ((hex[3] & 0x01) == 0x01) {                      IsCompressedPoint = true;                  }              } else {                  throw new ArgumentException("Not a valid key");              }
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: if (hex == null) {                  throw new ArgumentException("Not a valid key");              } else if (hex.Length == 36 && hex[0] == 0x02 && hex[1] == 0x05 && hex[2] <= 0x80) {                  // Apparently valid. Read the compressed point flag.                  if ((hex[3] & 0x01) == 0x01) {                      IsCompressedPoint = true;                  }              } else {                  throw new ArgumentException("Not a valid key");              }
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: if (hex == null) {                  throw new ArgumentException("Not a valid key");              } else if (hex.Length == 36 && hex[0] == 0x02 && hex[1] == 0x05 && hex[2] <= 0x80) {                  // Apparently valid. Read the compressed point flag.                  if ((hex[3] & 0x01) == 0x01) {                      IsCompressedPoint = true;                  }              } else {                  throw new ArgumentException("Not a valid key");              }
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: aes.KeySize = 256;
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: byte[] rv = new byte[36];
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: encryptor.TransformBlock(_privKey' 0' 16' rv' 4);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: encryptor.TransformBlock(_privKey' 0' 16' rv' 4);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: encryptor.TransformBlock(_privKey' 0' 16' rv' 4);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: encryptor.TransformBlock(_privKey' 0' 16' rv' 4);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: byte[] interblock = new byte[16];
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: Array.Copy(rv' 4' interblock' 0' 16);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: Array.Copy(rv' 4' interblock' 0' 16);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: for (int x = 0; x < 16; x++) interblock[x] ^= _privKey[16 + x];
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: for (int x = 0; x < 16; x++) interblock[x] ^= _privKey[16 + x];
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: encryptor.TransformBlock(interblock' 0' 16' rv' 20);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: encryptor.TransformBlock(interblock' 0' 16' rv' 20);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: encryptor.TransformBlock(interblock' 0' 16' rv' 20);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: encryptor.TransformBlock(interblock' 0' 16' rv' 20);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: rv[2] = (byte)(checksum[0] & 0x7F);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: rv[3] = (byte)(checksum[1] & 0xFE);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,ShaPassphraseKeyPair,The following statement contains a magic number: if (key.IsCompressedPoint) rv[3]++;
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex[2] != 0x80) {                  if ((checksum[0] & 0x7f) != hex[2] || (checksum[1] & 0x7e) != (hex[3] & 0x7e)) {                      return false;                  }              }
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex[2] != 0x80) {                  if ((checksum[0] & 0x7f) != hex[2] || (checksum[1] & 0x7e) != (hex[3] & 0x7e)) {                      return false;                  }              }
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: if (hex[2] != 0x80) {                  if ((checksum[0] & 0x7f) != hex[2] || (checksum[1] & 0x7e) != (hex[3] & 0x7e)) {                      return false;                  }              }
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: aes.KeySize = 256;
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: byte[] decrypted = new byte[33];
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(hex' 4' 16' decrypted' 1);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(hex' 4' 16' decrypted' 1);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(hex' 4' 16' decrypted' 1);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(hex' 4' 16' decrypted' 1);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(hex' 20' 16' decrypted' 17);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(hex' 20' 16' decrypted' 17);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(hex' 20' 16' decrypted' 17);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(hex' 20' 16' decrypted' 17);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(hex' 20' 16' decrypted' 17);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: decryptor.TransformBlock(hex' 20' 16' decrypted' 17);
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: for (int x = 0; x < 16; x++) decrypted[17 + x] ^= hex[4 + x];
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: for (int x = 0; x < 16; x++) decrypted[17 + x] ^= hex[4 + x];
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: for (int x = 0; x < 16; x++) decrypted[17 + x] ^= hex[4 + x];
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: _privKey = new byte[32];
Magic Number,Casascius.Bitcoin,ShaPassphraseKeyPair,C:\repos\casascius_Bitcoin-Address-Utility\Model\ShaPassphraseKeyPair.cs,DecryptWithPassphrase,The following statement contains a magic number: Array.Copy(decrypted' 1' _privKey' 0' 32);
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,InterpretBatch,The following statement contains a magic number: int biggest_anticipated_string = 100;
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 21:                              // It's an address of some sort.                              return new AddressBase(what);                          case 31:                          case 32:                          case 33:                          case 34:                              // Unencrypted private key                              return new KeyPair(what);                          case 36:                              // these pairs aren't decided by length alone'                              // but the constructors will throw an exception if they                              // don't contain valid key material.                              return new ShaPassphraseKeyPair(what);                                                  case 39:                              return new Bip38KeyPair(what);                          case 49:                              return new Bip38Intermediate(what' Bip38Intermediate.Interpretation.IntermediateCode);                          case 51:                              return new Bip38Confirmation(what);                      }                  } catch {}                  // If a constructor didn't like something' then don't return anything.                              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 21:                              // It's an address of some sort.                              return new AddressBase(what);                          case 31:                          case 32:                          case 33:                          case 34:                              // Unencrypted private key                              return new KeyPair(what);                          case 36:                              // these pairs aren't decided by length alone'                              // but the constructors will throw an exception if they                              // don't contain valid key material.                              return new ShaPassphraseKeyPair(what);                                                  case 39:                              return new Bip38KeyPair(what);                          case 49:                              return new Bip38Intermediate(what' Bip38Intermediate.Interpretation.IntermediateCode);                          case 51:                              return new Bip38Confirmation(what);                      }                  } catch {}                  // If a constructor didn't like something' then don't return anything.                              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 21:                              // It's an address of some sort.                              return new AddressBase(what);                          case 31:                          case 32:                          case 33:                          case 34:                              // Unencrypted private key                              return new KeyPair(what);                          case 36:                              // these pairs aren't decided by length alone'                              // but the constructors will throw an exception if they                              // don't contain valid key material.                              return new ShaPassphraseKeyPair(what);                                                  case 39:                              return new Bip38KeyPair(what);                          case 49:                              return new Bip38Intermediate(what' Bip38Intermediate.Interpretation.IntermediateCode);                          case 51:                              return new Bip38Confirmation(what);                      }                  } catch {}                  // If a constructor didn't like something' then don't return anything.                              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 21:                              // It's an address of some sort.                              return new AddressBase(what);                          case 31:                          case 32:                          case 33:                          case 34:                              // Unencrypted private key                              return new KeyPair(what);                          case 36:                              // these pairs aren't decided by length alone'                              // but the constructors will throw an exception if they                              // don't contain valid key material.                              return new ShaPassphraseKeyPair(what);                                                  case 39:                              return new Bip38KeyPair(what);                          case 49:                              return new Bip38Intermediate(what' Bip38Intermediate.Interpretation.IntermediateCode);                          case 51:                              return new Bip38Confirmation(what);                      }                  } catch {}                  // If a constructor didn't like something' then don't return anything.                              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 21:                              // It's an address of some sort.                              return new AddressBase(what);                          case 31:                          case 32:                          case 33:                          case 34:                              // Unencrypted private key                              return new KeyPair(what);                          case 36:                              // these pairs aren't decided by length alone'                              // but the constructors will throw an exception if they                              // don't contain valid key material.                              return new ShaPassphraseKeyPair(what);                                                  case 39:                              return new Bip38KeyPair(what);                          case 49:                              return new Bip38Intermediate(what' Bip38Intermediate.Interpretation.IntermediateCode);                          case 51:                              return new Bip38Confirmation(what);                      }                  } catch {}                  // If a constructor didn't like something' then don't return anything.                              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 21:                              // It's an address of some sort.                              return new AddressBase(what);                          case 31:                          case 32:                          case 33:                          case 34:                              // Unencrypted private key                              return new KeyPair(what);                          case 36:                              // these pairs aren't decided by length alone'                              // but the constructors will throw an exception if they                              // don't contain valid key material.                              return new ShaPassphraseKeyPair(what);                                                  case 39:                              return new Bip38KeyPair(what);                          case 49:                              return new Bip38Intermediate(what' Bip38Intermediate.Interpretation.IntermediateCode);                          case 51:                              return new Bip38Confirmation(what);                      }                  } catch {}                  // If a constructor didn't like something' then don't return anything.                              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 21:                              // It's an address of some sort.                              return new AddressBase(what);                          case 31:                          case 32:                          case 33:                          case 34:                              // Unencrypted private key                              return new KeyPair(what);                          case 36:                              // these pairs aren't decided by length alone'                              // but the constructors will throw an exception if they                              // don't contain valid key material.                              return new ShaPassphraseKeyPair(what);                                                  case 39:                              return new Bip38KeyPair(what);                          case 49:                              return new Bip38Intermediate(what' Bip38Intermediate.Interpretation.IntermediateCode);                          case 51:                              return new Bip38Confirmation(what);                      }                  } catch {}                  // If a constructor didn't like something' then don't return anything.                              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 21:                              // It's an address of some sort.                              return new AddressBase(what);                          case 31:                          case 32:                          case 33:                          case 34:                              // Unencrypted private key                              return new KeyPair(what);                          case 36:                              // these pairs aren't decided by length alone'                              // but the constructors will throw an exception if they                              // don't contain valid key material.                              return new ShaPassphraseKeyPair(what);                                                  case 39:                              return new Bip38KeyPair(what);                          case 49:                              return new Bip38Intermediate(what' Bip38Intermediate.Interpretation.IntermediateCode);                          case 51:                              return new Bip38Confirmation(what);                      }                  } catch {}                  // If a constructor didn't like something' then don't return anything.                              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 21:                              // It's an address of some sort.                              return new AddressBase(what);                          case 31:                          case 32:                          case 33:                          case 34:                              // Unencrypted private key                              return new KeyPair(what);                          case 36:                              // these pairs aren't decided by length alone'                              // but the constructors will throw an exception if they                              // don't contain valid key material.                              return new ShaPassphraseKeyPair(what);                                                  case 39:                              return new Bip38KeyPair(what);                          case 49:                              return new Bip38Intermediate(what' Bip38Intermediate.Interpretation.IntermediateCode);                          case 51:                              return new Bip38Confirmation(what);                      }                  } catch {}                  // If a constructor didn't like something' then don't return anything.                              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 33:                          case 65:                              return new PublicKey(hex);                          case 20:                              return new AddressBase(hex' addressType);                          case 21: // hash160                              return new AddressBase(hex);                          case 30:                          case 31:                          case 32:                              return new KeyPair(hex' compressed: compressed' addressType: addressType);                      }                  } catch { }              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 33:                          case 65:                              return new PublicKey(hex);                          case 20:                              return new AddressBase(hex' addressType);                          case 21: // hash160                              return new AddressBase(hex);                          case 30:                          case 31:                          case 32:                              return new KeyPair(hex' compressed: compressed' addressType: addressType);                      }                  } catch { }              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 33:                          case 65:                              return new PublicKey(hex);                          case 20:                              return new AddressBase(hex' addressType);                          case 21: // hash160                              return new AddressBase(hex);                          case 30:                          case 31:                          case 32:                              return new KeyPair(hex' compressed: compressed' addressType: addressType);                      }                  } catch { }              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 33:                          case 65:                              return new PublicKey(hex);                          case 20:                              return new AddressBase(hex' addressType);                          case 21: // hash160                              return new AddressBase(hex);                          case 30:                          case 31:                          case 32:                              return new KeyPair(hex' compressed: compressed' addressType: addressType);                      }                  } catch { }              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 33:                          case 65:                              return new PublicKey(hex);                          case 20:                              return new AddressBase(hex' addressType);                          case 21: // hash160                              return new AddressBase(hex);                          case 30:                          case 31:                          case 32:                              return new KeyPair(hex' compressed: compressed' addressType: addressType);                      }                  } catch { }              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 33:                          case 65:                              return new PublicKey(hex);                          case 20:                              return new AddressBase(hex' addressType);                          case 21: // hash160                              return new AddressBase(hex);                          case 30:                          case 31:                          case 32:                              return new KeyPair(hex' compressed: compressed' addressType: addressType);                      }                  } catch { }              }
Magic Number,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following statement contains a magic number: if (hex != null) {                  try {                      switch (hex.Length) {                          case 33:                          case 65:                              return new PublicKey(hex);                          case 20:                              return new AddressBase(hex' addressType);                          case 21: // hash160                              return new AddressBase(hex);                          case 30:                          case 31:                          case 32:                              return new KeyPair(hex' compressed: compressed' addressType: addressType);                      }                  } catch { }              }
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,BytesToUInt32,The following statement contains a magic number: return                  (uint)bytes[offset + 0] << 24 |                  (uint)bytes[offset + 1] << 16 |                  (uint)bytes[offset + 2] << 8 |                  (uint)bytes[offset + 3];
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,BytesToUInt32,The following statement contains a magic number: return                  (uint)bytes[offset + 0] << 24 |                  (uint)bytes[offset + 1] << 16 |                  (uint)bytes[offset + 2] << 8 |                  (uint)bytes[offset + 3];
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,BytesToUInt32,The following statement contains a magic number: return                  (uint)bytes[offset + 0] << 24 |                  (uint)bytes[offset + 1] << 16 |                  (uint)bytes[offset + 2] << 8 |                  (uint)bytes[offset + 3];
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,BytesToUInt32,The following statement contains a magic number: return                  (uint)bytes[offset + 0] << 24 |                  (uint)bytes[offset + 1] << 16 |                  (uint)bytes[offset + 2] << 8 |                  (uint)bytes[offset + 3];
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,BytesToUInt32,The following statement contains a magic number: return                  (uint)bytes[offset + 0] << 24 |                  (uint)bytes[offset + 1] << 16 |                  (uint)bytes[offset + 2] << 8 |                  (uint)bytes[offset + 3];
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,BytesToUInt32LE,The following statement contains a magic number: return                  (uint)bytes[offset + 3] << 24 |                  (uint)bytes[offset + 2] << 16 |                  (uint)bytes[offset + 1] << 8 |                  (uint)bytes[offset + 0];
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,BytesToUInt32LE,The following statement contains a magic number: return                  (uint)bytes[offset + 3] << 24 |                  (uint)bytes[offset + 2] << 16 |                  (uint)bytes[offset + 1] << 8 |                  (uint)bytes[offset + 0];
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,BytesToUInt32LE,The following statement contains a magic number: return                  (uint)bytes[offset + 3] << 24 |                  (uint)bytes[offset + 2] << 16 |                  (uint)bytes[offset + 1] << 8 |                  (uint)bytes[offset + 0];
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,BytesToUInt32LE,The following statement contains a magic number: return                  (uint)bytes[offset + 3] << 24 |                  (uint)bytes[offset + 2] << 16 |                  (uint)bytes[offset + 1] << 8 |                  (uint)bytes[offset + 0];
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,BytesToUInt32LE,The following statement contains a magic number: return                  (uint)bytes[offset + 3] << 24 |                  (uint)bytes[offset + 2] << 16 |                  (uint)bytes[offset + 1] << 8 |                  (uint)bytes[offset + 0];
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,UInt32ToBytes,The following statement contains a magic number: bytes[offset + 0] = (byte)(value >> 24);
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,UInt32ToBytes,The following statement contains a magic number: bytes[offset + 1] = (byte)(value >> 16);
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,UInt32ToBytes,The following statement contains a magic number: bytes[offset + 2] = (byte)(value >> 8);
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,UInt32ToBytes,The following statement contains a magic number: bytes[offset + 2] = (byte)(value >> 8);
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,UInt32ToBytes,The following statement contains a magic number: bytes[offset + 3] = (byte)(value);
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,UInt32ToBytesLE,The following statement contains a magic number: bytes[offset + 3] = (byte)(value >> 24);
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,UInt32ToBytesLE,The following statement contains a magic number: bytes[offset + 3] = (byte)(value >> 24);
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,UInt32ToBytesLE,The following statement contains a magic number: bytes[offset + 2] = (byte)(value >> 16);
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,UInt32ToBytesLE,The following statement contains a magic number: bytes[offset + 2] = (byte)(value >> 16);
Magic Number,CryptSharp.Utility,Helper,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Helper.cs,UInt32ToBytesLE,The following statement contains a magic number: bytes[offset + 1] = (byte)(value >> 8);
Magic Number,CryptSharp.Utility,Pbkdf2,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Pbkdf2.cs,Reopen,The following statement contains a magic number: Helper.CheckRange("salt"' salt' 0' int.MaxValue - 4);
Magic Number,CryptSharp.Utility,Pbkdf2,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Pbkdf2.cs,Reopen,The following statement contains a magic number: _saltBuf = new byte[salt.Length + 4];
Magic Number,CryptSharp.Utility,Pbkdf2,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Pbkdf2.cs,ComputeBlock,The following statement contains a magic number: Helper.UInt32ToBytes(pos' _saltBuf' _saltBuf.Length - 4);
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,R,The following statement contains a magic number: return (a << b) | (a >> (32 - b));
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: if (rounds < 1 || rounds > 20 || (rounds & 1) == 1) { throw new ArgumentOutOfRangeException("rounds"); }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,Salsa20Core,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\Salsa20Core.cs,Compute,The following statement contains a magic number: try {                  int i;                  uint x0 = input[0 + inputOffset];                  uint x1 = input[1 + inputOffset];                  uint x2 = input[2 + inputOffset];                  uint x3 = input[3 + inputOffset];                  uint x4 = input[4 + inputOffset];                  uint x5 = input[5 + inputOffset];                  uint x6 = input[6 + inputOffset];                  uint x7 = input[7 + inputOffset];                  uint x8 = input[8 + inputOffset];                  uint x9 = input[9 + inputOffset];                  uint x10 = input[10 + inputOffset];                  uint x11 = input[11 + inputOffset];                  uint x12 = input[12 + inputOffset];                  uint x13 = input[13 + inputOffset];                  uint x14 = input[14 + inputOffset];                  uint x15 = input[15 + inputOffset];                    for (i = rounds; i > 0; i -= 2) {                      //x4 ^= R(x0 + x12' 7); x8 ^= R(x4 + x0' 9);                      x4 ^= (x0 + x12 << 7) | (x0 + x12 >> (32 - 7));                      x8 ^= (x4 + x0 << 9) | (x4 + x0 >> (32 - 9));                        //x12 ^= R(x8 + x4' 13); x0 ^= R(x12 + x8' 18);                      x12 ^= (x8 + x4 << 13) | (x8 + x4 >> (32 - 13));                      x0 ^= (x12 + x8 << 18) | (x12 + x8 >> (32 - 18));                        //x9 ^= R(x5 + x1' 7); x13 ^= R(x9 + x5' 9);                      x9 ^= (x5 + x1 << 7) | (x5 + x1 >> (32 - 7));                      x13 ^= (x9 + x5 << 9) | (x9 + x5 >> (32 - 9));                        //x1 ^= R(x13 + x9' 13); x5 ^= R(x1 + x13' 18);                      x1 ^= (x13 + x9 << 13) | (x13 + x9 >> (32 - 13));                      x5 ^= (x1 + x13 << 18) | (x1 + x13 >> (32 - 18));                        //x14 ^= R(x10 + x6' 7); x2 ^= R(x14 + x10' 9);                      x14 ^= (x10 + x6 << 7) | (x10 + x6 >> (32 - 7));                      x2 ^= (x14 + x10 << 9) | (x14 + x10 >> (32 - 9));                        //x6 ^= R(x2 + x14' 13); x10 ^= R(x6 + x2' 18);                      x6 ^= (x2 + x14 << 13) | (x2 + x14 >> (32 - 13));                      x10 ^= (x6 + x2 << 18) | (x6 + x2 >> (32 - 18));                        //x3 ^= R(x15 + x11' 7); x7 ^= R(x3 + x15' 9);                      x3 ^= (x15 + x11 << 7) | (x15 + x11 >> (32 - 7));                      x7 ^= (x3 + x15 << 9) | (x3 + x15 >> (32 - 9));                        //x11 ^= R(x7 + x3' 13); x15 ^= R(x11 + x7' 18);                      x11 ^= (x7 + x3 << 13) | (x7 + x3 >> (32 - 13));                      x15 ^= (x11 + x7 << 18) | (x11 + x7 >> (32 - 18));                        //x1 ^= R(x0 + x3' 7); x2 ^= R(x1 + x0' 9);                      x1 ^= (x0 + x3 << 7) | (x0 + x3 >> (32 - 7));                      x2 ^= (x1 + x0 << 9) | (x1 + x0 >> (32 - 9));                        //x3 ^= R(x2 + x1' 13); x0 ^= R(x3 + x2' 18);                      x3 ^= (x2 + x1 << 13) | (x2 + x1 >> (32 - 13));                      x0 ^= (x3 + x2 << 18) | (x3 + x2 >> (32 - 18));                        //x6 ^= R(x5 + x4' 7); x7 ^= R(x6 + x5' 9);                      x6 ^= (x5 + x4 << 7) | (x5 + x4 >> (32 - 7));                      x7 ^= (x6 + x5 << 9) | (x6 + x5 >> (32 - 9));                        //x4 ^= R(x7 + x6' 13); x5 ^= R(x4 + x7' 18);                      x4 ^= (x7 + x6 << 13) | (x7 + x6 >> (32 - 13));                      x5 ^= (x4 + x7 << 18) | (x4 + x7 >> (32 - 18));                        //x11 ^= R(x10 + x9' 7); x8 ^= R(x11 + x10' 9);                      x11 ^= (x10 + x9 << 7) | (x10 + x9 >> (32 - 7));                      x8 ^= (x11 + x10 << 9) | (x11 + x10 >> (32 - 9));                        //x9 ^= R(x8 + x11' 13); x10 ^= R(x9 + x8' 18);                      x9 ^= (x8 + x11 << 13) | (x8 + x11 >> (32 - 13));                      x10 ^= (x9 + x8 << 18) | (x9 + x8 >> (32 - 18));                        //x12 ^= R(x15 + x14' 7); x13 ^= R(x12 + x15' 9);                      x12 ^= (x15 + x14 << 7) | (x15 + x14 >> (32 - 7));                      x13 ^= (x12 + x15 << 9) | (x12 + x15 >> (32 - 9));                        //x14 ^= R(x13 + x12' 13); x15 ^= R(x14 + x13' 18);                      x14 ^= (x13 + x12 << 13) | (x13 + x12 >> (32 - 13));                      x15 ^= (x14 + x13 << 18) | (x14 + x13 >> (32 - 18));                    }                  output[0 + outputOffset] = x0 + input[0 + inputOffset];                  output[1 + outputOffset] = x1 + input[1 + inputOffset];                  output[2 + outputOffset] = x2 + input[2 + inputOffset];                  output[3 + outputOffset] = x3 + input[3 + inputOffset];                  output[4 + outputOffset] = x4 + input[4 + inputOffset];                  output[5 + outputOffset] = x5 + input[5 + inputOffset];                  output[6 + outputOffset] = x6 + input[6 + inputOffset];                  output[7 + outputOffset] = x7 + input[7 + inputOffset];                  output[8 + outputOffset] = x8 + input[8 + inputOffset];                  output[9 + outputOffset] = x9 + input[9 + inputOffset];                  output[10 + outputOffset] = x10 + input[10 + inputOffset];                  output[11 + outputOffset] = x11 + input[11 + inputOffset];                  output[12 + outputOffset] = x12 + input[12 + inputOffset];                  output[13 + outputOffset] = x13 + input[13 + inputOffset];                  output[14 + outputOffset] = x14 + input[14 + inputOffset];                  output[15 + outputOffset] = x15 + input[15 + inputOffset];                } catch {                  Helper.CheckNull("input"' input); Helper.CheckBounds("input"' input' inputOffset' 16);                  Helper.CheckNull("output"' output); Helper.CheckBounds("output"' output' outputOffset' 16);                  Helper.CheckNull("x"' x); Helper.CheckBounds("x"' x' 0' 16);                  throw;              }
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,MFcrypt,The following statement contains a magic number: int MFLen = blockSize * 128;
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,MFcrypt,The following statement contains a magic number: Helper.CheckRange("blockSize"' blockSize' 1' int.MaxValue / 32);
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,MFcrypt,The following statement contains a magic number: uint[] B0 = new uint[B.Length / 4];
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,MFcrypt,The following statement contains a magic number: for (int i = 0; i < B0.Length; i++) { B0[i] = Helper.BytesToUInt32LE(B' i * 4); }
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,MFcrypt,The following statement contains a magic number: for (int i = 0; i < B0.Length; i++) { Helper.UInt32ToBytesLE(B0[i]' B' i * 4); }
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,ThreadSMixCalls,The following statement contains a magic number: ThreadStart workerThread = delegate() {                  while (true) {                      int j = Interlocked.Increment(ref current) - 1;                      if (j >= parallel) { break; }                        SMix(B0' j * MFLen / 4' B0' j * MFLen / 4' (uint)cost' blockSize);                  }              };
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,ThreadSMixCalls,The following statement contains a magic number: ThreadStart workerThread = delegate() {                  while (true) {                      int j = Interlocked.Increment(ref current) - 1;                      if (j >= parallel) { break; }                        SMix(B0' j * MFLen / 4' B0' j * MFLen / 4' (uint)cost' blockSize);                  }              };
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,ThreadSMixCalls,The following statement contains a magic number: for (int i = 0; i < threads.Length; i++) { (threads[i] = new Thread(workerThread' 8192)).Start(); }
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,SMix,The following statement contains a magic number: int Bs = 16 * 2 * r;
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,SMix,The following statement contains a magic number: int Bs = 16 * 2 * r;
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,SMix,The following statement contains a magic number: uint[] scratch1 = new uint[16]' scratch2 = new uint[16];
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,SMix,The following statement contains a magic number: uint[] scratch1 = new uint[16]' scratch2 = new uint[16];
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,SMix,The following statement contains a magic number: uint[] scratchX = new uint[16]' scratchY = new uint[Bs];
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,SMix,The following statement contains a magic number: for (uint i = 0; i < N; i++) {                  uint j = x[Bs - 16] & Nmask; uint[] vj = v[j];                  for (int k = 0; k < scratchZ.Length; k++) { scratchZ[k] = x[k] ^ vj[k]; }                  BlockMix(scratchZ' 0' x' 0' scratchX' scratchY' scratch1' scratch2' r);              }
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The following statement contains a magic number: int k = Boffset' m = 0' n = 16 * r;
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The following statement contains a magic number: Array.Copy(B' (2 * r - 1) * 16' x' 0' 16);
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The following statement contains a magic number: Array.Copy(B' (2 * r - 1) * 16' x' 0' 16);
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The following statement contains a magic number: Array.Copy(B' (2 * r - 1) * 16' x' 0' 16);
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The following statement contains a magic number: for (int i = 0; i < r; i++) {                  for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m' 16);                  k += 16;                    for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m + n' 16);                  k += 16;                    m += 16;              }
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The following statement contains a magic number: for (int i = 0; i < r; i++) {                  for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m' 16);                  k += 16;                    for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m + n' 16);                  k += 16;                    m += 16;              }
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The following statement contains a magic number: for (int i = 0; i < r; i++) {                  for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m' 16);                  k += 16;                    for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m + n' 16);                  k += 16;                    m += 16;              }
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The following statement contains a magic number: for (int i = 0; i < r; i++) {                  for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m' 16);                  k += 16;                    for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m + n' 16);                  k += 16;                    m += 16;              }
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The following statement contains a magic number: for (int i = 0; i < r; i++) {                  for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m' 16);                  k += 16;                    for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m + n' 16);                  k += 16;                    m += 16;              }
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The following statement contains a magic number: for (int i = 0; i < r; i++) {                  for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m' 16);                  k += 16;                    for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m + n' 16);                  k += 16;                    m += 16;              }
Magic Number,CryptSharp.Utility,SCrypt,C:\repos\casascius_Bitcoin-Address-Utility\CryptSharp\SCrypt.cs,BlockMix,The following statement contains a magic number: for (int i = 0; i < r; i++) {                  for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m' 16);                  k += 16;                    for (int j = 0; j < scratch1.Length; j++) { scratch1[j] = x[j] ^ B[j + k]; }                  Salsa20Core.Compute(8' scratch1' 0' x' 0' scratch2);                  Array.Copy(x' 0' y' m + n' 16);                  k += 16;                    m += 16;              }
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,btnGenerateAddresses_Click,The following statement contains a magic number: timer1.Interval = 250;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoDeterministicWallet.Location = new System.Drawing.Point(14' 84);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoDeterministicWallet.Location = new System.Drawing.Point(14' 84);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoDeterministicWallet.Size = new System.Drawing.Size(114' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoDeterministicWallet.Size = new System.Drawing.Size(114' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoDeterministicWallet.TabIndex = 5;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.txtTextInput.Location = new System.Drawing.Point(8' 148);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.txtTextInput.Location = new System.Drawing.Point(8' 148);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.txtTextInput.Size = new System.Drawing.Size(365' 20);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.txtTextInput.Size = new System.Drawing.Size(365' 20);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoRandomWallet.Location = new System.Drawing.Point(14' 33);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoRandomWallet.Location = new System.Drawing.Point(14' 33);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoRandomWallet.Size = new System.Drawing.Size(102' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoRandomWallet.Size = new System.Drawing.Size(102' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoRandomWallet.TabIndex = 4;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(10' 18);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(10' 18);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(164' 13);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(164' 13);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 3;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Location = new System.Drawing.Point(51' 34);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Location = new System.Drawing.Point(51' 34);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Maximum = new decimal(new int[] {              99999'              0'              0'              0});
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Size = new System.Drawing.Size(90' 20);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Size = new System.Drawing.Size(90' 20);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.TabIndex = 2;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.numGenCount.Value = new decimal(new int[] {              8'              0'              0'              0});
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoMiniKeys.Location = new System.Drawing.Point(14' 16);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoMiniKeys.Location = new System.Drawing.Point(14' 16);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoMiniKeys.Size = new System.Drawing.Size(62' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoMiniKeys.Size = new System.Drawing.Size(62' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoMiniKeys.TabIndex = 5;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateAddresses.Location = new System.Drawing.Point(109' 182);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateAddresses.Location = new System.Drawing.Point(109' 182);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateAddresses.Size = new System.Drawing.Size(173' 36);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateAddresses.Size = new System.Drawing.Size(173' 36);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateAddresses.TabIndex = 6;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.lblTextInput.Location = new System.Drawing.Point(6' 132);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.lblTextInput.Location = new System.Drawing.Point(6' 132);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.lblTextInput.Size = new System.Drawing.Size(161' 13);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.lblTextInput.Size = new System.Drawing.Size(161' 13);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.lblTextInput.TabIndex = 10;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(194' 18);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Location = new System.Drawing.Point(194' 18);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(179' 111);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.Size = new System.Drawing.Size(179' 111);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.groupBox1.TabIndex = 12;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoEncrypted.Location = new System.Drawing.Point(14' 50);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoEncrypted.Location = new System.Drawing.Point(14' 50);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoEncrypted.Size = new System.Drawing.Size(131' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoEncrypted.Size = new System.Drawing.Size(131' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoEncrypted.TabIndex = 6;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Location = new System.Drawing.Point(0' 232);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(384' 22);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(384' 22);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.TabIndex = 13;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Size = new System.Drawing.Size(0' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.toolStripProgressBar1.Size = new System.Drawing.Size(100' 16);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.toolStripProgressBar1.Size = new System.Drawing.Size(100' 16);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.chkRetainPrivKey.Location = new System.Drawing.Point(8' 102);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.chkRetainPrivKey.Location = new System.Drawing.Point(8' 102);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.chkRetainPrivKey.Size = new System.Drawing.Size(174' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.chkRetainPrivKey.Size = new System.Drawing.Size(174' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.chkRetainPrivKey.TabIndex = 14;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoTwoFactor.Location = new System.Drawing.Point(14' 67);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoTwoFactor.Location = new System.Drawing.Point(14' 67);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoTwoFactor.Size = new System.Drawing.Size(130' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoTwoFactor.Size = new System.Drawing.Size(130' 17);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.rdoTwoFactor.TabIndex = 7;
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(384' 254);
Magic Number,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(384' 254);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,btnGoMulti_Click,The following statement contains a magic number: if (this.Height < 500) this.Height = 500;
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,btnGoMulti_Click,The following statement contains a magic number: if (this.Height < 500) this.Height = 500;
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.lblEnterWhat.Location = new System.Drawing.Point(12' 13);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.lblEnterWhat.Location = new System.Drawing.Point(12' 13);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.lblEnterWhat.Size = new System.Drawing.Size(177' 13);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.lblEnterWhat.Size = new System.Drawing.Size(177' 13);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(15' 29);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Location = new System.Drawing.Point(15' 29);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(499' 20);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.textBox1.Size = new System.Drawing.Size(499' 20);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Location = new System.Drawing.Point(356' 55);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Location = new System.Drawing.Point(356' 55);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Size = new System.Drawing.Size(75' 23);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.Size = new System.Drawing.Size(75' 23);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnOK.TabIndex = 2;
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(439' 55);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(439' 55);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 3;
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnGoMulti.Location = new System.Drawing.Point(15' 55);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnGoMulti.Location = new System.Drawing.Point(15' 55);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnGoMulti.Size = new System.Drawing.Size(144' 23);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnGoMulti.Size = new System.Drawing.Size(144' 23);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.btnGoMulti.TabIndex = 4;
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(529' 87);
Magic Number,BtcAddress.Forms,AddSingleAddress,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddSingleAddress.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(529' 87);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: if (confbytes.Length != 51 || confbytes[0] != 0x64 || confbytes[1] != 0x3B || confbytes[2] != 0xF6 ||                  confbytes[3] != 0xA8 || confbytes[4] != 0x9A || confbytes[18] < 0x02 || confbytes[18] > 0x03) {                    // Unrecognized Base58 object.  Do we know what this is?  Tell the user.                  object result = StringInterpreter.Interpret(txtConfCode.Text.Trim());                  if (result != null) {                        // did we actually get an encrypted private key?  if so' just try to decrypt it.                      if (result is PassphraseKeyPair) {                          PassphraseKeyPair ppkp = result as PassphraseKeyPair;                          if (ppkp.DecryptWithPassphrase(txtPassphrase.Text)) {                              confirmIsValid(ppkp.GetAddress().AddressBase58);                              MessageBox.Show("What you provided contains a private key' not just a confirmation. " +                                  "Confirmation is successful' and with this correct passphrase' " +                                  "you are also able to spend the funds from the address."' "This is actually a private key"'                                  MessageBoxButtons.OK' MessageBoxIcon.Information);                              return;                          } else {                              MessageBox.Show("This is not a valid confirmation code.  It looks like an " +                                  "encrypted private key.  Decryption was attempted but the passphrase couldn't decrypt it"' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                              return;                          }                      }                        string objectKind = result.GetType().Name;                      if (objectKind == "AddressBase") {                          objectKind = "an Address";                      } else {                          objectKind = "a " + objectKind;                      }                        MessageBox.Show("This is not a valid confirmation code.  Instead' it looks like " + objectKind +                        ".  Perhaps you entered the wrong thing?  Confirmation codes " +                      "start with \"cfrm\"."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                      return;                  }                    MessageBox.Show("This is not a valid confirmation code."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                  return;                                }
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: if (confbytes.Length != 51 || confbytes[0] != 0x64 || confbytes[1] != 0x3B || confbytes[2] != 0xF6 ||                  confbytes[3] != 0xA8 || confbytes[4] != 0x9A || confbytes[18] < 0x02 || confbytes[18] > 0x03) {                    // Unrecognized Base58 object.  Do we know what this is?  Tell the user.                  object result = StringInterpreter.Interpret(txtConfCode.Text.Trim());                  if (result != null) {                        // did we actually get an encrypted private key?  if so' just try to decrypt it.                      if (result is PassphraseKeyPair) {                          PassphraseKeyPair ppkp = result as PassphraseKeyPair;                          if (ppkp.DecryptWithPassphrase(txtPassphrase.Text)) {                              confirmIsValid(ppkp.GetAddress().AddressBase58);                              MessageBox.Show("What you provided contains a private key' not just a confirmation. " +                                  "Confirmation is successful' and with this correct passphrase' " +                                  "you are also able to spend the funds from the address."' "This is actually a private key"'                                  MessageBoxButtons.OK' MessageBoxIcon.Information);                              return;                          } else {                              MessageBox.Show("This is not a valid confirmation code.  It looks like an " +                                  "encrypted private key.  Decryption was attempted but the passphrase couldn't decrypt it"' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                              return;                          }                      }                        string objectKind = result.GetType().Name;                      if (objectKind == "AddressBase") {                          objectKind = "an Address";                      } else {                          objectKind = "a " + objectKind;                      }                        MessageBox.Show("This is not a valid confirmation code.  Instead' it looks like " + objectKind +                        ".  Perhaps you entered the wrong thing?  Confirmation codes " +                      "start with \"cfrm\"."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                      return;                  }                    MessageBox.Show("This is not a valid confirmation code."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                  return;                                }
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: if (confbytes.Length != 51 || confbytes[0] != 0x64 || confbytes[1] != 0x3B || confbytes[2] != 0xF6 ||                  confbytes[3] != 0xA8 || confbytes[4] != 0x9A || confbytes[18] < 0x02 || confbytes[18] > 0x03) {                    // Unrecognized Base58 object.  Do we know what this is?  Tell the user.                  object result = StringInterpreter.Interpret(txtConfCode.Text.Trim());                  if (result != null) {                        // did we actually get an encrypted private key?  if so' just try to decrypt it.                      if (result is PassphraseKeyPair) {                          PassphraseKeyPair ppkp = result as PassphraseKeyPair;                          if (ppkp.DecryptWithPassphrase(txtPassphrase.Text)) {                              confirmIsValid(ppkp.GetAddress().AddressBase58);                              MessageBox.Show("What you provided contains a private key' not just a confirmation. " +                                  "Confirmation is successful' and with this correct passphrase' " +                                  "you are also able to spend the funds from the address."' "This is actually a private key"'                                  MessageBoxButtons.OK' MessageBoxIcon.Information);                              return;                          } else {                              MessageBox.Show("This is not a valid confirmation code.  It looks like an " +                                  "encrypted private key.  Decryption was attempted but the passphrase couldn't decrypt it"' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                              return;                          }                      }                        string objectKind = result.GetType().Name;                      if (objectKind == "AddressBase") {                          objectKind = "an Address";                      } else {                          objectKind = "a " + objectKind;                      }                        MessageBox.Show("This is not a valid confirmation code.  Instead' it looks like " + objectKind +                        ".  Perhaps you entered the wrong thing?  Confirmation codes " +                      "start with \"cfrm\"."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                      return;                  }                    MessageBox.Show("This is not a valid confirmation code."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                  return;                                }
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: if (confbytes.Length != 51 || confbytes[0] != 0x64 || confbytes[1] != 0x3B || confbytes[2] != 0xF6 ||                  confbytes[3] != 0xA8 || confbytes[4] != 0x9A || confbytes[18] < 0x02 || confbytes[18] > 0x03) {                    // Unrecognized Base58 object.  Do we know what this is?  Tell the user.                  object result = StringInterpreter.Interpret(txtConfCode.Text.Trim());                  if (result != null) {                        // did we actually get an encrypted private key?  if so' just try to decrypt it.                      if (result is PassphraseKeyPair) {                          PassphraseKeyPair ppkp = result as PassphraseKeyPair;                          if (ppkp.DecryptWithPassphrase(txtPassphrase.Text)) {                              confirmIsValid(ppkp.GetAddress().AddressBase58);                              MessageBox.Show("What you provided contains a private key' not just a confirmation. " +                                  "Confirmation is successful' and with this correct passphrase' " +                                  "you are also able to spend the funds from the address."' "This is actually a private key"'                                  MessageBoxButtons.OK' MessageBoxIcon.Information);                              return;                          } else {                              MessageBox.Show("This is not a valid confirmation code.  It looks like an " +                                  "encrypted private key.  Decryption was attempted but the passphrase couldn't decrypt it"' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                              return;                          }                      }                        string objectKind = result.GetType().Name;                      if (objectKind == "AddressBase") {                          objectKind = "an Address";                      } else {                          objectKind = "a " + objectKind;                      }                        MessageBox.Show("This is not a valid confirmation code.  Instead' it looks like " + objectKind +                        ".  Perhaps you entered the wrong thing?  Confirmation codes " +                      "start with \"cfrm\"."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                      return;                  }                    MessageBox.Show("This is not a valid confirmation code."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                  return;                                }
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: if (confbytes.Length != 51 || confbytes[0] != 0x64 || confbytes[1] != 0x3B || confbytes[2] != 0xF6 ||                  confbytes[3] != 0xA8 || confbytes[4] != 0x9A || confbytes[18] < 0x02 || confbytes[18] > 0x03) {                    // Unrecognized Base58 object.  Do we know what this is?  Tell the user.                  object result = StringInterpreter.Interpret(txtConfCode.Text.Trim());                  if (result != null) {                        // did we actually get an encrypted private key?  if so' just try to decrypt it.                      if (result is PassphraseKeyPair) {                          PassphraseKeyPair ppkp = result as PassphraseKeyPair;                          if (ppkp.DecryptWithPassphrase(txtPassphrase.Text)) {                              confirmIsValid(ppkp.GetAddress().AddressBase58);                              MessageBox.Show("What you provided contains a private key' not just a confirmation. " +                                  "Confirmation is successful' and with this correct passphrase' " +                                  "you are also able to spend the funds from the address."' "This is actually a private key"'                                  MessageBoxButtons.OK' MessageBoxIcon.Information);                              return;                          } else {                              MessageBox.Show("This is not a valid confirmation code.  It looks like an " +                                  "encrypted private key.  Decryption was attempted but the passphrase couldn't decrypt it"' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                              return;                          }                      }                        string objectKind = result.GetType().Name;                      if (objectKind == "AddressBase") {                          objectKind = "an Address";                      } else {                          objectKind = "a " + objectKind;                      }                        MessageBox.Show("This is not a valid confirmation code.  Instead' it looks like " + objectKind +                        ".  Perhaps you entered the wrong thing?  Confirmation codes " +                      "start with \"cfrm\"."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                      return;                  }                    MessageBox.Show("This is not a valid confirmation code."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                  return;                                }
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: if (confbytes.Length != 51 || confbytes[0] != 0x64 || confbytes[1] != 0x3B || confbytes[2] != 0xF6 ||                  confbytes[3] != 0xA8 || confbytes[4] != 0x9A || confbytes[18] < 0x02 || confbytes[18] > 0x03) {                    // Unrecognized Base58 object.  Do we know what this is?  Tell the user.                  object result = StringInterpreter.Interpret(txtConfCode.Text.Trim());                  if (result != null) {                        // did we actually get an encrypted private key?  if so' just try to decrypt it.                      if (result is PassphraseKeyPair) {                          PassphraseKeyPair ppkp = result as PassphraseKeyPair;                          if (ppkp.DecryptWithPassphrase(txtPassphrase.Text)) {                              confirmIsValid(ppkp.GetAddress().AddressBase58);                              MessageBox.Show("What you provided contains a private key' not just a confirmation. " +                                  "Confirmation is successful' and with this correct passphrase' " +                                  "you are also able to spend the funds from the address."' "This is actually a private key"'                                  MessageBoxButtons.OK' MessageBoxIcon.Information);                              return;                          } else {                              MessageBox.Show("This is not a valid confirmation code.  It looks like an " +                                  "encrypted private key.  Decryption was attempted but the passphrase couldn't decrypt it"' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                              return;                          }                      }                        string objectKind = result.GetType().Name;                      if (objectKind == "AddressBase") {                          objectKind = "an Address";                      } else {                          objectKind = "a " + objectKind;                      }                        MessageBox.Show("This is not a valid confirmation code.  Instead' it looks like " + objectKind +                        ".  Perhaps you entered the wrong thing?  Confirmation codes " +                      "start with \"cfrm\"."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                      return;                  }                    MessageBox.Show("This is not a valid confirmation code."' "Invalid confirmation code"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                  return;                                }
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: byte[] ownersalt = new byte[8];
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: Array.Copy(confbytes' 10' ownersalt' 0' 8);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: Array.Copy(confbytes' 10' ownersalt' 0' 8);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: bool includeHashStep = (confbytes[5] & 0x04) == 0x04;
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: byte[] addresshashplusownersalt = new byte[12];
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: Array.Copy(confbytes' 6' addresshashplusownersalt' 0' 4);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: Array.Copy(confbytes' 6' addresshashplusownersalt' 0' 4);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: Array.Copy(intermediate.ownerentropy' 0' addresshashplusownersalt' 4' 8);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: Array.Copy(intermediate.ownerentropy' 0' addresshashplusownersalt' 4' 8);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: byte[] derived = new byte[64];
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: SCrypt.ComputeKey(intermediate.passpoint' addresshashplusownersalt' 1024' 1' 1' 1' derived);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: byte[] derivedhalf2 = new byte[32];
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: Array.Copy(derived' 32' derivedhalf2' 0' 32);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: Array.Copy(derived' 32' derivedhalf2' 0' 32);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: byte[] unencryptedpubkey = new byte[33];
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: unencryptedpubkey[0] = (byte)(confbytes[18] ^ (derived[63] & 0x01));
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: unencryptedpubkey[0] = (byte)(confbytes[18] ^ (derived[63] & 0x01));
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: aes.KeySize = 256;
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19' 16' unencryptedpubkey' 1);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19' 16' unencryptedpubkey' 1);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19' 16' unencryptedpubkey' 1);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19' 16' unencryptedpubkey' 1);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19 + 16' 16' unencryptedpubkey' 17);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19 + 16' 16' unencryptedpubkey' 17);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19 + 16' 16' unencryptedpubkey' 17);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19 + 16' 16' unencryptedpubkey' 17);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19 + 16' 16' unencryptedpubkey' 17);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19 + 16' 16' unencryptedpubkey' 17);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19 + 16' 16' unencryptedpubkey' 17);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: decryptor.TransformBlock(confbytes' 19 + 16' 16' unencryptedpubkey' 17);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: for (int i = 0; i < 32; i++) unencryptedpubkey[i + 1] ^= derived[i];
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: try {                  point = ps.Curve.DecodePoint(unencryptedpubkey);                    // multiply passfactor.  Result is going to be compressed.                  ECPoint pubpoint = point.Multiply(new BigInteger(1' intermediate.passfactor));                    // Do we want it uncompressed?  then we will have to uncompress it.                  byte flagbyte = confbytes[5];                  if ((flagbyte & 0x20) == 0x00) {                      pubpoint = ps.Curve.CreatePoint(pubpoint.X.ToBigInteger()' pubpoint.Y.ToBigInteger()' false);                  }                    // Convert to bitcoin address and check address hash.                  PublicKey generatedaddress = new PublicKey(pubpoint);                    // get addresshash                  UTF8Encoding utf8 = new UTF8Encoding(false);                  Sha256Digest sha256 = new Sha256Digest();                  byte[] generatedaddressbytes = utf8.GetBytes(generatedaddress.AddressBase58);                  sha256.BlockUpdate(generatedaddressbytes' 0' generatedaddressbytes.Length);                  byte[] addresshashfull = new byte[32];                  sha256.DoFinal(addresshashfull' 0);                  sha256.BlockUpdate(addresshashfull' 0' 32);                  sha256.DoFinal(addresshashfull' 0);                    for (int i = 0; i < 4; i++) {                      if (addresshashfull[i] != confbytes[i + 6]) {                          MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                          return;                      }                  }                    confirmIsValid(generatedaddress.AddressBase58);              } catch {                  // Might throw an exception - not every 256-bit integer is a valid X coordinate                  MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                  return;              }
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: try {                  point = ps.Curve.DecodePoint(unencryptedpubkey);                    // multiply passfactor.  Result is going to be compressed.                  ECPoint pubpoint = point.Multiply(new BigInteger(1' intermediate.passfactor));                    // Do we want it uncompressed?  then we will have to uncompress it.                  byte flagbyte = confbytes[5];                  if ((flagbyte & 0x20) == 0x00) {                      pubpoint = ps.Curve.CreatePoint(pubpoint.X.ToBigInteger()' pubpoint.Y.ToBigInteger()' false);                  }                    // Convert to bitcoin address and check address hash.                  PublicKey generatedaddress = new PublicKey(pubpoint);                    // get addresshash                  UTF8Encoding utf8 = new UTF8Encoding(false);                  Sha256Digest sha256 = new Sha256Digest();                  byte[] generatedaddressbytes = utf8.GetBytes(generatedaddress.AddressBase58);                  sha256.BlockUpdate(generatedaddressbytes' 0' generatedaddressbytes.Length);                  byte[] addresshashfull = new byte[32];                  sha256.DoFinal(addresshashfull' 0);                  sha256.BlockUpdate(addresshashfull' 0' 32);                  sha256.DoFinal(addresshashfull' 0);                    for (int i = 0; i < 4; i++) {                      if (addresshashfull[i] != confbytes[i + 6]) {                          MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                          return;                      }                  }                    confirmIsValid(generatedaddress.AddressBase58);              } catch {                  // Might throw an exception - not every 256-bit integer is a valid X coordinate                  MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                  return;              }
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: try {                  point = ps.Curve.DecodePoint(unencryptedpubkey);                    // multiply passfactor.  Result is going to be compressed.                  ECPoint pubpoint = point.Multiply(new BigInteger(1' intermediate.passfactor));                    // Do we want it uncompressed?  then we will have to uncompress it.                  byte flagbyte = confbytes[5];                  if ((flagbyte & 0x20) == 0x00) {                      pubpoint = ps.Curve.CreatePoint(pubpoint.X.ToBigInteger()' pubpoint.Y.ToBigInteger()' false);                  }                    // Convert to bitcoin address and check address hash.                  PublicKey generatedaddress = new PublicKey(pubpoint);                    // get addresshash                  UTF8Encoding utf8 = new UTF8Encoding(false);                  Sha256Digest sha256 = new Sha256Digest();                  byte[] generatedaddressbytes = utf8.GetBytes(generatedaddress.AddressBase58);                  sha256.BlockUpdate(generatedaddressbytes' 0' generatedaddressbytes.Length);                  byte[] addresshashfull = new byte[32];                  sha256.DoFinal(addresshashfull' 0);                  sha256.BlockUpdate(addresshashfull' 0' 32);                  sha256.DoFinal(addresshashfull' 0);                    for (int i = 0; i < 4; i++) {                      if (addresshashfull[i] != confbytes[i + 6]) {                          MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                          return;                      }                  }                    confirmIsValid(generatedaddress.AddressBase58);              } catch {                  // Might throw an exception - not every 256-bit integer is a valid X coordinate                  MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                  return;              }
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: try {                  point = ps.Curve.DecodePoint(unencryptedpubkey);                    // multiply passfactor.  Result is going to be compressed.                  ECPoint pubpoint = point.Multiply(new BigInteger(1' intermediate.passfactor));                    // Do we want it uncompressed?  then we will have to uncompress it.                  byte flagbyte = confbytes[5];                  if ((flagbyte & 0x20) == 0x00) {                      pubpoint = ps.Curve.CreatePoint(pubpoint.X.ToBigInteger()' pubpoint.Y.ToBigInteger()' false);                  }                    // Convert to bitcoin address and check address hash.                  PublicKey generatedaddress = new PublicKey(pubpoint);                    // get addresshash                  UTF8Encoding utf8 = new UTF8Encoding(false);                  Sha256Digest sha256 = new Sha256Digest();                  byte[] generatedaddressbytes = utf8.GetBytes(generatedaddress.AddressBase58);                  sha256.BlockUpdate(generatedaddressbytes' 0' generatedaddressbytes.Length);                  byte[] addresshashfull = new byte[32];                  sha256.DoFinal(addresshashfull' 0);                  sha256.BlockUpdate(addresshashfull' 0' 32);                  sha256.DoFinal(addresshashfull' 0);                    for (int i = 0; i < 4; i++) {                      if (addresshashfull[i] != confbytes[i + 6]) {                          MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                          return;                      }                  }                    confirmIsValid(generatedaddress.AddressBase58);              } catch {                  // Might throw an exception - not every 256-bit integer is a valid X coordinate                  MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                  return;              }
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,btnConfirm_Click,The following statement contains a magic number: try {                  point = ps.Curve.DecodePoint(unencryptedpubkey);                    // multiply passfactor.  Result is going to be compressed.                  ECPoint pubpoint = point.Multiply(new BigInteger(1' intermediate.passfactor));                    // Do we want it uncompressed?  then we will have to uncompress it.                  byte flagbyte = confbytes[5];                  if ((flagbyte & 0x20) == 0x00) {                      pubpoint = ps.Curve.CreatePoint(pubpoint.X.ToBigInteger()' pubpoint.Y.ToBigInteger()' false);                  }                    // Convert to bitcoin address and check address hash.                  PublicKey generatedaddress = new PublicKey(pubpoint);                    // get addresshash                  UTF8Encoding utf8 = new UTF8Encoding(false);                  Sha256Digest sha256 = new Sha256Digest();                  byte[] generatedaddressbytes = utf8.GetBytes(generatedaddress.AddressBase58);                  sha256.BlockUpdate(generatedaddressbytes' 0' generatedaddressbytes.Length);                  byte[] addresshashfull = new byte[32];                  sha256.DoFinal(addresshashfull' 0);                  sha256.BlockUpdate(addresshashfull' 0' 32);                  sha256.DoFinal(addresshashfull' 0);                    for (int i = 0; i < 4; i++) {                      if (addresshashfull[i] != confbytes[i + 6]) {                          MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                          return;                      }                  }                    confirmIsValid(generatedaddress.AddressBase58);              } catch {                  // Might throw an exception - not every 256-bit integer is a valid X coordinate                  MessageBox.Show("This passphrase is wrong or does not belong to this confirmation code."' "Invalid passphrase"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);                  return;              }
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 9);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 9);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(676' 104);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(676' 104);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(115' 125);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(115' 125);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(688' 20);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(688' 20);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 128);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 128);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(62' 13);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(62' 13);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 2;
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(12' 154);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(12' 154);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(92' 13);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(92' 13);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 4;
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.txtConfCode.Location = new System.Drawing.Point(115' 151);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.txtConfCode.Location = new System.Drawing.Point(115' 151);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.txtConfCode.Size = new System.Drawing.Size(688' 20);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.txtConfCode.Size = new System.Drawing.Size(688' 20);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.txtConfCode.TabIndex = 3;
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirm.Location = new System.Drawing.Point(115' 177);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirm.Location = new System.Drawing.Point(115' 177);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirm.Size = new System.Drawing.Size(75' 23);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirm.Size = new System.Drawing.Size(75' 23);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.btnConfirm.TabIndex = 5;
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblAddressHeader.Location = new System.Drawing.Point(12' 216);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblAddressHeader.Location = new System.Drawing.Point(12' 216);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblAddressHeader.Size = new System.Drawing.Size(98' 13);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblAddressHeader.Size = new System.Drawing.Size(98' 13);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblAddressHeader.TabIndex = 6;
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblAddressItself.Location = new System.Drawing.Point(112' 216);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblAddressItself.Location = new System.Drawing.Point(112' 216);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblAddressItself.Size = new System.Drawing.Size(170' 13);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblAddressItself.Size = new System.Drawing.Size(170' 13);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblAddressItself.TabIndex = 7;
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblResult.Location = new System.Drawing.Point(112' 238);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblResult.Location = new System.Drawing.Point(112' 238);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblResult.Size = new System.Drawing.Size(394' 13);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblResult.Size = new System.Drawing.Size(394' 13);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.lblResult.TabIndex = 8;
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(815' 268);
Magic Number,BtcAddress.Forms,Bip38ConfValidator,C:\repos\casascius_Bitcoin-Address-Utility\Forms\Bip38ConfValidator.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(815' 268);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.txtEncrypted.Location = new System.Drawing.Point(151' 14);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.txtEncrypted.Location = new System.Drawing.Point(151' 14);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.txtEncrypted.Size = new System.Drawing.Size(579' 20);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.txtEncrypted.Size = new System.Drawing.Size(579' 20);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 17);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 17);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(117' 13);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(117' 13);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 38);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 38);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(107' 26);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(107' 26);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 3;
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(151' 40);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Location = new System.Drawing.Point(151' 40);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(579' 20);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.Size = new System.Drawing.Size(579' 20);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.txtPassphrase.TabIndex = 2;
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.btnDecrypt.Location = new System.Drawing.Point(151' 66);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.btnDecrypt.Location = new System.Drawing.Point(151' 66);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.btnDecrypt.Size = new System.Drawing.Size(162' 27);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.btnDecrypt.Size = new System.Drawing.Size(162' 27);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.btnDecrypt.TabIndex = 4;
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(744' 104);
Magic Number,BtcAddress.Forms,DecryptKey,C:\repos\casascius_Bitcoin-Address-Utility\Forms\DecryptKey.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(744' 104);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Location = new System.Drawing.Point(12' 12);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Location = new System.Drawing.Point(12' 12);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Size = new System.Drawing.Size(731' 428);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabControl1.Size = new System.Drawing.Size(731' 428);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabHowItWorks.Location = new System.Drawing.Point(4' 22);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabHowItWorks.Location = new System.Drawing.Point(4' 22);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabHowItWorks.Padding = new System.Windows.Forms.Padding(3);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabHowItWorks.Size = new System.Drawing.Size(723' 402);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabHowItWorks.Size = new System.Drawing.Size(723' 402);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabHowItWorks.TabIndex = 4;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Location = new System.Drawing.Point(562' 386);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Location = new System.Drawing.Point(562' 386);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Size = new System.Drawing.Size(155' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Size = new System.Drawing.Size(155' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.richTextBox1.Location = new System.Drawing.Point(7' 7);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.richTextBox1.Location = new System.Drawing.Point(7' 7);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.richTextBox1.Size = new System.Drawing.Size(710' 376);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.richTextBox1.Size = new System.Drawing.Size(710' 376);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage1.Location = new System.Drawing.Point(4' 22);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage1.Location = new System.Drawing.Point(4' 22);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage1.Size = new System.Drawing.Size(723' 402);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage1.Size = new System.Drawing.Size(723' 402);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(16' 221);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(16' 221);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(688' 169);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(688' 169);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 9;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeGeneratedAddress.Location = new System.Drawing.Point(19' 198);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeGeneratedAddress.Location = new System.Drawing.Point(19' 198);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeGeneratedAddress.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeGeneratedAddress.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeGeneratedAddress.TabIndex = 8;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(16' 182);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(16' 182);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(619' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(619' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 7;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.button4.Location = new System.Drawing.Point(615' 130);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.button4.Location = new System.Drawing.Point(615' 130);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.button4.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.button4.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.button4.TabIndex = 6;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.button3.Location = new System.Drawing.Point(525' 130);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.button3.Location = new System.Drawing.Point(525' 130);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.button3.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.button3.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.button3.TabIndex = 5;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeGeneratedInvite.Location = new System.Drawing.Point(19' 156);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeGeneratedInvite.Location = new System.Drawing.Point(19' 156);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeGeneratedInvite.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeGeneratedInvite.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeGeneratedInvite.TabIndex = 4;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(16' 140);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(16' 140);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(477' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(477' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 3;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnGenPayee.Location = new System.Drawing.Point(19' 109);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnGenPayee.Location = new System.Drawing.Point(19' 109);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnGenPayee.Size = new System.Drawing.Size(214' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnGenPayee.Size = new System.Drawing.Size(214' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnGenPayee.TabIndex = 2;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeCode.Location = new System.Drawing.Point(19' 85);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeCode.Location = new System.Drawing.Point(19' 85);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeCode.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayeeCode.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(16' 17);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(16' 17);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(681' 65);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(681' 65);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage2.Location = new System.Drawing.Point(4' 22);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage2.Location = new System.Drawing.Point(4' 22);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage2.Padding = new System.Windows.Forms.Padding(3);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage2.Size = new System.Drawing.Size(723' 402);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage2.Size = new System.Drawing.Size(723' 402);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerDone.Location = new System.Drawing.Point(20' 190);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerDone.Location = new System.Drawing.Point(20' 190);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerDone.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerDone.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerDone.TabIndex = 20;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(17' 217);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label6.Location = new System.Drawing.Point(17' 217);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(669' 156);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label6.Size = new System.Drawing.Size(669' 156);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label6.TabIndex = 19;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerAddress.Location = new System.Drawing.Point(20' 165);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerAddress.Location = new System.Drawing.Point(20' 165);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerAddress.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerAddress.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerAddress.TabIndex = 18;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.lblPayerHereIs.Location = new System.Drawing.Point(17' 136);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.lblPayerHereIs.Location = new System.Drawing.Point(17' 136);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.lblPayerHereIs.Size = new System.Drawing.Size(658' 26);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.lblPayerHereIs.Size = new System.Drawing.Size(658' 26);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.lblPayerHereIs.TabIndex = 17;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerPrint.Location = new System.Drawing.Point(616' 190);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerPrint.Location = new System.Drawing.Point(616' 190);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerPrint.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerPrint.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerPrint.TabIndex = 16;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerSave.Location = new System.Drawing.Point(526' 190);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerSave.Location = new System.Drawing.Point(526' 190);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerSave.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerSave.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnPayerSave.TabIndex = 15;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerCode2.Location = new System.Drawing.Point(20' 113);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerCode2.Location = new System.Drawing.Point(20' 113);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerCode2.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerCode2.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerCode2.TabIndex = 14;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerCode1.Location = new System.Drawing.Point(20' 84);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerCode1.Location = new System.Drawing.Point(20' 84);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerCode1.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerCode1.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtPayerCode1.TabIndex = 11;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(17' 16);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label9.Location = new System.Drawing.Point(17' 16);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(640' 78);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label9.Size = new System.Drawing.Size(640' 78);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label9.TabIndex = 10;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage3.Location = new System.Drawing.Point(4' 22);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage3.Location = new System.Drawing.Point(4' 22);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage3.Padding = new System.Windows.Forms.Padding(3);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage3.Size = new System.Drawing.Size(723' 402);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage3.Size = new System.Drawing.Size(723' 402);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage3.TabIndex = 2;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(15' 205);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label8.Location = new System.Drawing.Point(15' 205);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(703' 169);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label8.Size = new System.Drawing.Size(703' 169);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label8.TabIndex = 19;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnEscrowPrint.Location = new System.Drawing.Point(614' 115);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnEscrowPrint.Location = new System.Drawing.Point(614' 115);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnEscrowPrint.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnEscrowPrint.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnEscrowPrint.TabIndex = 16;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnEscrowSave.Location = new System.Drawing.Point(524' 115);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnEscrowSave.Location = new System.Drawing.Point(524' 115);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnEscrowSave.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnEscrowSave.Size = new System.Drawing.Size(84' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnEscrowSave.TabIndex = 15;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtEscrowForPayee.Location = new System.Drawing.Point(18' 173);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtEscrowForPayee.Location = new System.Drawing.Point(18' 173);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtEscrowForPayee.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtEscrowForPayee.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtEscrowForPayee.TabIndex = 14;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.lblEscrowHead.Location = new System.Drawing.Point(15' 125);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.lblEscrowHead.Location = new System.Drawing.Point(15' 125);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.lblEscrowHead.Size = new System.Drawing.Size(504' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.lblEscrowHead.Size = new System.Drawing.Size(504' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.lblEscrowHead.TabIndex = 13;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateEscrowInvitation.Location = new System.Drawing.Point(18' 95);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateEscrowInvitation.Location = new System.Drawing.Point(18' 95);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateEscrowInvitation.Size = new System.Drawing.Size(214' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateEscrowInvitation.Size = new System.Drawing.Size(214' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnGenerateEscrowInvitation.TabIndex = 12;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtEscrowForPayer.Location = new System.Drawing.Point(18' 147);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtEscrowForPayer.Location = new System.Drawing.Point(18' 147);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtEscrowForPayer.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtEscrowForPayer.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtEscrowForPayer.TabIndex = 11;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(15' 14);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label12.Location = new System.Drawing.Point(15' 14);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(672' 78);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label12.Size = new System.Drawing.Size(672' 78);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label12.TabIndex = 10;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage4.Location = new System.Drawing.Point(4' 22);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage4.Location = new System.Drawing.Point(4' 22);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage4.Padding = new System.Windows.Forms.Padding(3);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage4.Size = new System.Drawing.Size(723' 402);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage4.Size = new System.Drawing.Size(723' 402);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.tabPage4.TabIndex = 3;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemPrivKey.Location = new System.Drawing.Point(21' 283);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemPrivKey.Location = new System.Drawing.Point(21' 283);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemPrivKey.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemPrivKey.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemPrivKey.TabIndex = 9;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label15.Location = new System.Drawing.Point(18' 267);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label15.Location = new System.Drawing.Point(18' 267);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label15.Size = new System.Drawing.Size(367' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label15.Size = new System.Drawing.Size(367' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label15.TabIndex = 8;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemAddress.Location = new System.Drawing.Point(21' 223);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemAddress.Location = new System.Drawing.Point(21' 223);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemAddress.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemAddress.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemAddress.TabIndex = 7;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label14.Location = new System.Drawing.Point(18' 207);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label14.Location = new System.Drawing.Point(18' 207);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label14.Size = new System.Drawing.Size(114' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label14.Size = new System.Drawing.Size(114' 13);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label14.TabIndex = 6;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnRedeem.Location = new System.Drawing.Point(21' 163);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnRedeem.Location = new System.Drawing.Point(21' 163);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnRedeem.Size = new System.Drawing.Size(75' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnRedeem.Size = new System.Drawing.Size(75' 23);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.btnRedeem.TabIndex = 5;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode3.Location = new System.Drawing.Point(21' 137);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode3.Location = new System.Drawing.Point(21' 137);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode3.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode3.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode3.TabIndex = 4;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode2.Location = new System.Drawing.Point(21' 111);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode2.Location = new System.Drawing.Point(21' 111);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode2.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode2.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode2.TabIndex = 3;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode1.Location = new System.Drawing.Point(21' 85);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode1.Location = new System.Drawing.Point(21' 85);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode1.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode1.Size = new System.Drawing.Size(680' 20);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.txtRedeemCode1.TabIndex = 2;
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(18' 17);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(18' 17);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(470' 65);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(470' 65);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(755' 452);
Magic Number,BtcAddress.Forms,EscrowTools,C:\repos\casascius_Bitcoin-Address-Utility\Forms\EscrowTools.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(755' 452);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,KeyCollectionView_Load,The following statement contains a magic number: listView1.Columns[0].Width = 400;
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,KeyCollectionView_Load,The following statement contains a magic number: listView1.Columns[1].Width = 100;
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(629' 24);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(629' 24);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.toolsToolStripMenuItem.Size = new System.Drawing.Size(48' 20);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.toolsToolStripMenuItem.Size = new System.Drawing.Size(48' 20);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.addressUtilityToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.addressUtilityToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.base58CalculatorToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.base58CalculatorToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.keyDecrypterToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.keyDecrypterToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.mofNCalculatorToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.mofNCalculatorToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.twoFactorBitcoinToolsToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.twoFactorBitcoinToolsToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.intermediateGeneratorToolStripMenuItem.Size = new System.Drawing.Size(227' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.intermediateGeneratorToolStripMenuItem.Size = new System.Drawing.Size(227' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.confirmationCodeValidatorToolStripMenuItem.Size = new System.Drawing.Size(227' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.confirmationCodeValidatorToolStripMenuItem.Size = new System.Drawing.Size(227' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.keyCombinerToolStripMenuItem.Size = new System.Drawing.Size(227' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.keyCombinerToolStripMenuItem.Size = new System.Drawing.Size(227' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.keyDecrypterToolStripMenuItem1.Size = new System.Drawing.Size(227' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.keyDecrypterToolStripMenuItem1.Size = new System.Drawing.Size(227' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.escrowToolsToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.escrowToolsToolStripMenuItem.Size = new System.Drawing.Size(207' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size(37' 20);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size(37' 20);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.clearAllToolStripMenuItem.Size = new System.Drawing.Size(118' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.clearAllToolStripMenuItem.Size = new System.Drawing.Size(118' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.saveToolStripMenuItem.Size = new System.Drawing.Size(118' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.saveToolStripMenuItem.Size = new System.Drawing.Size(118' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.exitToolStripMenuItem.Size = new System.Drawing.Size(118' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.exitToolStripMenuItem.Size = new System.Drawing.Size(118' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.keyToolStripMenuItem.Size = new System.Drawing.Size(61' 20);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.keyToolStripMenuItem.Size = new System.Drawing.Size(61' 20);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.newAddressToolStripMenuItem.Size = new System.Drawing.Size(183' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.newAddressToolStripMenuItem.Size = new System.Drawing.Size(183' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.generateKeysToolStripMenuItem.Size = new System.Drawing.Size(183' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.generateKeysToolStripMenuItem.Size = new System.Drawing.Size(183' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.enterAnAddressToolStripMenuItem.Size = new System.Drawing.Size(183' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.enterAnAddressToolStripMenuItem.Size = new System.Drawing.Size(183' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.selectionToolStripMenuItem.Size = new System.Drawing.Size(67' 20);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.selectionToolStripMenuItem.Size = new System.Drawing.Size(67' 20);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.selectAllToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.selectAllToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.deselectAllToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.deselectAllToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator1.Size = new System.Drawing.Size(262' 6);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator1.Size = new System.Drawing.Size(262' 6);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.printBanknoteVouchersToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.printBanknoteVouchersToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.printTwoFactorCoinInsertsToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.printTwoFactorCoinInsertsToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.printPhysicalBitcoinInsertsDenseToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.printPhysicalBitcoinInsertsDenseToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.printPaperWalletsToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.printPaperWalletsToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator2.Size = new System.Drawing.Size(262' 6);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator2.Size = new System.Drawing.Size(262' 6);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.saveAddressListToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.saveAddressListToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator3.Size = new System.Drawing.Size(262' 6);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator3.Size = new System.Drawing.Size(262' 6);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.deleteSelectedItemsToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.deleteSelectedItemsToolStripMenuItem.Size = new System.Drawing.Size(265' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Location = new System.Drawing.Point(0' 412);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(629' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(629' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Size = new System.Drawing.Size(118' 17);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatusLabel1.Size = new System.Drawing.Size(118' 17);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.listView1.Location = new System.Drawing.Point(0' 27);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.listView1.Size = new System.Drawing.Size(629' 382);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.listView1.Size = new System.Drawing.Size(629' 382);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.listView1.TabIndex = 2;
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.chAddress.Width = 480;
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.chPrivateKey.Width = 100;
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStrip1.Size = new System.Drawing.Size(110' 26);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStrip1.Size = new System.Drawing.Size(110' 26);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.detailsToolStripMenuItem.Size = new System.Drawing.Size(109' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.detailsToolStripMenuItem.Size = new System.Drawing.Size(109' 22);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.saveAddressListWithPrivKeyToolStripMenuItem.Size = new System.Drawing.Size(315' 24);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.saveAddressListWithPrivKeyToolStripMenuItem.Size = new System.Drawing.Size(315' 24);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(629' 434);
Magic Number,BtcAddress.Forms,KeyCollectionView,C:\repos\casascius_Bitcoin-Address-Utility\Forms\KeyCollectionView.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(629' 434);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.numVouchersPerPage.Location = new System.Drawing.Point(215' 16);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.numVouchersPerPage.Location = new System.Drawing.Point(215' 16);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.numVouchersPerPage.Maximum = new decimal(new int[] {              3'              0'              0'              0});
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.numVouchersPerPage.Size = new System.Drawing.Size(65' 20);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.numVouchersPerPage.Size = new System.Drawing.Size(65' 20);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.numVouchersPerPage.Value = new decimal(new int[] {              3'              0'              0'              0});
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 18);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(12' 18);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(132' 13);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(132' 13);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 3;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.cboArtworkStyle.Location = new System.Drawing.Point(85' 42);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.cboArtworkStyle.Location = new System.Drawing.Point(85' 42);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.cboArtworkStyle.Size = new System.Drawing.Size(195' 21);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.cboArtworkStyle.Size = new System.Drawing.Size(195' 21);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.cboArtworkStyle.TabIndex = 4;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(12' 45);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(12' 45);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(67' 13);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(67' 13);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 5;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(12' 72);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(12' 72);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(107' 13);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(107' 13);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 6;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.txtDenomination.Location = new System.Drawing.Point(153' 69);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.txtDenomination.Location = new System.Drawing.Point(153' 69);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.txtDenomination.Size = new System.Drawing.Size(127' 20);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.txtDenomination.Size = new System.Drawing.Size(127' 20);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.txtDenomination.TabIndex = 7;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.comboBox2.Location = new System.Drawing.Point(85' 95);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.comboBox2.Location = new System.Drawing.Point(85' 95);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.comboBox2.Size = new System.Drawing.Size(195' 21);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.comboBox2.Size = new System.Drawing.Size(195' 21);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.comboBox2.TabIndex = 8;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 98);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(12' 98);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(70' 13);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(70' 13);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 9;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.comboBox3.Location = new System.Drawing.Point(110' 122);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.comboBox3.Location = new System.Drawing.Point(110' 122);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.comboBox3.Size = new System.Drawing.Size(170' 21);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.comboBox3.Size = new System.Drawing.Size(170' 21);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.comboBox3.TabIndex = 10;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(12' 125);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(12' 125);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(92' 13);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(92' 13);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 11;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Location = new System.Drawing.Point(118' 72);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Location = new System.Drawing.Point(118' 72);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Size = new System.Drawing.Size(14' 15);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.Size = new System.Drawing.Size(14' 15);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel1.TabIndex = 12;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel2.Location = new System.Drawing.Point(133' 72);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel2.Location = new System.Drawing.Point(133' 72);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel2.Size = new System.Drawing.Size(14' 15);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel2.Size = new System.Drawing.Size(14' 15);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.linkLabel2.TabIndex = 13;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(12' 171);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.button1.Location = new System.Drawing.Point(12' 171);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(268' 31);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.button1.Size = new System.Drawing.Size(268' 31);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.button1.TabIndex = 14;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.chkPrintUnencrypted.Location = new System.Drawing.Point(12' 148);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.chkPrintUnencrypted.Location = new System.Drawing.Point(12' 148);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.chkPrintUnencrypted.Size = new System.Drawing.Size(218' 17);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.chkPrintUnencrypted.Size = new System.Drawing.Size(218' 17);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.chkPrintUnencrypted.TabIndex = 15;
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(292' 222);
Magic Number,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(292' 222);
Magic Number,PC,PCPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\PCPrint.cs,OnBeginPrint,The following statement contains a magic number: if (_font == null)             {                 //Create the font we need                 _font = new Font("Times New Roman"' 10);             }
Missing Default,BtcAddress,QRPrint,C:\repos\casascius_Bitcoin-Address-Utility\Reports\QRPrint.cs,OnPrintPage,The following switch statement is missing a default case: switch (PrintMode) {                        case PrintModes.PubPrivQR:                          if (i >= 8) i = 999;                          eachheight = 120;                          break;                        case PrintModes.PsyBanknote:                          if (i >= 3) i = 999;                          eachheight = 365;                          break;                  }
Missing Default,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following switch statement is missing a default case: switch (hex.Length) {                          case 21:                              // It's an address of some sort.                              return new AddressBase(what);                          case 31:                          case 32:                          case 33:                          case 34:                              // Unencrypted private key                              return new KeyPair(what);                          case 36:                              // these pairs aren't decided by length alone'                              // but the constructors will throw an exception if they                              // don't contain valid key material.                              return new ShaPassphraseKeyPair(what);                                                  case 39:                              return new Bip38KeyPair(what);                          case 49:                              return new Bip38Intermediate(what' Bip38Intermediate.Interpretation.IntermediateCode);                          case 51:                              return new Bip38Confirmation(what);                      }
Missing Default,Casascius.Bitcoin,StringInterpreter,C:\repos\casascius_Bitcoin-Address-Utility\Model\StringInterpreter.cs,Interpret,The following switch statement is missing a default case: switch (hex.Length) {                          case 33:                          case 65:                              return new PublicKey(hex);                          case 20:                              return new AddressBase(hex' addressType);                          case 21: // hash160                              return new AddressBase(hex);                          case 30:                          case 31:                          case 32:                              return new KeyPair(hex' compressed: compressed' addressType: addressType);                      }
Missing Default,BtcAddress.Forms,AddressGen,C:\repos\casascius_Bitcoin-Address-Utility\Forms\AddressGen.cs,GenerationThreadProcess,The following switch statement is missing a default case: switch (GenChoice) {                      case GenChoices.Minikey:                          MiniKeyPair mkp = MiniKeyPair.CreateRandom(ExtraEntropy.GetEntropy());                          string s = mkp.AddressBase58; // read the property to entice it to compute everything                          newitem = new KeyCollectionItem(mkp);                          break;                      case GenChoices.WIF:                          KeyPair kp = KeyPair.Create(ExtraEntropy.GetEntropy());                          s = kp.AddressBase58;                          newitem = new KeyCollectionItem(kp);                          break;                      case GenChoices.Deterministic:                          kp = KeyPair.CreateFromString(UserText + detcount);                          detcount++;                          s = kp.AddressBase58;                          newitem = new KeyCollectionItem(kp);                          break;                      case GenChoices.Encrypted:                          Bip38KeyPair ekp = new Bip38KeyPair(intermediate);                          newitem = new KeyCollectionItem(ekp);                          break;                      case GenChoices.TwoFactor:                          ekp = new Bip38KeyPair(intermediatesForGeneration[intermediateIdx++]);                          if (intermediateIdx >= intermediatesForGeneration.Length) intermediateIdx = 0;                          newitem = new KeyCollectionItem(ekp);                          break;                  }
Missing Default,BtcAddress.Forms,PrintVouchers,C:\repos\casascius_Bitcoin-Address-Utility\Forms\PrintVouchers.cs,button1_Click,The following switch statement is missing a default case: switch (cboArtworkStyle.Text.ToLower()) {                      case "yellow":                      case "green":                      case "blue":                      case "purple":                      case "greyscale":                          printer.ImageFilename = "note-" + cboArtworkStyle.SelectedItem.ToString().ToLowerInvariant() + ".png";                          break;                  }
