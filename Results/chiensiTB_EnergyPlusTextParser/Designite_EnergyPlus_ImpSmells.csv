Implementation smell,Namespace,Class,File,Method,Description
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,getAllEPConstructions,The method has 155 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWeekIntervalSchedule,The method has 124 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The method has 292 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The method has 288 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The method has 402 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The method has 119 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeEPlusSurfaceList,The method has 141 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSpacestoObjectList,The method has 288 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusZonestoObjectList,The method has 499 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusWindowstoObject,The method has 220 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusWindowstoObject,The method has 264 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The method has 176 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The method has 161 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The method has 239 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeStripWindow,The method has 186 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The method has 224 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The method has 163 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The method has 180 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The method has 140 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The method has 159 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The method has 113 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The method has 200 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The method has 104 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The method has 104 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The method has 118 lines of code.
Long Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateRadSurfaceConstructions,The method has 104 lines of code.
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,Cyclomatic complexity of the method is 13
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeGlazingLayer,Cyclomatic complexity of the method is 16
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeMaterial,Cyclomatic complexity of the method is 12
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,getAllEPConstructions,Cyclomatic complexity of the method is 22
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,getEPSchedules,Cyclomatic complexity of the method is 14
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeYearSchedule,Cyclomatic complexity of the method is 18
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWeekIntervalSchedule,Cyclomatic complexity of the method is 28
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeDayIntervalSchedule,Cyclomatic complexity of the method is 12
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,Cyclomatic complexity of the method is 43
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,Cyclomatic complexity of the method is 40
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,Cyclomatic complexity of the method is 35
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,Cyclomatic complexity of the method is 13
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeEPlusSurfaceList,Cyclomatic complexity of the method is 25
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeEPlusShadeList,Cyclomatic complexity of the method is 10
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSpacesNames,Cyclomatic complexity of the method is 11
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSpacestoObjectList,Cyclomatic complexity of the method is 43
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusZonestoObjectList,Cyclomatic complexity of the method is 65
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADepPeopleToObj,Cyclomatic complexity of the method is 15
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADepEquipToObj,Cyclomatic complexity of the method is 15
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADeplightToObj,Cyclomatic complexity of the method is 16
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeZoneGroup,Cyclomatic complexity of the method is 9
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeZoneList,Cyclomatic complexity of the method is 9
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusWindowstoObject,Cyclomatic complexity of the method is 32
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusWindowstoObject,Cyclomatic complexity of the method is 37
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeEPlusWindowsList,Cyclomatic complexity of the method is 10
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADMakeEPlusWindowsList,Cyclomatic complexity of the method is 10
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,Cyclomatic complexity of the method is 32
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,Cyclomatic complexity of the method is 30
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MatchIDFFileSpaces,Cyclomatic complexity of the method is 18
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,Cyclomatic complexity of the method is 57
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeStripWindow,Cyclomatic complexity of the method is 24
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSurfaceGroupObject,Cyclomatic complexity of the method is 8
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,Cyclomatic complexity of the method is 13
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,Cyclomatic complexity of the method is 29
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,Cyclomatic complexity of the method is 24
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,Cyclomatic complexity of the method is 27
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,Cyclomatic complexity of the method is 15
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,Cyclomatic complexity of the method is 16
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNormalQuadWallWidth,Cyclomatic complexity of the method is 16
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNormalQuadWindowWidth,Cyclomatic complexity of the method is 16
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,Cyclomatic complexity of the method is 26
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,Cyclomatic complexity of the method is 26
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,Cyclomatic complexity of the method is 24
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,Cyclomatic complexity of the method is 24
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,Cyclomatic complexity of the method is 24
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,Cyclomatic complexity of the method is 24
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,Cyclomatic complexity of the method is 21
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,Cyclomatic complexity of the method is 26
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,Cyclomatic complexity of the method is 17
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,Cyclomatic complexity of the method is 17
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirection,Cyclomatic complexity of the method is 12
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,Cyclomatic complexity of the method is 18
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,Cyclomatic complexity of the method is 27
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,Cyclomatic complexity of the method is 18
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewDLUpperQuadPunchedWindowCoordinates,Cyclomatic complexity of the method is 21
Complex Method,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateRadSurfaceConstructions,Cyclomatic complexity of the method is 17
Long Parameter List,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The method has 7 parameters.
Long Parameter List,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeStripWindow,The method has 9 parameters.
Long Parameter List,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The method has 9 parameters.
Long Parameter List,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The method has 6 parameters.
Long Parameter List,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The method has 6 parameters.
Long Parameter List,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedDaylightWindow,The method has 5 parameters.
Long Parameter List,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The method has 8 parameters.
Long Parameter List,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The method has 7 parameters.
Long Parameter List,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,The method has 5 parameters.
Long Parameter List,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The method has 5 parameters.
Long Parameter List,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The method has 6 parameters.
Long Identifier,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The length of the parameter fenestrationParentSurfaceRegex is 30.
Long Identifier,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeStripWindow,The length of the parameter fenestrationParentSurfaceRegex is 30.
Long Identifier,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The length of the parameter fenestrationParentSurfaceRegex is 30.
Long Identifier,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateRadSurfaceConstructions,The length of the parameter outsideBoundaryConditionObject is 30.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindTilt,The length of the statement  "	//alignment with y axis means north pointing' alignment with z-axis means it is pointing up to the sky (like a flat roof) " is 121.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindTilt,The length of the statement  "	//since parallel and anti parallel vectors will return the same cross product [0'0'0] I need to filter out the antiparalll case " is 127.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The length of the statement  "	//alignment with y axis means north pointing' alignment with z-axis means it is pointing up to the sky (like a flat roof) " is 121.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The length of the statement  "	if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) { " is 145.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The length of the statement  "	//this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways " is 152.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetSurface,The length of the statement  "	ModelingUtilities.BuildingObjects.MemorySafe_Surface emptySurface = new ModelingUtilities.BuildingObjects.MemorySafe_Surface (name' multiplier' SurfaceType' constName' ob' zoneName' outsideBC' sunExp' windExp' vF' numVert' sc' tilt' az); " is 237.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The length of the statement  "						string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'\s*(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'\s*(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+)\s*)"; " is 143.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The length of the statement  "		logline.AppendLine (currentSurface.name + "' " + currentSurface.surfaceType + "' " + currentSurface.outsideBoundary.ToString ()); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The length of the statement  "		Console.WriteLine (currentSurface.name + "' " + currentSurface.surfaceType + "' " + currentSurface.outsideBoundary.ToString ()); " is 128.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The length of the statement  "		logline.AppendLine (RHRNormalVector.X.ToString () + "' " + RHRNormalVector.Y.ToString () + "' " + RHRNormalVector.Z.ToString () + "' " + currentSurface.azimuth.ToString () + "' " + currentSurface.tilt.ToString ()); " is 214.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The length of the statement  "		Console.WriteLine (RHRNormalVector.X.ToString () + "' " + RHRNormalVector.Y.ToString () + "' " + RHRNormalVector.Z.ToString () + "' " + currentSurface.azimuth.ToString () + "' " + currentSurface.tilt.ToString ()); " is 213.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The length of the statement  "					string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))"; " is 134.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The length of the statement  "	logline.AppendLine (currentSurface.name + "' " + currentSurface.surfaceType + "' " + currentSurface.outsideBoundary.ToString ()); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The length of the statement  "	Console.WriteLine (currentSurface.name + "' " + currentSurface.surfaceType + "' " + currentSurface.outsideBoundary.ToString ()); " is 128.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The length of the statement  "	logline.AppendLine (RHRNormalVector.X.ToString () + "' " + RHRNormalVector.Y.ToString () + "' " + RHRNormalVector.Z.ToString () + "' " + currentSurface.azimuth.ToString () + "' " + currentSurface.tilt.ToString ()); " is 214.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The length of the statement  "	Console.WriteLine (RHRNormalVector.X.ToString () + "' " + RHRNormalVector.Y.ToString () + "' " + RHRNormalVector.Z.ToString () + "' " + currentSurface.azimuth.ToString () + "' " + currentSurface.tilt.ToString ()); " is 213.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The length of the statement  "			//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients; " is 123.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The length of the statement  "			//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel; " is 126.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The length of the statement  "					string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))"; " is 134.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The length of the statement  "	logline.AppendLine (currentSurface.name + "' " + currentSurface.surfaceType + "' " + currentSurface.outsideBoundary.ToString ()); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The length of the statement  "	Console.WriteLine (currentSurface.name + "' " + currentSurface.surfaceType + "' " + currentSurface.outsideBoundary.ToString ()); " is 128.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The length of the statement  "	logline.AppendLine (RHRNormalVector.X.ToString () + "' " + RHRNormalVector.Y.ToString () + "' " + RHRNormalVector.Z.ToString () + "' " + currentSurface.azimuth.ToString () + "' " + currentSurface.tilt.ToString ()); " is 214.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The length of the statement  "	Console.WriteLine (RHRNormalVector.X.ToString () + "' " + RHRNormalVector.Y.ToString () + "' " + RHRNormalVector.Z.ToString () + "' " + currentSurface.azimuth.ToString () + "' " + currentSurface.tilt.ToString ()); " is 213.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The length of the statement  "					string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))"; " is 134.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The length of the statement  "	logline.AppendLine (currentSurface.name + "' " + currentSurface.surfaceType + "' " + currentSurface.outsideBoundary.ToString ()); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The length of the statement  "	Console.WriteLine (currentSurface.name + "' " + currentSurface.surfaceType + "' " + currentSurface.outsideBoundary.ToString ()); " is 128.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The length of the statement  "	logline.AppendLine (RHRNormalVector.X.ToString () + "' " + RHRNormalVector.Y.ToString () + "' " + RHRNormalVector.Z.ToString () + "' " + currentSurface.azimuth.ToString () + "' " + currentSurface.tilt.ToString ()); " is 214.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The length of the statement  "	Console.WriteLine (RHRNormalVector.X.ToString () + "' " + RHRNormalVector.Y.ToString () + "' " + RHRNormalVector.Z.ToString () + "' " + currentSurface.azimuth.ToString () + "' " + currentSurface.tilt.ToString ()); " is 213.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeEPlusSurfaceList,The length of the statement  "	List<ModelingUtilities.BuildingObjects.MemorySafe_Surface> projectSurfaces = new List<ModelingUtilities.BuildingObjects.MemorySafe_Surface> (); " is 143.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeEPlusSurfaceList,The length of the statement  "						ModelingUtilities.BuildingObjects.MemorySafe_Surface memSurf = ModelingUtilities.BuildingObjects.convert2MemorySafeSurface (surfaceReturned); " is 141.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeEPlusShadeList,The length of the statement  "	List<ModelingUtilities.BuildingObjects.MemorySafe_Surface> projectShades = new List<ModelingUtilities.BuildingObjects.MemorySafe_Surface> (); " is 141.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeEPlusShadeList,The length of the statement  "						ModelingUtilities.BuildingObjects.MemorySafe_Surface memSurf = ModelingUtilities.BuildingObjects.convert2MemorySafeSurface (surfaceReturned); " is 141.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSpacestoObjectList,The length of the statement  "	List<ModelingUtilities.BuildingObjects.MemorySafe_Spaces> memSafeProjectSpaces = new List<ModelingUtilities.BuildingObjects.MemorySafe_Spaces> (); " is 146.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSpacestoObjectList,The length of the statement  "						//ModelingUtilities.BuildingObjects.Surface surfaceReturned = EPlusFunctions.EPlusSurfacetoObject("C:\\Temp\\detailedSurface.txt");                                 " is 131.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSpacestoObjectList,The length of the statement  "				List<ModelingUtilities.BuildingObjects.MemorySafe_Surface> projectSpaceSurfaces = new List<ModelingUtilities.BuildingObjects.MemorySafe_Surface> (); " is 148.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSpacestoObjectList,The length of the statement  "					ModelingUtilities.BuildingObjects.MemorySafe_Surface memsurf = ModelingUtilities.BuildingObjects.convert2MemorySafeSurface (surface); " is 133.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSpacestoObjectList,The length of the statement  "				ModelingUtilities.BuildingObjects.MemorySafe_Spaces memSpace = new ModelingUtilities.BuildingObjects.MemorySafe_Spaces (zoneName' multiplier' projectSpaceSurfaces); " is 164.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusZonestoObjectList,The length of the statement  "						//ModelingUtilities.BuildingObjects.Surface surfaceReturned = EPlusFunctions.EPlusSurfacetoObject("C:\\Temp\\detailedSurface.txt");                                 " is 131.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusZonestoObjectList,The length of the statement  "					ModelingUtilities.BuildingObjects.MemorySafe_Surface memsurf = ModelingUtilities.BuildingObjects.convert2MemorySafeSurface (surface); " is 133.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusWindowstoObject,The length of the statement  "	ModelingUtilities.BuildingObjects.OpeningDefinitions window = new ModelingUtilities.BuildingObjects.OpeningDefinitions (); " is 122.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusWindowstoObject,The length of the statement  "							string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))"; " is 134.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusWindowstoObject,The length of the statement  "	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions memOpening = ModelingUtilities.BuildingObjects.convert2MemorySafeOpening (window); " is 146.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusWindowstoObject,The length of the statement  "	ModelingUtilities.BuildingObjects.OpeningDefinitions window = new ModelingUtilities.BuildingObjects.OpeningDefinitions (); " is 122.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusWindowstoObject,The length of the statement  "	ModelingUtilities.BuildingObjects.MemorySafe_ADOpeningDefinitions memwindow = ModelingUtilities.BuildingObjects.convert2ADMemorySafeOpening (window); " is 149.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeEPlusWindowsList,The length of the statement  "	List<ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions> openings = new List<ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions> (); " is 158.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeEPlusWindowsList,The length of the statement  "						ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions openingReturned = EPlusFunctions.EPlusWindowstoObject ("C:\\Temp\\detailedSurface.txt"); " is 152.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADMakeEPlusWindowsList,The length of the statement  "	List<ModelingUtilities.BuildingObjects.MemorySafe_ADOpeningDefinitions> openings = new List<ModelingUtilities.BuildingObjects.MemorySafe_ADOpeningDefinitions> (); " is 162.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADMakeEPlusWindowsList,The length of the statement  "						ModelingUtilities.BuildingObjects.MemorySafe_ADOpeningDefinitions openingReturned = EPlusFunctions.ADEPlusWindowstoObject ("C:\\Temp\\detailedSurface.txt"); " is 156.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The length of the statement  "	List<ModelingUtilities.BuildingObjects.MemorySafe_Surface> foundSurfaces = new List<ModelingUtilities.BuildingObjects.MemorySafe_Surface> (); " is 141.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The length of the statement  "					output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ()); " is 219.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The length of the statement  "					output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ()); " is 219.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The length of the statement  "					output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ()); " is 219.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The length of the statement  "					output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ()); " is 219.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The length of the statement  "	double buildingWWR = (buildingEastWindowArea + buildingNorthWindowArea + buildingSouthWindowArea + buildingWestWindowArea) / (buildingEastExtWallArea + buildingNorthExtWallArea + buildingSouthExtWallArea + buildingWestExtWallArea); " is 231.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The length of the statement  "	double buildingTotalExtWallArea = (buildingEastExtWallArea + buildingNorthExtWallArea + buildingSouthExtWallArea + buildingWestExtWallArea); " is 140.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The length of the statement  "	double buildingTotalExtWindowArea = (buildingEastWindowArea + buildingNorthWindowArea + buildingSouthWindowArea + buildingWestWindowArea); " is 138.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The length of the statement  "	output.AppendLine ("Wall Area(m2)'" + buildingTotalExtWallArea.ToString () + "'" + buildingNorthExtWallArea.ToString () + "'" + buildingEastExtWallArea.ToString () + "'" + buildingSouthExtWallArea.ToString () + "'" + buildingWestExtWallArea.ToString ()); " is 254.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The length of the statement  "	output.AppendLine ("Window Area(m2)'" + buildingTotalExtWindowArea.ToString () + "'" + buildingNorthWindowArea.ToString () + "'" + buildingEastWindowArea.ToString () + "'" + buildingSouthWindowArea.ToString () + "'" + buildingWestWindowArea.ToString ()); " is 254.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "	List<ModelingUtilities.BuildingObjects.MemorySafe_Surface> foundSurfaces = new List<ModelingUtilities.BuildingObjects.MemorySafe_Surface> (); " is 141.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) { " is 187.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "			string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt; " is 141.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "			if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) { " is 187.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "					output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ()); " is 219.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "					output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ()); " is 219.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "					output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ()); " is 219.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "					output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ()); " is 219.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "	double buildingWWR = (buildingEastWindowArea + buildingNorthWindowArea + buildingSouthWindowArea + buildingWestWindowArea) / (buildingEastExtWallArea + buildingNorthExtWallArea + buildingSouthExtWallArea + buildingWestExtWallArea); " is 231.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "	double buildingTotalExtWallArea = (buildingEastExtWallArea + buildingNorthExtWallArea + buildingSouthExtWallArea + buildingWestExtWallArea); " is 140.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "	double buildingTotalExtWindowArea = (buildingEastWindowArea + buildingNorthWindowArea + buildingSouthWindowArea + buildingWestWindowArea); " is 138.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "	output.AppendLine ("Wall Area(m2)'" + buildingTotalExtWallArea.ToString () + "'" + buildingNorthExtWallArea.ToString () + "'" + buildingEastExtWallArea.ToString () + "'" + buildingSouthExtWallArea.ToString () + "'" + buildingWestExtWallArea.ToString ()); " is 254.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The length of the statement  "	output.AppendLine ("Window Area(m2)'" + buildingTotalExtWindowArea.ToString () + "'" + buildingNorthWindowArea.ToString () + "'" + buildingEastWindowArea.ToString () + "'" + buildingSouthWindowArea.ToString () + "'" + buildingWestWindowArea.ToString ()); " is 254.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MatchIDFFileSpaces,The length of the statement  "			//this function hinges on the names being the same for the spaces in both files.  Used to compare two spaces of similar size " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MatchIDFFileSpaces,The length of the statement  "								logline.AppendLine ("Coordinate match' X: " + coord.X.ToString () + "Y: " + coord.Y.ToString () + "Z: " + coord.Z.ToString ()); " is 127.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MatchIDFFileSpaces,The length of the statement  "								//could not find a coordinate match for the given coordinate' this fails the surface' but this does not mean the test fails " is 123.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MatchIDFFileSpaces,The length of the statement  "								//logline.AppendLine("Could not find match for coordinate X: " + coord.X.ToString() + "Y: " + coord.Y.ToString() + "Z: " + coord.Z.ToString()); " is 143.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MatchIDFFileSpaces,The length of the statement  "								//I could try and break out of the whole routine at this point' because I could not find a coordinate match for a given coordinate  " is 130.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MatchIDFFileSpaces,The length of the statement  "						//if the coordinate match count is good' it kicks us to here' but could also be reached when the coordinate matching is not successful " is 134.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MatchIDFFileSpaces,The length of the statement  "							logline.AppendLine ("No space name match found for : " + idf1Spaces [i].name + ".  Surfaces could not be matched' though name matched."); " is 137.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeStripWindow,The length of the statement  "									ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces); " is 126.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The length of the statement  "	//ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = new ModelingUtilities.BuildingObjects.OpeningDefinitions(); " is 134.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The length of the statement  "						ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings); " is 126.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The length of the statement  "								ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces); " is 126.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The length of the statement  "												newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The length of the statement  "														newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The length of the statement  "															makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound"); " is 121.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The length of the statement  "														ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier); " is 168.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The length of the statement  "											makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound"); " is 121.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	ModelingUtilities.BuildingObjects.OpeningDefinitions newOpening = new ModelingUtilities.BuildingObjects.OpeningDefinitions (currentOpening); " is 140.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.nameId + "_AD_" + windowCount.ToString () + "'    " + EPlusObjects.TagEndings.DetFenEndings.Name); " is 137.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.openingType + "'                 " + EPlusObjects.TagEndings.DetFenEndings.Type); " is 120.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.constructionName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.ConstName); " is 130.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.parentSurfaceNameId + "'                 " + EPlusObjects.TagEndings.DetFenEndings.BldSurfName); " is 135.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.outsideBoundaryConditionObj + "'                 " + EPlusObjects.TagEndings.DetFenEndings.OutsideBound); " is 144.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.viewFactortoGround + "'                 " + EPlusObjects.TagEndings.DetFenEndings.viewFactor); " is 133.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.shadeControlSch + "'                 " + EPlusObjects.TagEndings.DetFenEndings.shadeControl); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.frameAndDividerName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.frameAndDivider); " is 139.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.multiplier + "'                 " + EPlusObjects.TagEndings.DetFenEndings.multiplier); " is 125.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.numVertices + "'                 " + EPlusObjects.TagEndings.DetFenEndings.numberVertices); " is 130.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newOpening = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (currentOpening); " is 162.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.nameId + "_AD_" + windowCount.ToString () + "'    " + EPlusObjects.TagEndings.DetFenEndings.Name); " is 137.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.openingType + "'                 " + EPlusObjects.TagEndings.DetFenEndings.Type); " is 120.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.constructionName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.ConstName); " is 130.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.parentSurfaceNameId + "'                 " + EPlusObjects.TagEndings.DetFenEndings.BldSurfName); " is 135.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.outsideBoundaryConditionObj + "'                 " + EPlusObjects.TagEndings.DetFenEndings.OutsideBound); " is 144.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.viewFactortoGround + "'                 " + EPlusObjects.TagEndings.DetFenEndings.viewFactor); " is 133.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.shadeControlSch + "'                 " + EPlusObjects.TagEndings.DetFenEndings.shadeControl); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.frameAndDividerName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.frameAndDivider); " is 139.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.multiplier + "'                 " + EPlusObjects.TagEndings.DetFenEndings.multiplier); " is 125.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.numVertices + "'                 " + EPlusObjects.TagEndings.DetFenEndings.numberVertices); " is 130.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newOpening = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (currentOpening); " is 162.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.nameId + "_AD_" + windowCount.ToString () + "'    " + EPlusObjects.TagEndings.DetFenEndings.Name); " is 137.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.openingType + "'                 " + EPlusObjects.TagEndings.DetFenEndings.Type); " is 120.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.constructionName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.ConstName); " is 130.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.parentSurfaceNameId + "'                 " + EPlusObjects.TagEndings.DetFenEndings.BldSurfName); " is 135.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.outsideBoundaryConditionObj + "'                 " + EPlusObjects.TagEndings.DetFenEndings.OutsideBound); " is 144.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.viewFactortoGround + "'                 " + EPlusObjects.TagEndings.DetFenEndings.viewFactor); " is 133.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.shadeControlSch + "'                 " + EPlusObjects.TagEndings.DetFenEndings.shadeControl); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.frameAndDividerName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.frameAndDivider); " is 139.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.multiplier + "'                 " + EPlusObjects.TagEndings.DetFenEndings.multiplier); " is 125.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowDuplicates,The length of the statement  "	output.AppendLine ("    " + newOpening.numVertices + "'                 " + EPlusObjects.TagEndings.DetFenEndings.numberVertices); " is 130.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The length of the statement  "									output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}"); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The length of the statement  "									output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}"); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The length of the statement  "										output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}"); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The length of the statement  "										output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}"); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The length of the statement  "									output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}"); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The length of the statement  "									output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}"); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The length of the statement  "										output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}"); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The length of the statement  "										output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}"); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The length of the statement  "	ModelingUtilities.BuildingObjects.OpeningDefinitions tempOpening = new ModelingUtilities.BuildingObjects.OpeningDefinitions (); " is 127.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The length of the statement  "					ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings); " is 142.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The length of the statement  "					ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces); " is 140.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The length of the statement  "	ModelingUtilities.BuildingObjects.OpeningDefinitions tempCurrentOpening = new ModelingUtilities.BuildingObjects.OpeningDefinitions (); " is 134.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The length of the statement  "					ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings); " is 142.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The length of the statement  "					ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces); " is 140.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The length of the statement  "									output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer); " is 128.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedDaylightWindow,The length of the statement  "	ModelingUtilities.BuildingObjects.OpeningDefinitions dlOpening = new ModelingUtilities.BuildingObjects.OpeningDefinitions (currentOpening); " is 139.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.constructionName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.ConstName); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.parentSurfaceNameId + "'                 " + EPlusObjects.TagEndings.DetFenEndings.BldSurfName); " is 134.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.outsideBoundaryConditionObj + "'                 " + EPlusObjects.TagEndings.DetFenEndings.OutsideBound); " is 143.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.viewFactortoGround + "'                 " + EPlusObjects.TagEndings.DetFenEndings.viewFactor); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.shadeControlSch + "'                 " + EPlusObjects.TagEndings.DetFenEndings.shadeControl); " is 131.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.frameAndDividerName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.frameAndDivider); " is 138.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.multiplier + "'                 " + EPlusObjects.TagEndings.DetFenEndings.multiplier); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.numVertices + "'                 " + EPlusObjects.TagEndings.DetFenEndings.numberVertices); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions dlOpening = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (currentOpening); " is 161.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.constructionName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.ConstName); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.parentSurfaceNameId + "'                 " + EPlusObjects.TagEndings.DetFenEndings.BldSurfName); " is 134.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.outsideBoundaryConditionObj + "'                 " + EPlusObjects.TagEndings.DetFenEndings.OutsideBound); " is 143.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.viewFactortoGround + "'                 " + EPlusObjects.TagEndings.DetFenEndings.viewFactor); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.shadeControlSch + "'                 " + EPlusObjects.TagEndings.DetFenEndings.shadeControl); " is 131.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.frameAndDividerName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.frameAndDivider); " is 138.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.multiplier + "'                 " + EPlusObjects.TagEndings.DetFenEndings.multiplier); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.numVertices + "'                 " + EPlusObjects.TagEndings.DetFenEndings.numberVertices); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	ModelingUtilities.BuildingObjects.OpeningDefinitions dlOpening = new ModelingUtilities.BuildingObjects.OpeningDefinitions (currentOpening); " is 139.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.constructionName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.ConstName); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.parentSurfaceNameId + "'                 " + EPlusObjects.TagEndings.DetFenEndings.BldSurfName); " is 134.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.outsideBoundaryConditionObj + "'                 " + EPlusObjects.TagEndings.DetFenEndings.OutsideBound); " is 143.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.viewFactortoGround + "'                 " + EPlusObjects.TagEndings.DetFenEndings.viewFactor); " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.shadeControlSch + "'                 " + EPlusObjects.TagEndings.DetFenEndings.shadeControl); " is 131.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.frameAndDividerName + "'                 " + EPlusObjects.TagEndings.DetFenEndings.frameAndDivider); " is 138.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.multiplier + "'                 " + EPlusObjects.TagEndings.DetFenEndings.multiplier); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeDaylightWindow,The length of the statement  "	output.AppendLine ("    " + dlOpening.numVertices + "'                 " + EPlusObjects.TagEndings.DetFenEndings.numberVertices); " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The length of the statement  "	//Check the parent coordinates relative to the window coordinates to figure out how the window coordinates should be reconstructed. " is 131.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The length of the statement  "					X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (windowCopyCount - 1) * localX.X + firstSpace * localX.X; " is 123.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The length of the statement  "					X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (windowCopyCount - 1) * localX.X + firstSpace * localX.X; " is 123.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The length of the statement  "					Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (windowCopyCount - 1) * localX.Y + firstSpace * localX.Y; " is 123.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The length of the statement  "					Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (windowCopyCount - 1) * localX.Y + firstSpace * localX.Y; " is 123.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The length of the statement  "					X = window.coordinateList [i].X - (((windowSpacing + windowWidth) * (windowCopyCount - 1)) * localX.X) - firstSpace * localX.X; " is 127.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The length of the statement  "					X = window.coordinateList [i].X - (((windowSpacing + windowWidth) * (windowCopyCount - 1)) * localX.X) - firstSpace * localX.X; " is 127.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The length of the statement  "					Y = window.coordinateList [i].Y - (((windowSpacing + windowWidth) * (windowCopyCount - 1)) * localX.Y) - firstSpace * localX.Y; " is 127.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The length of the statement  "					Y = window.coordinateList [i].Y - (((windowSpacing + windowWidth) * (windowCopyCount - 1)) * localX.Y) - firstSpace * localX.Y; " is 127.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The length of the statement  "		double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2); " is 124.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirection,The length of the statement  "	//now try and figure out whether you are going to be writing in the positive or negative direction on this new coordinate system " is 128.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirection,The length of the statement  "	//if the difference between the greater Y's is larger than the difference between the lesser Y's' then I move in positive direction. " is 132.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirection,The length of the statement  "	//write forward means that the new window coordinates are supposed to progress in the direction of the local X axis defined above. " is 130.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The length of the statement  "	//Points lie in the same plane if we can prove the vectors formed by these points are orthogonal' using the scalar triple product " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The length of the statement  "	makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4)); " is 155.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The length of the statement  "	//Points lie in the same plane if we can prove the vectors formed by these points are orthogonal' using the scalar triple product " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The length of the statement  "	makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4)); " is 155.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The length of the statement  "	//Points lie in the same plane if we can prove the vectors formed by these points are orthogonal' using the scalar triple product " is 129.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The length of the statement  "	makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4)); " is 155.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetParentSurface,The length of the statement  "	ModelingUtilities.BuildingObjects.MemorySafe_Surface emptySurface = new ModelingUtilities.BuildingObjects.MemorySafe_Surface (name' multiplier' SurfaceType' constName' ob' zoneName' outsideBC' sunExp' windExp' vF' numVert' sc' tilt' az); " is 237.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetOpeningfromStringId,The length of the statement  "	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions emptyOpening = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (nameId' openType' parentSurf' parentAz' parentTilt' oBCond' vF' shadeCntrlSch' coordList' az' tilt' RHR' constName' frameandDivider' mult' numVert' area); " is 302.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateRadSurfaceConstructions,The length of the statement  "				ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = EPlusFunctions.GetSurface (surfaceName' projectSurfaces); " is 120.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateRadSurfaceConstructions,The length of the statement  "				ModelingUtilities.BuildingObjects.MemorySafe_Surface neighboringSurface = EPlusFunctions.GetSurface (outsideBoundaryConditionObject' projectSurfaces); " is 150.
Long Statement,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateRadSurfaceConstructions,The length of the statement  "		//ModelingUtilities.BuildingObjects.MemorySafe_Surface currentSurface = new ModelingUtilities.BuildingObjects.Surface(); " is 120.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The conditional expression  "(normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The conditional expression  "(normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The conditional expression  "(normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The conditional expression  "(parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The conditional expression  "(azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The conditional expression  "(parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNormalQuadWallWidth,The conditional expression  "x1Filled && y1Filled && x2Filled && y2Filled"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNormalQuadWallWidth,The conditional expression  "x1Filled && y1Filled && x2Filled && y2Filled"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNormalQuadWallWidth,The conditional expression  "x1Filled && y1Filled && x2Filled && y2Filled"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNormalQuadWallWidth,The conditional expression  "x1Filled && y1Filled && x2Filled && y2Filled"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNormalQuadWindowWidth,The conditional expression  "x1Filled && y1Filled && x2Filled && y2Filled"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNormalQuadWindowWidth,The conditional expression  "x1Filled && y1Filled && x2Filled && y2Filled"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNormalQuadWindowWidth,The conditional expression  "x1Filled && y1Filled && x2Filled && y2Filled"  is complex.
Complex Conditional,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNormalQuadWindowWidth,The conditional expression  "x1Filled && y1Filled && x2Filled && y2Filled"  is complex.
Empty Catch Block,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSurfaceGroupObject,The method has an empty catch block.
Empty Catch Block,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateRadSurfaceConstructions,The method has an empty catch block.
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindTilt,The following statement contains a magic number: if (normalVector.X == upVector.X * -1 && normalVector.Y == upVector.Y * -1 && normalVector.Z == upVector.Z * -1) {  	calculatedTilt = 180;  	return calculatedTilt;  }  else {  	Vector.MemorySafe_CartVect tiltVector = Vector.CrossProduct (normalVector' upVector);  	double tiltVectorMagnitude = Vector.VectorMagnitude (tiltVector);  	calculatedTilt = Math.Round (Math.Asin (tiltVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedTilt;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindTilt,The following statement contains a magic number: if (normalVector.X == upVector.X * -1 && normalVector.Y == upVector.Y * -1 && normalVector.Z == upVector.Z * -1) {  	calculatedTilt = 180;  	return calculatedTilt;  }  else {  	Vector.MemorySafe_CartVect tiltVector = Vector.CrossProduct (normalVector' upVector);  	double tiltVectorMagnitude = Vector.VectorMagnitude (tiltVector);  	calculatedTilt = Math.Round (Math.Asin (tiltVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedTilt;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindTilt,The following statement contains a magic number: if (normalVector.X == upVector.X * -1 && normalVector.Y == upVector.Y * -1 && normalVector.Z == upVector.Z * -1) {  	calculatedTilt = 180;  	return calculatedTilt;  }  else {  	Vector.MemorySafe_CartVect tiltVector = Vector.CrossProduct (normalVector' upVector);  	double tiltVectorMagnitude = Vector.VectorMagnitude (tiltVector);  	calculatedTilt = Math.Round (Math.Asin (tiltVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedTilt;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindTilt,The following statement contains a magic number: calculatedTilt = 180;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindTilt,The following statement contains a magic number: calculatedTilt = Math.Round (Math.Asin (tiltVectorMagnitude) * 180 / Math.PI' 2);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindTilt,The following statement contains a magic number: calculatedTilt = Math.Round (Math.Asin (tiltVectorMagnitude) * 180 / Math.PI' 2);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) {  	//get azimuth:  cross product of normal vector x-y projection and northVector  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' northVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedAzimuth;  }  //second quadrant  else if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) {  	//get azimuth:  cross product of normal vector x-y projection and northVector  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' northVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedAzimuth;  }  //second quadrant  else if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) {  	//get azimuth:  cross product of normal vector x-y projection and northVector  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' northVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedAzimuth;  }  //second quadrant  else if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) {  	//get azimuth:  cross product of normal vector x-y projection and northVector  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' northVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedAzimuth;  }  //second quadrant  else if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) {  	//get azimuth:  cross product of normal vector x-y projection and northVector  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' northVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedAzimuth;  }  //second quadrant  else if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) {  	//get azimuth:  cross product of normal vector x-y projection and northVector  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' northVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedAzimuth;  }  //second quadrant  else if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) {  	//get azimuth:  cross product of normal vector x-y projection and northVector  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' northVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedAzimuth;  }  //second quadrant  else if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) {  	//get azimuth:  cross product of normal vector x-y projection and northVector  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' northVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedAzimuth;  }  //second quadrant  else if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) {  	//get azimuth:  cross product of normal vector x-y projection and northVector  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' northVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedAzimuth;  }  //second quadrant  else if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) {  	//get azimuth:  cross product of normal vector x-y projection and northVector  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' northVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedAzimuth;  }  //second quadrant  else if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X == 0 && normalVector.Y == 1) || (normalVector.X == 1 && normalVector.Y == 0) || (normalVector.X > 0 && normalVector.Y > 0)) {  	//get azimuth:  cross product of normal vector x-y projection and northVector  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' northVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  	return calculatedAzimuth;  }  //second quadrant  else if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if (normalVector.X < 0 && normalVector.Y > 0) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' westVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  	return calculatedAzimuth;  }  //quadrant 3  else if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 270;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X < 0 && normalVector.Y < 0) || (normalVector.X == -1 && normalVector.Y == 0)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' southVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  	return calculatedAzimuth;  }  //quadrant 4  else if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 180;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: if ((normalVector.X > 0 && normalVector.Y < 0) || (normalVector.X == 0 && normalVector.Y == -1)) {  	Vector.CartVect azVector = Vector.CrossProduct (normalVector' eastVector);  	double azVectorMagnitude = Vector.VectorMagnitude (azVector);  	//modification for when the vector is in different quadrants  	calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  	return calculatedAzimuth;  }  //this will happen to vectors that point straight down or straight up because we are only interested in the X-Y projection and set the Z to zero anyways  else if (normalVector.X == 0 && normalVector.Y == 0 && normalVector.Z == 0) {  	calculatedAzimuth = 0;  	return calculatedAzimuth;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,FindAzimuth,The following statement contains a magic number: calculatedAzimuth = Math.Round (Math.Asin (azVectorMagnitude) * 180 / Math.PI' 2) + 90;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: for (int line = 0; line < linestuff.Count; line++) {  	if (line == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.name = pure.Groups [2].Value.Trim ();  			continue;  		}  	}  	Match semicolon = scfound.Match (linestuff [line]);  	if (semicolon.Success) {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  	else {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: for (int line = 0; line < linestuff.Count; line++) {  	if (line == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.name = pure.Groups [2].Value.Trim ();  			continue;  		}  	}  	Match semicolon = scfound.Match (linestuff [line]);  	if (semicolon.Success) {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  	else {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: for (int line = 0; line < linestuff.Count; line++) {  	if (line == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.name = pure.Groups [2].Value.Trim ();  			continue;  		}  	}  	Match semicolon = scfound.Match (linestuff [line]);  	if (semicolon.Success) {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  	else {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: for (int line = 0; line < linestuff.Count; line++) {  	if (line == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.name = pure.Groups [2].Value.Trim ();  			continue;  		}  	}  	Match semicolon = scfound.Match (linestuff [line]);  	if (semicolon.Success) {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  	else {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: for (int line = 0; line < linestuff.Count; line++) {  	if (line == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.name = pure.Groups [2].Value.Trim ();  			continue;  		}  	}  	Match semicolon = scfound.Match (linestuff [line]);  	if (semicolon.Success) {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  	else {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: for (int line = 0; line < linestuff.Count; line++) {  	if (line == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.name = pure.Groups [2].Value.Trim ();  			continue;  		}  	}  	Match semicolon = scfound.Match (linestuff [line]);  	if (semicolon.Success) {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  	else {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: for (int line = 0; line < linestuff.Count; line++) {  	if (line == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.name = pure.Groups [2].Value.Trim ();  			continue;  		}  	}  	Match semicolon = scfound.Match (linestuff [line]);  	if (semicolon.Success) {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  	else {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: for (int line = 0; line < linestuff.Count; line++) {  	if (line == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.name = pure.Groups [2].Value.Trim ();  			continue;  		}  	}  	Match semicolon = scfound.Match (linestuff [line]);  	if (semicolon.Success) {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  	else {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: for (int line = 0; line < linestuff.Count; line++) {  	if (line == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.name = pure.Groups [2].Value.Trim ();  			continue;  		}  	}  	Match semicolon = scfound.Match (linestuff [line]);  	if (semicolon.Success) {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  	else {  		if (line % 2 == 1) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  		if (line % 2 == 0) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (linestuff [line]);  			if (pure.Success) {  				retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (line == 0) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retwindow.name = pure.Groups [2].Value.Trim ();  		continue;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (pure.Success) {  	retwindow.name = pure.Groups [2].Value.Trim ();  	continue;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: retwindow.name = pure.Groups [2].Value.Trim ();  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (semicolon.Success) {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  else {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (semicolon.Success) {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  else {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (semicolon.Success) {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  else {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (semicolon.Success) {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  else {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (semicolon.Success) {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  else {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (semicolon.Success) {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  else {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (semicolon.Success) {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  else {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (semicolon.Success) {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  else {  	if (line % 2 == 1) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  	if (line % 2 == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (line % 2 == 1) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (line % 2 == 1) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (pure.Success) {  	retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (line % 2 == 0) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (line % 2 == 0) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (pure.Success) {  	retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (line % 2 == 1) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (line % 2 == 1) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (pure.Success) {  	retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: retwindow.glazingLayers.Add (pure.Groups [2].Value.Trim ());  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (line % 2 == 0) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (line % 2 == 0) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: if (pure.Success) {  	retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeWindowConstruction,The following statement contains a magic number: retwindow.gasLayers.Add (pure.Groups [2].Value.Trim ());  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeOpaqueConstruction,The following statement contains a magic number: for (int line = 0; line < linestuff.Count; line++) {  	if (line == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retconst.name = pure.Groups [2].Value.Trim ();  		}  	}  	else {  		Match semimatch = semicolon.Match (linestuff [line]);  		string purify = "";  		if (semimatch.Success) {  			purify = @"(?'ws'\s*)(?'goods'.*)(?'semic';)";  		}  		else {  			purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		}  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retconst.layernames.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeOpaqueConstruction,The following statement contains a magic number: for (int line = 0; line < linestuff.Count; line++) {  	if (line == 0) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retconst.name = pure.Groups [2].Value.Trim ();  		}  	}  	else {  		Match semimatch = semicolon.Match (linestuff [line]);  		string purify = "";  		if (semimatch.Success) {  			purify = @"(?'ws'\s*)(?'goods'.*)(?'semic';)";  		}  		else {  			purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		}  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (linestuff [line]);  		if (pure.Success) {  			retconst.layernames.Add (pure.Groups [2].Value.Trim ());  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeOpaqueConstruction,The following statement contains a magic number: if (line == 0) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retconst.name = pure.Groups [2].Value.Trim ();  	}  }  else {  	Match semimatch = semicolon.Match (linestuff [line]);  	string purify = "";  	if (semimatch.Success) {  		purify = @"(?'ws'\s*)(?'goods'.*)(?'semic';)";  	}  	else {  		purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	}  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retconst.layernames.Add (pure.Groups [2].Value.Trim ());  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeOpaqueConstruction,The following statement contains a magic number: if (line == 0) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retconst.name = pure.Groups [2].Value.Trim ();  	}  }  else {  	Match semimatch = semicolon.Match (linestuff [line]);  	string purify = "";  	if (semimatch.Success) {  		purify = @"(?'ws'\s*)(?'goods'.*)(?'semic';)";  	}  	else {  		purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	}  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (linestuff [line]);  	if (pure.Success) {  		retconst.layernames.Add (pure.Groups [2].Value.Trim ());  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeOpaqueConstruction,The following statement contains a magic number: if (pure.Success) {  	retconst.name = pure.Groups [2].Value.Trim ();  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeOpaqueConstruction,The following statement contains a magic number: retconst.name = pure.Groups [2].Value.Trim ();  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeOpaqueConstruction,The following statement contains a magic number: if (pure.Success) {  	retconst.layernames.Add (pure.Groups [2].Value.Trim ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeOpaqueConstruction,The following statement contains a magic number: retconst.layernames.Add (pure.Groups [2].Value.Trim ());  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeYearWeekObject,The following statement contains a magic number: week.startday = Convert.ToInt16 (yrWeekStrings [2]);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeYearWeekObject,The following statement contains a magic number: week.endmonth = Convert.ToInt16 (yrWeekStrings [3]);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeYearWeekObject,The following statement contains a magic number: week.endday = Convert.ToInt16 (yrWeekStrings [4]);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeDayIntervalSchedule,The following statement contains a magic number: foreach (string line in stuff) {  	Match name = dayschedname.Match (line);  	if (name.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (name.Groups ["1"].Value);  		if (pure.Success) {  			dsint.Name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match schedlimits = dayschedtype.Match (line);  	if (schedlimits.Success) {  		var ret = Purify (schedlimits' "'");  		if (ret != null) {  			dsint.type = ret;  		}  		continue;  	}  	Match interpol = dayschedinterp.Match (line);  	if (interpol.Success) {  		var ret = Purify (interpol' "'");  		if (ret != null) {  			dsint.Interpolate = ret;  		}  		continue;  	}  	Match dyvals = dayschedvalsreg.Match (line);  	if (dyvals.Success) {  		List<decimal> temp = new List<decimal> ();  		string eptime = @"(?'hr'\d+)(?'colon':)(?'min'\d+)";  		Regex eptimereg = new Regex (eptime);  		Match eptimematch = eptimereg.Match (dyvals.Groups ["1"].Value.Trim ());  		if (eptimematch.Success) {  			decimal hr = Convert.ToDecimal (eptimematch.Groups ["hr"].Value);  			decimal min = Convert.ToDecimal (eptimematch.Groups ["min"].Value) / 60;  			//decimal time = Math.Round(hr + min'2);  			decimal time = hr + min;  			temp.Add (time);  			temp.Add (Convert.ToDecimal (dyvals.Groups ["2"].Value.Trim ()));  			dsint.timevals.Add (temp);  		}  		continue;  	}  	Match dyvalsend = dayschedvalsreglast.Match (line);  	if (dyvalsend.Success) {  		List<decimal> temp = new List<decimal> ();  		string eptime = @"(?'hr'\d+)(?'colon':)(?'min'\d+)";  		Regex eptimereg = new Regex (eptime);  		Match eptimematch = eptimereg.Match (dyvalsend.Groups ["1"].Value.Trim ());  		if (eptimematch.Success) {  			decimal hr = Convert.ToDecimal (eptimematch.Groups ["hr"].Value);  			decimal min = Convert.ToDecimal (eptimematch.Groups ["min"].Value) / 60;  			//decimal time = Math.Round(hr + min' 2);  			decimal time = hr + min;  			temp.Add (time);  			temp.Add (Convert.ToDecimal (dyvalsend.Groups ["2"].Value.Trim ()));  			dsint.timevals.Add (temp);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeDayIntervalSchedule,The following statement contains a magic number: foreach (string line in stuff) {  	Match name = dayschedname.Match (line);  	if (name.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (name.Groups ["1"].Value);  		if (pure.Success) {  			dsint.Name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match schedlimits = dayschedtype.Match (line);  	if (schedlimits.Success) {  		var ret = Purify (schedlimits' "'");  		if (ret != null) {  			dsint.type = ret;  		}  		continue;  	}  	Match interpol = dayschedinterp.Match (line);  	if (interpol.Success) {  		var ret = Purify (interpol' "'");  		if (ret != null) {  			dsint.Interpolate = ret;  		}  		continue;  	}  	Match dyvals = dayschedvalsreg.Match (line);  	if (dyvals.Success) {  		List<decimal> temp = new List<decimal> ();  		string eptime = @"(?'hr'\d+)(?'colon':)(?'min'\d+)";  		Regex eptimereg = new Regex (eptime);  		Match eptimematch = eptimereg.Match (dyvals.Groups ["1"].Value.Trim ());  		if (eptimematch.Success) {  			decimal hr = Convert.ToDecimal (eptimematch.Groups ["hr"].Value);  			decimal min = Convert.ToDecimal (eptimematch.Groups ["min"].Value) / 60;  			//decimal time = Math.Round(hr + min'2);  			decimal time = hr + min;  			temp.Add (time);  			temp.Add (Convert.ToDecimal (dyvals.Groups ["2"].Value.Trim ()));  			dsint.timevals.Add (temp);  		}  		continue;  	}  	Match dyvalsend = dayschedvalsreglast.Match (line);  	if (dyvalsend.Success) {  		List<decimal> temp = new List<decimal> ();  		string eptime = @"(?'hr'\d+)(?'colon':)(?'min'\d+)";  		Regex eptimereg = new Regex (eptime);  		Match eptimematch = eptimereg.Match (dyvalsend.Groups ["1"].Value.Trim ());  		if (eptimematch.Success) {  			decimal hr = Convert.ToDecimal (eptimematch.Groups ["hr"].Value);  			decimal min = Convert.ToDecimal (eptimematch.Groups ["min"].Value) / 60;  			//decimal time = Math.Round(hr + min' 2);  			decimal time = hr + min;  			temp.Add (time);  			temp.Add (Convert.ToDecimal (dyvalsend.Groups ["2"].Value.Trim ()));  			dsint.timevals.Add (temp);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeDayIntervalSchedule,The following statement contains a magic number: if (dyvals.Success) {  	List<decimal> temp = new List<decimal> ();  	string eptime = @"(?'hr'\d+)(?'colon':)(?'min'\d+)";  	Regex eptimereg = new Regex (eptime);  	Match eptimematch = eptimereg.Match (dyvals.Groups ["1"].Value.Trim ());  	if (eptimematch.Success) {  		decimal hr = Convert.ToDecimal (eptimematch.Groups ["hr"].Value);  		decimal min = Convert.ToDecimal (eptimematch.Groups ["min"].Value) / 60;  		//decimal time = Math.Round(hr + min'2);  		decimal time = hr + min;  		temp.Add (time);  		temp.Add (Convert.ToDecimal (dyvals.Groups ["2"].Value.Trim ()));  		dsint.timevals.Add (temp);  	}  	continue;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeDayIntervalSchedule,The following statement contains a magic number: if (eptimematch.Success) {  	decimal hr = Convert.ToDecimal (eptimematch.Groups ["hr"].Value);  	decimal min = Convert.ToDecimal (eptimematch.Groups ["min"].Value) / 60;  	//decimal time = Math.Round(hr + min'2);  	decimal time = hr + min;  	temp.Add (time);  	temp.Add (Convert.ToDecimal (dyvals.Groups ["2"].Value.Trim ()));  	dsint.timevals.Add (temp);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeDayIntervalSchedule,The following statement contains a magic number: if (dyvalsend.Success) {  	List<decimal> temp = new List<decimal> ();  	string eptime = @"(?'hr'\d+)(?'colon':)(?'min'\d+)";  	Regex eptimereg = new Regex (eptime);  	Match eptimematch = eptimereg.Match (dyvalsend.Groups ["1"].Value.Trim ());  	if (eptimematch.Success) {  		decimal hr = Convert.ToDecimal (eptimematch.Groups ["hr"].Value);  		decimal min = Convert.ToDecimal (eptimematch.Groups ["min"].Value) / 60;  		//decimal time = Math.Round(hr + min' 2);  		decimal time = hr + min;  		temp.Add (time);  		temp.Add (Convert.ToDecimal (dyvalsend.Groups ["2"].Value.Trim ()));  		dsint.timevals.Add (temp);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,makeDayIntervalSchedule,The following statement contains a magic number: if (eptimematch.Success) {  	decimal hr = Convert.ToDecimal (eptimematch.Groups ["hr"].Value);  	decimal min = Convert.ToDecimal (eptimematch.Groups ["min"].Value) / 60;  	//decimal time = Math.Round(hr + min' 2);  	decimal time = hr + min;  	temp.Add (time);  	temp.Add (Convert.ToDecimal (dyvalsend.Groups ["2"].Value.Trim ()));  	dsint.timevals.Add (temp);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		if (!vertexMatching) {  			Match surfaceNameMatch = surfaceNameRegex.Match (line);  			int matchstart' matchlength = -1;  			if (surfaceNameMatch.Success) {  				matchstart = surfaceNameMatch.Index;  				matchlength = surfaceNameMatch.Length;  				//strip off the whitespace and comma  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					currentSurface.name = pure.Groups ["goods"].Value;  					continue;  				}  			}  			//Get Surface Type  			Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  			if (surfaceTypeMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  				if (pure.Success) {  					string type = pure.Groups ["goods"].Value;  					type = type.ToLower ();  					if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  						currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  						continue;  					}  					else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  						currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  						continue;  					}  					else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  						currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  						continue;  					}  					else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  						currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  						continue;  					}  				}  			}  			//Get Construction Type  			Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  			if (constructionTypeMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  				if (pure.Success) {  					currentSurface.constructionName = pure.Groups ["goods"].Value;  					continue;  				}  			}  			//GetZone Name  			Match zoneNameMatch = surfaceZoneNameRegex.Match (line);  			if (zoneNameMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (zoneNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					currentSurface.zoneName = pure.Groups ["goods"].Value;  					continue;  				}  			}  			//GetOutside Boundary Name  			if (!outsideBoundaryMatched) {  				Match outsideBoundaryMatch = outsideBoundaryRegex.Match (line);  				if (outsideBoundaryMatch.Success)  				#region  				 {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (outsideBoundaryMatch.Groups ["1"].Value);  					if (pure.Success) {  						string type = pure.Groups ["goods"].Value;  						type = type.ToLower ();  						if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  							currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  							outsideBoundaryMatched = true;  						}  						else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  							currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  							outsideBoundaryMatched = true;  						}  						else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  							currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  							outsideBoundaryMatched = true;  						}  						else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  							currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  							outsideBoundaryMatched = true;  						}  						else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  							currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  							outsideBoundaryMatched = true;  						}  						else {  							currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  							outsideBoundaryMatched = true;  						}  						continue;  					}  				}  			}  			#endregion  			//Get Outside Boundary Condition Object  			Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match (line);  			if (outsideBoundaryConditionMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (outsideBoundaryConditionMatch.Groups ["1"].Value);  				if (pure.Success) {  					currentSurface.outsideBoundaryCondition = pure.Groups ["goods"].Value;  					continue;  				}  			}  			//Get Sun Exposure  			Match sunExposureMatch = sunExposureRegex.Match (line);  			if (sunExposureMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (sunExposureMatch.Groups ["1"].Value);  				if (pure.Success) {  					currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  					continue;  				}  			}  			//Get Wind Exposure  			Match windExposureMatch = windExposureRegex.Match (line);  			if (windExposureMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (windExposureMatch.Groups ["1"].Value);  				if (pure.Success) {  					currentSurface.windExposureVar = pure.Groups ["goods"].Value;  					continue;  				}  			}  			//View Factor  			Match viewFactorMatch = viewFactorRegex.Match (line);  			if (viewFactorMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (viewFactorMatch.Groups ["1"].Value);  				if (pure.Success) {  					if (pure.Groups ["goods"].Value == "AutoCalculate") {  						currentSurface.viewFactor = -999;  					}  					else {  						currentSurface.viewFactor = Convert.ToDouble (pure.Groups ["goods"].Value);  					}  					continue;  				}  			}  			//Number of Vertices  			Match numVerticesMatch = numberofVerticesRegex.Match (line);  			if (numVerticesMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (numVerticesMatch.Groups ["1"].Value);  				if (pure.Success) {  					currentSurface.numVertices = Convert.ToInt32 (pure.Groups ["goods"].Value);  					continue;  				}  			}  		}  		//Get Vertices  		//loop through them until the end  		Match vertexMatch = typicalVertexRegex.Match (line);  		if (vertexMatch.Success) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (vertexMatch.Groups ["1"].Value);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				Match XYZMatch = coordRegex.Match (pure.Groups ["goods"].Value);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	if (!vertexMatching) {  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Get Surface Type  		Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  		if (surfaceTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  					continue;  				}  			}  		}  		//Get Construction Type  		Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  		if (constructionTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.constructionName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//GetZone Name  		Match zoneNameMatch = surfaceZoneNameRegex.Match (line);  		if (zoneNameMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (zoneNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.zoneName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//GetOutside Boundary Name  		if (!outsideBoundaryMatched) {  			Match outsideBoundaryMatch = outsideBoundaryRegex.Match (line);  			if (outsideBoundaryMatch.Success)  			#region  			 {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (outsideBoundaryMatch.Groups ["1"].Value);  				if (pure.Success) {  					string type = pure.Groups ["goods"].Value;  					type = type.ToLower ();  					if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  						currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  						outsideBoundaryMatched = true;  					}  					else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  						currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  						outsideBoundaryMatched = true;  					}  					else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  						currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  						outsideBoundaryMatched = true;  					}  					else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  						currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  						outsideBoundaryMatched = true;  					}  					else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  						currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  						outsideBoundaryMatched = true;  					}  					else {  						currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  						outsideBoundaryMatched = true;  					}  					continue;  				}  			}  		}  		#endregion  		//Get Outside Boundary Condition Object  		Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match (line);  		if (outsideBoundaryConditionMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (outsideBoundaryConditionMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.outsideBoundaryCondition = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Get Sun Exposure  		Match sunExposureMatch = sunExposureRegex.Match (line);  		if (sunExposureMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (sunExposureMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Get Wind Exposure  		Match windExposureMatch = windExposureRegex.Match (line);  		if (windExposureMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (windExposureMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.windExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor  		Match viewFactorMatch = viewFactorRegex.Match (line);  		if (viewFactorMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (viewFactorMatch.Groups ["1"].Value);  			if (pure.Success) {  				if (pure.Groups ["goods"].Value == "AutoCalculate") {  					currentSurface.viewFactor = -999;  				}  				else {  					currentSurface.viewFactor = Convert.ToDouble (pure.Groups ["goods"].Value);  				}  				continue;  			}  		}  		//Number of Vertices  		Match numVerticesMatch = numberofVerticesRegex.Match (line);  		if (numVerticesMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (numVerticesMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.numVertices = Convert.ToInt32 (pure.Groups ["goods"].Value);  				continue;  			}  		}  	}  	//Get Vertices  	//loop through them until the end  	Match vertexMatch = typicalVertexRegex.Match (line);  	if (vertexMatch.Success) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (vertexMatch.Groups ["1"].Value);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			Match XYZMatch = coordRegex.Match (pure.Groups ["goods"].Value);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The following statement contains a magic number: if (!vertexMatching) {  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Get Surface Type  	Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  	if (surfaceTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  				continue;  			}  		}  	}  	//Get Construction Type  	Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  	if (constructionTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.constructionName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//GetZone Name  	Match zoneNameMatch = surfaceZoneNameRegex.Match (line);  	if (zoneNameMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (zoneNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.zoneName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//GetOutside Boundary Name  	if (!outsideBoundaryMatched) {  		Match outsideBoundaryMatch = outsideBoundaryRegex.Match (line);  		if (outsideBoundaryMatch.Success)  		#region  		 {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (outsideBoundaryMatch.Groups ["1"].Value);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  					outsideBoundaryMatched = true;  				}  				else {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  					outsideBoundaryMatched = true;  				}  				continue;  			}  		}  	}  	#endregion  	//Get Outside Boundary Condition Object  	Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match (line);  	if (outsideBoundaryConditionMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (outsideBoundaryConditionMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.outsideBoundaryCondition = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Get Sun Exposure  	Match sunExposureMatch = sunExposureRegex.Match (line);  	if (sunExposureMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (sunExposureMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Get Wind Exposure  	Match windExposureMatch = windExposureRegex.Match (line);  	if (windExposureMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (windExposureMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.windExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor  	Match viewFactorMatch = viewFactorRegex.Match (line);  	if (viewFactorMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (viewFactorMatch.Groups ["1"].Value);  		if (pure.Success) {  			if (pure.Groups ["goods"].Value == "AutoCalculate") {  				currentSurface.viewFactor = -999;  			}  			else {  				currentSurface.viewFactor = Convert.ToDouble (pure.Groups ["goods"].Value);  			}  			continue;  		}  	}  	//Number of Vertices  	Match numVerticesMatch = numberofVerticesRegex.Match (line);  	if (numVerticesMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (numVerticesMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.numVertices = Convert.ToInt32 (pure.Groups ["goods"].Value);  			continue;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The following statement contains a magic number: if (viewFactorMatch.Success) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (viewFactorMatch.Groups ["1"].Value);  	if (pure.Success) {  		if (pure.Groups ["goods"].Value == "AutoCalculate") {  			currentSurface.viewFactor = -999;  		}  		else {  			currentSurface.viewFactor = Convert.ToDouble (pure.Groups ["goods"].Value);  		}  		continue;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The following statement contains a magic number: if (pure.Success) {  	if (pure.Groups ["goods"].Value == "AutoCalculate") {  		currentSurface.viewFactor = -999;  	}  	else {  		currentSurface.viewFactor = Convert.ToDouble (pure.Groups ["goods"].Value);  	}  	continue;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The following statement contains a magic number: if (pure.Groups ["goods"].Value == "AutoCalculate") {  	currentSurface.viewFactor = -999;  }  else {  	currentSurface.viewFactor = Convert.ToDouble (pure.Groups ["goods"].Value);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,EPlusSurfacetoObject,The following statement contains a magic number: currentSurface.viewFactor = -999;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Get Surface Type  		Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  		if (surfaceTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  					continue;  				}  			}  		}  		//Get Construction Type  		Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  		if (constructionTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.constructionName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  		if (insideFaceEnvMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.zoneName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Outside Boundary condition lineCount = 6  		if (linecount == 6) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  					outsideBoundaryMatched = true;  				}  				else {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  					outsideBoundaryMatched = true;  				}  				continue;  			}  		}  		//Outside Boundary Condition Object lineCount = 7  		if (linecount == 7) {  			continue;  		}  		//SunExposure lineCount = 8  		if (linecount == 8) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//WindExposure lineCount = 9  		if (linecount == 9) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.windExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 10  		if (linecount == 10) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 11  		if (linecount == 11) {  			continue;  		}  		//next 12 lines //skip lineCount = 12  		if (linecount == 12) {  			continue;  		}  		//GetZone Name  		//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  		//if (zoneNameMatch.Success)  		//{  		//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//    Regex purifyRegex = new Regex(purify);  		//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  		//    if (pure.Success)  		//    {  		//        currentSurface.zoneName = pure.Groups["goods"].Value;  		//        continue;  		//    }  		//}  		//GetOutside Boundary Name  		//if (!outsideBoundaryMatched)  		//{  		//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  		//    if (outsideBoundaryMatch.Success)  		//    #region  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            string type = pure.Groups["goods"].Value;  		//            type = type.ToLower();  		//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  		//                outsideBoundaryMatched = true;  		//            }  		//            else  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  		//                outsideBoundaryMatched = true;  		//            }  		//            continue;  		//        }  		//    }  		//}  		#endregion  		//    //Get Outside Boundary Condition Object  		//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  		//    if (outsideBoundaryConditionMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Sun Exposure  		//    Match sunExposureMatch = sunExposureRegex.Match(line);  		//    if (sunExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Wind Exposure  		//    Match windExposureMatch = windExposureRegex.Match(line);  		//    if (windExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //View Factor  		//    Match viewFactorMatch = viewFactorRegex.Match(line);  		//    if (viewFactorMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            if (pure.Groups["goods"].Value == "AutoCalculate")  		//            {  		//                currentSurface.viewFactor = -999;  		//            }  		//            else  		//            {  		//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  		//            }  		//            continue;  		//        }  		//    }  		//    //Number of Vertices  		//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  		//    if (numVerticesMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  		//            continue;  		//        }  		//    }  		//}  		//Get Vertices  		//loop through them until the end  		if (linecount > 12) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Get Surface Type  		Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  		if (surfaceTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  					continue;  				}  			}  		}  		//Get Construction Type  		Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  		if (constructionTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.constructionName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  		if (insideFaceEnvMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.zoneName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Outside Boundary condition lineCount = 6  		if (linecount == 6) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  					outsideBoundaryMatched = true;  				}  				else {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  					outsideBoundaryMatched = true;  				}  				continue;  			}  		}  		//Outside Boundary Condition Object lineCount = 7  		if (linecount == 7) {  			continue;  		}  		//SunExposure lineCount = 8  		if (linecount == 8) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//WindExposure lineCount = 9  		if (linecount == 9) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.windExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 10  		if (linecount == 10) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 11  		if (linecount == 11) {  			continue;  		}  		//next 12 lines //skip lineCount = 12  		if (linecount == 12) {  			continue;  		}  		//GetZone Name  		//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  		//if (zoneNameMatch.Success)  		//{  		//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//    Regex purifyRegex = new Regex(purify);  		//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  		//    if (pure.Success)  		//    {  		//        currentSurface.zoneName = pure.Groups["goods"].Value;  		//        continue;  		//    }  		//}  		//GetOutside Boundary Name  		//if (!outsideBoundaryMatched)  		//{  		//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  		//    if (outsideBoundaryMatch.Success)  		//    #region  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            string type = pure.Groups["goods"].Value;  		//            type = type.ToLower();  		//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  		//                outsideBoundaryMatched = true;  		//            }  		//            else  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  		//                outsideBoundaryMatched = true;  		//            }  		//            continue;  		//        }  		//    }  		//}  		#endregion  		//    //Get Outside Boundary Condition Object  		//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  		//    if (outsideBoundaryConditionMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Sun Exposure  		//    Match sunExposureMatch = sunExposureRegex.Match(line);  		//    if (sunExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Wind Exposure  		//    Match windExposureMatch = windExposureRegex.Match(line);  		//    if (windExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //View Factor  		//    Match viewFactorMatch = viewFactorRegex.Match(line);  		//    if (viewFactorMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            if (pure.Groups["goods"].Value == "AutoCalculate")  		//            {  		//                currentSurface.viewFactor = -999;  		//            }  		//            else  		//            {  		//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  		//            }  		//            continue;  		//        }  		//    }  		//    //Number of Vertices  		//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  		//    if (numVerticesMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  		//            continue;  		//        }  		//    }  		//}  		//Get Vertices  		//loop through them until the end  		if (linecount > 12) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Get Surface Type  		Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  		if (surfaceTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  					continue;  				}  			}  		}  		//Get Construction Type  		Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  		if (constructionTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.constructionName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  		if (insideFaceEnvMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.zoneName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Outside Boundary condition lineCount = 6  		if (linecount == 6) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  					outsideBoundaryMatched = true;  				}  				else {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  					outsideBoundaryMatched = true;  				}  				continue;  			}  		}  		//Outside Boundary Condition Object lineCount = 7  		if (linecount == 7) {  			continue;  		}  		//SunExposure lineCount = 8  		if (linecount == 8) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//WindExposure lineCount = 9  		if (linecount == 9) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.windExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 10  		if (linecount == 10) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 11  		if (linecount == 11) {  			continue;  		}  		//next 12 lines //skip lineCount = 12  		if (linecount == 12) {  			continue;  		}  		//GetZone Name  		//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  		//if (zoneNameMatch.Success)  		//{  		//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//    Regex purifyRegex = new Regex(purify);  		//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  		//    if (pure.Success)  		//    {  		//        currentSurface.zoneName = pure.Groups["goods"].Value;  		//        continue;  		//    }  		//}  		//GetOutside Boundary Name  		//if (!outsideBoundaryMatched)  		//{  		//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  		//    if (outsideBoundaryMatch.Success)  		//    #region  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            string type = pure.Groups["goods"].Value;  		//            type = type.ToLower();  		//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  		//                outsideBoundaryMatched = true;  		//            }  		//            else  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  		//                outsideBoundaryMatched = true;  		//            }  		//            continue;  		//        }  		//    }  		//}  		#endregion  		//    //Get Outside Boundary Condition Object  		//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  		//    if (outsideBoundaryConditionMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Sun Exposure  		//    Match sunExposureMatch = sunExposureRegex.Match(line);  		//    if (sunExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Wind Exposure  		//    Match windExposureMatch = windExposureRegex.Match(line);  		//    if (windExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //View Factor  		//    Match viewFactorMatch = viewFactorRegex.Match(line);  		//    if (viewFactorMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            if (pure.Groups["goods"].Value == "AutoCalculate")  		//            {  		//                currentSurface.viewFactor = -999;  		//            }  		//            else  		//            {  		//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  		//            }  		//            continue;  		//        }  		//    }  		//    //Number of Vertices  		//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  		//    if (numVerticesMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  		//            continue;  		//        }  		//    }  		//}  		//Get Vertices  		//loop through them until the end  		if (linecount > 12) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Get Surface Type  		Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  		if (surfaceTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  					continue;  				}  			}  		}  		//Get Construction Type  		Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  		if (constructionTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.constructionName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  		if (insideFaceEnvMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.zoneName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Outside Boundary condition lineCount = 6  		if (linecount == 6) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  					outsideBoundaryMatched = true;  				}  				else {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  					outsideBoundaryMatched = true;  				}  				continue;  			}  		}  		//Outside Boundary Condition Object lineCount = 7  		if (linecount == 7) {  			continue;  		}  		//SunExposure lineCount = 8  		if (linecount == 8) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//WindExposure lineCount = 9  		if (linecount == 9) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.windExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 10  		if (linecount == 10) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 11  		if (linecount == 11) {  			continue;  		}  		//next 12 lines //skip lineCount = 12  		if (linecount == 12) {  			continue;  		}  		//GetZone Name  		//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  		//if (zoneNameMatch.Success)  		//{  		//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//    Regex purifyRegex = new Regex(purify);  		//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  		//    if (pure.Success)  		//    {  		//        currentSurface.zoneName = pure.Groups["goods"].Value;  		//        continue;  		//    }  		//}  		//GetOutside Boundary Name  		//if (!outsideBoundaryMatched)  		//{  		//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  		//    if (outsideBoundaryMatch.Success)  		//    #region  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            string type = pure.Groups["goods"].Value;  		//            type = type.ToLower();  		//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  		//                outsideBoundaryMatched = true;  		//            }  		//            else  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  		//                outsideBoundaryMatched = true;  		//            }  		//            continue;  		//        }  		//    }  		//}  		#endregion  		//    //Get Outside Boundary Condition Object  		//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  		//    if (outsideBoundaryConditionMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Sun Exposure  		//    Match sunExposureMatch = sunExposureRegex.Match(line);  		//    if (sunExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Wind Exposure  		//    Match windExposureMatch = windExposureRegex.Match(line);  		//    if (windExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //View Factor  		//    Match viewFactorMatch = viewFactorRegex.Match(line);  		//    if (viewFactorMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            if (pure.Groups["goods"].Value == "AutoCalculate")  		//            {  		//                currentSurface.viewFactor = -999;  		//            }  		//            else  		//            {  		//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  		//            }  		//            continue;  		//        }  		//    }  		//    //Number of Vertices  		//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  		//    if (numVerticesMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  		//            continue;  		//        }  		//    }  		//}  		//Get Vertices  		//loop through them until the end  		if (linecount > 12) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Get Surface Type  		Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  		if (surfaceTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  					continue;  				}  			}  		}  		//Get Construction Type  		Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  		if (constructionTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.constructionName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  		if (insideFaceEnvMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.zoneName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Outside Boundary condition lineCount = 6  		if (linecount == 6) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  					outsideBoundaryMatched = true;  				}  				else {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  					outsideBoundaryMatched = true;  				}  				continue;  			}  		}  		//Outside Boundary Condition Object lineCount = 7  		if (linecount == 7) {  			continue;  		}  		//SunExposure lineCount = 8  		if (linecount == 8) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//WindExposure lineCount = 9  		if (linecount == 9) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.windExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 10  		if (linecount == 10) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 11  		if (linecount == 11) {  			continue;  		}  		//next 12 lines //skip lineCount = 12  		if (linecount == 12) {  			continue;  		}  		//GetZone Name  		//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  		//if (zoneNameMatch.Success)  		//{  		//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//    Regex purifyRegex = new Regex(purify);  		//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  		//    if (pure.Success)  		//    {  		//        currentSurface.zoneName = pure.Groups["goods"].Value;  		//        continue;  		//    }  		//}  		//GetOutside Boundary Name  		//if (!outsideBoundaryMatched)  		//{  		//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  		//    if (outsideBoundaryMatch.Success)  		//    #region  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            string type = pure.Groups["goods"].Value;  		//            type = type.ToLower();  		//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  		//                outsideBoundaryMatched = true;  		//            }  		//            else  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  		//                outsideBoundaryMatched = true;  		//            }  		//            continue;  		//        }  		//    }  		//}  		#endregion  		//    //Get Outside Boundary Condition Object  		//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  		//    if (outsideBoundaryConditionMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Sun Exposure  		//    Match sunExposureMatch = sunExposureRegex.Match(line);  		//    if (sunExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Wind Exposure  		//    Match windExposureMatch = windExposureRegex.Match(line);  		//    if (windExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //View Factor  		//    Match viewFactorMatch = viewFactorRegex.Match(line);  		//    if (viewFactorMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            if (pure.Groups["goods"].Value == "AutoCalculate")  		//            {  		//                currentSurface.viewFactor = -999;  		//            }  		//            else  		//            {  		//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  		//            }  		//            continue;  		//        }  		//    }  		//    //Number of Vertices  		//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  		//    if (numVerticesMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  		//            continue;  		//        }  		//    }  		//}  		//Get Vertices  		//loop through them until the end  		if (linecount > 12) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Get Surface Type  		Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  		if (surfaceTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  					continue;  				}  			}  		}  		//Get Construction Type  		Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  		if (constructionTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.constructionName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  		if (insideFaceEnvMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.zoneName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Outside Boundary condition lineCount = 6  		if (linecount == 6) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  					outsideBoundaryMatched = true;  				}  				else {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  					outsideBoundaryMatched = true;  				}  				continue;  			}  		}  		//Outside Boundary Condition Object lineCount = 7  		if (linecount == 7) {  			continue;  		}  		//SunExposure lineCount = 8  		if (linecount == 8) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//WindExposure lineCount = 9  		if (linecount == 9) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.windExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 10  		if (linecount == 10) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 11  		if (linecount == 11) {  			continue;  		}  		//next 12 lines //skip lineCount = 12  		if (linecount == 12) {  			continue;  		}  		//GetZone Name  		//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  		//if (zoneNameMatch.Success)  		//{  		//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//    Regex purifyRegex = new Regex(purify);  		//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  		//    if (pure.Success)  		//    {  		//        currentSurface.zoneName = pure.Groups["goods"].Value;  		//        continue;  		//    }  		//}  		//GetOutside Boundary Name  		//if (!outsideBoundaryMatched)  		//{  		//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  		//    if (outsideBoundaryMatch.Success)  		//    #region  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            string type = pure.Groups["goods"].Value;  		//            type = type.ToLower();  		//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  		//                outsideBoundaryMatched = true;  		//            }  		//            else  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  		//                outsideBoundaryMatched = true;  		//            }  		//            continue;  		//        }  		//    }  		//}  		#endregion  		//    //Get Outside Boundary Condition Object  		//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  		//    if (outsideBoundaryConditionMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Sun Exposure  		//    Match sunExposureMatch = sunExposureRegex.Match(line);  		//    if (sunExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Wind Exposure  		//    Match windExposureMatch = windExposureRegex.Match(line);  		//    if (windExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //View Factor  		//    Match viewFactorMatch = viewFactorRegex.Match(line);  		//    if (viewFactorMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            if (pure.Groups["goods"].Value == "AutoCalculate")  		//            {  		//                currentSurface.viewFactor = -999;  		//            }  		//            else  		//            {  		//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  		//            }  		//            continue;  		//        }  		//    }  		//    //Number of Vertices  		//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  		//    if (numVerticesMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  		//            continue;  		//        }  		//    }  		//}  		//Get Vertices  		//loop through them until the end  		if (linecount > 12) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Get Surface Type  		Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  		if (surfaceTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  					continue;  				}  			}  		}  		//Get Construction Type  		Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  		if (constructionTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.constructionName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  		if (insideFaceEnvMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.zoneName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Outside Boundary condition lineCount = 6  		if (linecount == 6) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  					outsideBoundaryMatched = true;  				}  				else {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  					outsideBoundaryMatched = true;  				}  				continue;  			}  		}  		//Outside Boundary Condition Object lineCount = 7  		if (linecount == 7) {  			continue;  		}  		//SunExposure lineCount = 8  		if (linecount == 8) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//WindExposure lineCount = 9  		if (linecount == 9) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.windExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 10  		if (linecount == 10) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 11  		if (linecount == 11) {  			continue;  		}  		//next 12 lines //skip lineCount = 12  		if (linecount == 12) {  			continue;  		}  		//GetZone Name  		//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  		//if (zoneNameMatch.Success)  		//{  		//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//    Regex purifyRegex = new Regex(purify);  		//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  		//    if (pure.Success)  		//    {  		//        currentSurface.zoneName = pure.Groups["goods"].Value;  		//        continue;  		//    }  		//}  		//GetOutside Boundary Name  		//if (!outsideBoundaryMatched)  		//{  		//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  		//    if (outsideBoundaryMatch.Success)  		//    #region  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            string type = pure.Groups["goods"].Value;  		//            type = type.ToLower();  		//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  		//                outsideBoundaryMatched = true;  		//            }  		//            else  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  		//                outsideBoundaryMatched = true;  		//            }  		//            continue;  		//        }  		//    }  		//}  		#endregion  		//    //Get Outside Boundary Condition Object  		//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  		//    if (outsideBoundaryConditionMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Sun Exposure  		//    Match sunExposureMatch = sunExposureRegex.Match(line);  		//    if (sunExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Wind Exposure  		//    Match windExposureMatch = windExposureRegex.Match(line);  		//    if (windExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //View Factor  		//    Match viewFactorMatch = viewFactorRegex.Match(line);  		//    if (viewFactorMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            if (pure.Groups["goods"].Value == "AutoCalculate")  		//            {  		//                currentSurface.viewFactor = -999;  		//            }  		//            else  		//            {  		//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  		//            }  		//            continue;  		//        }  		//    }  		//    //Number of Vertices  		//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  		//    if (numVerticesMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  		//            continue;  		//        }  		//    }  		//}  		//Get Vertices  		//loop through them until the end  		if (linecount > 12) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Get Surface Type  		Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  		if (surfaceTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  					continue;  				}  				else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  					currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  					continue;  				}  			}  		}  		//Get Construction Type  		Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  		if (constructionTypeMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.constructionName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  		if (insideFaceEnvMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.zoneName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//Outside Boundary condition lineCount = 6  		if (linecount == 6) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				string type = pure.Groups ["goods"].Value;  				type = type.ToLower ();  				if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  					outsideBoundaryMatched = true;  				}  				else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  					outsideBoundaryMatched = true;  				}  				else {  					currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  					outsideBoundaryMatched = true;  				}  				continue;  			}  		}  		//Outside Boundary Condition Object lineCount = 7  		if (linecount == 7) {  			continue;  		}  		//SunExposure lineCount = 8  		if (linecount == 8) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//WindExposure lineCount = 9  		if (linecount == 9) {  			string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (commapurify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				currentSurface.windExposureVar = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 10  		if (linecount == 10) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 11  		if (linecount == 11) {  			continue;  		}  		//next 12 lines //skip lineCount = 12  		if (linecount == 12) {  			continue;  		}  		//GetZone Name  		//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  		//if (zoneNameMatch.Success)  		//{  		//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//    Regex purifyRegex = new Regex(purify);  		//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  		//    if (pure.Success)  		//    {  		//        currentSurface.zoneName = pure.Groups["goods"].Value;  		//        continue;  		//    }  		//}  		//GetOutside Boundary Name  		//if (!outsideBoundaryMatched)  		//{  		//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  		//    if (outsideBoundaryMatch.Success)  		//    #region  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            string type = pure.Groups["goods"].Value;  		//            type = type.ToLower();  		//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  		//                outsideBoundaryMatched = true;  		//            }  		//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  		//                outsideBoundaryMatched = true;  		//            }  		//            else  		//            {  		//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  		//                outsideBoundaryMatched = true;  		//            }  		//            continue;  		//        }  		//    }  		//}  		#endregion  		//    //Get Outside Boundary Condition Object  		//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  		//    if (outsideBoundaryConditionMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Sun Exposure  		//    Match sunExposureMatch = sunExposureRegex.Match(line);  		//    if (sunExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //Get Wind Exposure  		//    Match windExposureMatch = windExposureRegex.Match(line);  		//    if (windExposureMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  		//            continue;  		//        }  		//    }  		//    //View Factor  		//    Match viewFactorMatch = viewFactorRegex.Match(line);  		//    if (viewFactorMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            if (pure.Groups["goods"].Value == "AutoCalculate")  		//            {  		//                currentSurface.viewFactor = -999;  		//            }  		//            else  		//            {  		//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  		//            }  		//            continue;  		//        }  		//    }  		//    //Number of Vertices  		//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  		//    if (numVerticesMatch.Success)  		//    {  		//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		//        Regex purifyRegex = new Regex(purify);  		//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  		//        if (pure.Success)  		//        {  		//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  		//            continue;  		//        }  		//    }  		//}  		//Get Vertices  		//loop through them until the end  		if (linecount > 12) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Get Surface Type  	Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  	if (surfaceTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  				continue;  			}  		}  	}  	//Get Construction Type  	Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  	if (constructionTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.constructionName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  	if (insideFaceEnvMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.zoneName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Outside Boundary condition lineCount = 6  	if (linecount == 6) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  				outsideBoundaryMatched = true;  			}  			else {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  				outsideBoundaryMatched = true;  			}  			continue;  		}  	}  	//Outside Boundary Condition Object lineCount = 7  	if (linecount == 7) {  		continue;  	}  	//SunExposure lineCount = 8  	if (linecount == 8) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//WindExposure lineCount = 9  	if (linecount == 9) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.windExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 10  	if (linecount == 10) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 11  	if (linecount == 11) {  		continue;  	}  	//next 12 lines //skip lineCount = 12  	if (linecount == 12) {  		continue;  	}  	//GetZone Name  	//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  	//if (zoneNameMatch.Success)  	//{  	//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//    Regex purifyRegex = new Regex(purify);  	//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  	//    if (pure.Success)  	//    {  	//        currentSurface.zoneName = pure.Groups["goods"].Value;  	//        continue;  	//    }  	//}  	//GetOutside Boundary Name  	//if (!outsideBoundaryMatched)  	//{  	//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  	//    if (outsideBoundaryMatch.Success)  	//    #region  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            string type = pure.Groups["goods"].Value;  	//            type = type.ToLower();  	//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  	//                outsideBoundaryMatched = true;  	//            }  	//            else  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  	//                outsideBoundaryMatched = true;  	//            }  	//            continue;  	//        }  	//    }  	//}  	#endregion  	//    //Get Outside Boundary Condition Object  	//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  	//    if (outsideBoundaryConditionMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Sun Exposure  	//    Match sunExposureMatch = sunExposureRegex.Match(line);  	//    if (sunExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Wind Exposure  	//    Match windExposureMatch = windExposureRegex.Match(line);  	//    if (windExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //View Factor  	//    Match viewFactorMatch = viewFactorRegex.Match(line);  	//    if (viewFactorMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            if (pure.Groups["goods"].Value == "AutoCalculate")  	//            {  	//                currentSurface.viewFactor = -999;  	//            }  	//            else  	//            {  	//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  	//            }  	//            continue;  	//        }  	//    }  	//    //Number of Vertices  	//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  	//    if (numVerticesMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  	//            continue;  	//        }  	//    }  	//}  	//Get Vertices  	//loop through them until the end  	if (linecount > 12) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Get Surface Type  	Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  	if (surfaceTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  				continue;  			}  		}  	}  	//Get Construction Type  	Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  	if (constructionTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.constructionName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  	if (insideFaceEnvMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.zoneName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Outside Boundary condition lineCount = 6  	if (linecount == 6) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  				outsideBoundaryMatched = true;  			}  			else {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  				outsideBoundaryMatched = true;  			}  			continue;  		}  	}  	//Outside Boundary Condition Object lineCount = 7  	if (linecount == 7) {  		continue;  	}  	//SunExposure lineCount = 8  	if (linecount == 8) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//WindExposure lineCount = 9  	if (linecount == 9) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.windExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 10  	if (linecount == 10) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 11  	if (linecount == 11) {  		continue;  	}  	//next 12 lines //skip lineCount = 12  	if (linecount == 12) {  		continue;  	}  	//GetZone Name  	//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  	//if (zoneNameMatch.Success)  	//{  	//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//    Regex purifyRegex = new Regex(purify);  	//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  	//    if (pure.Success)  	//    {  	//        currentSurface.zoneName = pure.Groups["goods"].Value;  	//        continue;  	//    }  	//}  	//GetOutside Boundary Name  	//if (!outsideBoundaryMatched)  	//{  	//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  	//    if (outsideBoundaryMatch.Success)  	//    #region  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            string type = pure.Groups["goods"].Value;  	//            type = type.ToLower();  	//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  	//                outsideBoundaryMatched = true;  	//            }  	//            else  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  	//                outsideBoundaryMatched = true;  	//            }  	//            continue;  	//        }  	//    }  	//}  	#endregion  	//    //Get Outside Boundary Condition Object  	//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  	//    if (outsideBoundaryConditionMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Sun Exposure  	//    Match sunExposureMatch = sunExposureRegex.Match(line);  	//    if (sunExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Wind Exposure  	//    Match windExposureMatch = windExposureRegex.Match(line);  	//    if (windExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //View Factor  	//    Match viewFactorMatch = viewFactorRegex.Match(line);  	//    if (viewFactorMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            if (pure.Groups["goods"].Value == "AutoCalculate")  	//            {  	//                currentSurface.viewFactor = -999;  	//            }  	//            else  	//            {  	//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  	//            }  	//            continue;  	//        }  	//    }  	//    //Number of Vertices  	//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  	//    if (numVerticesMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  	//            continue;  	//        }  	//    }  	//}  	//Get Vertices  	//loop through them until the end  	if (linecount > 12) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Get Surface Type  	Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  	if (surfaceTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  				continue;  			}  		}  	}  	//Get Construction Type  	Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  	if (constructionTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.constructionName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  	if (insideFaceEnvMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.zoneName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Outside Boundary condition lineCount = 6  	if (linecount == 6) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  				outsideBoundaryMatched = true;  			}  			else {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  				outsideBoundaryMatched = true;  			}  			continue;  		}  	}  	//Outside Boundary Condition Object lineCount = 7  	if (linecount == 7) {  		continue;  	}  	//SunExposure lineCount = 8  	if (linecount == 8) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//WindExposure lineCount = 9  	if (linecount == 9) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.windExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 10  	if (linecount == 10) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 11  	if (linecount == 11) {  		continue;  	}  	//next 12 lines //skip lineCount = 12  	if (linecount == 12) {  		continue;  	}  	//GetZone Name  	//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  	//if (zoneNameMatch.Success)  	//{  	//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//    Regex purifyRegex = new Regex(purify);  	//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  	//    if (pure.Success)  	//    {  	//        currentSurface.zoneName = pure.Groups["goods"].Value;  	//        continue;  	//    }  	//}  	//GetOutside Boundary Name  	//if (!outsideBoundaryMatched)  	//{  	//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  	//    if (outsideBoundaryMatch.Success)  	//    #region  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            string type = pure.Groups["goods"].Value;  	//            type = type.ToLower();  	//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  	//                outsideBoundaryMatched = true;  	//            }  	//            else  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  	//                outsideBoundaryMatched = true;  	//            }  	//            continue;  	//        }  	//    }  	//}  	#endregion  	//    //Get Outside Boundary Condition Object  	//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  	//    if (outsideBoundaryConditionMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Sun Exposure  	//    Match sunExposureMatch = sunExposureRegex.Match(line);  	//    if (sunExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Wind Exposure  	//    Match windExposureMatch = windExposureRegex.Match(line);  	//    if (windExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //View Factor  	//    Match viewFactorMatch = viewFactorRegex.Match(line);  	//    if (viewFactorMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            if (pure.Groups["goods"].Value == "AutoCalculate")  	//            {  	//                currentSurface.viewFactor = -999;  	//            }  	//            else  	//            {  	//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  	//            }  	//            continue;  	//        }  	//    }  	//    //Number of Vertices  	//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  	//    if (numVerticesMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  	//            continue;  	//        }  	//    }  	//}  	//Get Vertices  	//loop through them until the end  	if (linecount > 12) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Get Surface Type  	Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  	if (surfaceTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  				continue;  			}  		}  	}  	//Get Construction Type  	Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  	if (constructionTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.constructionName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  	if (insideFaceEnvMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.zoneName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Outside Boundary condition lineCount = 6  	if (linecount == 6) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  				outsideBoundaryMatched = true;  			}  			else {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  				outsideBoundaryMatched = true;  			}  			continue;  		}  	}  	//Outside Boundary Condition Object lineCount = 7  	if (linecount == 7) {  		continue;  	}  	//SunExposure lineCount = 8  	if (linecount == 8) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//WindExposure lineCount = 9  	if (linecount == 9) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.windExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 10  	if (linecount == 10) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 11  	if (linecount == 11) {  		continue;  	}  	//next 12 lines //skip lineCount = 12  	if (linecount == 12) {  		continue;  	}  	//GetZone Name  	//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  	//if (zoneNameMatch.Success)  	//{  	//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//    Regex purifyRegex = new Regex(purify);  	//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  	//    if (pure.Success)  	//    {  	//        currentSurface.zoneName = pure.Groups["goods"].Value;  	//        continue;  	//    }  	//}  	//GetOutside Boundary Name  	//if (!outsideBoundaryMatched)  	//{  	//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  	//    if (outsideBoundaryMatch.Success)  	//    #region  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            string type = pure.Groups["goods"].Value;  	//            type = type.ToLower();  	//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  	//                outsideBoundaryMatched = true;  	//            }  	//            else  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  	//                outsideBoundaryMatched = true;  	//            }  	//            continue;  	//        }  	//    }  	//}  	#endregion  	//    //Get Outside Boundary Condition Object  	//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  	//    if (outsideBoundaryConditionMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Sun Exposure  	//    Match sunExposureMatch = sunExposureRegex.Match(line);  	//    if (sunExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Wind Exposure  	//    Match windExposureMatch = windExposureRegex.Match(line);  	//    if (windExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //View Factor  	//    Match viewFactorMatch = viewFactorRegex.Match(line);  	//    if (viewFactorMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            if (pure.Groups["goods"].Value == "AutoCalculate")  	//            {  	//                currentSurface.viewFactor = -999;  	//            }  	//            else  	//            {  	//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  	//            }  	//            continue;  	//        }  	//    }  	//    //Number of Vertices  	//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  	//    if (numVerticesMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  	//            continue;  	//        }  	//    }  	//}  	//Get Vertices  	//loop through them until the end  	if (linecount > 12) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Get Surface Type  	Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  	if (surfaceTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  				continue;  			}  		}  	}  	//Get Construction Type  	Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  	if (constructionTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.constructionName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  	if (insideFaceEnvMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.zoneName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Outside Boundary condition lineCount = 6  	if (linecount == 6) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  				outsideBoundaryMatched = true;  			}  			else {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  				outsideBoundaryMatched = true;  			}  			continue;  		}  	}  	//Outside Boundary Condition Object lineCount = 7  	if (linecount == 7) {  		continue;  	}  	//SunExposure lineCount = 8  	if (linecount == 8) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//WindExposure lineCount = 9  	if (linecount == 9) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.windExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 10  	if (linecount == 10) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 11  	if (linecount == 11) {  		continue;  	}  	//next 12 lines //skip lineCount = 12  	if (linecount == 12) {  		continue;  	}  	//GetZone Name  	//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  	//if (zoneNameMatch.Success)  	//{  	//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//    Regex purifyRegex = new Regex(purify);  	//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  	//    if (pure.Success)  	//    {  	//        currentSurface.zoneName = pure.Groups["goods"].Value;  	//        continue;  	//    }  	//}  	//GetOutside Boundary Name  	//if (!outsideBoundaryMatched)  	//{  	//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  	//    if (outsideBoundaryMatch.Success)  	//    #region  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            string type = pure.Groups["goods"].Value;  	//            type = type.ToLower();  	//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  	//                outsideBoundaryMatched = true;  	//            }  	//            else  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  	//                outsideBoundaryMatched = true;  	//            }  	//            continue;  	//        }  	//    }  	//}  	#endregion  	//    //Get Outside Boundary Condition Object  	//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  	//    if (outsideBoundaryConditionMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Sun Exposure  	//    Match sunExposureMatch = sunExposureRegex.Match(line);  	//    if (sunExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Wind Exposure  	//    Match windExposureMatch = windExposureRegex.Match(line);  	//    if (windExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //View Factor  	//    Match viewFactorMatch = viewFactorRegex.Match(line);  	//    if (viewFactorMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            if (pure.Groups["goods"].Value == "AutoCalculate")  	//            {  	//                currentSurface.viewFactor = -999;  	//            }  	//            else  	//            {  	//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  	//            }  	//            continue;  	//        }  	//    }  	//    //Number of Vertices  	//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  	//    if (numVerticesMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  	//            continue;  	//        }  	//    }  	//}  	//Get Vertices  	//loop through them until the end  	if (linecount > 12) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Get Surface Type  	Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  	if (surfaceTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  				continue;  			}  		}  	}  	//Get Construction Type  	Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  	if (constructionTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.constructionName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  	if (insideFaceEnvMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.zoneName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Outside Boundary condition lineCount = 6  	if (linecount == 6) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  				outsideBoundaryMatched = true;  			}  			else {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  				outsideBoundaryMatched = true;  			}  			continue;  		}  	}  	//Outside Boundary Condition Object lineCount = 7  	if (linecount == 7) {  		continue;  	}  	//SunExposure lineCount = 8  	if (linecount == 8) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//WindExposure lineCount = 9  	if (linecount == 9) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.windExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 10  	if (linecount == 10) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 11  	if (linecount == 11) {  		continue;  	}  	//next 12 lines //skip lineCount = 12  	if (linecount == 12) {  		continue;  	}  	//GetZone Name  	//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  	//if (zoneNameMatch.Success)  	//{  	//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//    Regex purifyRegex = new Regex(purify);  	//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  	//    if (pure.Success)  	//    {  	//        currentSurface.zoneName = pure.Groups["goods"].Value;  	//        continue;  	//    }  	//}  	//GetOutside Boundary Name  	//if (!outsideBoundaryMatched)  	//{  	//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  	//    if (outsideBoundaryMatch.Success)  	//    #region  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            string type = pure.Groups["goods"].Value;  	//            type = type.ToLower();  	//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  	//                outsideBoundaryMatched = true;  	//            }  	//            else  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  	//                outsideBoundaryMatched = true;  	//            }  	//            continue;  	//        }  	//    }  	//}  	#endregion  	//    //Get Outside Boundary Condition Object  	//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  	//    if (outsideBoundaryConditionMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Sun Exposure  	//    Match sunExposureMatch = sunExposureRegex.Match(line);  	//    if (sunExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Wind Exposure  	//    Match windExposureMatch = windExposureRegex.Match(line);  	//    if (windExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //View Factor  	//    Match viewFactorMatch = viewFactorRegex.Match(line);  	//    if (viewFactorMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            if (pure.Groups["goods"].Value == "AutoCalculate")  	//            {  	//                currentSurface.viewFactor = -999;  	//            }  	//            else  	//            {  	//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  	//            }  	//            continue;  	//        }  	//    }  	//    //Number of Vertices  	//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  	//    if (numVerticesMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  	//            continue;  	//        }  	//    }  	//}  	//Get Vertices  	//loop through them until the end  	if (linecount > 12) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Get Surface Type  	Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  	if (surfaceTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  				continue;  			}  		}  	}  	//Get Construction Type  	Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  	if (constructionTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.constructionName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  	if (insideFaceEnvMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.zoneName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Outside Boundary condition lineCount = 6  	if (linecount == 6) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  				outsideBoundaryMatched = true;  			}  			else {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  				outsideBoundaryMatched = true;  			}  			continue;  		}  	}  	//Outside Boundary Condition Object lineCount = 7  	if (linecount == 7) {  		continue;  	}  	//SunExposure lineCount = 8  	if (linecount == 8) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//WindExposure lineCount = 9  	if (linecount == 9) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.windExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 10  	if (linecount == 10) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 11  	if (linecount == 11) {  		continue;  	}  	//next 12 lines //skip lineCount = 12  	if (linecount == 12) {  		continue;  	}  	//GetZone Name  	//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  	//if (zoneNameMatch.Success)  	//{  	//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//    Regex purifyRegex = new Regex(purify);  	//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  	//    if (pure.Success)  	//    {  	//        currentSurface.zoneName = pure.Groups["goods"].Value;  	//        continue;  	//    }  	//}  	//GetOutside Boundary Name  	//if (!outsideBoundaryMatched)  	//{  	//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  	//    if (outsideBoundaryMatch.Success)  	//    #region  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            string type = pure.Groups["goods"].Value;  	//            type = type.ToLower();  	//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  	//                outsideBoundaryMatched = true;  	//            }  	//            else  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  	//                outsideBoundaryMatched = true;  	//            }  	//            continue;  	//        }  	//    }  	//}  	#endregion  	//    //Get Outside Boundary Condition Object  	//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  	//    if (outsideBoundaryConditionMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Sun Exposure  	//    Match sunExposureMatch = sunExposureRegex.Match(line);  	//    if (sunExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Wind Exposure  	//    Match windExposureMatch = windExposureRegex.Match(line);  	//    if (windExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //View Factor  	//    Match viewFactorMatch = viewFactorRegex.Match(line);  	//    if (viewFactorMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            if (pure.Groups["goods"].Value == "AutoCalculate")  	//            {  	//                currentSurface.viewFactor = -999;  	//            }  	//            else  	//            {  	//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  	//            }  	//            continue;  	//        }  	//    }  	//    //Number of Vertices  	//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  	//    if (numVerticesMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  	//            continue;  	//        }  	//    }  	//}  	//Get Vertices  	//loop through them until the end  	if (linecount > 12) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Get Surface Type  	Match surfaceTypeMatch = surfaceTypeRegex.Match (line);  	if (surfaceTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.SurfaceTypes.Ceiling.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Ceiling;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Floor.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Floor;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Roof.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Roof;  				continue;  			}  			else if (type == EPlusObjects.Surface.SurfaceTypes.Wall.ToString ().ToLower ()) {  				currentSurface.surfaceType = ModelingUtilities.BuildingObjects.SurfaceTypes.Wall;  				continue;  			}  		}  	}  	//Get Construction Type  	Match constructionTypeMatch = surfaceConstructionNameRegex.Match (line);  	if (constructionTypeMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (constructionTypeMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.constructionName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match insideFaceEnvMatch = surfaceInsideBoundsRegex.Match (line);  	if (insideFaceEnvMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (insideFaceEnvMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.zoneName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//Outside Boundary condition lineCount = 6  	if (linecount == 6) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			string type = pure.Groups ["goods"].Value;  			type = type.ToLower ();  			if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  				outsideBoundaryMatched = true;  			}  			else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  				outsideBoundaryMatched = true;  			}  			else {  				currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  				outsideBoundaryMatched = true;  			}  			continue;  		}  	}  	//Outside Boundary Condition Object lineCount = 7  	if (linecount == 7) {  		continue;  	}  	//SunExposure lineCount = 8  	if (linecount == 8) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//WindExposure lineCount = 9  	if (linecount == 9) {  		string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (commapurify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			currentSurface.windExposureVar = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 10  	if (linecount == 10) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 11  	if (linecount == 11) {  		continue;  	}  	//next 12 lines //skip lineCount = 12  	if (linecount == 12) {  		continue;  	}  	//GetZone Name  	//Match zoneNameMatch = surfaceZoneNameRegex.Match(line);  	//if (zoneNameMatch.Success)  	//{  	//    string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//    Regex purifyRegex = new Regex(purify);  	//    Match pure = purifyRegex.Match(zoneNameMatch.Groups["1"].Value);  	//    if (pure.Success)  	//    {  	//        currentSurface.zoneName = pure.Groups["goods"].Value;  	//        continue;  	//    }  	//}  	//GetOutside Boundary Name  	//if (!outsideBoundaryMatched)  	//{  	//    Match outsideBoundaryMatch = outsideBoundaryRegex.Match(line);  	//    if (outsideBoundaryMatch.Success)  	//    #region  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            string type = pure.Groups["goods"].Value;  	//            type = type.ToLower();  	//            if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  	//                outsideBoundaryMatched = true;  	//            }  	//            else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString().ToLower())  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  	//                outsideBoundaryMatched = true;  	//            }  	//            else  	//            {  	//                currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  	//                outsideBoundaryMatched = true;  	//            }  	//            continue;  	//        }  	//    }  	//}  	#endregion  	//    //Get Outside Boundary Condition Object  	//    Match outsideBoundaryConditionMatch = outsideBoundaryConditionRegex.Match(line);  	//    if (outsideBoundaryConditionMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(outsideBoundaryConditionMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.outsideBoundaryCondition = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Sun Exposure  	//    Match sunExposureMatch = sunExposureRegex.Match(line);  	//    if (sunExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(sunExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.sunExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //Get Wind Exposure  	//    Match windExposureMatch = windExposureRegex.Match(line);  	//    if (windExposureMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(windExposureMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.windExposureVar = pure.Groups["goods"].Value;  	//            continue;  	//        }  	//    }  	//    //View Factor  	//    Match viewFactorMatch = viewFactorRegex.Match(line);  	//    if (viewFactorMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(viewFactorMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            if (pure.Groups["goods"].Value == "AutoCalculate")  	//            {  	//                currentSurface.viewFactor = -999;  	//            }  	//            else  	//            {  	//                currentSurface.viewFactor = Convert.ToDouble(pure.Groups["goods"].Value);  	//            }  	//            continue;  	//        }  	//    }  	//    //Number of Vertices  	//    Match numVerticesMatch = numberofVerticesRegex.Match(line);  	//    if (numVerticesMatch.Success)  	//    {  	//        string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	//        Regex purifyRegex = new Regex(purify);  	//        Match pure = purifyRegex.Match(numVerticesMatch.Groups["1"].Value);  	//        if (pure.Success)  	//        {  	//            currentSurface.numVertices = Convert.ToInt32(pure.Groups["goods"].Value);  	//            continue;  	//        }  	//    }  	//}  	//Get Vertices  	//loop through them until the end  	if (linecount > 12) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (linecount == 6) {  	string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (commapurify);  	Match pure = purifyRegex.Match (line);  	if (pure.Success) {  		string type = pure.Groups ["goods"].Value;  		type = type.ToLower ();  		if (type == EPlusObjects.Surface.OutsideBoundary.Ground.ToString ().ToLower ()) {  			currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Ground;  			outsideBoundaryMatched = true;  		}  		else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideCoefficients.ToString ().ToLower ()) {  			currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideCoefficients;  			outsideBoundaryMatched = true;  		}  		else if (type == EPlusObjects.Surface.OutsideBoundary.OtherSideConditionsModel.ToString ().ToLower ()) {  			currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.OtherSideConditionsModel;  			outsideBoundaryMatched = true;  		}  		else if (type == EPlusObjects.Surface.OutsideBoundary.Outdoors.ToString ().ToLower ()) {  			currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors;  			outsideBoundaryMatched = true;  		}  		else if (type == EPlusObjects.Surface.OutsideBoundary.Surface.ToString ().ToLower ()) {  			currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Surface;  			outsideBoundaryMatched = true;  		}  		else {  			currentSurface.outsideBoundary = ModelingUtilities.BuildingObjects.OutsideBoundary.Zone;  			outsideBoundaryMatched = true;  		}  		continue;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (linecount == 7) {  	continue;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (linecount == 8) {  	string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (commapurify);  	Match pure = purifyRegex.Match (line);  	if (pure.Success) {  		currentSurface.sunExposureVar = pure.Groups ["goods"].Value;  		continue;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (linecount == 9) {  	string commapurify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (commapurify);  	Match pure = purifyRegex.Match (line);  	if (pure.Success) {  		currentSurface.windExposureVar = pure.Groups ["goods"].Value;  		continue;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (linecount == 10) {  	continue;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (linecount == 11) {  	continue;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (linecount == 12) {  	continue;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusSurfacetoObject,The following statement contains a magic number: if (linecount > 12) {  	vertexMatching = true;  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (line);  	if (pure.Success) {  		//extract the X'Y' and Z coordinate from the purified string  		//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  		string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  		Regex coordRegex = new Regex (coordinateString);  		string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  		Match XYZMatch = coordRegex.Match (coords);  		if (XYZMatch.Success) {  			Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  			surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  			surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  			surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  			currentSurface.SurfaceCoords.Add (surfaceCoord);  		}  	}  	//see if there is a semi-colon  	Match smicolonMatch = smicln.Match (line);  	if (smicolonMatch.Success) {  		semicolonfound = true;  		vertexMatching = false;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 3  		if (linecount == 3) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 4  		if (linecount == 4) {  			continue;  		}  		//next 12 lines //skip lineCount = 5  		if (linecount == 5) {  			continue;  		}  		#endregion  		if (linecount > 5) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 3  		if (linecount == 3) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 4  		if (linecount == 4) {  			continue;  		}  		//next 12 lines //skip lineCount = 5  		if (linecount == 5) {  			continue;  		}  		#endregion  		if (linecount > 5) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 3  		if (linecount == 3) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 4  		if (linecount == 4) {  			continue;  		}  		//next 12 lines //skip lineCount = 5  		if (linecount == 5) {  			continue;  		}  		#endregion  		if (linecount > 5) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: foreach (string line in detailedSurfaceString) {  	linecount++;  	#region  	MatchCollection surfaceStart = surfaceYes.Matches (line);  	if (surfaceStart.Count > 0) {  		detailedsurface = true;  		continue;  	}  	//now that a surface element is established in the IDF' we can work through it to create surface objects  	if (detailedsurface == true) {  		//Surface Name  		//get the name in the file  		Match surfaceNameMatch = surfaceNameRegex.Match (line);  		int matchstart' matchlength = -1;  		if (surfaceNameMatch.Success) {  			matchstart = surfaceNameMatch.Index;  			matchlength = surfaceNameMatch.Length;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentSurface.name = pure.Groups ["goods"].Value;  				continue;  			}  		}  		//View Factor (skipping) lineCount = 3  		if (linecount == 3) {  			continue;  		}  		//PolyGon vertices (skipping) lineCount = 4  		if (linecount == 4) {  			continue;  		}  		//next 12 lines //skip lineCount = 5  		if (linecount == 5) {  			continue;  		}  		#endregion  		if (linecount > 5) {  			vertexMatching = true;  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (line);  			if (pure.Success) {  				//extract the X'Y' and Z coordinate from the purified string  				//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  				string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  				Regex coordRegex = new Regex (coordinateString);  				string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  				Match XYZMatch = coordRegex.Match (coords);  				if (XYZMatch.Success) {  					Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  					surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  					surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  					surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  					currentSurface.SurfaceCoords.Add (surfaceCoord);  				}  			}  			//see if there is a semi-colon  			Match smicolonMatch = smicln.Match (line);  			if (smicolonMatch.Success) {  				semicolonfound = true;  				vertexMatching = false;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 3  	if (linecount == 3) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 4  	if (linecount == 4) {  		continue;  	}  	//next 12 lines //skip lineCount = 5  	if (linecount == 5) {  		continue;  	}  	#endregion  	if (linecount > 5) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 3  	if (linecount == 3) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 4  	if (linecount == 4) {  		continue;  	}  	//next 12 lines //skip lineCount = 5  	if (linecount == 5) {  		continue;  	}  	#endregion  	if (linecount > 5) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 3  	if (linecount == 3) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 4  	if (linecount == 4) {  		continue;  	}  	//next 12 lines //skip lineCount = 5  	if (linecount == 5) {  		continue;  	}  	#endregion  	if (linecount > 5) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: if (detailedsurface == true) {  	//Surface Name  	//get the name in the file  	Match surfaceNameMatch = surfaceNameRegex.Match (line);  	int matchstart' matchlength = -1;  	if (surfaceNameMatch.Success) {  		matchstart = surfaceNameMatch.Index;  		matchlength = surfaceNameMatch.Length;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentSurface.name = pure.Groups ["goods"].Value;  			continue;  		}  	}  	//View Factor (skipping) lineCount = 3  	if (linecount == 3) {  		continue;  	}  	//PolyGon vertices (skipping) lineCount = 4  	if (linecount == 4) {  		continue;  	}  	//next 12 lines //skip lineCount = 5  	if (linecount == 5) {  		continue;  	}  	#endregion  	if (linecount > 5) {  		vertexMatching = true;  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (line);  		if (pure.Success) {  			//extract the X'Y' and Z coordinate from the purified string  			//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  			string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  			Regex coordRegex = new Regex (coordinateString);  			string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  			Match XYZMatch = coordRegex.Match (coords);  			if (XYZMatch.Success) {  				Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  				surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  				surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  				surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  				currentSurface.SurfaceCoords.Add (surfaceCoord);  			}  		}  		//see if there is a semi-colon  		Match smicolonMatch = smicln.Match (line);  		if (smicolonMatch.Success) {  			semicolonfound = true;  			vertexMatching = false;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: if (linecount == 3) {  	continue;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: if (linecount == 4) {  	continue;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: if (linecount == 5) {  	continue;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ADEPlusShadetoObject,The following statement contains a magic number: if (linecount > 5) {  	vertexMatching = true;  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (line);  	if (pure.Success) {  		//extract the X'Y' and Z coordinate from the purified string  		//string coordinateString = @"(?'X'[-]\d+[\.]\d+|\d+)'(?'Y'[-]\d+[\.]\d+|\d+)'(?'Z'[-]\d+[\.]\d+|\d+)";  		string coordinateString = @"(?'X'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Y'[-+]?([0-9]*\.[0-9]+|[0-9]+))'(?'Z'[-+]?([0-9]*\.[0-9]+|[0-9]+))";  		Regex coordRegex = new Regex (coordinateString);  		string coords = pure.Groups ["goods"].Value.Replace (" "' string.Empty);  		Match XYZMatch = coordRegex.Match (coords);  		if (XYZMatch.Success) {  			Vector.CartCoord surfaceCoord = new Vector.CartCoord ();  			surfaceCoord.X = Convert.ToDouble (XYZMatch.Groups ["X"].Value);  			surfaceCoord.Y = Convert.ToDouble (XYZMatch.Groups ["Y"].Value);  			surfaceCoord.Z = Convert.ToDouble (XYZMatch.Groups ["Z"].Value);  			currentSurface.SurfaceCoords.Add (surfaceCoord);  		}  	}  	//see if there is a semi-colon  	Match smicolonMatch = smicln.Match (line);  	if (smicolonMatch.Success) {  		semicolonfound = true;  		vertexMatching = false;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			bool surfaceMatch = false;  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingNorthWindowArea += windowarea;  						if (buildingNorthExtWallArea == 0)  							buildingNorthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingNorthExtWallArea += wallarea;  					buildingNorthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingEastWindowArea += windowarea;  						if (buildingEastExtWallArea == 0)  							buildingEastExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingEastExtWallArea += wallarea;  					buildingEastWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingSouthWindowArea += windowarea;  						if (buildingSouthExtWallArea == 0)  							buildingSouthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingSouthExtWallArea += wallarea;  					buildingSouthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingWestWindowArea += windowarea;  						if (buildingWestExtWallArea == 0)  							buildingWestExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingWestExtWallArea += wallarea;  					buildingWestWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			bool surfaceMatch = false;  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingNorthWindowArea += windowarea;  						if (buildingNorthExtWallArea == 0)  							buildingNorthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingNorthExtWallArea += wallarea;  					buildingNorthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingEastWindowArea += windowarea;  						if (buildingEastExtWallArea == 0)  							buildingEastExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingEastExtWallArea += wallarea;  					buildingEastWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingSouthWindowArea += windowarea;  						if (buildingSouthExtWallArea == 0)  							buildingSouthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingSouthExtWallArea += wallarea;  					buildingSouthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingWestWindowArea += windowarea;  						if (buildingWestExtWallArea == 0)  							buildingWestExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingWestExtWallArea += wallarea;  					buildingWestWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			bool surfaceMatch = false;  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingNorthWindowArea += windowarea;  						if (buildingNorthExtWallArea == 0)  							buildingNorthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingNorthExtWallArea += wallarea;  					buildingNorthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingEastWindowArea += windowarea;  						if (buildingEastExtWallArea == 0)  							buildingEastExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingEastExtWallArea += wallarea;  					buildingEastWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingSouthWindowArea += windowarea;  						if (buildingSouthExtWallArea == 0)  							buildingSouthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingSouthExtWallArea += wallarea;  					buildingSouthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingWestWindowArea += windowarea;  						if (buildingWestExtWallArea == 0)  							buildingWestExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingWestExtWallArea += wallarea;  					buildingWestWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			bool surfaceMatch = false;  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingNorthWindowArea += windowarea;  						if (buildingNorthExtWallArea == 0)  							buildingNorthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingNorthExtWallArea += wallarea;  					buildingNorthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingEastWindowArea += windowarea;  						if (buildingEastExtWallArea == 0)  							buildingEastExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingEastExtWallArea += wallarea;  					buildingEastWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingSouthWindowArea += windowarea;  						if (buildingSouthExtWallArea == 0)  							buildingSouthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingSouthExtWallArea += wallarea;  					buildingSouthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingWestWindowArea += windowarea;  						if (buildingWestExtWallArea == 0)  							buildingWestExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingWestExtWallArea += wallarea;  					buildingWestWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			bool surfaceMatch = false;  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingNorthWindowArea += windowarea;  						if (buildingNorthExtWallArea == 0)  							buildingNorthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingNorthExtWallArea += wallarea;  					buildingNorthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingEastWindowArea += windowarea;  						if (buildingEastExtWallArea == 0)  							buildingEastExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingEastExtWallArea += wallarea;  					buildingEastWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingSouthWindowArea += windowarea;  						if (buildingSouthExtWallArea == 0)  							buildingSouthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingSouthExtWallArea += wallarea;  					buildingSouthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingWestWindowArea += windowarea;  						if (buildingWestExtWallArea == 0)  							buildingWestExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingWestExtWallArea += wallarea;  					buildingWestWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			bool surfaceMatch = false;  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingNorthWindowArea += windowarea;  						if (buildingNorthExtWallArea == 0)  							buildingNorthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingNorthExtWallArea += wallarea;  					buildingNorthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingEastWindowArea += windowarea;  						if (buildingEastExtWallArea == 0)  							buildingEastExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingEastExtWallArea += wallarea;  					buildingEastWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingSouthWindowArea += windowarea;  						if (buildingSouthExtWallArea == 0)  							buildingSouthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingSouthExtWallArea += wallarea;  					buildingSouthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingWestWindowArea += windowarea;  						if (buildingWestExtWallArea == 0)  							buildingWestExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingWestExtWallArea += wallarea;  					buildingWestWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			bool surfaceMatch = false;  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingNorthWindowArea += windowarea;  						if (buildingNorthExtWallArea == 0)  							buildingNorthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingNorthExtWallArea += wallarea;  					buildingNorthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingEastWindowArea += windowarea;  						if (buildingEastExtWallArea == 0)  							buildingEastExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingEastExtWallArea += wallarea;  					buildingEastWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingSouthWindowArea += windowarea;  						if (buildingSouthExtWallArea == 0)  							buildingSouthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingSouthExtWallArea += wallarea;  					buildingSouthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingWestWindowArea += windowarea;  						if (buildingWestExtWallArea == 0)  							buildingWestExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingWestExtWallArea += wallarea;  					buildingWestWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			bool surfaceMatch = false;  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingNorthWindowArea += windowarea;  						if (buildingNorthExtWallArea == 0)  							buildingNorthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingNorthExtWallArea += wallarea;  					buildingNorthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingEastWindowArea += windowarea;  						if (buildingEastExtWallArea == 0)  							buildingEastExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingEastExtWallArea += wallarea;  					buildingEastWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingSouthWindowArea += windowarea;  						if (buildingSouthExtWallArea == 0)  							buildingSouthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingSouthExtWallArea += wallarea;  					buildingSouthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingWestWindowArea += windowarea;  						if (buildingWestExtWallArea == 0)  							buildingWestExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingWestExtWallArea += wallarea;  					buildingWestWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			bool surfaceMatch = false;  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingNorthWindowArea += windowarea;  						if (buildingNorthExtWallArea == 0)  							buildingNorthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingNorthExtWallArea += wallarea;  					buildingNorthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingEastWindowArea += windowarea;  						if (buildingEastExtWallArea == 0)  							buildingEastExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingEastExtWallArea += wallarea;  					buildingEastWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingSouthWindowArea += windowarea;  						if (buildingSouthExtWallArea == 0)  							buildingSouthExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingSouthExtWallArea += wallarea;  					buildingSouthWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  				if (projectSurfaces [j].multiplier > 0) {  					wallarea *= projectSurfaces [j].multiplier;  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				//do not want to double count wall areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  					if (surface.name == projectSurfaces [j].name) {  						buildingWestWindowArea += windowarea;  						if (buildingWestExtWallArea == 0)  							buildingWestExtWallArea += wallarea;  						surfaceMatch = true;  						break;  					}  				}  				if (surfaceMatch == false) {  					buildingWestExtWallArea += wallarea;  					buildingWestWindowArea += windowarea;  					foundSurfaces.Add (projectSurfaces [j]);  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		bool surfaceMatch = false;  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingNorthWindowArea += windowarea;  					if (buildingNorthExtWallArea == 0)  						buildingNorthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingNorthExtWallArea += wallarea;  				buildingNorthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingEastWindowArea += windowarea;  					if (buildingEastExtWallArea == 0)  						buildingEastExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingEastExtWallArea += wallarea;  				buildingEastWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingSouthWindowArea += windowarea;  					if (buildingSouthExtWallArea == 0)  						buildingSouthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingSouthExtWallArea += wallarea;  				buildingSouthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingWestWindowArea += windowarea;  					if (buildingWestExtWallArea == 0)  						buildingWestExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingWestExtWallArea += wallarea;  				buildingWestWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		bool surfaceMatch = false;  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingNorthWindowArea += windowarea;  					if (buildingNorthExtWallArea == 0)  						buildingNorthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingNorthExtWallArea += wallarea;  				buildingNorthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingEastWindowArea += windowarea;  					if (buildingEastExtWallArea == 0)  						buildingEastExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingEastExtWallArea += wallarea;  				buildingEastWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingSouthWindowArea += windowarea;  					if (buildingSouthExtWallArea == 0)  						buildingSouthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingSouthExtWallArea += wallarea;  				buildingSouthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingWestWindowArea += windowarea;  					if (buildingWestExtWallArea == 0)  						buildingWestExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingWestExtWallArea += wallarea;  				buildingWestWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		bool surfaceMatch = false;  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingNorthWindowArea += windowarea;  					if (buildingNorthExtWallArea == 0)  						buildingNorthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingNorthExtWallArea += wallarea;  				buildingNorthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingEastWindowArea += windowarea;  					if (buildingEastExtWallArea == 0)  						buildingEastExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingEastExtWallArea += wallarea;  				buildingEastWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingSouthWindowArea += windowarea;  					if (buildingSouthExtWallArea == 0)  						buildingSouthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingSouthExtWallArea += wallarea;  				buildingSouthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingWestWindowArea += windowarea;  					if (buildingWestExtWallArea == 0)  						buildingWestExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingWestExtWallArea += wallarea;  				buildingWestWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		bool surfaceMatch = false;  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingNorthWindowArea += windowarea;  					if (buildingNorthExtWallArea == 0)  						buildingNorthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingNorthExtWallArea += wallarea;  				buildingNorthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingEastWindowArea += windowarea;  					if (buildingEastExtWallArea == 0)  						buildingEastExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingEastExtWallArea += wallarea;  				buildingEastWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingSouthWindowArea += windowarea;  					if (buildingSouthExtWallArea == 0)  						buildingSouthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingSouthExtWallArea += wallarea;  				buildingSouthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingWestWindowArea += windowarea;  					if (buildingWestExtWallArea == 0)  						buildingWestExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingWestExtWallArea += wallarea;  				buildingWestWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		bool surfaceMatch = false;  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingNorthWindowArea += windowarea;  					if (buildingNorthExtWallArea == 0)  						buildingNorthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingNorthExtWallArea += wallarea;  				buildingNorthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingEastWindowArea += windowarea;  					if (buildingEastExtWallArea == 0)  						buildingEastExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingEastExtWallArea += wallarea;  				buildingEastWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingSouthWindowArea += windowarea;  					if (buildingSouthExtWallArea == 0)  						buildingSouthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingSouthExtWallArea += wallarea;  				buildingSouthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingWestWindowArea += windowarea;  					if (buildingWestExtWallArea == 0)  						buildingWestExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingWestExtWallArea += wallarea;  				buildingWestWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		bool surfaceMatch = false;  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingNorthWindowArea += windowarea;  					if (buildingNorthExtWallArea == 0)  						buildingNorthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingNorthExtWallArea += wallarea;  				buildingNorthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingEastWindowArea += windowarea;  					if (buildingEastExtWallArea == 0)  						buildingEastExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingEastExtWallArea += wallarea;  				buildingEastWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingSouthWindowArea += windowarea;  					if (buildingSouthExtWallArea == 0)  						buildingSouthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingSouthExtWallArea += wallarea;  				buildingSouthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingWestWindowArea += windowarea;  					if (buildingWestExtWallArea == 0)  						buildingWestExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingWestExtWallArea += wallarea;  				buildingWestWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		bool surfaceMatch = false;  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingNorthWindowArea += windowarea;  					if (buildingNorthExtWallArea == 0)  						buildingNorthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingNorthExtWallArea += wallarea;  				buildingNorthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingEastWindowArea += windowarea;  					if (buildingEastExtWallArea == 0)  						buildingEastExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingEastExtWallArea += wallarea;  				buildingEastWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingSouthWindowArea += windowarea;  					if (buildingSouthExtWallArea == 0)  						buildingSouthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingSouthExtWallArea += wallarea;  				buildingSouthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingWestWindowArea += windowarea;  					if (buildingWestExtWallArea == 0)  						buildingWestExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingWestExtWallArea += wallarea;  				buildingWestWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		bool surfaceMatch = false;  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingNorthWindowArea += windowarea;  					if (buildingNorthExtWallArea == 0)  						buildingNorthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingNorthExtWallArea += wallarea;  				buildingNorthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingEastWindowArea += windowarea;  					if (buildingEastExtWallArea == 0)  						buildingEastExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingEastExtWallArea += wallarea;  				buildingEastWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingSouthWindowArea += windowarea;  					if (buildingSouthExtWallArea == 0)  						buildingSouthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingSouthExtWallArea += wallarea;  				buildingSouthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingWestWindowArea += windowarea;  					if (buildingWestExtWallArea == 0)  						buildingWestExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingWestExtWallArea += wallarea;  				buildingWestWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		bool surfaceMatch = false;  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingNorthWindowArea += windowarea;  					if (buildingNorthExtWallArea == 0)  						buildingNorthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingNorthExtWallArea += wallarea;  				buildingNorthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingEastWindowArea += windowarea;  					if (buildingEastExtWallArea == 0)  						buildingEastExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingEastExtWallArea += wallarea;  				buildingEastWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingSouthWindowArea += windowarea;  					if (buildingSouthExtWallArea == 0)  						buildingSouthExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingSouthExtWallArea += wallarea;  				buildingSouthWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  			if (projectSurfaces [j].multiplier > 0) {  				wallarea *= projectSurfaces [j].multiplier;  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			//do not want to double count wall areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  				if (surface.name == projectSurfaces [j].name) {  					buildingWestWindowArea += windowarea;  					if (buildingWestExtWallArea == 0)  						buildingWestExtWallArea += wallarea;  					surfaceMatch = true;  					break;  				}  			}  			if (surfaceMatch == false) {  				buildingWestExtWallArea += wallarea;  				buildingWestWindowArea += windowarea;  				foundSurfaces.Add (projectSurfaces [j]);  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	bool surfaceMatch = false;  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingNorthWindowArea += windowarea;  				if (buildingNorthExtWallArea == 0)  					buildingNorthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingNorthExtWallArea += wallarea;  			buildingNorthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingEastWindowArea += windowarea;  				if (buildingEastExtWallArea == 0)  					buildingEastExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingEastExtWallArea += wallarea;  			buildingEastWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingSouthWindowArea += windowarea;  				if (buildingSouthExtWallArea == 0)  					buildingSouthExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingSouthExtWallArea += wallarea;  			buildingSouthWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  		if (projectSurfaces [j].multiplier > 0) {  			wallarea *= projectSurfaces [j].multiplier;  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		//do not want to double count wall areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  			if (surface.name == projectSurfaces [j].name) {  				buildingWestWindowArea += windowarea;  				if (buildingWestExtWallArea == 0)  					buildingWestExtWallArea += wallarea;  				surfaceMatch = true;  				break;  			}  		}  		if (surfaceMatch == false) {  			buildingWestExtWallArea += wallarea;  			buildingWestWindowArea += windowarea;  			foundSurfaces.Add (projectSurfaces [j]);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingNorthWindowArea += windowarea;  			if (buildingNorthExtWallArea == 0)  				buildingNorthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingNorthExtWallArea += wallarea;  		buildingNorthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingNorthWindowArea += windowarea;  			if (buildingNorthExtWallArea == 0)  				buildingNorthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingNorthExtWallArea += wallarea;  		buildingNorthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingNorthWindowArea += windowarea;  			if (buildingNorthExtWallArea == 0)  				buildingNorthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingNorthExtWallArea += wallarea;  		buildingNorthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingNorthWindowArea += windowarea;  			if (buildingNorthExtWallArea == 0)  				buildingNorthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingNorthExtWallArea += wallarea;  		buildingNorthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingNorthWindowArea += windowarea;  			if (buildingNorthExtWallArea == 0)  				buildingNorthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingNorthExtWallArea += wallarea;  		buildingNorthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingNorthWindowArea += windowarea;  			if (buildingNorthExtWallArea == 0)  				buildingNorthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingNorthExtWallArea += wallarea;  		buildingNorthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingNorthWindowArea += windowarea;  			if (buildingNorthExtWallArea == 0)  				buildingNorthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingNorthExtWallArea += wallarea;  		buildingNorthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingNorthWindowArea += windowarea;  			if (buildingNorthExtWallArea == 0)  				buildingNorthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingNorthExtWallArea += wallarea;  		buildingNorthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingNorthWindowArea += windowarea;  			if (buildingNorthExtWallArea == 0)  				buildingNorthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingNorthExtWallArea += wallarea;  		buildingNorthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingEastWindowArea += windowarea;  			if (buildingEastExtWallArea == 0)  				buildingEastExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingEastExtWallArea += wallarea;  		buildingEastWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingSouthWindowArea += windowarea;  			if (buildingSouthExtWallArea == 0)  				buildingSouthExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingSouthExtWallArea += wallarea;  		buildingSouthWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetHighLevelProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (projectSurfaces [j]);  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]);  	if (projectSurfaces [j].multiplier > 0) {  		wallarea *= projectSurfaces [j].multiplier;  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	//do not want to double count wall areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in foundSurfaces) {  		if (surface.name == projectSurfaces [j].name) {  			buildingWestWindowArea += windowarea;  			if (buildingWestExtWallArea == 0)  				buildingWestExtWallArea += wallarea;  			surfaceMatch = true;  			break;  		}  	}  	if (surfaceMatch == false) {  		buildingWestExtWallArea += wallarea;  		buildingWestWindowArea += windowarea;  		foundSurfaces.Add (projectSurfaces [j]);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface wallSurface in projectSurfaces) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		string surfaceName = wallSurface.name;  		string constructionType = wallSurface.constructionName;  		string azimuth = wallSurface.azimuth.ToString ();  		string tilt = wallSurface.tilt.ToString ();  		double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  		string multiplier = wallSurface.multiplier.ToString ();  		if (wallSurface.multiplier > 0)  			wallArea = wallArea * wallSurface.multiplier;  		string comma = "'";  		string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  		output.AppendLine (outline);  	}  	if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  		if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  			if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  				Console.Write ("");  			}  			double azimuth = wallSurface.azimuth;  			if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingNorthExtWallArea += wallarea;  			}  			else if ((azimuth >= 45 && azimuth < 135)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingEastExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingEastExtWallArea += wallarea;  			}  			else if ((azimuth >= 135 && azimuth < 225)) {  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingSouthExtWallArea += wallarea;  			}  			else if ((azimuth >= 225 && azimuth < 315)) {  				//get the area of the surface  				double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  				if (wallSurface.multiplier > 0)  					buildingWestExtWallArea += wallarea * wallSurface.multiplier;  				else  					buildingWestExtWallArea += wallarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	string surfaceName = wallSurface.name;  	string constructionType = wallSurface.constructionName;  	string azimuth = wallSurface.azimuth.ToString ();  	string tilt = wallSurface.tilt.ToString ();  	double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  	string multiplier = wallSurface.multiplier.ToString ();  	if (wallSurface.multiplier > 0)  		wallArea = wallArea * wallSurface.multiplier;  	string comma = "'";  	string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  	output.AppendLine (outline);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	string surfaceName = wallSurface.name;  	string constructionType = wallSurface.constructionName;  	string azimuth = wallSurface.azimuth.ToString ();  	string tilt = wallSurface.tilt.ToString ();  	double wallArea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (.3048' 2);  	string multiplier = wallSurface.multiplier.ToString ();  	if (wallSurface.multiplier > 0)  		wallArea = wallArea * wallSurface.multiplier;  	string comma = "'";  	string outline = surfaceName + comma + constructionType + comma + wallArea.ToString () + comma + multiplier + comma + azimuth + comma + tilt;  	output.AppendLine (outline);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.surfaceType == ModelingUtilities.BuildingObjects.SurfaceTypes.Wall) {  	if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  		if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  			Console.Write ("");  		}  		double azimuth = wallSurface.azimuth;  		if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingNorthExtWallArea += wallarea;  		}  		else if ((azimuth >= 45 && azimuth < 135)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingEastExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingEastExtWallArea += wallarea;  		}  		else if ((azimuth >= 135 && azimuth < 225)) {  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingSouthExtWallArea += wallarea;  		}  		else if ((azimuth >= 225 && azimuth < 315)) {  			//get the area of the surface  			double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  			if (wallSurface.multiplier > 0)  				buildingWestExtWallArea += wallarea * wallSurface.multiplier;  			else  				buildingWestExtWallArea += wallarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Outdoors || wallSurface.outsideBoundary == ModelingUtilities.BuildingObjects.OutsideBoundary.Ground) {  	if (wallSurface.name == "2nd%Floor/1:02%office%center_Wall_11_2_1") {  		Console.Write ("");  	}  	double azimuth = wallSurface.azimuth;  	if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingNorthExtWallArea += wallarea;  	}  	else if ((azimuth >= 45 && azimuth < 135)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingEastExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingEastExtWallArea += wallarea;  	}  	else if ((azimuth >= 135 && azimuth < 225)) {  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingSouthExtWallArea += wallarea;  	}  	else if ((azimuth >= 225 && azimuth < 315)) {  		//get the area of the surface  		double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  		if (wallSurface.multiplier > 0)  			buildingWestExtWallArea += wallarea * wallSurface.multiplier;  		else  			buildingWestExtWallArea += wallarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth > 315 && azimuth <= 360) || (azimuth >= 0 && azimuth < 45)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingNorthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingNorthExtWallArea += wallarea;  }  else if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 45 && azimuth < 135)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingEastExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingEastExtWallArea += wallarea;  }  else if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 135 && azimuth < 225)) {  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingSouthExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingSouthExtWallArea += wallarea;  }  else if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((azimuth >= 225 && azimuth < 315)) {  	//get the area of the surface  	double wallarea = Vector.GetAreaofSurface (wallSurface) / Math.Pow (0.3048' 2);  	if (wallSurface.multiplier > 0)  		buildingWestExtWallArea += wallarea * wallSurface.multiplier;  	else  		buildingWestExtWallArea += wallarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int i = 0; i < projectOpenings.Count (); i++) {  	string parentSurfaceName = projectOpenings [i].parentSurfaceNameId;  	//search for parent surface  	for (int j = 0; j < projectSurfaces.Count (); j++) {  		if (projectSurfaces [j].name != parentSurfaceName)  			continue;  		else if (projectSurfaces [j].name == parentSurfaceName) {  			//initialize found surfaces  			if (i == 0)  				foundSurfaces.Add (projectSurfaces [j]);  			double parentAzimuth = projectSurfaces [j].azimuth;  			//bin the surface areas based on orientation  			if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				//modifications to the window and wall area due to multipliers  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingNorthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingEastWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingSouthWindowArea += windowarea;  			}  			else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  				//get the area of the window  				double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  				if (projectSurfaces [j].multiplier > 0) {  					windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  				}  				else {  					windowarea *= projectOpenings [i].multiplier;  				}  				output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  				buildingWestWindowArea += windowarea;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: for (int j = 0; j < projectSurfaces.Count (); j++) {  	if (projectSurfaces [j].name != parentSurfaceName)  		continue;  	else if (projectSurfaces [j].name == parentSurfaceName) {  		//initialize found surfaces  		if (i == 0)  			foundSurfaces.Add (projectSurfaces [j]);  		double parentAzimuth = projectSurfaces [j].azimuth;  		//bin the surface areas based on orientation  		if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			//modifications to the window and wall area due to multipliers  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingNorthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingEastWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingSouthWindowArea += windowarea;  		}  		else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  			//get the area of the window  			double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  			if (projectSurfaces [j].multiplier > 0) {  				windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  			}  			else {  				windowarea *= projectOpenings [i].multiplier;  			}  			output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  			buildingWestWindowArea += windowarea;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name != parentSurfaceName)  	continue;  else if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if (projectSurfaces [j].name == parentSurfaceName) {  	//initialize found surfaces  	if (i == 0)  		foundSurfaces.Add (projectSurfaces [j]);  	double parentAzimuth = projectSurfaces [j].azimuth;  	//bin the surface areas based on orientation  	if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		//modifications to the window and wall area due to multipliers  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingNorthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingEastWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingSouthWindowArea += windowarea;  	}  	else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  		//get the area of the window  		double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  		if (projectSurfaces [j].multiplier > 0) {  			windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  		}  		else {  			windowarea *= projectOpenings [i].multiplier;  		}  		output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  		buildingWestWindowArea += windowarea;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth > 315 && parentAzimuth <= 360) || (parentAzimuth >= 0 && parentAzimuth < 45)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	//modifications to the window and wall area due to multipliers  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingNorthWindowArea += windowarea;  }  else if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 45 && parentAzimuth < 135)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingEastWindowArea += windowarea;  }  else if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 135 && parentAzimuth < 225)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingSouthWindowArea += windowarea;  }  else if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,AboveAndBelowGradeProjectWWR,The following statement contains a magic number: if ((parentAzimuth >= 225 && parentAzimuth < 315)) {  	//get the area of the window  	double windowarea = Vector.GetAreaofWindow (projectOpenings [i]) / Math.Pow (0.3048' 2);  	if (projectSurfaces [j].multiplier > 0) {  		windowarea *= projectOpenings [i].multiplier * projectSurfaces [j].multiplier;  	}  	else {  		windowarea *= projectOpenings [i].multiplier;  	}  	output.AppendLine (projectOpenings [i].nameId + "'" + windowarea.ToString () + "'" + projectOpenings [i].parentSurfaceNameId + "'" + projectOpenings [i].Azimuth.ToString () + "'" + projectOpenings [i].Tilt.ToString ());  	buildingWestWindowArea += windowarea;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: try {  	Regex fenestrationYes = new Regex (EPlusObjects.EPlusRegexString.startFenestration);  	Regex fenestrationNameRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationName);  	Regex fenestrationParentSurfaceRegex = new Regex (EPlusObjects.EPlusRegexString.parentSurfaceName);  	Regex typicalVertexRegex = new Regex (EPlusObjects.EPlusRegexString.typicalVertex);  	Regex semiColonRegex = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Regex multiplierRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationMultiplier);  	Encoding encoding;  	bool firstLineofFenestration = false;  	bool semicolonfound = false;  	string windowName = "";  	string parentSurfaceName = "";  	using (StreamReader reader = new StreamReader (idfname)) {  		string line;  		encoding = reader.CurrentEncoding;  		bool detailedFenestration = false;  		bool vertexMatching = false;  		int vertexCounter = 1;  		while ((line = reader.ReadLine ()) != null) {  			MatchCollection fenStart = fenestrationYes.Matches (line);  			if (fenStart.Count > 0) {  				detailedFenestration = true;  				firstLineofFenestration = true;  				output.AppendLine (line);  				continue;  			}  			if (detailedFenestration) {  				//Match the name of the window  				Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  				if (fenestrationNameMatch.Success) {  					firstLineofFenestration = false;  					//strip off the whitespace and comma  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  					if (pure.Success) {  						windowName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						continue;  					}  				}  				Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  				if (parentSurfaceIdMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  					if (pure.Success) {  						parentSurfaceName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						continue;  					}  				}  				//Get multiplier  				Match multiplierMatch = multiplierRegex.Match (line);  				if (multiplierMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  					if (pure.Success) {  						string frontSpace = "    ";  						//string multiPlier = pure.Groups["goods"].Value;  						string multiPlier = "1";  						string comma = "'";  						string endString = "                       !- Multiplier";  						output.AppendLine (frontSpace + multiPlier + comma + endString);  						continue;  					}  				}  				//My next match is the coordinates' since the rest I should be able to skip at this point  				Match typicalVertexMatch = typicalVertexRegex.Match (line);  				if (typicalVertexMatch.Success) {  					vertexMatching = true;  					if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  						#region  						//globally change all the windows to a new window area based on the surface attached  						//get the areas  						foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  							if (window.nameId == windowName) {  								foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  									if (window.parentSurfaceNameId == surface.name) {  										double windowArea = Vector.GetAreaofWindow (window);  										double wallArea = Vector.GetAreaofSurface (surface);  										if (surface.multiplier > 0) {  											wallArea *= surface.multiplier;  											windowArea *= surface.multiplier * window.multiplier;  										}  										else {  											windowArea *= window.multiplier;  										}  										double WWR = windowArea / wallArea;  										if (WWR != desiredUserWWR) {  											//simple here in assuming that the wall is a square surface' otherwise  											//we would have to use some sort of scaling function that emanates from the  											//centroid' which we currently do not have' so we only work when the num vertices  											//is equal to four  											if (surface.numVertices == 4) {  												//under the simplifying assumption that walls are tilted to 90oF  												double zlow = 0.0;  												double zHigh = 0.0;  												for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  													if (j == 0) {  														zlow = surface.SurfaceCoords [j].Z;  														zHigh = surface.SurfaceCoords [j].Z;  													}  													else {  														if (surface.SurfaceCoords [j].Z < zlow)  															zlow = surface.SurfaceCoords [j].Z;  														if (surface.SurfaceCoords [j].Z > zHigh)  															zHigh = surface.SurfaceCoords [j].Z;  													}  												}  												double wallHeight = zHigh - zlow;  												//make each x' y vertex the same in both the surface and window  												//and strip window heights that are adjusted based on user preference  												if (window.numVertices == 4) {  													//we assume that the vertexes start in the lower left hand corner' though   													//subject to change  													for (int i = 0; i < window.coordinateList.Count; i++) {  														//assume that the coordinates both go in the same order  														switch (i) {  														case 0:  															double X = surface.SurfaceCoords [i].X;  															double Y = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z = surface.SurfaceCoords [i].Z + sillHeight;  															Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  															newCoords.Add (newWindowCoord);  															break;  														case 1:  															double X1 = surface.SurfaceCoords [i].X;  															double Y1 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  															Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  															newCoords.Add (newWindowCoord1);  															break;  														case 2:  															double X2 = surface.SurfaceCoords [i].X;  															double Y2 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  															Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  															newCoords.Add (newWindowCoord2);  															break;  														case 3:  															double X3 = surface.SurfaceCoords [i].X;  															double Y3 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  															Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  															newCoords.Add (newWindowCoord3);  															break;  														}  													}  												}  											}  										}  									}  								}  							}  						}  						#endregion  					}  					//once I have the newCoordinates' then I should go on to change the values in the file  					//we can assume that if there are no new coords' then the old file matches the new exactly  					if (newCoords.Count > 0) {  						//make a new vertex point and append it to the line  						//do a check for the semicolon now because this changes the type of exchange that we make  						Match semicolonMatch = semiColonRegex.Match (line);  						if (semicolonMatch.Success) {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string semicolon = ";";  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							newCoords.Clear ();  							//reset  							vertexMatching = false;  							detailedFenestration = false;  							vertexCounter = 1;  							continue;  						}  						//it is a normal typical vertex line  						else {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							newCoords.Clear ();  							continue;  						}  					}  					//apparently the lines were exactly the same  					else {  						output.AppendLine (line);  						vertexCounter++;  						continue;  					}  				}  				//this is admittedly a bit sloppy and should be cleaned up  				//basically says' if there is no match' then move append and work on the next line  				else {  					output.AppendLine (line);  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	successfulUpdate = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	Console.WriteLine (e.ToString ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: try {  	Regex fenestrationYes = new Regex (EPlusObjects.EPlusRegexString.startFenestration);  	Regex fenestrationNameRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationName);  	Regex fenestrationParentSurfaceRegex = new Regex (EPlusObjects.EPlusRegexString.parentSurfaceName);  	Regex typicalVertexRegex = new Regex (EPlusObjects.EPlusRegexString.typicalVertex);  	Regex semiColonRegex = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Regex multiplierRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationMultiplier);  	Encoding encoding;  	bool firstLineofFenestration = false;  	bool semicolonfound = false;  	string windowName = "";  	string parentSurfaceName = "";  	using (StreamReader reader = new StreamReader (idfname)) {  		string line;  		encoding = reader.CurrentEncoding;  		bool detailedFenestration = false;  		bool vertexMatching = false;  		int vertexCounter = 1;  		while ((line = reader.ReadLine ()) != null) {  			MatchCollection fenStart = fenestrationYes.Matches (line);  			if (fenStart.Count > 0) {  				detailedFenestration = true;  				firstLineofFenestration = true;  				output.AppendLine (line);  				continue;  			}  			if (detailedFenestration) {  				//Match the name of the window  				Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  				if (fenestrationNameMatch.Success) {  					firstLineofFenestration = false;  					//strip off the whitespace and comma  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  					if (pure.Success) {  						windowName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						continue;  					}  				}  				Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  				if (parentSurfaceIdMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  					if (pure.Success) {  						parentSurfaceName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						continue;  					}  				}  				//Get multiplier  				Match multiplierMatch = multiplierRegex.Match (line);  				if (multiplierMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  					if (pure.Success) {  						string frontSpace = "    ";  						//string multiPlier = pure.Groups["goods"].Value;  						string multiPlier = "1";  						string comma = "'";  						string endString = "                       !- Multiplier";  						output.AppendLine (frontSpace + multiPlier + comma + endString);  						continue;  					}  				}  				//My next match is the coordinates' since the rest I should be able to skip at this point  				Match typicalVertexMatch = typicalVertexRegex.Match (line);  				if (typicalVertexMatch.Success) {  					vertexMatching = true;  					if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  						#region  						//globally change all the windows to a new window area based on the surface attached  						//get the areas  						foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  							if (window.nameId == windowName) {  								foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  									if (window.parentSurfaceNameId == surface.name) {  										double windowArea = Vector.GetAreaofWindow (window);  										double wallArea = Vector.GetAreaofSurface (surface);  										if (surface.multiplier > 0) {  											wallArea *= surface.multiplier;  											windowArea *= surface.multiplier * window.multiplier;  										}  										else {  											windowArea *= window.multiplier;  										}  										double WWR = windowArea / wallArea;  										if (WWR != desiredUserWWR) {  											//simple here in assuming that the wall is a square surface' otherwise  											//we would have to use some sort of scaling function that emanates from the  											//centroid' which we currently do not have' so we only work when the num vertices  											//is equal to four  											if (surface.numVertices == 4) {  												//under the simplifying assumption that walls are tilted to 90oF  												double zlow = 0.0;  												double zHigh = 0.0;  												for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  													if (j == 0) {  														zlow = surface.SurfaceCoords [j].Z;  														zHigh = surface.SurfaceCoords [j].Z;  													}  													else {  														if (surface.SurfaceCoords [j].Z < zlow)  															zlow = surface.SurfaceCoords [j].Z;  														if (surface.SurfaceCoords [j].Z > zHigh)  															zHigh = surface.SurfaceCoords [j].Z;  													}  												}  												double wallHeight = zHigh - zlow;  												//make each x' y vertex the same in both the surface and window  												//and strip window heights that are adjusted based on user preference  												if (window.numVertices == 4) {  													//we assume that the vertexes start in the lower left hand corner' though   													//subject to change  													for (int i = 0; i < window.coordinateList.Count; i++) {  														//assume that the coordinates both go in the same order  														switch (i) {  														case 0:  															double X = surface.SurfaceCoords [i].X;  															double Y = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z = surface.SurfaceCoords [i].Z + sillHeight;  															Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  															newCoords.Add (newWindowCoord);  															break;  														case 1:  															double X1 = surface.SurfaceCoords [i].X;  															double Y1 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  															Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  															newCoords.Add (newWindowCoord1);  															break;  														case 2:  															double X2 = surface.SurfaceCoords [i].X;  															double Y2 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  															Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  															newCoords.Add (newWindowCoord2);  															break;  														case 3:  															double X3 = surface.SurfaceCoords [i].X;  															double Y3 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  															Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  															newCoords.Add (newWindowCoord3);  															break;  														}  													}  												}  											}  										}  									}  								}  							}  						}  						#endregion  					}  					//once I have the newCoordinates' then I should go on to change the values in the file  					//we can assume that if there are no new coords' then the old file matches the new exactly  					if (newCoords.Count > 0) {  						//make a new vertex point and append it to the line  						//do a check for the semicolon now because this changes the type of exchange that we make  						Match semicolonMatch = semiColonRegex.Match (line);  						if (semicolonMatch.Success) {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string semicolon = ";";  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							newCoords.Clear ();  							//reset  							vertexMatching = false;  							detailedFenestration = false;  							vertexCounter = 1;  							continue;  						}  						//it is a normal typical vertex line  						else {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							newCoords.Clear ();  							continue;  						}  					}  					//apparently the lines were exactly the same  					else {  						output.AppendLine (line);  						vertexCounter++;  						continue;  					}  				}  				//this is admittedly a bit sloppy and should be cleaned up  				//basically says' if there is no match' then move append and work on the next line  				else {  					output.AppendLine (line);  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	successfulUpdate = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	Console.WriteLine (e.ToString ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: try {  	Regex fenestrationYes = new Regex (EPlusObjects.EPlusRegexString.startFenestration);  	Regex fenestrationNameRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationName);  	Regex fenestrationParentSurfaceRegex = new Regex (EPlusObjects.EPlusRegexString.parentSurfaceName);  	Regex typicalVertexRegex = new Regex (EPlusObjects.EPlusRegexString.typicalVertex);  	Regex semiColonRegex = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Regex multiplierRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationMultiplier);  	Encoding encoding;  	bool firstLineofFenestration = false;  	bool semicolonfound = false;  	string windowName = "";  	string parentSurfaceName = "";  	using (StreamReader reader = new StreamReader (idfname)) {  		string line;  		encoding = reader.CurrentEncoding;  		bool detailedFenestration = false;  		bool vertexMatching = false;  		int vertexCounter = 1;  		while ((line = reader.ReadLine ()) != null) {  			MatchCollection fenStart = fenestrationYes.Matches (line);  			if (fenStart.Count > 0) {  				detailedFenestration = true;  				firstLineofFenestration = true;  				output.AppendLine (line);  				continue;  			}  			if (detailedFenestration) {  				//Match the name of the window  				Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  				if (fenestrationNameMatch.Success) {  					firstLineofFenestration = false;  					//strip off the whitespace and comma  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  					if (pure.Success) {  						windowName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						continue;  					}  				}  				Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  				if (parentSurfaceIdMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  					if (pure.Success) {  						parentSurfaceName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						continue;  					}  				}  				//Get multiplier  				Match multiplierMatch = multiplierRegex.Match (line);  				if (multiplierMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  					if (pure.Success) {  						string frontSpace = "    ";  						//string multiPlier = pure.Groups["goods"].Value;  						string multiPlier = "1";  						string comma = "'";  						string endString = "                       !- Multiplier";  						output.AppendLine (frontSpace + multiPlier + comma + endString);  						continue;  					}  				}  				//My next match is the coordinates' since the rest I should be able to skip at this point  				Match typicalVertexMatch = typicalVertexRegex.Match (line);  				if (typicalVertexMatch.Success) {  					vertexMatching = true;  					if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  						#region  						//globally change all the windows to a new window area based on the surface attached  						//get the areas  						foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  							if (window.nameId == windowName) {  								foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  									if (window.parentSurfaceNameId == surface.name) {  										double windowArea = Vector.GetAreaofWindow (window);  										double wallArea = Vector.GetAreaofSurface (surface);  										if (surface.multiplier > 0) {  											wallArea *= surface.multiplier;  											windowArea *= surface.multiplier * window.multiplier;  										}  										else {  											windowArea *= window.multiplier;  										}  										double WWR = windowArea / wallArea;  										if (WWR != desiredUserWWR) {  											//simple here in assuming that the wall is a square surface' otherwise  											//we would have to use some sort of scaling function that emanates from the  											//centroid' which we currently do not have' so we only work when the num vertices  											//is equal to four  											if (surface.numVertices == 4) {  												//under the simplifying assumption that walls are tilted to 90oF  												double zlow = 0.0;  												double zHigh = 0.0;  												for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  													if (j == 0) {  														zlow = surface.SurfaceCoords [j].Z;  														zHigh = surface.SurfaceCoords [j].Z;  													}  													else {  														if (surface.SurfaceCoords [j].Z < zlow)  															zlow = surface.SurfaceCoords [j].Z;  														if (surface.SurfaceCoords [j].Z > zHigh)  															zHigh = surface.SurfaceCoords [j].Z;  													}  												}  												double wallHeight = zHigh - zlow;  												//make each x' y vertex the same in both the surface and window  												//and strip window heights that are adjusted based on user preference  												if (window.numVertices == 4) {  													//we assume that the vertexes start in the lower left hand corner' though   													//subject to change  													for (int i = 0; i < window.coordinateList.Count; i++) {  														//assume that the coordinates both go in the same order  														switch (i) {  														case 0:  															double X = surface.SurfaceCoords [i].X;  															double Y = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z = surface.SurfaceCoords [i].Z + sillHeight;  															Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  															newCoords.Add (newWindowCoord);  															break;  														case 1:  															double X1 = surface.SurfaceCoords [i].X;  															double Y1 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  															Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  															newCoords.Add (newWindowCoord1);  															break;  														case 2:  															double X2 = surface.SurfaceCoords [i].X;  															double Y2 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  															Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  															newCoords.Add (newWindowCoord2);  															break;  														case 3:  															double X3 = surface.SurfaceCoords [i].X;  															double Y3 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  															Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  															newCoords.Add (newWindowCoord3);  															break;  														}  													}  												}  											}  										}  									}  								}  							}  						}  						#endregion  					}  					//once I have the newCoordinates' then I should go on to change the values in the file  					//we can assume that if there are no new coords' then the old file matches the new exactly  					if (newCoords.Count > 0) {  						//make a new vertex point and append it to the line  						//do a check for the semicolon now because this changes the type of exchange that we make  						Match semicolonMatch = semiColonRegex.Match (line);  						if (semicolonMatch.Success) {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string semicolon = ";";  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							newCoords.Clear ();  							//reset  							vertexMatching = false;  							detailedFenestration = false;  							vertexCounter = 1;  							continue;  						}  						//it is a normal typical vertex line  						else {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							newCoords.Clear ();  							continue;  						}  					}  					//apparently the lines were exactly the same  					else {  						output.AppendLine (line);  						vertexCounter++;  						continue;  					}  				}  				//this is admittedly a bit sloppy and should be cleaned up  				//basically says' if there is no match' then move append and work on the next line  				else {  					output.AppendLine (line);  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	successfulUpdate = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	Console.WriteLine (e.ToString ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: try {  	Regex fenestrationYes = new Regex (EPlusObjects.EPlusRegexString.startFenestration);  	Regex fenestrationNameRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationName);  	Regex fenestrationParentSurfaceRegex = new Regex (EPlusObjects.EPlusRegexString.parentSurfaceName);  	Regex typicalVertexRegex = new Regex (EPlusObjects.EPlusRegexString.typicalVertex);  	Regex semiColonRegex = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Regex multiplierRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationMultiplier);  	Encoding encoding;  	bool firstLineofFenestration = false;  	bool semicolonfound = false;  	string windowName = "";  	string parentSurfaceName = "";  	using (StreamReader reader = new StreamReader (idfname)) {  		string line;  		encoding = reader.CurrentEncoding;  		bool detailedFenestration = false;  		bool vertexMatching = false;  		int vertexCounter = 1;  		while ((line = reader.ReadLine ()) != null) {  			MatchCollection fenStart = fenestrationYes.Matches (line);  			if (fenStart.Count > 0) {  				detailedFenestration = true;  				firstLineofFenestration = true;  				output.AppendLine (line);  				continue;  			}  			if (detailedFenestration) {  				//Match the name of the window  				Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  				if (fenestrationNameMatch.Success) {  					firstLineofFenestration = false;  					//strip off the whitespace and comma  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  					if (pure.Success) {  						windowName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						continue;  					}  				}  				Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  				if (parentSurfaceIdMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  					if (pure.Success) {  						parentSurfaceName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						continue;  					}  				}  				//Get multiplier  				Match multiplierMatch = multiplierRegex.Match (line);  				if (multiplierMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  					if (pure.Success) {  						string frontSpace = "    ";  						//string multiPlier = pure.Groups["goods"].Value;  						string multiPlier = "1";  						string comma = "'";  						string endString = "                       !- Multiplier";  						output.AppendLine (frontSpace + multiPlier + comma + endString);  						continue;  					}  				}  				//My next match is the coordinates' since the rest I should be able to skip at this point  				Match typicalVertexMatch = typicalVertexRegex.Match (line);  				if (typicalVertexMatch.Success) {  					vertexMatching = true;  					if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  						#region  						//globally change all the windows to a new window area based on the surface attached  						//get the areas  						foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  							if (window.nameId == windowName) {  								foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  									if (window.parentSurfaceNameId == surface.name) {  										double windowArea = Vector.GetAreaofWindow (window);  										double wallArea = Vector.GetAreaofSurface (surface);  										if (surface.multiplier > 0) {  											wallArea *= surface.multiplier;  											windowArea *= surface.multiplier * window.multiplier;  										}  										else {  											windowArea *= window.multiplier;  										}  										double WWR = windowArea / wallArea;  										if (WWR != desiredUserWWR) {  											//simple here in assuming that the wall is a square surface' otherwise  											//we would have to use some sort of scaling function that emanates from the  											//centroid' which we currently do not have' so we only work when the num vertices  											//is equal to four  											if (surface.numVertices == 4) {  												//under the simplifying assumption that walls are tilted to 90oF  												double zlow = 0.0;  												double zHigh = 0.0;  												for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  													if (j == 0) {  														zlow = surface.SurfaceCoords [j].Z;  														zHigh = surface.SurfaceCoords [j].Z;  													}  													else {  														if (surface.SurfaceCoords [j].Z < zlow)  															zlow = surface.SurfaceCoords [j].Z;  														if (surface.SurfaceCoords [j].Z > zHigh)  															zHigh = surface.SurfaceCoords [j].Z;  													}  												}  												double wallHeight = zHigh - zlow;  												//make each x' y vertex the same in both the surface and window  												//and strip window heights that are adjusted based on user preference  												if (window.numVertices == 4) {  													//we assume that the vertexes start in the lower left hand corner' though   													//subject to change  													for (int i = 0; i < window.coordinateList.Count; i++) {  														//assume that the coordinates both go in the same order  														switch (i) {  														case 0:  															double X = surface.SurfaceCoords [i].X;  															double Y = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z = surface.SurfaceCoords [i].Z + sillHeight;  															Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  															newCoords.Add (newWindowCoord);  															break;  														case 1:  															double X1 = surface.SurfaceCoords [i].X;  															double Y1 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  															Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  															newCoords.Add (newWindowCoord1);  															break;  														case 2:  															double X2 = surface.SurfaceCoords [i].X;  															double Y2 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  															Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  															newCoords.Add (newWindowCoord2);  															break;  														case 3:  															double X3 = surface.SurfaceCoords [i].X;  															double Y3 = surface.SurfaceCoords [i].Y;  															//this should be settable  															double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  															Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  															newCoords.Add (newWindowCoord3);  															break;  														}  													}  												}  											}  										}  									}  								}  							}  						}  						#endregion  					}  					//once I have the newCoordinates' then I should go on to change the values in the file  					//we can assume that if there are no new coords' then the old file matches the new exactly  					if (newCoords.Count > 0) {  						//make a new vertex point and append it to the line  						//do a check for the semicolon now because this changes the type of exchange that we make  						Match semicolonMatch = semiColonRegex.Match (line);  						if (semicolonMatch.Success) {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string semicolon = ";";  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							newCoords.Clear ();  							//reset  							vertexMatching = false;  							detailedFenestration = false;  							vertexCounter = 1;  							continue;  						}  						//it is a normal typical vertex line  						else {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							newCoords.Clear ();  							continue;  						}  					}  					//apparently the lines were exactly the same  					else {  						output.AppendLine (line);  						vertexCounter++;  						continue;  					}  				}  				//this is admittedly a bit sloppy and should be cleaned up  				//basically says' if there is no match' then move append and work on the next line  				else {  					output.AppendLine (line);  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	successfulUpdate = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	Console.WriteLine (e.ToString ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: using (StreamReader reader = new StreamReader (idfname)) {  	string line;  	encoding = reader.CurrentEncoding;  	bool detailedFenestration = false;  	bool vertexMatching = false;  	int vertexCounter = 1;  	while ((line = reader.ReadLine ()) != null) {  		MatchCollection fenStart = fenestrationYes.Matches (line);  		if (fenStart.Count > 0) {  			detailedFenestration = true;  			firstLineofFenestration = true;  			output.AppendLine (line);  			continue;  		}  		if (detailedFenestration) {  			//Match the name of the window  			Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  			if (fenestrationNameMatch.Success) {  				firstLineofFenestration = false;  				//strip off the whitespace and comma  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					windowName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					continue;  				}  			}  			Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  			if (parentSurfaceIdMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  				if (pure.Success) {  					parentSurfaceName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					continue;  				}  			}  			//Get multiplier  			Match multiplierMatch = multiplierRegex.Match (line);  			if (multiplierMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  				if (pure.Success) {  					string frontSpace = "    ";  					//string multiPlier = pure.Groups["goods"].Value;  					string multiPlier = "1";  					string comma = "'";  					string endString = "                       !- Multiplier";  					output.AppendLine (frontSpace + multiPlier + comma + endString);  					continue;  				}  			}  			//My next match is the coordinates' since the rest I should be able to skip at this point  			Match typicalVertexMatch = typicalVertexRegex.Match (line);  			if (typicalVertexMatch.Success) {  				vertexMatching = true;  				if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  					#region  					//globally change all the windows to a new window area based on the surface attached  					//get the areas  					foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  						if (window.nameId == windowName) {  							foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  								if (window.parentSurfaceNameId == surface.name) {  									double windowArea = Vector.GetAreaofWindow (window);  									double wallArea = Vector.GetAreaofSurface (surface);  									if (surface.multiplier > 0) {  										wallArea *= surface.multiplier;  										windowArea *= surface.multiplier * window.multiplier;  									}  									else {  										windowArea *= window.multiplier;  									}  									double WWR = windowArea / wallArea;  									if (WWR != desiredUserWWR) {  										//simple here in assuming that the wall is a square surface' otherwise  										//we would have to use some sort of scaling function that emanates from the  										//centroid' which we currently do not have' so we only work when the num vertices  										//is equal to four  										if (surface.numVertices == 4) {  											//under the simplifying assumption that walls are tilted to 90oF  											double zlow = 0.0;  											double zHigh = 0.0;  											for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  												if (j == 0) {  													zlow = surface.SurfaceCoords [j].Z;  													zHigh = surface.SurfaceCoords [j].Z;  												}  												else {  													if (surface.SurfaceCoords [j].Z < zlow)  														zlow = surface.SurfaceCoords [j].Z;  													if (surface.SurfaceCoords [j].Z > zHigh)  														zHigh = surface.SurfaceCoords [j].Z;  												}  											}  											double wallHeight = zHigh - zlow;  											//make each x' y vertex the same in both the surface and window  											//and strip window heights that are adjusted based on user preference  											if (window.numVertices == 4) {  												//we assume that the vertexes start in the lower left hand corner' though   												//subject to change  												for (int i = 0; i < window.coordinateList.Count; i++) {  													//assume that the coordinates both go in the same order  													switch (i) {  													case 0:  														double X = surface.SurfaceCoords [i].X;  														double Y = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z = surface.SurfaceCoords [i].Z + sillHeight;  														Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  														newCoords.Add (newWindowCoord);  														break;  													case 1:  														double X1 = surface.SurfaceCoords [i].X;  														double Y1 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  														Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  														newCoords.Add (newWindowCoord1);  														break;  													case 2:  														double X2 = surface.SurfaceCoords [i].X;  														double Y2 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  														Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  														newCoords.Add (newWindowCoord2);  														break;  													case 3:  														double X3 = surface.SurfaceCoords [i].X;  														double Y3 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  														Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  														newCoords.Add (newWindowCoord3);  														break;  													}  												}  											}  										}  									}  								}  							}  						}  					}  					#endregion  				}  				//once I have the newCoordinates' then I should go on to change the values in the file  				//we can assume that if there are no new coords' then the old file matches the new exactly  				if (newCoords.Count > 0) {  					//make a new vertex point and append it to the line  					//do a check for the semicolon now because this changes the type of exchange that we make  					Match semicolonMatch = semiColonRegex.Match (line);  					if (semicolonMatch.Success) {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string semicolon = ";";  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						newCoords.Clear ();  						//reset  						vertexMatching = false;  						detailedFenestration = false;  						vertexCounter = 1;  						continue;  					}  					//it is a normal typical vertex line  					else {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						newCoords.Clear ();  						continue;  					}  				}  				//apparently the lines were exactly the same  				else {  					output.AppendLine (line);  					vertexCounter++;  					continue;  				}  			}  			//this is admittedly a bit sloppy and should be cleaned up  			//basically says' if there is no match' then move append and work on the next line  			else {  				output.AppendLine (line);  			}  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: using (StreamReader reader = new StreamReader (idfname)) {  	string line;  	encoding = reader.CurrentEncoding;  	bool detailedFenestration = false;  	bool vertexMatching = false;  	int vertexCounter = 1;  	while ((line = reader.ReadLine ()) != null) {  		MatchCollection fenStart = fenestrationYes.Matches (line);  		if (fenStart.Count > 0) {  			detailedFenestration = true;  			firstLineofFenestration = true;  			output.AppendLine (line);  			continue;  		}  		if (detailedFenestration) {  			//Match the name of the window  			Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  			if (fenestrationNameMatch.Success) {  				firstLineofFenestration = false;  				//strip off the whitespace and comma  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					windowName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					continue;  				}  			}  			Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  			if (parentSurfaceIdMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  				if (pure.Success) {  					parentSurfaceName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					continue;  				}  			}  			//Get multiplier  			Match multiplierMatch = multiplierRegex.Match (line);  			if (multiplierMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  				if (pure.Success) {  					string frontSpace = "    ";  					//string multiPlier = pure.Groups["goods"].Value;  					string multiPlier = "1";  					string comma = "'";  					string endString = "                       !- Multiplier";  					output.AppendLine (frontSpace + multiPlier + comma + endString);  					continue;  				}  			}  			//My next match is the coordinates' since the rest I should be able to skip at this point  			Match typicalVertexMatch = typicalVertexRegex.Match (line);  			if (typicalVertexMatch.Success) {  				vertexMatching = true;  				if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  					#region  					//globally change all the windows to a new window area based on the surface attached  					//get the areas  					foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  						if (window.nameId == windowName) {  							foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  								if (window.parentSurfaceNameId == surface.name) {  									double windowArea = Vector.GetAreaofWindow (window);  									double wallArea = Vector.GetAreaofSurface (surface);  									if (surface.multiplier > 0) {  										wallArea *= surface.multiplier;  										windowArea *= surface.multiplier * window.multiplier;  									}  									else {  										windowArea *= window.multiplier;  									}  									double WWR = windowArea / wallArea;  									if (WWR != desiredUserWWR) {  										//simple here in assuming that the wall is a square surface' otherwise  										//we would have to use some sort of scaling function that emanates from the  										//centroid' which we currently do not have' so we only work when the num vertices  										//is equal to four  										if (surface.numVertices == 4) {  											//under the simplifying assumption that walls are tilted to 90oF  											double zlow = 0.0;  											double zHigh = 0.0;  											for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  												if (j == 0) {  													zlow = surface.SurfaceCoords [j].Z;  													zHigh = surface.SurfaceCoords [j].Z;  												}  												else {  													if (surface.SurfaceCoords [j].Z < zlow)  														zlow = surface.SurfaceCoords [j].Z;  													if (surface.SurfaceCoords [j].Z > zHigh)  														zHigh = surface.SurfaceCoords [j].Z;  												}  											}  											double wallHeight = zHigh - zlow;  											//make each x' y vertex the same in both the surface and window  											//and strip window heights that are adjusted based on user preference  											if (window.numVertices == 4) {  												//we assume that the vertexes start in the lower left hand corner' though   												//subject to change  												for (int i = 0; i < window.coordinateList.Count; i++) {  													//assume that the coordinates both go in the same order  													switch (i) {  													case 0:  														double X = surface.SurfaceCoords [i].X;  														double Y = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z = surface.SurfaceCoords [i].Z + sillHeight;  														Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  														newCoords.Add (newWindowCoord);  														break;  													case 1:  														double X1 = surface.SurfaceCoords [i].X;  														double Y1 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  														Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  														newCoords.Add (newWindowCoord1);  														break;  													case 2:  														double X2 = surface.SurfaceCoords [i].X;  														double Y2 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  														Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  														newCoords.Add (newWindowCoord2);  														break;  													case 3:  														double X3 = surface.SurfaceCoords [i].X;  														double Y3 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  														Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  														newCoords.Add (newWindowCoord3);  														break;  													}  												}  											}  										}  									}  								}  							}  						}  					}  					#endregion  				}  				//once I have the newCoordinates' then I should go on to change the values in the file  				//we can assume that if there are no new coords' then the old file matches the new exactly  				if (newCoords.Count > 0) {  					//make a new vertex point and append it to the line  					//do a check for the semicolon now because this changes the type of exchange that we make  					Match semicolonMatch = semiColonRegex.Match (line);  					if (semicolonMatch.Success) {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string semicolon = ";";  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						newCoords.Clear ();  						//reset  						vertexMatching = false;  						detailedFenestration = false;  						vertexCounter = 1;  						continue;  					}  					//it is a normal typical vertex line  					else {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						newCoords.Clear ();  						continue;  					}  				}  				//apparently the lines were exactly the same  				else {  					output.AppendLine (line);  					vertexCounter++;  					continue;  				}  			}  			//this is admittedly a bit sloppy and should be cleaned up  			//basically says' if there is no match' then move append and work on the next line  			else {  				output.AppendLine (line);  			}  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: using (StreamReader reader = new StreamReader (idfname)) {  	string line;  	encoding = reader.CurrentEncoding;  	bool detailedFenestration = false;  	bool vertexMatching = false;  	int vertexCounter = 1;  	while ((line = reader.ReadLine ()) != null) {  		MatchCollection fenStart = fenestrationYes.Matches (line);  		if (fenStart.Count > 0) {  			detailedFenestration = true;  			firstLineofFenestration = true;  			output.AppendLine (line);  			continue;  		}  		if (detailedFenestration) {  			//Match the name of the window  			Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  			if (fenestrationNameMatch.Success) {  				firstLineofFenestration = false;  				//strip off the whitespace and comma  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					windowName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					continue;  				}  			}  			Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  			if (parentSurfaceIdMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  				if (pure.Success) {  					parentSurfaceName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					continue;  				}  			}  			//Get multiplier  			Match multiplierMatch = multiplierRegex.Match (line);  			if (multiplierMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  				if (pure.Success) {  					string frontSpace = "    ";  					//string multiPlier = pure.Groups["goods"].Value;  					string multiPlier = "1";  					string comma = "'";  					string endString = "                       !- Multiplier";  					output.AppendLine (frontSpace + multiPlier + comma + endString);  					continue;  				}  			}  			//My next match is the coordinates' since the rest I should be able to skip at this point  			Match typicalVertexMatch = typicalVertexRegex.Match (line);  			if (typicalVertexMatch.Success) {  				vertexMatching = true;  				if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  					#region  					//globally change all the windows to a new window area based on the surface attached  					//get the areas  					foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  						if (window.nameId == windowName) {  							foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  								if (window.parentSurfaceNameId == surface.name) {  									double windowArea = Vector.GetAreaofWindow (window);  									double wallArea = Vector.GetAreaofSurface (surface);  									if (surface.multiplier > 0) {  										wallArea *= surface.multiplier;  										windowArea *= surface.multiplier * window.multiplier;  									}  									else {  										windowArea *= window.multiplier;  									}  									double WWR = windowArea / wallArea;  									if (WWR != desiredUserWWR) {  										//simple here in assuming that the wall is a square surface' otherwise  										//we would have to use some sort of scaling function that emanates from the  										//centroid' which we currently do not have' so we only work when the num vertices  										//is equal to four  										if (surface.numVertices == 4) {  											//under the simplifying assumption that walls are tilted to 90oF  											double zlow = 0.0;  											double zHigh = 0.0;  											for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  												if (j == 0) {  													zlow = surface.SurfaceCoords [j].Z;  													zHigh = surface.SurfaceCoords [j].Z;  												}  												else {  													if (surface.SurfaceCoords [j].Z < zlow)  														zlow = surface.SurfaceCoords [j].Z;  													if (surface.SurfaceCoords [j].Z > zHigh)  														zHigh = surface.SurfaceCoords [j].Z;  												}  											}  											double wallHeight = zHigh - zlow;  											//make each x' y vertex the same in both the surface and window  											//and strip window heights that are adjusted based on user preference  											if (window.numVertices == 4) {  												//we assume that the vertexes start in the lower left hand corner' though   												//subject to change  												for (int i = 0; i < window.coordinateList.Count; i++) {  													//assume that the coordinates both go in the same order  													switch (i) {  													case 0:  														double X = surface.SurfaceCoords [i].X;  														double Y = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z = surface.SurfaceCoords [i].Z + sillHeight;  														Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  														newCoords.Add (newWindowCoord);  														break;  													case 1:  														double X1 = surface.SurfaceCoords [i].X;  														double Y1 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  														Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  														newCoords.Add (newWindowCoord1);  														break;  													case 2:  														double X2 = surface.SurfaceCoords [i].X;  														double Y2 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  														Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  														newCoords.Add (newWindowCoord2);  														break;  													case 3:  														double X3 = surface.SurfaceCoords [i].X;  														double Y3 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  														Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  														newCoords.Add (newWindowCoord3);  														break;  													}  												}  											}  										}  									}  								}  							}  						}  					}  					#endregion  				}  				//once I have the newCoordinates' then I should go on to change the values in the file  				//we can assume that if there are no new coords' then the old file matches the new exactly  				if (newCoords.Count > 0) {  					//make a new vertex point and append it to the line  					//do a check for the semicolon now because this changes the type of exchange that we make  					Match semicolonMatch = semiColonRegex.Match (line);  					if (semicolonMatch.Success) {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string semicolon = ";";  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						newCoords.Clear ();  						//reset  						vertexMatching = false;  						detailedFenestration = false;  						vertexCounter = 1;  						continue;  					}  					//it is a normal typical vertex line  					else {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						newCoords.Clear ();  						continue;  					}  				}  				//apparently the lines were exactly the same  				else {  					output.AppendLine (line);  					vertexCounter++;  					continue;  				}  			}  			//this is admittedly a bit sloppy and should be cleaned up  			//basically says' if there is no match' then move append and work on the next line  			else {  				output.AppendLine (line);  			}  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: using (StreamReader reader = new StreamReader (idfname)) {  	string line;  	encoding = reader.CurrentEncoding;  	bool detailedFenestration = false;  	bool vertexMatching = false;  	int vertexCounter = 1;  	while ((line = reader.ReadLine ()) != null) {  		MatchCollection fenStart = fenestrationYes.Matches (line);  		if (fenStart.Count > 0) {  			detailedFenestration = true;  			firstLineofFenestration = true;  			output.AppendLine (line);  			continue;  		}  		if (detailedFenestration) {  			//Match the name of the window  			Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  			if (fenestrationNameMatch.Success) {  				firstLineofFenestration = false;  				//strip off the whitespace and comma  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					windowName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					continue;  				}  			}  			Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  			if (parentSurfaceIdMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  				if (pure.Success) {  					parentSurfaceName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					continue;  				}  			}  			//Get multiplier  			Match multiplierMatch = multiplierRegex.Match (line);  			if (multiplierMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  				if (pure.Success) {  					string frontSpace = "    ";  					//string multiPlier = pure.Groups["goods"].Value;  					string multiPlier = "1";  					string comma = "'";  					string endString = "                       !- Multiplier";  					output.AppendLine (frontSpace + multiPlier + comma + endString);  					continue;  				}  			}  			//My next match is the coordinates' since the rest I should be able to skip at this point  			Match typicalVertexMatch = typicalVertexRegex.Match (line);  			if (typicalVertexMatch.Success) {  				vertexMatching = true;  				if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  					#region  					//globally change all the windows to a new window area based on the surface attached  					//get the areas  					foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  						if (window.nameId == windowName) {  							foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  								if (window.parentSurfaceNameId == surface.name) {  									double windowArea = Vector.GetAreaofWindow (window);  									double wallArea = Vector.GetAreaofSurface (surface);  									if (surface.multiplier > 0) {  										wallArea *= surface.multiplier;  										windowArea *= surface.multiplier * window.multiplier;  									}  									else {  										windowArea *= window.multiplier;  									}  									double WWR = windowArea / wallArea;  									if (WWR != desiredUserWWR) {  										//simple here in assuming that the wall is a square surface' otherwise  										//we would have to use some sort of scaling function that emanates from the  										//centroid' which we currently do not have' so we only work when the num vertices  										//is equal to four  										if (surface.numVertices == 4) {  											//under the simplifying assumption that walls are tilted to 90oF  											double zlow = 0.0;  											double zHigh = 0.0;  											for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  												if (j == 0) {  													zlow = surface.SurfaceCoords [j].Z;  													zHigh = surface.SurfaceCoords [j].Z;  												}  												else {  													if (surface.SurfaceCoords [j].Z < zlow)  														zlow = surface.SurfaceCoords [j].Z;  													if (surface.SurfaceCoords [j].Z > zHigh)  														zHigh = surface.SurfaceCoords [j].Z;  												}  											}  											double wallHeight = zHigh - zlow;  											//make each x' y vertex the same in both the surface and window  											//and strip window heights that are adjusted based on user preference  											if (window.numVertices == 4) {  												//we assume that the vertexes start in the lower left hand corner' though   												//subject to change  												for (int i = 0; i < window.coordinateList.Count; i++) {  													//assume that the coordinates both go in the same order  													switch (i) {  													case 0:  														double X = surface.SurfaceCoords [i].X;  														double Y = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z = surface.SurfaceCoords [i].Z + sillHeight;  														Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  														newCoords.Add (newWindowCoord);  														break;  													case 1:  														double X1 = surface.SurfaceCoords [i].X;  														double Y1 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  														Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  														newCoords.Add (newWindowCoord1);  														break;  													case 2:  														double X2 = surface.SurfaceCoords [i].X;  														double Y2 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  														Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  														newCoords.Add (newWindowCoord2);  														break;  													case 3:  														double X3 = surface.SurfaceCoords [i].X;  														double Y3 = surface.SurfaceCoords [i].Y;  														//this should be settable  														double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  														Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  														newCoords.Add (newWindowCoord3);  														break;  													}  												}  											}  										}  									}  								}  							}  						}  					}  					#endregion  				}  				//once I have the newCoordinates' then I should go on to change the values in the file  				//we can assume that if there are no new coords' then the old file matches the new exactly  				if (newCoords.Count > 0) {  					//make a new vertex point and append it to the line  					//do a check for the semicolon now because this changes the type of exchange that we make  					Match semicolonMatch = semiColonRegex.Match (line);  					if (semicolonMatch.Success) {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string semicolon = ";";  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						newCoords.Clear ();  						//reset  						vertexMatching = false;  						detailedFenestration = false;  						vertexCounter = 1;  						continue;  					}  					//it is a normal typical vertex line  					else {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						newCoords.Clear ();  						continue;  					}  				}  				//apparently the lines were exactly the same  				else {  					output.AppendLine (line);  					vertexCounter++;  					continue;  				}  			}  			//this is admittedly a bit sloppy and should be cleaned up  			//basically says' if there is no match' then move append and work on the next line  			else {  				output.AppendLine (line);  			}  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	MatchCollection fenStart = fenestrationYes.Matches (line);  	if (fenStart.Count > 0) {  		detailedFenestration = true;  		firstLineofFenestration = true;  		output.AppendLine (line);  		continue;  	}  	if (detailedFenestration) {  		//Match the name of the window  		Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  		if (fenestrationNameMatch.Success) {  			firstLineofFenestration = false;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				windowName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				continue;  			}  		}  		Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  		if (parentSurfaceIdMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  			if (pure.Success) {  				parentSurfaceName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				continue;  			}  		}  		//Get multiplier  		Match multiplierMatch = multiplierRegex.Match (line);  		if (multiplierMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  			if (pure.Success) {  				string frontSpace = "    ";  				//string multiPlier = pure.Groups["goods"].Value;  				string multiPlier = "1";  				string comma = "'";  				string endString = "                       !- Multiplier";  				output.AppendLine (frontSpace + multiPlier + comma + endString);  				continue;  			}  		}  		//My next match is the coordinates' since the rest I should be able to skip at this point  		Match typicalVertexMatch = typicalVertexRegex.Match (line);  		if (typicalVertexMatch.Success) {  			vertexMatching = true;  			if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  				#region  				//globally change all the windows to a new window area based on the surface attached  				//get the areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  					if (window.nameId == windowName) {  						foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  							if (window.parentSurfaceNameId == surface.name) {  								double windowArea = Vector.GetAreaofWindow (window);  								double wallArea = Vector.GetAreaofSurface (surface);  								if (surface.multiplier > 0) {  									wallArea *= surface.multiplier;  									windowArea *= surface.multiplier * window.multiplier;  								}  								else {  									windowArea *= window.multiplier;  								}  								double WWR = windowArea / wallArea;  								if (WWR != desiredUserWWR) {  									//simple here in assuming that the wall is a square surface' otherwise  									//we would have to use some sort of scaling function that emanates from the  									//centroid' which we currently do not have' so we only work when the num vertices  									//is equal to four  									if (surface.numVertices == 4) {  										//under the simplifying assumption that walls are tilted to 90oF  										double zlow = 0.0;  										double zHigh = 0.0;  										for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  											if (j == 0) {  												zlow = surface.SurfaceCoords [j].Z;  												zHigh = surface.SurfaceCoords [j].Z;  											}  											else {  												if (surface.SurfaceCoords [j].Z < zlow)  													zlow = surface.SurfaceCoords [j].Z;  												if (surface.SurfaceCoords [j].Z > zHigh)  													zHigh = surface.SurfaceCoords [j].Z;  											}  										}  										double wallHeight = zHigh - zlow;  										//make each x' y vertex the same in both the surface and window  										//and strip window heights that are adjusted based on user preference  										if (window.numVertices == 4) {  											//we assume that the vertexes start in the lower left hand corner' though   											//subject to change  											for (int i = 0; i < window.coordinateList.Count; i++) {  												//assume that the coordinates both go in the same order  												switch (i) {  												case 0:  													double X = surface.SurfaceCoords [i].X;  													double Y = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z = surface.SurfaceCoords [i].Z + sillHeight;  													Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  													newCoords.Add (newWindowCoord);  													break;  												case 1:  													double X1 = surface.SurfaceCoords [i].X;  													double Y1 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  													Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  													newCoords.Add (newWindowCoord1);  													break;  												case 2:  													double X2 = surface.SurfaceCoords [i].X;  													double Y2 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  													Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  													newCoords.Add (newWindowCoord2);  													break;  												case 3:  													double X3 = surface.SurfaceCoords [i].X;  													double Y3 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  													Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  													newCoords.Add (newWindowCoord3);  													break;  												}  											}  										}  									}  								}  							}  						}  					}  				}  				#endregion  			}  			//once I have the newCoordinates' then I should go on to change the values in the file  			//we can assume that if there are no new coords' then the old file matches the new exactly  			if (newCoords.Count > 0) {  				//make a new vertex point and append it to the line  				//do a check for the semicolon now because this changes the type of exchange that we make  				Match semicolonMatch = semiColonRegex.Match (line);  				if (semicolonMatch.Success) {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string semicolon = ";";  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					newCoords.Clear ();  					//reset  					vertexMatching = false;  					detailedFenestration = false;  					vertexCounter = 1;  					continue;  				}  				//it is a normal typical vertex line  				else {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					newCoords.Clear ();  					continue;  				}  			}  			//apparently the lines were exactly the same  			else {  				output.AppendLine (line);  				vertexCounter++;  				continue;  			}  		}  		//this is admittedly a bit sloppy and should be cleaned up  		//basically says' if there is no match' then move append and work on the next line  		else {  			output.AppendLine (line);  		}  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	MatchCollection fenStart = fenestrationYes.Matches (line);  	if (fenStart.Count > 0) {  		detailedFenestration = true;  		firstLineofFenestration = true;  		output.AppendLine (line);  		continue;  	}  	if (detailedFenestration) {  		//Match the name of the window  		Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  		if (fenestrationNameMatch.Success) {  			firstLineofFenestration = false;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				windowName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				continue;  			}  		}  		Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  		if (parentSurfaceIdMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  			if (pure.Success) {  				parentSurfaceName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				continue;  			}  		}  		//Get multiplier  		Match multiplierMatch = multiplierRegex.Match (line);  		if (multiplierMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  			if (pure.Success) {  				string frontSpace = "    ";  				//string multiPlier = pure.Groups["goods"].Value;  				string multiPlier = "1";  				string comma = "'";  				string endString = "                       !- Multiplier";  				output.AppendLine (frontSpace + multiPlier + comma + endString);  				continue;  			}  		}  		//My next match is the coordinates' since the rest I should be able to skip at this point  		Match typicalVertexMatch = typicalVertexRegex.Match (line);  		if (typicalVertexMatch.Success) {  			vertexMatching = true;  			if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  				#region  				//globally change all the windows to a new window area based on the surface attached  				//get the areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  					if (window.nameId == windowName) {  						foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  							if (window.parentSurfaceNameId == surface.name) {  								double windowArea = Vector.GetAreaofWindow (window);  								double wallArea = Vector.GetAreaofSurface (surface);  								if (surface.multiplier > 0) {  									wallArea *= surface.multiplier;  									windowArea *= surface.multiplier * window.multiplier;  								}  								else {  									windowArea *= window.multiplier;  								}  								double WWR = windowArea / wallArea;  								if (WWR != desiredUserWWR) {  									//simple here in assuming that the wall is a square surface' otherwise  									//we would have to use some sort of scaling function that emanates from the  									//centroid' which we currently do not have' so we only work when the num vertices  									//is equal to four  									if (surface.numVertices == 4) {  										//under the simplifying assumption that walls are tilted to 90oF  										double zlow = 0.0;  										double zHigh = 0.0;  										for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  											if (j == 0) {  												zlow = surface.SurfaceCoords [j].Z;  												zHigh = surface.SurfaceCoords [j].Z;  											}  											else {  												if (surface.SurfaceCoords [j].Z < zlow)  													zlow = surface.SurfaceCoords [j].Z;  												if (surface.SurfaceCoords [j].Z > zHigh)  													zHigh = surface.SurfaceCoords [j].Z;  											}  										}  										double wallHeight = zHigh - zlow;  										//make each x' y vertex the same in both the surface and window  										//and strip window heights that are adjusted based on user preference  										if (window.numVertices == 4) {  											//we assume that the vertexes start in the lower left hand corner' though   											//subject to change  											for (int i = 0; i < window.coordinateList.Count; i++) {  												//assume that the coordinates both go in the same order  												switch (i) {  												case 0:  													double X = surface.SurfaceCoords [i].X;  													double Y = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z = surface.SurfaceCoords [i].Z + sillHeight;  													Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  													newCoords.Add (newWindowCoord);  													break;  												case 1:  													double X1 = surface.SurfaceCoords [i].X;  													double Y1 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  													Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  													newCoords.Add (newWindowCoord1);  													break;  												case 2:  													double X2 = surface.SurfaceCoords [i].X;  													double Y2 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  													Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  													newCoords.Add (newWindowCoord2);  													break;  												case 3:  													double X3 = surface.SurfaceCoords [i].X;  													double Y3 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  													Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  													newCoords.Add (newWindowCoord3);  													break;  												}  											}  										}  									}  								}  							}  						}  					}  				}  				#endregion  			}  			//once I have the newCoordinates' then I should go on to change the values in the file  			//we can assume that if there are no new coords' then the old file matches the new exactly  			if (newCoords.Count > 0) {  				//make a new vertex point and append it to the line  				//do a check for the semicolon now because this changes the type of exchange that we make  				Match semicolonMatch = semiColonRegex.Match (line);  				if (semicolonMatch.Success) {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string semicolon = ";";  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					newCoords.Clear ();  					//reset  					vertexMatching = false;  					detailedFenestration = false;  					vertexCounter = 1;  					continue;  				}  				//it is a normal typical vertex line  				else {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					newCoords.Clear ();  					continue;  				}  			}  			//apparently the lines were exactly the same  			else {  				output.AppendLine (line);  				vertexCounter++;  				continue;  			}  		}  		//this is admittedly a bit sloppy and should be cleaned up  		//basically says' if there is no match' then move append and work on the next line  		else {  			output.AppendLine (line);  		}  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	MatchCollection fenStart = fenestrationYes.Matches (line);  	if (fenStart.Count > 0) {  		detailedFenestration = true;  		firstLineofFenestration = true;  		output.AppendLine (line);  		continue;  	}  	if (detailedFenestration) {  		//Match the name of the window  		Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  		if (fenestrationNameMatch.Success) {  			firstLineofFenestration = false;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				windowName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				continue;  			}  		}  		Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  		if (parentSurfaceIdMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  			if (pure.Success) {  				parentSurfaceName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				continue;  			}  		}  		//Get multiplier  		Match multiplierMatch = multiplierRegex.Match (line);  		if (multiplierMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  			if (pure.Success) {  				string frontSpace = "    ";  				//string multiPlier = pure.Groups["goods"].Value;  				string multiPlier = "1";  				string comma = "'";  				string endString = "                       !- Multiplier";  				output.AppendLine (frontSpace + multiPlier + comma + endString);  				continue;  			}  		}  		//My next match is the coordinates' since the rest I should be able to skip at this point  		Match typicalVertexMatch = typicalVertexRegex.Match (line);  		if (typicalVertexMatch.Success) {  			vertexMatching = true;  			if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  				#region  				//globally change all the windows to a new window area based on the surface attached  				//get the areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  					if (window.nameId == windowName) {  						foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  							if (window.parentSurfaceNameId == surface.name) {  								double windowArea = Vector.GetAreaofWindow (window);  								double wallArea = Vector.GetAreaofSurface (surface);  								if (surface.multiplier > 0) {  									wallArea *= surface.multiplier;  									windowArea *= surface.multiplier * window.multiplier;  								}  								else {  									windowArea *= window.multiplier;  								}  								double WWR = windowArea / wallArea;  								if (WWR != desiredUserWWR) {  									//simple here in assuming that the wall is a square surface' otherwise  									//we would have to use some sort of scaling function that emanates from the  									//centroid' which we currently do not have' so we only work when the num vertices  									//is equal to four  									if (surface.numVertices == 4) {  										//under the simplifying assumption that walls are tilted to 90oF  										double zlow = 0.0;  										double zHigh = 0.0;  										for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  											if (j == 0) {  												zlow = surface.SurfaceCoords [j].Z;  												zHigh = surface.SurfaceCoords [j].Z;  											}  											else {  												if (surface.SurfaceCoords [j].Z < zlow)  													zlow = surface.SurfaceCoords [j].Z;  												if (surface.SurfaceCoords [j].Z > zHigh)  													zHigh = surface.SurfaceCoords [j].Z;  											}  										}  										double wallHeight = zHigh - zlow;  										//make each x' y vertex the same in both the surface and window  										//and strip window heights that are adjusted based on user preference  										if (window.numVertices == 4) {  											//we assume that the vertexes start in the lower left hand corner' though   											//subject to change  											for (int i = 0; i < window.coordinateList.Count; i++) {  												//assume that the coordinates both go in the same order  												switch (i) {  												case 0:  													double X = surface.SurfaceCoords [i].X;  													double Y = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z = surface.SurfaceCoords [i].Z + sillHeight;  													Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  													newCoords.Add (newWindowCoord);  													break;  												case 1:  													double X1 = surface.SurfaceCoords [i].X;  													double Y1 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  													Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  													newCoords.Add (newWindowCoord1);  													break;  												case 2:  													double X2 = surface.SurfaceCoords [i].X;  													double Y2 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  													Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  													newCoords.Add (newWindowCoord2);  													break;  												case 3:  													double X3 = surface.SurfaceCoords [i].X;  													double Y3 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  													Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  													newCoords.Add (newWindowCoord3);  													break;  												}  											}  										}  									}  								}  							}  						}  					}  				}  				#endregion  			}  			//once I have the newCoordinates' then I should go on to change the values in the file  			//we can assume that if there are no new coords' then the old file matches the new exactly  			if (newCoords.Count > 0) {  				//make a new vertex point and append it to the line  				//do a check for the semicolon now because this changes the type of exchange that we make  				Match semicolonMatch = semiColonRegex.Match (line);  				if (semicolonMatch.Success) {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string semicolon = ";";  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					newCoords.Clear ();  					//reset  					vertexMatching = false;  					detailedFenestration = false;  					vertexCounter = 1;  					continue;  				}  				//it is a normal typical vertex line  				else {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					newCoords.Clear ();  					continue;  				}  			}  			//apparently the lines were exactly the same  			else {  				output.AppendLine (line);  				vertexCounter++;  				continue;  			}  		}  		//this is admittedly a bit sloppy and should be cleaned up  		//basically says' if there is no match' then move append and work on the next line  		else {  			output.AppendLine (line);  		}  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	MatchCollection fenStart = fenestrationYes.Matches (line);  	if (fenStart.Count > 0) {  		detailedFenestration = true;  		firstLineofFenestration = true;  		output.AppendLine (line);  		continue;  	}  	if (detailedFenestration) {  		//Match the name of the window  		Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  		if (fenestrationNameMatch.Success) {  			firstLineofFenestration = false;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				windowName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				continue;  			}  		}  		Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  		if (parentSurfaceIdMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  			if (pure.Success) {  				parentSurfaceName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				continue;  			}  		}  		//Get multiplier  		Match multiplierMatch = multiplierRegex.Match (line);  		if (multiplierMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  			if (pure.Success) {  				string frontSpace = "    ";  				//string multiPlier = pure.Groups["goods"].Value;  				string multiPlier = "1";  				string comma = "'";  				string endString = "                       !- Multiplier";  				output.AppendLine (frontSpace + multiPlier + comma + endString);  				continue;  			}  		}  		//My next match is the coordinates' since the rest I should be able to skip at this point  		Match typicalVertexMatch = typicalVertexRegex.Match (line);  		if (typicalVertexMatch.Success) {  			vertexMatching = true;  			if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  				#region  				//globally change all the windows to a new window area based on the surface attached  				//get the areas  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  					if (window.nameId == windowName) {  						foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  							if (window.parentSurfaceNameId == surface.name) {  								double windowArea = Vector.GetAreaofWindow (window);  								double wallArea = Vector.GetAreaofSurface (surface);  								if (surface.multiplier > 0) {  									wallArea *= surface.multiplier;  									windowArea *= surface.multiplier * window.multiplier;  								}  								else {  									windowArea *= window.multiplier;  								}  								double WWR = windowArea / wallArea;  								if (WWR != desiredUserWWR) {  									//simple here in assuming that the wall is a square surface' otherwise  									//we would have to use some sort of scaling function that emanates from the  									//centroid' which we currently do not have' so we only work when the num vertices  									//is equal to four  									if (surface.numVertices == 4) {  										//under the simplifying assumption that walls are tilted to 90oF  										double zlow = 0.0;  										double zHigh = 0.0;  										for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  											if (j == 0) {  												zlow = surface.SurfaceCoords [j].Z;  												zHigh = surface.SurfaceCoords [j].Z;  											}  											else {  												if (surface.SurfaceCoords [j].Z < zlow)  													zlow = surface.SurfaceCoords [j].Z;  												if (surface.SurfaceCoords [j].Z > zHigh)  													zHigh = surface.SurfaceCoords [j].Z;  											}  										}  										double wallHeight = zHigh - zlow;  										//make each x' y vertex the same in both the surface and window  										//and strip window heights that are adjusted based on user preference  										if (window.numVertices == 4) {  											//we assume that the vertexes start in the lower left hand corner' though   											//subject to change  											for (int i = 0; i < window.coordinateList.Count; i++) {  												//assume that the coordinates both go in the same order  												switch (i) {  												case 0:  													double X = surface.SurfaceCoords [i].X;  													double Y = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z = surface.SurfaceCoords [i].Z + sillHeight;  													Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  													newCoords.Add (newWindowCoord);  													break;  												case 1:  													double X1 = surface.SurfaceCoords [i].X;  													double Y1 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  													Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  													newCoords.Add (newWindowCoord1);  													break;  												case 2:  													double X2 = surface.SurfaceCoords [i].X;  													double Y2 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  													Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  													newCoords.Add (newWindowCoord2);  													break;  												case 3:  													double X3 = surface.SurfaceCoords [i].X;  													double Y3 = surface.SurfaceCoords [i].Y;  													//this should be settable  													double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  													Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  													newCoords.Add (newWindowCoord3);  													break;  												}  											}  										}  									}  								}  							}  						}  					}  				}  				#endregion  			}  			//once I have the newCoordinates' then I should go on to change the values in the file  			//we can assume that if there are no new coords' then the old file matches the new exactly  			if (newCoords.Count > 0) {  				//make a new vertex point and append it to the line  				//do a check for the semicolon now because this changes the type of exchange that we make  				Match semicolonMatch = semiColonRegex.Match (line);  				if (semicolonMatch.Success) {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string semicolon = ";";  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					newCoords.Clear ();  					//reset  					vertexMatching = false;  					detailedFenestration = false;  					vertexCounter = 1;  					continue;  				}  				//it is a normal typical vertex line  				else {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					newCoords.Clear ();  					continue;  				}  			}  			//apparently the lines were exactly the same  			else {  				output.AppendLine (line);  				vertexCounter++;  				continue;  			}  		}  		//this is admittedly a bit sloppy and should be cleaned up  		//basically says' if there is no match' then move append and work on the next line  		else {  			output.AppendLine (line);  		}  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (detailedFenestration) {  	//Match the name of the window  	Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  	if (fenestrationNameMatch.Success) {  		firstLineofFenestration = false;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			windowName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			continue;  		}  	}  	Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  	if (parentSurfaceIdMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  		if (pure.Success) {  			parentSurfaceName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			continue;  		}  	}  	//Get multiplier  	Match multiplierMatch = multiplierRegex.Match (line);  	if (multiplierMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  		if (pure.Success) {  			string frontSpace = "    ";  			//string multiPlier = pure.Groups["goods"].Value;  			string multiPlier = "1";  			string comma = "'";  			string endString = "                       !- Multiplier";  			output.AppendLine (frontSpace + multiPlier + comma + endString);  			continue;  		}  	}  	//My next match is the coordinates' since the rest I should be able to skip at this point  	Match typicalVertexMatch = typicalVertexRegex.Match (line);  	if (typicalVertexMatch.Success) {  		vertexMatching = true;  		if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  			#region  			//globally change all the windows to a new window area based on the surface attached  			//get the areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  				if (window.nameId == windowName) {  					foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  						if (window.parentSurfaceNameId == surface.name) {  							double windowArea = Vector.GetAreaofWindow (window);  							double wallArea = Vector.GetAreaofSurface (surface);  							if (surface.multiplier > 0) {  								wallArea *= surface.multiplier;  								windowArea *= surface.multiplier * window.multiplier;  							}  							else {  								windowArea *= window.multiplier;  							}  							double WWR = windowArea / wallArea;  							if (WWR != desiredUserWWR) {  								//simple here in assuming that the wall is a square surface' otherwise  								//we would have to use some sort of scaling function that emanates from the  								//centroid' which we currently do not have' so we only work when the num vertices  								//is equal to four  								if (surface.numVertices == 4) {  									//under the simplifying assumption that walls are tilted to 90oF  									double zlow = 0.0;  									double zHigh = 0.0;  									for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  										if (j == 0) {  											zlow = surface.SurfaceCoords [j].Z;  											zHigh = surface.SurfaceCoords [j].Z;  										}  										else {  											if (surface.SurfaceCoords [j].Z < zlow)  												zlow = surface.SurfaceCoords [j].Z;  											if (surface.SurfaceCoords [j].Z > zHigh)  												zHigh = surface.SurfaceCoords [j].Z;  										}  									}  									double wallHeight = zHigh - zlow;  									//make each x' y vertex the same in both the surface and window  									//and strip window heights that are adjusted based on user preference  									if (window.numVertices == 4) {  										//we assume that the vertexes start in the lower left hand corner' though   										//subject to change  										for (int i = 0; i < window.coordinateList.Count; i++) {  											//assume that the coordinates both go in the same order  											switch (i) {  											case 0:  												double X = surface.SurfaceCoords [i].X;  												double Y = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z = surface.SurfaceCoords [i].Z + sillHeight;  												Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  												newCoords.Add (newWindowCoord);  												break;  											case 1:  												double X1 = surface.SurfaceCoords [i].X;  												double Y1 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  												Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  												newCoords.Add (newWindowCoord1);  												break;  											case 2:  												double X2 = surface.SurfaceCoords [i].X;  												double Y2 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  												Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  												newCoords.Add (newWindowCoord2);  												break;  											case 3:  												double X3 = surface.SurfaceCoords [i].X;  												double Y3 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  												Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  												newCoords.Add (newWindowCoord3);  												break;  											}  										}  									}  								}  							}  						}  					}  				}  			}  			#endregion  		}  		//once I have the newCoordinates' then I should go on to change the values in the file  		//we can assume that if there are no new coords' then the old file matches the new exactly  		if (newCoords.Count > 0) {  			//make a new vertex point and append it to the line  			//do a check for the semicolon now because this changes the type of exchange that we make  			Match semicolonMatch = semiColonRegex.Match (line);  			if (semicolonMatch.Success) {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string semicolon = ";";  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				newCoords.Clear ();  				//reset  				vertexMatching = false;  				detailedFenestration = false;  				vertexCounter = 1;  				continue;  			}  			//it is a normal typical vertex line  			else {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				newCoords.Clear ();  				continue;  			}  		}  		//apparently the lines were exactly the same  		else {  			output.AppendLine (line);  			vertexCounter++;  			continue;  		}  	}  	//this is admittedly a bit sloppy and should be cleaned up  	//basically says' if there is no match' then move append and work on the next line  	else {  		output.AppendLine (line);  	}  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (detailedFenestration) {  	//Match the name of the window  	Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  	if (fenestrationNameMatch.Success) {  		firstLineofFenestration = false;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			windowName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			continue;  		}  	}  	Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  	if (parentSurfaceIdMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  		if (pure.Success) {  			parentSurfaceName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			continue;  		}  	}  	//Get multiplier  	Match multiplierMatch = multiplierRegex.Match (line);  	if (multiplierMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  		if (pure.Success) {  			string frontSpace = "    ";  			//string multiPlier = pure.Groups["goods"].Value;  			string multiPlier = "1";  			string comma = "'";  			string endString = "                       !- Multiplier";  			output.AppendLine (frontSpace + multiPlier + comma + endString);  			continue;  		}  	}  	//My next match is the coordinates' since the rest I should be able to skip at this point  	Match typicalVertexMatch = typicalVertexRegex.Match (line);  	if (typicalVertexMatch.Success) {  		vertexMatching = true;  		if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  			#region  			//globally change all the windows to a new window area based on the surface attached  			//get the areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  				if (window.nameId == windowName) {  					foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  						if (window.parentSurfaceNameId == surface.name) {  							double windowArea = Vector.GetAreaofWindow (window);  							double wallArea = Vector.GetAreaofSurface (surface);  							if (surface.multiplier > 0) {  								wallArea *= surface.multiplier;  								windowArea *= surface.multiplier * window.multiplier;  							}  							else {  								windowArea *= window.multiplier;  							}  							double WWR = windowArea / wallArea;  							if (WWR != desiredUserWWR) {  								//simple here in assuming that the wall is a square surface' otherwise  								//we would have to use some sort of scaling function that emanates from the  								//centroid' which we currently do not have' so we only work when the num vertices  								//is equal to four  								if (surface.numVertices == 4) {  									//under the simplifying assumption that walls are tilted to 90oF  									double zlow = 0.0;  									double zHigh = 0.0;  									for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  										if (j == 0) {  											zlow = surface.SurfaceCoords [j].Z;  											zHigh = surface.SurfaceCoords [j].Z;  										}  										else {  											if (surface.SurfaceCoords [j].Z < zlow)  												zlow = surface.SurfaceCoords [j].Z;  											if (surface.SurfaceCoords [j].Z > zHigh)  												zHigh = surface.SurfaceCoords [j].Z;  										}  									}  									double wallHeight = zHigh - zlow;  									//make each x' y vertex the same in both the surface and window  									//and strip window heights that are adjusted based on user preference  									if (window.numVertices == 4) {  										//we assume that the vertexes start in the lower left hand corner' though   										//subject to change  										for (int i = 0; i < window.coordinateList.Count; i++) {  											//assume that the coordinates both go in the same order  											switch (i) {  											case 0:  												double X = surface.SurfaceCoords [i].X;  												double Y = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z = surface.SurfaceCoords [i].Z + sillHeight;  												Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  												newCoords.Add (newWindowCoord);  												break;  											case 1:  												double X1 = surface.SurfaceCoords [i].X;  												double Y1 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  												Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  												newCoords.Add (newWindowCoord1);  												break;  											case 2:  												double X2 = surface.SurfaceCoords [i].X;  												double Y2 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  												Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  												newCoords.Add (newWindowCoord2);  												break;  											case 3:  												double X3 = surface.SurfaceCoords [i].X;  												double Y3 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  												Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  												newCoords.Add (newWindowCoord3);  												break;  											}  										}  									}  								}  							}  						}  					}  				}  			}  			#endregion  		}  		//once I have the newCoordinates' then I should go on to change the values in the file  		//we can assume that if there are no new coords' then the old file matches the new exactly  		if (newCoords.Count > 0) {  			//make a new vertex point and append it to the line  			//do a check for the semicolon now because this changes the type of exchange that we make  			Match semicolonMatch = semiColonRegex.Match (line);  			if (semicolonMatch.Success) {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string semicolon = ";";  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				newCoords.Clear ();  				//reset  				vertexMatching = false;  				detailedFenestration = false;  				vertexCounter = 1;  				continue;  			}  			//it is a normal typical vertex line  			else {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				newCoords.Clear ();  				continue;  			}  		}  		//apparently the lines were exactly the same  		else {  			output.AppendLine (line);  			vertexCounter++;  			continue;  		}  	}  	//this is admittedly a bit sloppy and should be cleaned up  	//basically says' if there is no match' then move append and work on the next line  	else {  		output.AppendLine (line);  	}  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (detailedFenestration) {  	//Match the name of the window  	Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  	if (fenestrationNameMatch.Success) {  		firstLineofFenestration = false;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			windowName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			continue;  		}  	}  	Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  	if (parentSurfaceIdMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  		if (pure.Success) {  			parentSurfaceName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			continue;  		}  	}  	//Get multiplier  	Match multiplierMatch = multiplierRegex.Match (line);  	if (multiplierMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  		if (pure.Success) {  			string frontSpace = "    ";  			//string multiPlier = pure.Groups["goods"].Value;  			string multiPlier = "1";  			string comma = "'";  			string endString = "                       !- Multiplier";  			output.AppendLine (frontSpace + multiPlier + comma + endString);  			continue;  		}  	}  	//My next match is the coordinates' since the rest I should be able to skip at this point  	Match typicalVertexMatch = typicalVertexRegex.Match (line);  	if (typicalVertexMatch.Success) {  		vertexMatching = true;  		if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  			#region  			//globally change all the windows to a new window area based on the surface attached  			//get the areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  				if (window.nameId == windowName) {  					foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  						if (window.parentSurfaceNameId == surface.name) {  							double windowArea = Vector.GetAreaofWindow (window);  							double wallArea = Vector.GetAreaofSurface (surface);  							if (surface.multiplier > 0) {  								wallArea *= surface.multiplier;  								windowArea *= surface.multiplier * window.multiplier;  							}  							else {  								windowArea *= window.multiplier;  							}  							double WWR = windowArea / wallArea;  							if (WWR != desiredUserWWR) {  								//simple here in assuming that the wall is a square surface' otherwise  								//we would have to use some sort of scaling function that emanates from the  								//centroid' which we currently do not have' so we only work when the num vertices  								//is equal to four  								if (surface.numVertices == 4) {  									//under the simplifying assumption that walls are tilted to 90oF  									double zlow = 0.0;  									double zHigh = 0.0;  									for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  										if (j == 0) {  											zlow = surface.SurfaceCoords [j].Z;  											zHigh = surface.SurfaceCoords [j].Z;  										}  										else {  											if (surface.SurfaceCoords [j].Z < zlow)  												zlow = surface.SurfaceCoords [j].Z;  											if (surface.SurfaceCoords [j].Z > zHigh)  												zHigh = surface.SurfaceCoords [j].Z;  										}  									}  									double wallHeight = zHigh - zlow;  									//make each x' y vertex the same in both the surface and window  									//and strip window heights that are adjusted based on user preference  									if (window.numVertices == 4) {  										//we assume that the vertexes start in the lower left hand corner' though   										//subject to change  										for (int i = 0; i < window.coordinateList.Count; i++) {  											//assume that the coordinates both go in the same order  											switch (i) {  											case 0:  												double X = surface.SurfaceCoords [i].X;  												double Y = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z = surface.SurfaceCoords [i].Z + sillHeight;  												Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  												newCoords.Add (newWindowCoord);  												break;  											case 1:  												double X1 = surface.SurfaceCoords [i].X;  												double Y1 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  												Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  												newCoords.Add (newWindowCoord1);  												break;  											case 2:  												double X2 = surface.SurfaceCoords [i].X;  												double Y2 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  												Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  												newCoords.Add (newWindowCoord2);  												break;  											case 3:  												double X3 = surface.SurfaceCoords [i].X;  												double Y3 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  												Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  												newCoords.Add (newWindowCoord3);  												break;  											}  										}  									}  								}  							}  						}  					}  				}  			}  			#endregion  		}  		//once I have the newCoordinates' then I should go on to change the values in the file  		//we can assume that if there are no new coords' then the old file matches the new exactly  		if (newCoords.Count > 0) {  			//make a new vertex point and append it to the line  			//do a check for the semicolon now because this changes the type of exchange that we make  			Match semicolonMatch = semiColonRegex.Match (line);  			if (semicolonMatch.Success) {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string semicolon = ";";  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				newCoords.Clear ();  				//reset  				vertexMatching = false;  				detailedFenestration = false;  				vertexCounter = 1;  				continue;  			}  			//it is a normal typical vertex line  			else {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				newCoords.Clear ();  				continue;  			}  		}  		//apparently the lines were exactly the same  		else {  			output.AppendLine (line);  			vertexCounter++;  			continue;  		}  	}  	//this is admittedly a bit sloppy and should be cleaned up  	//basically says' if there is no match' then move append and work on the next line  	else {  		output.AppendLine (line);  	}  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (detailedFenestration) {  	//Match the name of the window  	Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  	if (fenestrationNameMatch.Success) {  		firstLineofFenestration = false;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			windowName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			continue;  		}  	}  	Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  	if (parentSurfaceIdMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  		if (pure.Success) {  			parentSurfaceName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			continue;  		}  	}  	//Get multiplier  	Match multiplierMatch = multiplierRegex.Match (line);  	if (multiplierMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  		if (pure.Success) {  			string frontSpace = "    ";  			//string multiPlier = pure.Groups["goods"].Value;  			string multiPlier = "1";  			string comma = "'";  			string endString = "                       !- Multiplier";  			output.AppendLine (frontSpace + multiPlier + comma + endString);  			continue;  		}  	}  	//My next match is the coordinates' since the rest I should be able to skip at this point  	Match typicalVertexMatch = typicalVertexRegex.Match (line);  	if (typicalVertexMatch.Success) {  		vertexMatching = true;  		if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  			#region  			//globally change all the windows to a new window area based on the surface attached  			//get the areas  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  				if (window.nameId == windowName) {  					foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  						if (window.parentSurfaceNameId == surface.name) {  							double windowArea = Vector.GetAreaofWindow (window);  							double wallArea = Vector.GetAreaofSurface (surface);  							if (surface.multiplier > 0) {  								wallArea *= surface.multiplier;  								windowArea *= surface.multiplier * window.multiplier;  							}  							else {  								windowArea *= window.multiplier;  							}  							double WWR = windowArea / wallArea;  							if (WWR != desiredUserWWR) {  								//simple here in assuming that the wall is a square surface' otherwise  								//we would have to use some sort of scaling function that emanates from the  								//centroid' which we currently do not have' so we only work when the num vertices  								//is equal to four  								if (surface.numVertices == 4) {  									//under the simplifying assumption that walls are tilted to 90oF  									double zlow = 0.0;  									double zHigh = 0.0;  									for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  										if (j == 0) {  											zlow = surface.SurfaceCoords [j].Z;  											zHigh = surface.SurfaceCoords [j].Z;  										}  										else {  											if (surface.SurfaceCoords [j].Z < zlow)  												zlow = surface.SurfaceCoords [j].Z;  											if (surface.SurfaceCoords [j].Z > zHigh)  												zHigh = surface.SurfaceCoords [j].Z;  										}  									}  									double wallHeight = zHigh - zlow;  									//make each x' y vertex the same in both the surface and window  									//and strip window heights that are adjusted based on user preference  									if (window.numVertices == 4) {  										//we assume that the vertexes start in the lower left hand corner' though   										//subject to change  										for (int i = 0; i < window.coordinateList.Count; i++) {  											//assume that the coordinates both go in the same order  											switch (i) {  											case 0:  												double X = surface.SurfaceCoords [i].X;  												double Y = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z = surface.SurfaceCoords [i].Z + sillHeight;  												Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  												newCoords.Add (newWindowCoord);  												break;  											case 1:  												double X1 = surface.SurfaceCoords [i].X;  												double Y1 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  												Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  												newCoords.Add (newWindowCoord1);  												break;  											case 2:  												double X2 = surface.SurfaceCoords [i].X;  												double Y2 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  												Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  												newCoords.Add (newWindowCoord2);  												break;  											case 3:  												double X3 = surface.SurfaceCoords [i].X;  												double Y3 = surface.SurfaceCoords [i].Y;  												//this should be settable  												double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  												Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  												newCoords.Add (newWindowCoord3);  												break;  											}  										}  									}  								}  							}  						}  					}  				}  			}  			#endregion  		}  		//once I have the newCoordinates' then I should go on to change the values in the file  		//we can assume that if there are no new coords' then the old file matches the new exactly  		if (newCoords.Count > 0) {  			//make a new vertex point and append it to the line  			//do a check for the semicolon now because this changes the type of exchange that we make  			Match semicolonMatch = semiColonRegex.Match (line);  			if (semicolonMatch.Success) {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string semicolon = ";";  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				newCoords.Clear ();  				//reset  				vertexMatching = false;  				detailedFenestration = false;  				vertexCounter = 1;  				continue;  			}  			//it is a normal typical vertex line  			else {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				newCoords.Clear ();  				continue;  			}  		}  		//apparently the lines were exactly the same  		else {  			output.AppendLine (line);  			vertexCounter++;  			continue;  		}  	}  	//this is admittedly a bit sloppy and should be cleaned up  	//basically says' if there is no match' then move append and work on the next line  	else {  		output.AppendLine (line);  	}  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (typicalVertexMatch.Success) {  	vertexMatching = true;  	if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  		#region  		//globally change all the windows to a new window area based on the surface attached  		//get the areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  			if (window.nameId == windowName) {  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  					if (window.parentSurfaceNameId == surface.name) {  						double windowArea = Vector.GetAreaofWindow (window);  						double wallArea = Vector.GetAreaofSurface (surface);  						if (surface.multiplier > 0) {  							wallArea *= surface.multiplier;  							windowArea *= surface.multiplier * window.multiplier;  						}  						else {  							windowArea *= window.multiplier;  						}  						double WWR = windowArea / wallArea;  						if (WWR != desiredUserWWR) {  							//simple here in assuming that the wall is a square surface' otherwise  							//we would have to use some sort of scaling function that emanates from the  							//centroid' which we currently do not have' so we only work when the num vertices  							//is equal to four  							if (surface.numVertices == 4) {  								//under the simplifying assumption that walls are tilted to 90oF  								double zlow = 0.0;  								double zHigh = 0.0;  								for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  									if (j == 0) {  										zlow = surface.SurfaceCoords [j].Z;  										zHigh = surface.SurfaceCoords [j].Z;  									}  									else {  										if (surface.SurfaceCoords [j].Z < zlow)  											zlow = surface.SurfaceCoords [j].Z;  										if (surface.SurfaceCoords [j].Z > zHigh)  											zHigh = surface.SurfaceCoords [j].Z;  									}  								}  								double wallHeight = zHigh - zlow;  								//make each x' y vertex the same in both the surface and window  								//and strip window heights that are adjusted based on user preference  								if (window.numVertices == 4) {  									//we assume that the vertexes start in the lower left hand corner' though   									//subject to change  									for (int i = 0; i < window.coordinateList.Count; i++) {  										//assume that the coordinates both go in the same order  										switch (i) {  										case 0:  											double X = surface.SurfaceCoords [i].X;  											double Y = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z = surface.SurfaceCoords [i].Z + sillHeight;  											Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  											newCoords.Add (newWindowCoord);  											break;  										case 1:  											double X1 = surface.SurfaceCoords [i].X;  											double Y1 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  											Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  											newCoords.Add (newWindowCoord1);  											break;  										case 2:  											double X2 = surface.SurfaceCoords [i].X;  											double Y2 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  											Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  											newCoords.Add (newWindowCoord2);  											break;  										case 3:  											double X3 = surface.SurfaceCoords [i].X;  											double Y3 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  											Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  											newCoords.Add (newWindowCoord3);  											break;  										}  									}  								}  							}  						}  					}  				}  			}  		}  		#endregion  	}  	//once I have the newCoordinates' then I should go on to change the values in the file  	//we can assume that if there are no new coords' then the old file matches the new exactly  	if (newCoords.Count > 0) {  		//make a new vertex point and append it to the line  		//do a check for the semicolon now because this changes the type of exchange that we make  		Match semicolonMatch = semiColonRegex.Match (line);  		if (semicolonMatch.Success) {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string semicolon = ";";  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			newCoords.Clear ();  			//reset  			vertexMatching = false;  			detailedFenestration = false;  			vertexCounter = 1;  			continue;  		}  		//it is a normal typical vertex line  		else {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			newCoords.Clear ();  			continue;  		}  	}  	//apparently the lines were exactly the same  	else {  		output.AppendLine (line);  		vertexCounter++;  		continue;  	}  }  //this is admittedly a bit sloppy and should be cleaned up  //basically says' if there is no match' then move append and work on the next line  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (typicalVertexMatch.Success) {  	vertexMatching = true;  	if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  		#region  		//globally change all the windows to a new window area based on the surface attached  		//get the areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  			if (window.nameId == windowName) {  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  					if (window.parentSurfaceNameId == surface.name) {  						double windowArea = Vector.GetAreaofWindow (window);  						double wallArea = Vector.GetAreaofSurface (surface);  						if (surface.multiplier > 0) {  							wallArea *= surface.multiplier;  							windowArea *= surface.multiplier * window.multiplier;  						}  						else {  							windowArea *= window.multiplier;  						}  						double WWR = windowArea / wallArea;  						if (WWR != desiredUserWWR) {  							//simple here in assuming that the wall is a square surface' otherwise  							//we would have to use some sort of scaling function that emanates from the  							//centroid' which we currently do not have' so we only work when the num vertices  							//is equal to four  							if (surface.numVertices == 4) {  								//under the simplifying assumption that walls are tilted to 90oF  								double zlow = 0.0;  								double zHigh = 0.0;  								for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  									if (j == 0) {  										zlow = surface.SurfaceCoords [j].Z;  										zHigh = surface.SurfaceCoords [j].Z;  									}  									else {  										if (surface.SurfaceCoords [j].Z < zlow)  											zlow = surface.SurfaceCoords [j].Z;  										if (surface.SurfaceCoords [j].Z > zHigh)  											zHigh = surface.SurfaceCoords [j].Z;  									}  								}  								double wallHeight = zHigh - zlow;  								//make each x' y vertex the same in both the surface and window  								//and strip window heights that are adjusted based on user preference  								if (window.numVertices == 4) {  									//we assume that the vertexes start in the lower left hand corner' though   									//subject to change  									for (int i = 0; i < window.coordinateList.Count; i++) {  										//assume that the coordinates both go in the same order  										switch (i) {  										case 0:  											double X = surface.SurfaceCoords [i].X;  											double Y = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z = surface.SurfaceCoords [i].Z + sillHeight;  											Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  											newCoords.Add (newWindowCoord);  											break;  										case 1:  											double X1 = surface.SurfaceCoords [i].X;  											double Y1 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  											Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  											newCoords.Add (newWindowCoord1);  											break;  										case 2:  											double X2 = surface.SurfaceCoords [i].X;  											double Y2 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  											Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  											newCoords.Add (newWindowCoord2);  											break;  										case 3:  											double X3 = surface.SurfaceCoords [i].X;  											double Y3 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  											Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  											newCoords.Add (newWindowCoord3);  											break;  										}  									}  								}  							}  						}  					}  				}  			}  		}  		#endregion  	}  	//once I have the newCoordinates' then I should go on to change the values in the file  	//we can assume that if there are no new coords' then the old file matches the new exactly  	if (newCoords.Count > 0) {  		//make a new vertex point and append it to the line  		//do a check for the semicolon now because this changes the type of exchange that we make  		Match semicolonMatch = semiColonRegex.Match (line);  		if (semicolonMatch.Success) {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string semicolon = ";";  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			newCoords.Clear ();  			//reset  			vertexMatching = false;  			detailedFenestration = false;  			vertexCounter = 1;  			continue;  		}  		//it is a normal typical vertex line  		else {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			newCoords.Clear ();  			continue;  		}  	}  	//apparently the lines were exactly the same  	else {  		output.AppendLine (line);  		vertexCounter++;  		continue;  	}  }  //this is admittedly a bit sloppy and should be cleaned up  //basically says' if there is no match' then move append and work on the next line  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (typicalVertexMatch.Success) {  	vertexMatching = true;  	if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  		#region  		//globally change all the windows to a new window area based on the surface attached  		//get the areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  			if (window.nameId == windowName) {  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  					if (window.parentSurfaceNameId == surface.name) {  						double windowArea = Vector.GetAreaofWindow (window);  						double wallArea = Vector.GetAreaofSurface (surface);  						if (surface.multiplier > 0) {  							wallArea *= surface.multiplier;  							windowArea *= surface.multiplier * window.multiplier;  						}  						else {  							windowArea *= window.multiplier;  						}  						double WWR = windowArea / wallArea;  						if (WWR != desiredUserWWR) {  							//simple here in assuming that the wall is a square surface' otherwise  							//we would have to use some sort of scaling function that emanates from the  							//centroid' which we currently do not have' so we only work when the num vertices  							//is equal to four  							if (surface.numVertices == 4) {  								//under the simplifying assumption that walls are tilted to 90oF  								double zlow = 0.0;  								double zHigh = 0.0;  								for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  									if (j == 0) {  										zlow = surface.SurfaceCoords [j].Z;  										zHigh = surface.SurfaceCoords [j].Z;  									}  									else {  										if (surface.SurfaceCoords [j].Z < zlow)  											zlow = surface.SurfaceCoords [j].Z;  										if (surface.SurfaceCoords [j].Z > zHigh)  											zHigh = surface.SurfaceCoords [j].Z;  									}  								}  								double wallHeight = zHigh - zlow;  								//make each x' y vertex the same in both the surface and window  								//and strip window heights that are adjusted based on user preference  								if (window.numVertices == 4) {  									//we assume that the vertexes start in the lower left hand corner' though   									//subject to change  									for (int i = 0; i < window.coordinateList.Count; i++) {  										//assume that the coordinates both go in the same order  										switch (i) {  										case 0:  											double X = surface.SurfaceCoords [i].X;  											double Y = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z = surface.SurfaceCoords [i].Z + sillHeight;  											Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  											newCoords.Add (newWindowCoord);  											break;  										case 1:  											double X1 = surface.SurfaceCoords [i].X;  											double Y1 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  											Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  											newCoords.Add (newWindowCoord1);  											break;  										case 2:  											double X2 = surface.SurfaceCoords [i].X;  											double Y2 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  											Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  											newCoords.Add (newWindowCoord2);  											break;  										case 3:  											double X3 = surface.SurfaceCoords [i].X;  											double Y3 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  											Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  											newCoords.Add (newWindowCoord3);  											break;  										}  									}  								}  							}  						}  					}  				}  			}  		}  		#endregion  	}  	//once I have the newCoordinates' then I should go on to change the values in the file  	//we can assume that if there are no new coords' then the old file matches the new exactly  	if (newCoords.Count > 0) {  		//make a new vertex point and append it to the line  		//do a check for the semicolon now because this changes the type of exchange that we make  		Match semicolonMatch = semiColonRegex.Match (line);  		if (semicolonMatch.Success) {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string semicolon = ";";  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			newCoords.Clear ();  			//reset  			vertexMatching = false;  			detailedFenestration = false;  			vertexCounter = 1;  			continue;  		}  		//it is a normal typical vertex line  		else {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			newCoords.Clear ();  			continue;  		}  	}  	//apparently the lines were exactly the same  	else {  		output.AppendLine (line);  		vertexCounter++;  		continue;  	}  }  //this is admittedly a bit sloppy and should be cleaned up  //basically says' if there is no match' then move append and work on the next line  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (typicalVertexMatch.Success) {  	vertexMatching = true;  	if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  		#region  		//globally change all the windows to a new window area based on the surface attached  		//get the areas  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  			if (window.nameId == windowName) {  				foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  					if (window.parentSurfaceNameId == surface.name) {  						double windowArea = Vector.GetAreaofWindow (window);  						double wallArea = Vector.GetAreaofSurface (surface);  						if (surface.multiplier > 0) {  							wallArea *= surface.multiplier;  							windowArea *= surface.multiplier * window.multiplier;  						}  						else {  							windowArea *= window.multiplier;  						}  						double WWR = windowArea / wallArea;  						if (WWR != desiredUserWWR) {  							//simple here in assuming that the wall is a square surface' otherwise  							//we would have to use some sort of scaling function that emanates from the  							//centroid' which we currently do not have' so we only work when the num vertices  							//is equal to four  							if (surface.numVertices == 4) {  								//under the simplifying assumption that walls are tilted to 90oF  								double zlow = 0.0;  								double zHigh = 0.0;  								for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  									if (j == 0) {  										zlow = surface.SurfaceCoords [j].Z;  										zHigh = surface.SurfaceCoords [j].Z;  									}  									else {  										if (surface.SurfaceCoords [j].Z < zlow)  											zlow = surface.SurfaceCoords [j].Z;  										if (surface.SurfaceCoords [j].Z > zHigh)  											zHigh = surface.SurfaceCoords [j].Z;  									}  								}  								double wallHeight = zHigh - zlow;  								//make each x' y vertex the same in both the surface and window  								//and strip window heights that are adjusted based on user preference  								if (window.numVertices == 4) {  									//we assume that the vertexes start in the lower left hand corner' though   									//subject to change  									for (int i = 0; i < window.coordinateList.Count; i++) {  										//assume that the coordinates both go in the same order  										switch (i) {  										case 0:  											double X = surface.SurfaceCoords [i].X;  											double Y = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z = surface.SurfaceCoords [i].Z + sillHeight;  											Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  											newCoords.Add (newWindowCoord);  											break;  										case 1:  											double X1 = surface.SurfaceCoords [i].X;  											double Y1 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  											Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  											newCoords.Add (newWindowCoord1);  											break;  										case 2:  											double X2 = surface.SurfaceCoords [i].X;  											double Y2 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  											Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  											newCoords.Add (newWindowCoord2);  											break;  										case 3:  											double X3 = surface.SurfaceCoords [i].X;  											double Y3 = surface.SurfaceCoords [i].Y;  											//this should be settable  											double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  											Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  											newCoords.Add (newWindowCoord3);  											break;  										}  									}  								}  							}  						}  					}  				}  			}  		}  		#endregion  	}  	//once I have the newCoordinates' then I should go on to change the values in the file  	//we can assume that if there are no new coords' then the old file matches the new exactly  	if (newCoords.Count > 0) {  		//make a new vertex point and append it to the line  		//do a check for the semicolon now because this changes the type of exchange that we make  		Match semicolonMatch = semiColonRegex.Match (line);  		if (semicolonMatch.Success) {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string semicolon = ";";  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			newCoords.Clear ();  			//reset  			vertexMatching = false;  			detailedFenestration = false;  			vertexCounter = 1;  			continue;  		}  		//it is a normal typical vertex line  		else {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			newCoords.Clear ();  			continue;  		}  	}  	//apparently the lines were exactly the same  	else {  		output.AppendLine (line);  		vertexCounter++;  		continue;  	}  }  //this is admittedly a bit sloppy and should be cleaned up  //basically says' if there is no match' then move append and work on the next line  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  	#region  	//globally change all the windows to a new window area based on the surface attached  	//get the areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  		if (window.nameId == windowName) {  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  				if (window.parentSurfaceNameId == surface.name) {  					double windowArea = Vector.GetAreaofWindow (window);  					double wallArea = Vector.GetAreaofSurface (surface);  					if (surface.multiplier > 0) {  						wallArea *= surface.multiplier;  						windowArea *= surface.multiplier * window.multiplier;  					}  					else {  						windowArea *= window.multiplier;  					}  					double WWR = windowArea / wallArea;  					if (WWR != desiredUserWWR) {  						//simple here in assuming that the wall is a square surface' otherwise  						//we would have to use some sort of scaling function that emanates from the  						//centroid' which we currently do not have' so we only work when the num vertices  						//is equal to four  						if (surface.numVertices == 4) {  							//under the simplifying assumption that walls are tilted to 90oF  							double zlow = 0.0;  							double zHigh = 0.0;  							for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  								if (j == 0) {  									zlow = surface.SurfaceCoords [j].Z;  									zHigh = surface.SurfaceCoords [j].Z;  								}  								else {  									if (surface.SurfaceCoords [j].Z < zlow)  										zlow = surface.SurfaceCoords [j].Z;  									if (surface.SurfaceCoords [j].Z > zHigh)  										zHigh = surface.SurfaceCoords [j].Z;  								}  							}  							double wallHeight = zHigh - zlow;  							//make each x' y vertex the same in both the surface and window  							//and strip window heights that are adjusted based on user preference  							if (window.numVertices == 4) {  								//we assume that the vertexes start in the lower left hand corner' though   								//subject to change  								for (int i = 0; i < window.coordinateList.Count; i++) {  									//assume that the coordinates both go in the same order  									switch (i) {  									case 0:  										double X = surface.SurfaceCoords [i].X;  										double Y = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z = surface.SurfaceCoords [i].Z + sillHeight;  										Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  										newCoords.Add (newWindowCoord);  										break;  									case 1:  										double X1 = surface.SurfaceCoords [i].X;  										double Y1 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  										Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  										newCoords.Add (newWindowCoord1);  										break;  									case 2:  										double X2 = surface.SurfaceCoords [i].X;  										double Y2 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  										Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  										newCoords.Add (newWindowCoord2);  										break;  									case 3:  										double X3 = surface.SurfaceCoords [i].X;  										double Y3 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  										Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  										newCoords.Add (newWindowCoord3);  										break;  									}  								}  							}  						}  					}  				}  			}  		}  	}  	#endregion  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  	#region  	//globally change all the windows to a new window area based on the surface attached  	//get the areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  		if (window.nameId == windowName) {  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  				if (window.parentSurfaceNameId == surface.name) {  					double windowArea = Vector.GetAreaofWindow (window);  					double wallArea = Vector.GetAreaofSurface (surface);  					if (surface.multiplier > 0) {  						wallArea *= surface.multiplier;  						windowArea *= surface.multiplier * window.multiplier;  					}  					else {  						windowArea *= window.multiplier;  					}  					double WWR = windowArea / wallArea;  					if (WWR != desiredUserWWR) {  						//simple here in assuming that the wall is a square surface' otherwise  						//we would have to use some sort of scaling function that emanates from the  						//centroid' which we currently do not have' so we only work when the num vertices  						//is equal to four  						if (surface.numVertices == 4) {  							//under the simplifying assumption that walls are tilted to 90oF  							double zlow = 0.0;  							double zHigh = 0.0;  							for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  								if (j == 0) {  									zlow = surface.SurfaceCoords [j].Z;  									zHigh = surface.SurfaceCoords [j].Z;  								}  								else {  									if (surface.SurfaceCoords [j].Z < zlow)  										zlow = surface.SurfaceCoords [j].Z;  									if (surface.SurfaceCoords [j].Z > zHigh)  										zHigh = surface.SurfaceCoords [j].Z;  								}  							}  							double wallHeight = zHigh - zlow;  							//make each x' y vertex the same in both the surface and window  							//and strip window heights that are adjusted based on user preference  							if (window.numVertices == 4) {  								//we assume that the vertexes start in the lower left hand corner' though   								//subject to change  								for (int i = 0; i < window.coordinateList.Count; i++) {  									//assume that the coordinates both go in the same order  									switch (i) {  									case 0:  										double X = surface.SurfaceCoords [i].X;  										double Y = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z = surface.SurfaceCoords [i].Z + sillHeight;  										Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  										newCoords.Add (newWindowCoord);  										break;  									case 1:  										double X1 = surface.SurfaceCoords [i].X;  										double Y1 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  										Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  										newCoords.Add (newWindowCoord1);  										break;  									case 2:  										double X2 = surface.SurfaceCoords [i].X;  										double Y2 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  										Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  										newCoords.Add (newWindowCoord2);  										break;  									case 3:  										double X3 = surface.SurfaceCoords [i].X;  										double Y3 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  										Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  										newCoords.Add (newWindowCoord3);  										break;  									}  								}  							}  						}  					}  				}  			}  		}  	}  	#endregion  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  	#region  	//globally change all the windows to a new window area based on the surface attached  	//get the areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  		if (window.nameId == windowName) {  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  				if (window.parentSurfaceNameId == surface.name) {  					double windowArea = Vector.GetAreaofWindow (window);  					double wallArea = Vector.GetAreaofSurface (surface);  					if (surface.multiplier > 0) {  						wallArea *= surface.multiplier;  						windowArea *= surface.multiplier * window.multiplier;  					}  					else {  						windowArea *= window.multiplier;  					}  					double WWR = windowArea / wallArea;  					if (WWR != desiredUserWWR) {  						//simple here in assuming that the wall is a square surface' otherwise  						//we would have to use some sort of scaling function that emanates from the  						//centroid' which we currently do not have' so we only work when the num vertices  						//is equal to four  						if (surface.numVertices == 4) {  							//under the simplifying assumption that walls are tilted to 90oF  							double zlow = 0.0;  							double zHigh = 0.0;  							for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  								if (j == 0) {  									zlow = surface.SurfaceCoords [j].Z;  									zHigh = surface.SurfaceCoords [j].Z;  								}  								else {  									if (surface.SurfaceCoords [j].Z < zlow)  										zlow = surface.SurfaceCoords [j].Z;  									if (surface.SurfaceCoords [j].Z > zHigh)  										zHigh = surface.SurfaceCoords [j].Z;  								}  							}  							double wallHeight = zHigh - zlow;  							//make each x' y vertex the same in both the surface and window  							//and strip window heights that are adjusted based on user preference  							if (window.numVertices == 4) {  								//we assume that the vertexes start in the lower left hand corner' though   								//subject to change  								for (int i = 0; i < window.coordinateList.Count; i++) {  									//assume that the coordinates both go in the same order  									switch (i) {  									case 0:  										double X = surface.SurfaceCoords [i].X;  										double Y = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z = surface.SurfaceCoords [i].Z + sillHeight;  										Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  										newCoords.Add (newWindowCoord);  										break;  									case 1:  										double X1 = surface.SurfaceCoords [i].X;  										double Y1 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  										Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  										newCoords.Add (newWindowCoord1);  										break;  									case 2:  										double X2 = surface.SurfaceCoords [i].X;  										double Y2 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  										Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  										newCoords.Add (newWindowCoord2);  										break;  									case 3:  										double X3 = surface.SurfaceCoords [i].X;  										double Y3 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  										Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  										newCoords.Add (newWindowCoord3);  										break;  									}  								}  							}  						}  					}  				}  			}  		}  	}  	#endregion  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  	#region  	//globally change all the windows to a new window area based on the surface attached  	//get the areas  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  		if (window.nameId == windowName) {  			foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  				if (window.parentSurfaceNameId == surface.name) {  					double windowArea = Vector.GetAreaofWindow (window);  					double wallArea = Vector.GetAreaofSurface (surface);  					if (surface.multiplier > 0) {  						wallArea *= surface.multiplier;  						windowArea *= surface.multiplier * window.multiplier;  					}  					else {  						windowArea *= window.multiplier;  					}  					double WWR = windowArea / wallArea;  					if (WWR != desiredUserWWR) {  						//simple here in assuming that the wall is a square surface' otherwise  						//we would have to use some sort of scaling function that emanates from the  						//centroid' which we currently do not have' so we only work when the num vertices  						//is equal to four  						if (surface.numVertices == 4) {  							//under the simplifying assumption that walls are tilted to 90oF  							double zlow = 0.0;  							double zHigh = 0.0;  							for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  								if (j == 0) {  									zlow = surface.SurfaceCoords [j].Z;  									zHigh = surface.SurfaceCoords [j].Z;  								}  								else {  									if (surface.SurfaceCoords [j].Z < zlow)  										zlow = surface.SurfaceCoords [j].Z;  									if (surface.SurfaceCoords [j].Z > zHigh)  										zHigh = surface.SurfaceCoords [j].Z;  								}  							}  							double wallHeight = zHigh - zlow;  							//make each x' y vertex the same in both the surface and window  							//and strip window heights that are adjusted based on user preference  							if (window.numVertices == 4) {  								//we assume that the vertexes start in the lower left hand corner' though   								//subject to change  								for (int i = 0; i < window.coordinateList.Count; i++) {  									//assume that the coordinates both go in the same order  									switch (i) {  									case 0:  										double X = surface.SurfaceCoords [i].X;  										double Y = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z = surface.SurfaceCoords [i].Z + sillHeight;  										Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  										newCoords.Add (newWindowCoord);  										break;  									case 1:  										double X1 = surface.SurfaceCoords [i].X;  										double Y1 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  										Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  										newCoords.Add (newWindowCoord1);  										break;  									case 2:  										double X2 = surface.SurfaceCoords [i].X;  										double Y2 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  										Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  										newCoords.Add (newWindowCoord2);  										break;  									case 3:  										double X3 = surface.SurfaceCoords [i].X;  										double Y3 = surface.SurfaceCoords [i].Y;  										//this should be settable  										double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  										Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  										newCoords.Add (newWindowCoord3);  										break;  									}  								}  							}  						}  					}  				}  			}  		}  	}  	#endregion  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  	if (window.nameId == windowName) {  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  			if (window.parentSurfaceNameId == surface.name) {  				double windowArea = Vector.GetAreaofWindow (window);  				double wallArea = Vector.GetAreaofSurface (surface);  				if (surface.multiplier > 0) {  					wallArea *= surface.multiplier;  					windowArea *= surface.multiplier * window.multiplier;  				}  				else {  					windowArea *= window.multiplier;  				}  				double WWR = windowArea / wallArea;  				if (WWR != desiredUserWWR) {  					//simple here in assuming that the wall is a square surface' otherwise  					//we would have to use some sort of scaling function that emanates from the  					//centroid' which we currently do not have' so we only work when the num vertices  					//is equal to four  					if (surface.numVertices == 4) {  						//under the simplifying assumption that walls are tilted to 90oF  						double zlow = 0.0;  						double zHigh = 0.0;  						for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  							if (j == 0) {  								zlow = surface.SurfaceCoords [j].Z;  								zHigh = surface.SurfaceCoords [j].Z;  							}  							else {  								if (surface.SurfaceCoords [j].Z < zlow)  									zlow = surface.SurfaceCoords [j].Z;  								if (surface.SurfaceCoords [j].Z > zHigh)  									zHigh = surface.SurfaceCoords [j].Z;  							}  						}  						double wallHeight = zHigh - zlow;  						//make each x' y vertex the same in both the surface and window  						//and strip window heights that are adjusted based on user preference  						if (window.numVertices == 4) {  							//we assume that the vertexes start in the lower left hand corner' though   							//subject to change  							for (int i = 0; i < window.coordinateList.Count; i++) {  								//assume that the coordinates both go in the same order  								switch (i) {  								case 0:  									double X = surface.SurfaceCoords [i].X;  									double Y = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z = surface.SurfaceCoords [i].Z + sillHeight;  									Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  									newCoords.Add (newWindowCoord);  									break;  								case 1:  									double X1 = surface.SurfaceCoords [i].X;  									double Y1 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  									Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  									newCoords.Add (newWindowCoord1);  									break;  								case 2:  									double X2 = surface.SurfaceCoords [i].X;  									double Y2 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  									Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  									newCoords.Add (newWindowCoord2);  									break;  								case 3:  									double X3 = surface.SurfaceCoords [i].X;  									double Y3 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  									Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  									newCoords.Add (newWindowCoord3);  									break;  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  	if (window.nameId == windowName) {  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  			if (window.parentSurfaceNameId == surface.name) {  				double windowArea = Vector.GetAreaofWindow (window);  				double wallArea = Vector.GetAreaofSurface (surface);  				if (surface.multiplier > 0) {  					wallArea *= surface.multiplier;  					windowArea *= surface.multiplier * window.multiplier;  				}  				else {  					windowArea *= window.multiplier;  				}  				double WWR = windowArea / wallArea;  				if (WWR != desiredUserWWR) {  					//simple here in assuming that the wall is a square surface' otherwise  					//we would have to use some sort of scaling function that emanates from the  					//centroid' which we currently do not have' so we only work when the num vertices  					//is equal to four  					if (surface.numVertices == 4) {  						//under the simplifying assumption that walls are tilted to 90oF  						double zlow = 0.0;  						double zHigh = 0.0;  						for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  							if (j == 0) {  								zlow = surface.SurfaceCoords [j].Z;  								zHigh = surface.SurfaceCoords [j].Z;  							}  							else {  								if (surface.SurfaceCoords [j].Z < zlow)  									zlow = surface.SurfaceCoords [j].Z;  								if (surface.SurfaceCoords [j].Z > zHigh)  									zHigh = surface.SurfaceCoords [j].Z;  							}  						}  						double wallHeight = zHigh - zlow;  						//make each x' y vertex the same in both the surface and window  						//and strip window heights that are adjusted based on user preference  						if (window.numVertices == 4) {  							//we assume that the vertexes start in the lower left hand corner' though   							//subject to change  							for (int i = 0; i < window.coordinateList.Count; i++) {  								//assume that the coordinates both go in the same order  								switch (i) {  								case 0:  									double X = surface.SurfaceCoords [i].X;  									double Y = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z = surface.SurfaceCoords [i].Z + sillHeight;  									Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  									newCoords.Add (newWindowCoord);  									break;  								case 1:  									double X1 = surface.SurfaceCoords [i].X;  									double Y1 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  									Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  									newCoords.Add (newWindowCoord1);  									break;  								case 2:  									double X2 = surface.SurfaceCoords [i].X;  									double Y2 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  									Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  									newCoords.Add (newWindowCoord2);  									break;  								case 3:  									double X3 = surface.SurfaceCoords [i].X;  									double Y3 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  									Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  									newCoords.Add (newWindowCoord3);  									break;  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  	if (window.nameId == windowName) {  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  			if (window.parentSurfaceNameId == surface.name) {  				double windowArea = Vector.GetAreaofWindow (window);  				double wallArea = Vector.GetAreaofSurface (surface);  				if (surface.multiplier > 0) {  					wallArea *= surface.multiplier;  					windowArea *= surface.multiplier * window.multiplier;  				}  				else {  					windowArea *= window.multiplier;  				}  				double WWR = windowArea / wallArea;  				if (WWR != desiredUserWWR) {  					//simple here in assuming that the wall is a square surface' otherwise  					//we would have to use some sort of scaling function that emanates from the  					//centroid' which we currently do not have' so we only work when the num vertices  					//is equal to four  					if (surface.numVertices == 4) {  						//under the simplifying assumption that walls are tilted to 90oF  						double zlow = 0.0;  						double zHigh = 0.0;  						for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  							if (j == 0) {  								zlow = surface.SurfaceCoords [j].Z;  								zHigh = surface.SurfaceCoords [j].Z;  							}  							else {  								if (surface.SurfaceCoords [j].Z < zlow)  									zlow = surface.SurfaceCoords [j].Z;  								if (surface.SurfaceCoords [j].Z > zHigh)  									zHigh = surface.SurfaceCoords [j].Z;  							}  						}  						double wallHeight = zHigh - zlow;  						//make each x' y vertex the same in both the surface and window  						//and strip window heights that are adjusted based on user preference  						if (window.numVertices == 4) {  							//we assume that the vertexes start in the lower left hand corner' though   							//subject to change  							for (int i = 0; i < window.coordinateList.Count; i++) {  								//assume that the coordinates both go in the same order  								switch (i) {  								case 0:  									double X = surface.SurfaceCoords [i].X;  									double Y = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z = surface.SurfaceCoords [i].Z + sillHeight;  									Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  									newCoords.Add (newWindowCoord);  									break;  								case 1:  									double X1 = surface.SurfaceCoords [i].X;  									double Y1 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  									Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  									newCoords.Add (newWindowCoord1);  									break;  								case 2:  									double X2 = surface.SurfaceCoords [i].X;  									double Y2 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  									Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  									newCoords.Add (newWindowCoord2);  									break;  								case 3:  									double X3 = surface.SurfaceCoords [i].X;  									double Y3 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  									Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  									newCoords.Add (newWindowCoord3);  									break;  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window in projectOpenings) {  	if (window.nameId == windowName) {  		foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  			if (window.parentSurfaceNameId == surface.name) {  				double windowArea = Vector.GetAreaofWindow (window);  				double wallArea = Vector.GetAreaofSurface (surface);  				if (surface.multiplier > 0) {  					wallArea *= surface.multiplier;  					windowArea *= surface.multiplier * window.multiplier;  				}  				else {  					windowArea *= window.multiplier;  				}  				double WWR = windowArea / wallArea;  				if (WWR != desiredUserWWR) {  					//simple here in assuming that the wall is a square surface' otherwise  					//we would have to use some sort of scaling function that emanates from the  					//centroid' which we currently do not have' so we only work when the num vertices  					//is equal to four  					if (surface.numVertices == 4) {  						//under the simplifying assumption that walls are tilted to 90oF  						double zlow = 0.0;  						double zHigh = 0.0;  						for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  							if (j == 0) {  								zlow = surface.SurfaceCoords [j].Z;  								zHigh = surface.SurfaceCoords [j].Z;  							}  							else {  								if (surface.SurfaceCoords [j].Z < zlow)  									zlow = surface.SurfaceCoords [j].Z;  								if (surface.SurfaceCoords [j].Z > zHigh)  									zHigh = surface.SurfaceCoords [j].Z;  							}  						}  						double wallHeight = zHigh - zlow;  						//make each x' y vertex the same in both the surface and window  						//and strip window heights that are adjusted based on user preference  						if (window.numVertices == 4) {  							//we assume that the vertexes start in the lower left hand corner' though   							//subject to change  							for (int i = 0; i < window.coordinateList.Count; i++) {  								//assume that the coordinates both go in the same order  								switch (i) {  								case 0:  									double X = surface.SurfaceCoords [i].X;  									double Y = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z = surface.SurfaceCoords [i].Z + sillHeight;  									Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  									newCoords.Add (newWindowCoord);  									break;  								case 1:  									double X1 = surface.SurfaceCoords [i].X;  									double Y1 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  									Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  									newCoords.Add (newWindowCoord1);  									break;  								case 2:  									double X2 = surface.SurfaceCoords [i].X;  									double Y2 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  									Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  									newCoords.Add (newWindowCoord2);  									break;  								case 3:  									double X3 = surface.SurfaceCoords [i].X;  									double Y3 = surface.SurfaceCoords [i].Y;  									//this should be settable  									double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  									Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  									newCoords.Add (newWindowCoord3);  									break;  								}  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (window.nameId == windowName) {  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  		if (window.parentSurfaceNameId == surface.name) {  			double windowArea = Vector.GetAreaofWindow (window);  			double wallArea = Vector.GetAreaofSurface (surface);  			if (surface.multiplier > 0) {  				wallArea *= surface.multiplier;  				windowArea *= surface.multiplier * window.multiplier;  			}  			else {  				windowArea *= window.multiplier;  			}  			double WWR = windowArea / wallArea;  			if (WWR != desiredUserWWR) {  				//simple here in assuming that the wall is a square surface' otherwise  				//we would have to use some sort of scaling function that emanates from the  				//centroid' which we currently do not have' so we only work when the num vertices  				//is equal to four  				if (surface.numVertices == 4) {  					//under the simplifying assumption that walls are tilted to 90oF  					double zlow = 0.0;  					double zHigh = 0.0;  					for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  						if (j == 0) {  							zlow = surface.SurfaceCoords [j].Z;  							zHigh = surface.SurfaceCoords [j].Z;  						}  						else {  							if (surface.SurfaceCoords [j].Z < zlow)  								zlow = surface.SurfaceCoords [j].Z;  							if (surface.SurfaceCoords [j].Z > zHigh)  								zHigh = surface.SurfaceCoords [j].Z;  						}  					}  					double wallHeight = zHigh - zlow;  					//make each x' y vertex the same in both the surface and window  					//and strip window heights that are adjusted based on user preference  					if (window.numVertices == 4) {  						//we assume that the vertexes start in the lower left hand corner' though   						//subject to change  						for (int i = 0; i < window.coordinateList.Count; i++) {  							//assume that the coordinates both go in the same order  							switch (i) {  							case 0:  								double X = surface.SurfaceCoords [i].X;  								double Y = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z = surface.SurfaceCoords [i].Z + sillHeight;  								Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  								newCoords.Add (newWindowCoord);  								break;  							case 1:  								double X1 = surface.SurfaceCoords [i].X;  								double Y1 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  								Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  								newCoords.Add (newWindowCoord1);  								break;  							case 2:  								double X2 = surface.SurfaceCoords [i].X;  								double Y2 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  								Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  								newCoords.Add (newWindowCoord2);  								break;  							case 3:  								double X3 = surface.SurfaceCoords [i].X;  								double Y3 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  								Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  								newCoords.Add (newWindowCoord3);  								break;  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (window.nameId == windowName) {  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  		if (window.parentSurfaceNameId == surface.name) {  			double windowArea = Vector.GetAreaofWindow (window);  			double wallArea = Vector.GetAreaofSurface (surface);  			if (surface.multiplier > 0) {  				wallArea *= surface.multiplier;  				windowArea *= surface.multiplier * window.multiplier;  			}  			else {  				windowArea *= window.multiplier;  			}  			double WWR = windowArea / wallArea;  			if (WWR != desiredUserWWR) {  				//simple here in assuming that the wall is a square surface' otherwise  				//we would have to use some sort of scaling function that emanates from the  				//centroid' which we currently do not have' so we only work when the num vertices  				//is equal to four  				if (surface.numVertices == 4) {  					//under the simplifying assumption that walls are tilted to 90oF  					double zlow = 0.0;  					double zHigh = 0.0;  					for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  						if (j == 0) {  							zlow = surface.SurfaceCoords [j].Z;  							zHigh = surface.SurfaceCoords [j].Z;  						}  						else {  							if (surface.SurfaceCoords [j].Z < zlow)  								zlow = surface.SurfaceCoords [j].Z;  							if (surface.SurfaceCoords [j].Z > zHigh)  								zHigh = surface.SurfaceCoords [j].Z;  						}  					}  					double wallHeight = zHigh - zlow;  					//make each x' y vertex the same in both the surface and window  					//and strip window heights that are adjusted based on user preference  					if (window.numVertices == 4) {  						//we assume that the vertexes start in the lower left hand corner' though   						//subject to change  						for (int i = 0; i < window.coordinateList.Count; i++) {  							//assume that the coordinates both go in the same order  							switch (i) {  							case 0:  								double X = surface.SurfaceCoords [i].X;  								double Y = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z = surface.SurfaceCoords [i].Z + sillHeight;  								Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  								newCoords.Add (newWindowCoord);  								break;  							case 1:  								double X1 = surface.SurfaceCoords [i].X;  								double Y1 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  								Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  								newCoords.Add (newWindowCoord1);  								break;  							case 2:  								double X2 = surface.SurfaceCoords [i].X;  								double Y2 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  								Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  								newCoords.Add (newWindowCoord2);  								break;  							case 3:  								double X3 = surface.SurfaceCoords [i].X;  								double Y3 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  								Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  								newCoords.Add (newWindowCoord3);  								break;  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (window.nameId == windowName) {  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  		if (window.parentSurfaceNameId == surface.name) {  			double windowArea = Vector.GetAreaofWindow (window);  			double wallArea = Vector.GetAreaofSurface (surface);  			if (surface.multiplier > 0) {  				wallArea *= surface.multiplier;  				windowArea *= surface.multiplier * window.multiplier;  			}  			else {  				windowArea *= window.multiplier;  			}  			double WWR = windowArea / wallArea;  			if (WWR != desiredUserWWR) {  				//simple here in assuming that the wall is a square surface' otherwise  				//we would have to use some sort of scaling function that emanates from the  				//centroid' which we currently do not have' so we only work when the num vertices  				//is equal to four  				if (surface.numVertices == 4) {  					//under the simplifying assumption that walls are tilted to 90oF  					double zlow = 0.0;  					double zHigh = 0.0;  					for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  						if (j == 0) {  							zlow = surface.SurfaceCoords [j].Z;  							zHigh = surface.SurfaceCoords [j].Z;  						}  						else {  							if (surface.SurfaceCoords [j].Z < zlow)  								zlow = surface.SurfaceCoords [j].Z;  							if (surface.SurfaceCoords [j].Z > zHigh)  								zHigh = surface.SurfaceCoords [j].Z;  						}  					}  					double wallHeight = zHigh - zlow;  					//make each x' y vertex the same in both the surface and window  					//and strip window heights that are adjusted based on user preference  					if (window.numVertices == 4) {  						//we assume that the vertexes start in the lower left hand corner' though   						//subject to change  						for (int i = 0; i < window.coordinateList.Count; i++) {  							//assume that the coordinates both go in the same order  							switch (i) {  							case 0:  								double X = surface.SurfaceCoords [i].X;  								double Y = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z = surface.SurfaceCoords [i].Z + sillHeight;  								Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  								newCoords.Add (newWindowCoord);  								break;  							case 1:  								double X1 = surface.SurfaceCoords [i].X;  								double Y1 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  								Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  								newCoords.Add (newWindowCoord1);  								break;  							case 2:  								double X2 = surface.SurfaceCoords [i].X;  								double Y2 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  								Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  								newCoords.Add (newWindowCoord2);  								break;  							case 3:  								double X3 = surface.SurfaceCoords [i].X;  								double Y3 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  								Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  								newCoords.Add (newWindowCoord3);  								break;  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (window.nameId == windowName) {  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  		if (window.parentSurfaceNameId == surface.name) {  			double windowArea = Vector.GetAreaofWindow (window);  			double wallArea = Vector.GetAreaofSurface (surface);  			if (surface.multiplier > 0) {  				wallArea *= surface.multiplier;  				windowArea *= surface.multiplier * window.multiplier;  			}  			else {  				windowArea *= window.multiplier;  			}  			double WWR = windowArea / wallArea;  			if (WWR != desiredUserWWR) {  				//simple here in assuming that the wall is a square surface' otherwise  				//we would have to use some sort of scaling function that emanates from the  				//centroid' which we currently do not have' so we only work when the num vertices  				//is equal to four  				if (surface.numVertices == 4) {  					//under the simplifying assumption that walls are tilted to 90oF  					double zlow = 0.0;  					double zHigh = 0.0;  					for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  						if (j == 0) {  							zlow = surface.SurfaceCoords [j].Z;  							zHigh = surface.SurfaceCoords [j].Z;  						}  						else {  							if (surface.SurfaceCoords [j].Z < zlow)  								zlow = surface.SurfaceCoords [j].Z;  							if (surface.SurfaceCoords [j].Z > zHigh)  								zHigh = surface.SurfaceCoords [j].Z;  						}  					}  					double wallHeight = zHigh - zlow;  					//make each x' y vertex the same in both the surface and window  					//and strip window heights that are adjusted based on user preference  					if (window.numVertices == 4) {  						//we assume that the vertexes start in the lower left hand corner' though   						//subject to change  						for (int i = 0; i < window.coordinateList.Count; i++) {  							//assume that the coordinates both go in the same order  							switch (i) {  							case 0:  								double X = surface.SurfaceCoords [i].X;  								double Y = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z = surface.SurfaceCoords [i].Z + sillHeight;  								Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  								newCoords.Add (newWindowCoord);  								break;  							case 1:  								double X1 = surface.SurfaceCoords [i].X;  								double Y1 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  								Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  								newCoords.Add (newWindowCoord1);  								break;  							case 2:  								double X2 = surface.SurfaceCoords [i].X;  								double Y2 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  								Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  								newCoords.Add (newWindowCoord2);  								break;  							case 3:  								double X3 = surface.SurfaceCoords [i].X;  								double Y3 = surface.SurfaceCoords [i].Y;  								//this should be settable  								double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  								Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  								newCoords.Add (newWindowCoord3);  								break;  							}  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  	if (window.parentSurfaceNameId == surface.name) {  		double windowArea = Vector.GetAreaofWindow (window);  		double wallArea = Vector.GetAreaofSurface (surface);  		if (surface.multiplier > 0) {  			wallArea *= surface.multiplier;  			windowArea *= surface.multiplier * window.multiplier;  		}  		else {  			windowArea *= window.multiplier;  		}  		double WWR = windowArea / wallArea;  		if (WWR != desiredUserWWR) {  			//simple here in assuming that the wall is a square surface' otherwise  			//we would have to use some sort of scaling function that emanates from the  			//centroid' which we currently do not have' so we only work when the num vertices  			//is equal to four  			if (surface.numVertices == 4) {  				//under the simplifying assumption that walls are tilted to 90oF  				double zlow = 0.0;  				double zHigh = 0.0;  				for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  					if (j == 0) {  						zlow = surface.SurfaceCoords [j].Z;  						zHigh = surface.SurfaceCoords [j].Z;  					}  					else {  						if (surface.SurfaceCoords [j].Z < zlow)  							zlow = surface.SurfaceCoords [j].Z;  						if (surface.SurfaceCoords [j].Z > zHigh)  							zHigh = surface.SurfaceCoords [j].Z;  					}  				}  				double wallHeight = zHigh - zlow;  				//make each x' y vertex the same in both the surface and window  				//and strip window heights that are adjusted based on user preference  				if (window.numVertices == 4) {  					//we assume that the vertexes start in the lower left hand corner' though   					//subject to change  					for (int i = 0; i < window.coordinateList.Count; i++) {  						//assume that the coordinates both go in the same order  						switch (i) {  						case 0:  							double X = surface.SurfaceCoords [i].X;  							double Y = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z = surface.SurfaceCoords [i].Z + sillHeight;  							Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  							newCoords.Add (newWindowCoord);  							break;  						case 1:  							double X1 = surface.SurfaceCoords [i].X;  							double Y1 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  							Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  							newCoords.Add (newWindowCoord1);  							break;  						case 2:  							double X2 = surface.SurfaceCoords [i].X;  							double Y2 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  							Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  							newCoords.Add (newWindowCoord2);  							break;  						case 3:  							double X3 = surface.SurfaceCoords [i].X;  							double Y3 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  							Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  							newCoords.Add (newWindowCoord3);  							break;  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  	if (window.parentSurfaceNameId == surface.name) {  		double windowArea = Vector.GetAreaofWindow (window);  		double wallArea = Vector.GetAreaofSurface (surface);  		if (surface.multiplier > 0) {  			wallArea *= surface.multiplier;  			windowArea *= surface.multiplier * window.multiplier;  		}  		else {  			windowArea *= window.multiplier;  		}  		double WWR = windowArea / wallArea;  		if (WWR != desiredUserWWR) {  			//simple here in assuming that the wall is a square surface' otherwise  			//we would have to use some sort of scaling function that emanates from the  			//centroid' which we currently do not have' so we only work when the num vertices  			//is equal to four  			if (surface.numVertices == 4) {  				//under the simplifying assumption that walls are tilted to 90oF  				double zlow = 0.0;  				double zHigh = 0.0;  				for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  					if (j == 0) {  						zlow = surface.SurfaceCoords [j].Z;  						zHigh = surface.SurfaceCoords [j].Z;  					}  					else {  						if (surface.SurfaceCoords [j].Z < zlow)  							zlow = surface.SurfaceCoords [j].Z;  						if (surface.SurfaceCoords [j].Z > zHigh)  							zHigh = surface.SurfaceCoords [j].Z;  					}  				}  				double wallHeight = zHigh - zlow;  				//make each x' y vertex the same in both the surface and window  				//and strip window heights that are adjusted based on user preference  				if (window.numVertices == 4) {  					//we assume that the vertexes start in the lower left hand corner' though   					//subject to change  					for (int i = 0; i < window.coordinateList.Count; i++) {  						//assume that the coordinates both go in the same order  						switch (i) {  						case 0:  							double X = surface.SurfaceCoords [i].X;  							double Y = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z = surface.SurfaceCoords [i].Z + sillHeight;  							Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  							newCoords.Add (newWindowCoord);  							break;  						case 1:  							double X1 = surface.SurfaceCoords [i].X;  							double Y1 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  							Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  							newCoords.Add (newWindowCoord1);  							break;  						case 2:  							double X2 = surface.SurfaceCoords [i].X;  							double Y2 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  							Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  							newCoords.Add (newWindowCoord2);  							break;  						case 3:  							double X3 = surface.SurfaceCoords [i].X;  							double Y3 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  							Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  							newCoords.Add (newWindowCoord3);  							break;  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  	if (window.parentSurfaceNameId == surface.name) {  		double windowArea = Vector.GetAreaofWindow (window);  		double wallArea = Vector.GetAreaofSurface (surface);  		if (surface.multiplier > 0) {  			wallArea *= surface.multiplier;  			windowArea *= surface.multiplier * window.multiplier;  		}  		else {  			windowArea *= window.multiplier;  		}  		double WWR = windowArea / wallArea;  		if (WWR != desiredUserWWR) {  			//simple here in assuming that the wall is a square surface' otherwise  			//we would have to use some sort of scaling function that emanates from the  			//centroid' which we currently do not have' so we only work when the num vertices  			//is equal to four  			if (surface.numVertices == 4) {  				//under the simplifying assumption that walls are tilted to 90oF  				double zlow = 0.0;  				double zHigh = 0.0;  				for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  					if (j == 0) {  						zlow = surface.SurfaceCoords [j].Z;  						zHigh = surface.SurfaceCoords [j].Z;  					}  					else {  						if (surface.SurfaceCoords [j].Z < zlow)  							zlow = surface.SurfaceCoords [j].Z;  						if (surface.SurfaceCoords [j].Z > zHigh)  							zHigh = surface.SurfaceCoords [j].Z;  					}  				}  				double wallHeight = zHigh - zlow;  				//make each x' y vertex the same in both the surface and window  				//and strip window heights that are adjusted based on user preference  				if (window.numVertices == 4) {  					//we assume that the vertexes start in the lower left hand corner' though   					//subject to change  					for (int i = 0; i < window.coordinateList.Count; i++) {  						//assume that the coordinates both go in the same order  						switch (i) {  						case 0:  							double X = surface.SurfaceCoords [i].X;  							double Y = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z = surface.SurfaceCoords [i].Z + sillHeight;  							Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  							newCoords.Add (newWindowCoord);  							break;  						case 1:  							double X1 = surface.SurfaceCoords [i].X;  							double Y1 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  							Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  							newCoords.Add (newWindowCoord1);  							break;  						case 2:  							double X2 = surface.SurfaceCoords [i].X;  							double Y2 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  							Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  							newCoords.Add (newWindowCoord2);  							break;  						case 3:  							double X3 = surface.SurfaceCoords [i].X;  							double Y3 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  							Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  							newCoords.Add (newWindowCoord3);  							break;  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: foreach (ModelingUtilities.BuildingObjects.MemorySafe_Surface surface in projectSurfaces) {  	if (window.parentSurfaceNameId == surface.name) {  		double windowArea = Vector.GetAreaofWindow (window);  		double wallArea = Vector.GetAreaofSurface (surface);  		if (surface.multiplier > 0) {  			wallArea *= surface.multiplier;  			windowArea *= surface.multiplier * window.multiplier;  		}  		else {  			windowArea *= window.multiplier;  		}  		double WWR = windowArea / wallArea;  		if (WWR != desiredUserWWR) {  			//simple here in assuming that the wall is a square surface' otherwise  			//we would have to use some sort of scaling function that emanates from the  			//centroid' which we currently do not have' so we only work when the num vertices  			//is equal to four  			if (surface.numVertices == 4) {  				//under the simplifying assumption that walls are tilted to 90oF  				double zlow = 0.0;  				double zHigh = 0.0;  				for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  					if (j == 0) {  						zlow = surface.SurfaceCoords [j].Z;  						zHigh = surface.SurfaceCoords [j].Z;  					}  					else {  						if (surface.SurfaceCoords [j].Z < zlow)  							zlow = surface.SurfaceCoords [j].Z;  						if (surface.SurfaceCoords [j].Z > zHigh)  							zHigh = surface.SurfaceCoords [j].Z;  					}  				}  				double wallHeight = zHigh - zlow;  				//make each x' y vertex the same in both the surface and window  				//and strip window heights that are adjusted based on user preference  				if (window.numVertices == 4) {  					//we assume that the vertexes start in the lower left hand corner' though   					//subject to change  					for (int i = 0; i < window.coordinateList.Count; i++) {  						//assume that the coordinates both go in the same order  						switch (i) {  						case 0:  							double X = surface.SurfaceCoords [i].X;  							double Y = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z = surface.SurfaceCoords [i].Z + sillHeight;  							Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  							newCoords.Add (newWindowCoord);  							break;  						case 1:  							double X1 = surface.SurfaceCoords [i].X;  							double Y1 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  							Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  							newCoords.Add (newWindowCoord1);  							break;  						case 2:  							double X2 = surface.SurfaceCoords [i].X;  							double Y2 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  							Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  							newCoords.Add (newWindowCoord2);  							break;  						case 3:  							double X3 = surface.SurfaceCoords [i].X;  							double Y3 = surface.SurfaceCoords [i].Y;  							//this should be settable  							double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  							Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  							newCoords.Add (newWindowCoord3);  							break;  						}  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (window.parentSurfaceNameId == surface.name) {  	double windowArea = Vector.GetAreaofWindow (window);  	double wallArea = Vector.GetAreaofSurface (surface);  	if (surface.multiplier > 0) {  		wallArea *= surface.multiplier;  		windowArea *= surface.multiplier * window.multiplier;  	}  	else {  		windowArea *= window.multiplier;  	}  	double WWR = windowArea / wallArea;  	if (WWR != desiredUserWWR) {  		//simple here in assuming that the wall is a square surface' otherwise  		//we would have to use some sort of scaling function that emanates from the  		//centroid' which we currently do not have' so we only work when the num vertices  		//is equal to four  		if (surface.numVertices == 4) {  			//under the simplifying assumption that walls are tilted to 90oF  			double zlow = 0.0;  			double zHigh = 0.0;  			for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  				if (j == 0) {  					zlow = surface.SurfaceCoords [j].Z;  					zHigh = surface.SurfaceCoords [j].Z;  				}  				else {  					if (surface.SurfaceCoords [j].Z < zlow)  						zlow = surface.SurfaceCoords [j].Z;  					if (surface.SurfaceCoords [j].Z > zHigh)  						zHigh = surface.SurfaceCoords [j].Z;  				}  			}  			double wallHeight = zHigh - zlow;  			//make each x' y vertex the same in both the surface and window  			//and strip window heights that are adjusted based on user preference  			if (window.numVertices == 4) {  				//we assume that the vertexes start in the lower left hand corner' though   				//subject to change  				for (int i = 0; i < window.coordinateList.Count; i++) {  					//assume that the coordinates both go in the same order  					switch (i) {  					case 0:  						double X = surface.SurfaceCoords [i].X;  						double Y = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z = surface.SurfaceCoords [i].Z + sillHeight;  						Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  						newCoords.Add (newWindowCoord);  						break;  					case 1:  						double X1 = surface.SurfaceCoords [i].X;  						double Y1 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  						Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  						newCoords.Add (newWindowCoord1);  						break;  					case 2:  						double X2 = surface.SurfaceCoords [i].X;  						double Y2 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  						Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  						newCoords.Add (newWindowCoord2);  						break;  					case 3:  						double X3 = surface.SurfaceCoords [i].X;  						double Y3 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  						Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  						newCoords.Add (newWindowCoord3);  						break;  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (window.parentSurfaceNameId == surface.name) {  	double windowArea = Vector.GetAreaofWindow (window);  	double wallArea = Vector.GetAreaofSurface (surface);  	if (surface.multiplier > 0) {  		wallArea *= surface.multiplier;  		windowArea *= surface.multiplier * window.multiplier;  	}  	else {  		windowArea *= window.multiplier;  	}  	double WWR = windowArea / wallArea;  	if (WWR != desiredUserWWR) {  		//simple here in assuming that the wall is a square surface' otherwise  		//we would have to use some sort of scaling function that emanates from the  		//centroid' which we currently do not have' so we only work when the num vertices  		//is equal to four  		if (surface.numVertices == 4) {  			//under the simplifying assumption that walls are tilted to 90oF  			double zlow = 0.0;  			double zHigh = 0.0;  			for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  				if (j == 0) {  					zlow = surface.SurfaceCoords [j].Z;  					zHigh = surface.SurfaceCoords [j].Z;  				}  				else {  					if (surface.SurfaceCoords [j].Z < zlow)  						zlow = surface.SurfaceCoords [j].Z;  					if (surface.SurfaceCoords [j].Z > zHigh)  						zHigh = surface.SurfaceCoords [j].Z;  				}  			}  			double wallHeight = zHigh - zlow;  			//make each x' y vertex the same in both the surface and window  			//and strip window heights that are adjusted based on user preference  			if (window.numVertices == 4) {  				//we assume that the vertexes start in the lower left hand corner' though   				//subject to change  				for (int i = 0; i < window.coordinateList.Count; i++) {  					//assume that the coordinates both go in the same order  					switch (i) {  					case 0:  						double X = surface.SurfaceCoords [i].X;  						double Y = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z = surface.SurfaceCoords [i].Z + sillHeight;  						Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  						newCoords.Add (newWindowCoord);  						break;  					case 1:  						double X1 = surface.SurfaceCoords [i].X;  						double Y1 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  						Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  						newCoords.Add (newWindowCoord1);  						break;  					case 2:  						double X2 = surface.SurfaceCoords [i].X;  						double Y2 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  						Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  						newCoords.Add (newWindowCoord2);  						break;  					case 3:  						double X3 = surface.SurfaceCoords [i].X;  						double Y3 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  						Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  						newCoords.Add (newWindowCoord3);  						break;  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (window.parentSurfaceNameId == surface.name) {  	double windowArea = Vector.GetAreaofWindow (window);  	double wallArea = Vector.GetAreaofSurface (surface);  	if (surface.multiplier > 0) {  		wallArea *= surface.multiplier;  		windowArea *= surface.multiplier * window.multiplier;  	}  	else {  		windowArea *= window.multiplier;  	}  	double WWR = windowArea / wallArea;  	if (WWR != desiredUserWWR) {  		//simple here in assuming that the wall is a square surface' otherwise  		//we would have to use some sort of scaling function that emanates from the  		//centroid' which we currently do not have' so we only work when the num vertices  		//is equal to four  		if (surface.numVertices == 4) {  			//under the simplifying assumption that walls are tilted to 90oF  			double zlow = 0.0;  			double zHigh = 0.0;  			for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  				if (j == 0) {  					zlow = surface.SurfaceCoords [j].Z;  					zHigh = surface.SurfaceCoords [j].Z;  				}  				else {  					if (surface.SurfaceCoords [j].Z < zlow)  						zlow = surface.SurfaceCoords [j].Z;  					if (surface.SurfaceCoords [j].Z > zHigh)  						zHigh = surface.SurfaceCoords [j].Z;  				}  			}  			double wallHeight = zHigh - zlow;  			//make each x' y vertex the same in both the surface and window  			//and strip window heights that are adjusted based on user preference  			if (window.numVertices == 4) {  				//we assume that the vertexes start in the lower left hand corner' though   				//subject to change  				for (int i = 0; i < window.coordinateList.Count; i++) {  					//assume that the coordinates both go in the same order  					switch (i) {  					case 0:  						double X = surface.SurfaceCoords [i].X;  						double Y = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z = surface.SurfaceCoords [i].Z + sillHeight;  						Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  						newCoords.Add (newWindowCoord);  						break;  					case 1:  						double X1 = surface.SurfaceCoords [i].X;  						double Y1 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  						Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  						newCoords.Add (newWindowCoord1);  						break;  					case 2:  						double X2 = surface.SurfaceCoords [i].X;  						double Y2 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  						Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  						newCoords.Add (newWindowCoord2);  						break;  					case 3:  						double X3 = surface.SurfaceCoords [i].X;  						double Y3 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  						Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  						newCoords.Add (newWindowCoord3);  						break;  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (window.parentSurfaceNameId == surface.name) {  	double windowArea = Vector.GetAreaofWindow (window);  	double wallArea = Vector.GetAreaofSurface (surface);  	if (surface.multiplier > 0) {  		wallArea *= surface.multiplier;  		windowArea *= surface.multiplier * window.multiplier;  	}  	else {  		windowArea *= window.multiplier;  	}  	double WWR = windowArea / wallArea;  	if (WWR != desiredUserWWR) {  		//simple here in assuming that the wall is a square surface' otherwise  		//we would have to use some sort of scaling function that emanates from the  		//centroid' which we currently do not have' so we only work when the num vertices  		//is equal to four  		if (surface.numVertices == 4) {  			//under the simplifying assumption that walls are tilted to 90oF  			double zlow = 0.0;  			double zHigh = 0.0;  			for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  				if (j == 0) {  					zlow = surface.SurfaceCoords [j].Z;  					zHigh = surface.SurfaceCoords [j].Z;  				}  				else {  					if (surface.SurfaceCoords [j].Z < zlow)  						zlow = surface.SurfaceCoords [j].Z;  					if (surface.SurfaceCoords [j].Z > zHigh)  						zHigh = surface.SurfaceCoords [j].Z;  				}  			}  			double wallHeight = zHigh - zlow;  			//make each x' y vertex the same in both the surface and window  			//and strip window heights that are adjusted based on user preference  			if (window.numVertices == 4) {  				//we assume that the vertexes start in the lower left hand corner' though   				//subject to change  				for (int i = 0; i < window.coordinateList.Count; i++) {  					//assume that the coordinates both go in the same order  					switch (i) {  					case 0:  						double X = surface.SurfaceCoords [i].X;  						double Y = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z = surface.SurfaceCoords [i].Z + sillHeight;  						Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  						newCoords.Add (newWindowCoord);  						break;  					case 1:  						double X1 = surface.SurfaceCoords [i].X;  						double Y1 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  						Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  						newCoords.Add (newWindowCoord1);  						break;  					case 2:  						double X2 = surface.SurfaceCoords [i].X;  						double Y2 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  						Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  						newCoords.Add (newWindowCoord2);  						break;  					case 3:  						double X3 = surface.SurfaceCoords [i].X;  						double Y3 = surface.SurfaceCoords [i].Y;  						//this should be settable  						double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  						Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  						newCoords.Add (newWindowCoord3);  						break;  					}  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (WWR != desiredUserWWR) {  	//simple here in assuming that the wall is a square surface' otherwise  	//we would have to use some sort of scaling function that emanates from the  	//centroid' which we currently do not have' so we only work when the num vertices  	//is equal to four  	if (surface.numVertices == 4) {  		//under the simplifying assumption that walls are tilted to 90oF  		double zlow = 0.0;  		double zHigh = 0.0;  		for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  			if (j == 0) {  				zlow = surface.SurfaceCoords [j].Z;  				zHigh = surface.SurfaceCoords [j].Z;  			}  			else {  				if (surface.SurfaceCoords [j].Z < zlow)  					zlow = surface.SurfaceCoords [j].Z;  				if (surface.SurfaceCoords [j].Z > zHigh)  					zHigh = surface.SurfaceCoords [j].Z;  			}  		}  		double wallHeight = zHigh - zlow;  		//make each x' y vertex the same in both the surface and window  		//and strip window heights that are adjusted based on user preference  		if (window.numVertices == 4) {  			//we assume that the vertexes start in the lower left hand corner' though   			//subject to change  			for (int i = 0; i < window.coordinateList.Count; i++) {  				//assume that the coordinates both go in the same order  				switch (i) {  				case 0:  					double X = surface.SurfaceCoords [i].X;  					double Y = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z = surface.SurfaceCoords [i].Z + sillHeight;  					Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  					newCoords.Add (newWindowCoord);  					break;  				case 1:  					double X1 = surface.SurfaceCoords [i].X;  					double Y1 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  					Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  					newCoords.Add (newWindowCoord1);  					break;  				case 2:  					double X2 = surface.SurfaceCoords [i].X;  					double Y2 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  					Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  					newCoords.Add (newWindowCoord2);  					break;  				case 3:  					double X3 = surface.SurfaceCoords [i].X;  					double Y3 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  					Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  					newCoords.Add (newWindowCoord3);  					break;  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (WWR != desiredUserWWR) {  	//simple here in assuming that the wall is a square surface' otherwise  	//we would have to use some sort of scaling function that emanates from the  	//centroid' which we currently do not have' so we only work when the num vertices  	//is equal to four  	if (surface.numVertices == 4) {  		//under the simplifying assumption that walls are tilted to 90oF  		double zlow = 0.0;  		double zHigh = 0.0;  		for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  			if (j == 0) {  				zlow = surface.SurfaceCoords [j].Z;  				zHigh = surface.SurfaceCoords [j].Z;  			}  			else {  				if (surface.SurfaceCoords [j].Z < zlow)  					zlow = surface.SurfaceCoords [j].Z;  				if (surface.SurfaceCoords [j].Z > zHigh)  					zHigh = surface.SurfaceCoords [j].Z;  			}  		}  		double wallHeight = zHigh - zlow;  		//make each x' y vertex the same in both the surface and window  		//and strip window heights that are adjusted based on user preference  		if (window.numVertices == 4) {  			//we assume that the vertexes start in the lower left hand corner' though   			//subject to change  			for (int i = 0; i < window.coordinateList.Count; i++) {  				//assume that the coordinates both go in the same order  				switch (i) {  				case 0:  					double X = surface.SurfaceCoords [i].X;  					double Y = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z = surface.SurfaceCoords [i].Z + sillHeight;  					Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  					newCoords.Add (newWindowCoord);  					break;  				case 1:  					double X1 = surface.SurfaceCoords [i].X;  					double Y1 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  					Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  					newCoords.Add (newWindowCoord1);  					break;  				case 2:  					double X2 = surface.SurfaceCoords [i].X;  					double Y2 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  					Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  					newCoords.Add (newWindowCoord2);  					break;  				case 3:  					double X3 = surface.SurfaceCoords [i].X;  					double Y3 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  					Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  					newCoords.Add (newWindowCoord3);  					break;  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (WWR != desiredUserWWR) {  	//simple here in assuming that the wall is a square surface' otherwise  	//we would have to use some sort of scaling function that emanates from the  	//centroid' which we currently do not have' so we only work when the num vertices  	//is equal to four  	if (surface.numVertices == 4) {  		//under the simplifying assumption that walls are tilted to 90oF  		double zlow = 0.0;  		double zHigh = 0.0;  		for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  			if (j == 0) {  				zlow = surface.SurfaceCoords [j].Z;  				zHigh = surface.SurfaceCoords [j].Z;  			}  			else {  				if (surface.SurfaceCoords [j].Z < zlow)  					zlow = surface.SurfaceCoords [j].Z;  				if (surface.SurfaceCoords [j].Z > zHigh)  					zHigh = surface.SurfaceCoords [j].Z;  			}  		}  		double wallHeight = zHigh - zlow;  		//make each x' y vertex the same in both the surface and window  		//and strip window heights that are adjusted based on user preference  		if (window.numVertices == 4) {  			//we assume that the vertexes start in the lower left hand corner' though   			//subject to change  			for (int i = 0; i < window.coordinateList.Count; i++) {  				//assume that the coordinates both go in the same order  				switch (i) {  				case 0:  					double X = surface.SurfaceCoords [i].X;  					double Y = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z = surface.SurfaceCoords [i].Z + sillHeight;  					Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  					newCoords.Add (newWindowCoord);  					break;  				case 1:  					double X1 = surface.SurfaceCoords [i].X;  					double Y1 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  					Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  					newCoords.Add (newWindowCoord1);  					break;  				case 2:  					double X2 = surface.SurfaceCoords [i].X;  					double Y2 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  					Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  					newCoords.Add (newWindowCoord2);  					break;  				case 3:  					double X3 = surface.SurfaceCoords [i].X;  					double Y3 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  					Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  					newCoords.Add (newWindowCoord3);  					break;  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (WWR != desiredUserWWR) {  	//simple here in assuming that the wall is a square surface' otherwise  	//we would have to use some sort of scaling function that emanates from the  	//centroid' which we currently do not have' so we only work when the num vertices  	//is equal to four  	if (surface.numVertices == 4) {  		//under the simplifying assumption that walls are tilted to 90oF  		double zlow = 0.0;  		double zHigh = 0.0;  		for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  			if (j == 0) {  				zlow = surface.SurfaceCoords [j].Z;  				zHigh = surface.SurfaceCoords [j].Z;  			}  			else {  				if (surface.SurfaceCoords [j].Z < zlow)  					zlow = surface.SurfaceCoords [j].Z;  				if (surface.SurfaceCoords [j].Z > zHigh)  					zHigh = surface.SurfaceCoords [j].Z;  			}  		}  		double wallHeight = zHigh - zlow;  		//make each x' y vertex the same in both the surface and window  		//and strip window heights that are adjusted based on user preference  		if (window.numVertices == 4) {  			//we assume that the vertexes start in the lower left hand corner' though   			//subject to change  			for (int i = 0; i < window.coordinateList.Count; i++) {  				//assume that the coordinates both go in the same order  				switch (i) {  				case 0:  					double X = surface.SurfaceCoords [i].X;  					double Y = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z = surface.SurfaceCoords [i].Z + sillHeight;  					Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  					newCoords.Add (newWindowCoord);  					break;  				case 1:  					double X1 = surface.SurfaceCoords [i].X;  					double Y1 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  					Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  					newCoords.Add (newWindowCoord1);  					break;  				case 2:  					double X2 = surface.SurfaceCoords [i].X;  					double Y2 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  					Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  					newCoords.Add (newWindowCoord2);  					break;  				case 3:  					double X3 = surface.SurfaceCoords [i].X;  					double Y3 = surface.SurfaceCoords [i].Y;  					//this should be settable  					double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  					Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  					newCoords.Add (newWindowCoord3);  					break;  				}  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (surface.numVertices == 4) {  	//under the simplifying assumption that walls are tilted to 90oF  	double zlow = 0.0;  	double zHigh = 0.0;  	for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  		if (j == 0) {  			zlow = surface.SurfaceCoords [j].Z;  			zHigh = surface.SurfaceCoords [j].Z;  		}  		else {  			if (surface.SurfaceCoords [j].Z < zlow)  				zlow = surface.SurfaceCoords [j].Z;  			if (surface.SurfaceCoords [j].Z > zHigh)  				zHigh = surface.SurfaceCoords [j].Z;  		}  	}  	double wallHeight = zHigh - zlow;  	//make each x' y vertex the same in both the surface and window  	//and strip window heights that are adjusted based on user preference  	if (window.numVertices == 4) {  		//we assume that the vertexes start in the lower left hand corner' though   		//subject to change  		for (int i = 0; i < window.coordinateList.Count; i++) {  			//assume that the coordinates both go in the same order  			switch (i) {  			case 0:  				double X = surface.SurfaceCoords [i].X;  				double Y = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z = surface.SurfaceCoords [i].Z + sillHeight;  				Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  				newCoords.Add (newWindowCoord);  				break;  			case 1:  				double X1 = surface.SurfaceCoords [i].X;  				double Y1 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  				Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  				newCoords.Add (newWindowCoord1);  				break;  			case 2:  				double X2 = surface.SurfaceCoords [i].X;  				double Y2 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  				Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  				newCoords.Add (newWindowCoord2);  				break;  			case 3:  				double X3 = surface.SurfaceCoords [i].X;  				double Y3 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  				Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  				newCoords.Add (newWindowCoord3);  				break;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (surface.numVertices == 4) {  	//under the simplifying assumption that walls are tilted to 90oF  	double zlow = 0.0;  	double zHigh = 0.0;  	for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  		if (j == 0) {  			zlow = surface.SurfaceCoords [j].Z;  			zHigh = surface.SurfaceCoords [j].Z;  		}  		else {  			if (surface.SurfaceCoords [j].Z < zlow)  				zlow = surface.SurfaceCoords [j].Z;  			if (surface.SurfaceCoords [j].Z > zHigh)  				zHigh = surface.SurfaceCoords [j].Z;  		}  	}  	double wallHeight = zHigh - zlow;  	//make each x' y vertex the same in both the surface and window  	//and strip window heights that are adjusted based on user preference  	if (window.numVertices == 4) {  		//we assume that the vertexes start in the lower left hand corner' though   		//subject to change  		for (int i = 0; i < window.coordinateList.Count; i++) {  			//assume that the coordinates both go in the same order  			switch (i) {  			case 0:  				double X = surface.SurfaceCoords [i].X;  				double Y = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z = surface.SurfaceCoords [i].Z + sillHeight;  				Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  				newCoords.Add (newWindowCoord);  				break;  			case 1:  				double X1 = surface.SurfaceCoords [i].X;  				double Y1 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  				Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  				newCoords.Add (newWindowCoord1);  				break;  			case 2:  				double X2 = surface.SurfaceCoords [i].X;  				double Y2 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  				Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  				newCoords.Add (newWindowCoord2);  				break;  			case 3:  				double X3 = surface.SurfaceCoords [i].X;  				double Y3 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  				Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  				newCoords.Add (newWindowCoord3);  				break;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (surface.numVertices == 4) {  	//under the simplifying assumption that walls are tilted to 90oF  	double zlow = 0.0;  	double zHigh = 0.0;  	for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  		if (j == 0) {  			zlow = surface.SurfaceCoords [j].Z;  			zHigh = surface.SurfaceCoords [j].Z;  		}  		else {  			if (surface.SurfaceCoords [j].Z < zlow)  				zlow = surface.SurfaceCoords [j].Z;  			if (surface.SurfaceCoords [j].Z > zHigh)  				zHigh = surface.SurfaceCoords [j].Z;  		}  	}  	double wallHeight = zHigh - zlow;  	//make each x' y vertex the same in both the surface and window  	//and strip window heights that are adjusted based on user preference  	if (window.numVertices == 4) {  		//we assume that the vertexes start in the lower left hand corner' though   		//subject to change  		for (int i = 0; i < window.coordinateList.Count; i++) {  			//assume that the coordinates both go in the same order  			switch (i) {  			case 0:  				double X = surface.SurfaceCoords [i].X;  				double Y = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z = surface.SurfaceCoords [i].Z + sillHeight;  				Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  				newCoords.Add (newWindowCoord);  				break;  			case 1:  				double X1 = surface.SurfaceCoords [i].X;  				double Y1 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  				Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  				newCoords.Add (newWindowCoord1);  				break;  			case 2:  				double X2 = surface.SurfaceCoords [i].X;  				double Y2 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  				Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  				newCoords.Add (newWindowCoord2);  				break;  			case 3:  				double X3 = surface.SurfaceCoords [i].X;  				double Y3 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  				Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  				newCoords.Add (newWindowCoord3);  				break;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (surface.numVertices == 4) {  	//under the simplifying assumption that walls are tilted to 90oF  	double zlow = 0.0;  	double zHigh = 0.0;  	for (int j = 0; j < surface.SurfaceCoords.Count; j++) {  		if (j == 0) {  			zlow = surface.SurfaceCoords [j].Z;  			zHigh = surface.SurfaceCoords [j].Z;  		}  		else {  			if (surface.SurfaceCoords [j].Z < zlow)  				zlow = surface.SurfaceCoords [j].Z;  			if (surface.SurfaceCoords [j].Z > zHigh)  				zHigh = surface.SurfaceCoords [j].Z;  		}  	}  	double wallHeight = zHigh - zlow;  	//make each x' y vertex the same in both the surface and window  	//and strip window heights that are adjusted based on user preference  	if (window.numVertices == 4) {  		//we assume that the vertexes start in the lower left hand corner' though   		//subject to change  		for (int i = 0; i < window.coordinateList.Count; i++) {  			//assume that the coordinates both go in the same order  			switch (i) {  			case 0:  				double X = surface.SurfaceCoords [i].X;  				double Y = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z = surface.SurfaceCoords [i].Z + sillHeight;  				Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  				newCoords.Add (newWindowCoord);  				break;  			case 1:  				double X1 = surface.SurfaceCoords [i].X;  				double Y1 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  				Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  				newCoords.Add (newWindowCoord1);  				break;  			case 2:  				double X2 = surface.SurfaceCoords [i].X;  				double Y2 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  				Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  				newCoords.Add (newWindowCoord2);  				break;  			case 3:  				double X3 = surface.SurfaceCoords [i].X;  				double Y3 = surface.SurfaceCoords [i].Y;  				//this should be settable  				double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  				Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  				newCoords.Add (newWindowCoord3);  				break;  			}  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (window.numVertices == 4) {  	//we assume that the vertexes start in the lower left hand corner' though   	//subject to change  	for (int i = 0; i < window.coordinateList.Count; i++) {  		//assume that the coordinates both go in the same order  		switch (i) {  		case 0:  			double X = surface.SurfaceCoords [i].X;  			double Y = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z = surface.SurfaceCoords [i].Z + sillHeight;  			Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  			newCoords.Add (newWindowCoord);  			break;  		case 1:  			double X1 = surface.SurfaceCoords [i].X;  			double Y1 = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  			Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  			newCoords.Add (newWindowCoord1);  			break;  		case 2:  			double X2 = surface.SurfaceCoords [i].X;  			double Y2 = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  			Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  			newCoords.Add (newWindowCoord2);  			break;  		case 3:  			double X3 = surface.SurfaceCoords [i].X;  			double Y3 = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  			Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  			newCoords.Add (newWindowCoord3);  			break;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (window.numVertices == 4) {  	//we assume that the vertexes start in the lower left hand corner' though   	//subject to change  	for (int i = 0; i < window.coordinateList.Count; i++) {  		//assume that the coordinates both go in the same order  		switch (i) {  		case 0:  			double X = surface.SurfaceCoords [i].X;  			double Y = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z = surface.SurfaceCoords [i].Z + sillHeight;  			Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  			newCoords.Add (newWindowCoord);  			break;  		case 1:  			double X1 = surface.SurfaceCoords [i].X;  			double Y1 = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  			Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  			newCoords.Add (newWindowCoord1);  			break;  		case 2:  			double X2 = surface.SurfaceCoords [i].X;  			double Y2 = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  			Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  			newCoords.Add (newWindowCoord2);  			break;  		case 3:  			double X3 = surface.SurfaceCoords [i].X;  			double Y3 = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  			Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  			newCoords.Add (newWindowCoord3);  			break;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: if (window.numVertices == 4) {  	//we assume that the vertexes start in the lower left hand corner' though   	//subject to change  	for (int i = 0; i < window.coordinateList.Count; i++) {  		//assume that the coordinates both go in the same order  		switch (i) {  		case 0:  			double X = surface.SurfaceCoords [i].X;  			double Y = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z = surface.SurfaceCoords [i].Z + sillHeight;  			Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  			newCoords.Add (newWindowCoord);  			break;  		case 1:  			double X1 = surface.SurfaceCoords [i].X;  			double Y1 = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  			Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  			newCoords.Add (newWindowCoord1);  			break;  		case 2:  			double X2 = surface.SurfaceCoords [i].X;  			double Y2 = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  			Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  			newCoords.Add (newWindowCoord2);  			break;  		case 3:  			double X3 = surface.SurfaceCoords [i].X;  			double Y3 = surface.SurfaceCoords [i].Y;  			//this should be settable  			double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  			Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  			newCoords.Add (newWindowCoord3);  			break;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: for (int i = 0; i < window.coordinateList.Count; i++) {  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		double X = surface.SurfaceCoords [i].X;  		double Y = surface.SurfaceCoords [i].Y;  		//this should be settable  		double Z = surface.SurfaceCoords [i].Z + sillHeight;  		Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  		newCoords.Add (newWindowCoord);  		break;  	case 1:  		double X1 = surface.SurfaceCoords [i].X;  		double Y1 = surface.SurfaceCoords [i].Y;  		//this should be settable  		double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  		Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  		newCoords.Add (newWindowCoord1);  		break;  	case 2:  		double X2 = surface.SurfaceCoords [i].X;  		double Y2 = surface.SurfaceCoords [i].Y;  		//this should be settable  		double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  		Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  		newCoords.Add (newWindowCoord2);  		break;  	case 3:  		double X3 = surface.SurfaceCoords [i].X;  		double Y3 = surface.SurfaceCoords [i].Y;  		//this should be settable  		double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  		Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  		newCoords.Add (newWindowCoord3);  		break;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: for (int i = 0; i < window.coordinateList.Count; i++) {  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		double X = surface.SurfaceCoords [i].X;  		double Y = surface.SurfaceCoords [i].Y;  		//this should be settable  		double Z = surface.SurfaceCoords [i].Z + sillHeight;  		Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  		newCoords.Add (newWindowCoord);  		break;  	case 1:  		double X1 = surface.SurfaceCoords [i].X;  		double Y1 = surface.SurfaceCoords [i].Y;  		//this should be settable  		double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  		Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  		newCoords.Add (newWindowCoord1);  		break;  	case 2:  		double X2 = surface.SurfaceCoords [i].X;  		double Y2 = surface.SurfaceCoords [i].Y;  		//this should be settable  		double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  		Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  		newCoords.Add (newWindowCoord2);  		break;  	case 3:  		double X3 = surface.SurfaceCoords [i].X;  		double Y3 = surface.SurfaceCoords [i].Y;  		//this should be settable  		double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  		Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  		newCoords.Add (newWindowCoord3);  		break;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: switch (i) {  case 0:  	double X = surface.SurfaceCoords [i].X;  	double Y = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z = surface.SurfaceCoords [i].Z + sillHeight;  	Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  	newCoords.Add (newWindowCoord);  	break;  case 1:  	double X1 = surface.SurfaceCoords [i].X;  	double Y1 = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  	Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  	newCoords.Add (newWindowCoord1);  	break;  case 2:  	double X2 = surface.SurfaceCoords [i].X;  	double Y2 = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  	Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  	newCoords.Add (newWindowCoord2);  	break;  case 3:  	double X3 = surface.SurfaceCoords [i].X;  	double Y3 = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  	Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  	newCoords.Add (newWindowCoord3);  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following statement contains a magic number: switch (i) {  case 0:  	double X = surface.SurfaceCoords [i].X;  	double Y = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z = surface.SurfaceCoords [i].Z + sillHeight;  	Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  	newCoords.Add (newWindowCoord);  	break;  case 1:  	double X1 = surface.SurfaceCoords [i].X;  	double Y1 = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  	Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  	newCoords.Add (newWindowCoord1);  	break;  case 2:  	double X2 = surface.SurfaceCoords [i].X;  	double Y2 = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  	Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  	newCoords.Add (newWindowCoord2);  	break;  case 3:  	double X3 = surface.SurfaceCoords [i].X;  	double Y3 = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  	Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  	newCoords.Add (newWindowCoord3);  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: foreach (string line in surfaceGroupStrings) {  	Match surfaceGroupStartMatch = surfaceGroupStart.Match (line);  	if (surfaceGroupStartMatch.Success) {  		surfaceGroupFirstLine = true;  		continue;  	}  	if (surfaceGroupFirstLine) {  		Match surfaceGroupNameMatch = surfaceGroupName.Match (line);  		if (surfaceGroupNameMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceGroupNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				radSurfaceGroup.groupName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match surfaceNumNameMatch = surfaceNumNameRegex.Match (line);  		if (surfaceNumNameMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNumNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				surfaceName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match flowFractionMatch = flowFractionRegex.Match (line);  		if (flowFractionMatch.Success) {  			Match semiColonMatch = semiColonRegex.Match (line);  			if (semiColonMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  				if (pure.Success) {  					surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  					surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  				}  				surfaceGroupFirstLine = false;  				semicolonfound = true;  				radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  			}  			else {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  				if (pure.Success) {  					surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  					surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  				}  			}  		}  		if (!semicolonfound)  			radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: foreach (string line in surfaceGroupStrings) {  	Match surfaceGroupStartMatch = surfaceGroupStart.Match (line);  	if (surfaceGroupStartMatch.Success) {  		surfaceGroupFirstLine = true;  		continue;  	}  	if (surfaceGroupFirstLine) {  		Match surfaceGroupNameMatch = surfaceGroupName.Match (line);  		if (surfaceGroupNameMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceGroupNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				radSurfaceGroup.groupName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match surfaceNumNameMatch = surfaceNumNameRegex.Match (line);  		if (surfaceNumNameMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (surfaceNumNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				surfaceName = pure.Groups ["goods"].Value;  				continue;  			}  		}  		Match flowFractionMatch = flowFractionRegex.Match (line);  		if (flowFractionMatch.Success) {  			Match semiColonMatch = semiColonRegex.Match (line);  			if (semiColonMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  				if (pure.Success) {  					surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  					surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  				}  				surfaceGroupFirstLine = false;  				semicolonfound = true;  				radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  			}  			else {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  				if (pure.Success) {  					surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  					surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  				}  			}  		}  		if (!semicolonfound)  			radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: if (surfaceGroupFirstLine) {  	Match surfaceGroupNameMatch = surfaceGroupName.Match (line);  	if (surfaceGroupNameMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceGroupNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			radSurfaceGroup.groupName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match surfaceNumNameMatch = surfaceNumNameRegex.Match (line);  	if (surfaceNumNameMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNumNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			surfaceName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match flowFractionMatch = flowFractionRegex.Match (line);  	if (flowFractionMatch.Success) {  		Match semiColonMatch = semiColonRegex.Match (line);  		if (semiColonMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  			if (pure.Success) {  				surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  				surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  			}  			surfaceGroupFirstLine = false;  			semicolonfound = true;  			radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  		}  		else {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  			if (pure.Success) {  				surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  				surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  			}  		}  	}  	if (!semicolonfound)  		radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: if (surfaceGroupFirstLine) {  	Match surfaceGroupNameMatch = surfaceGroupName.Match (line);  	if (surfaceGroupNameMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceGroupNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			radSurfaceGroup.groupName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match surfaceNumNameMatch = surfaceNumNameRegex.Match (line);  	if (surfaceNumNameMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (surfaceNumNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			surfaceName = pure.Groups ["goods"].Value;  			continue;  		}  	}  	Match flowFractionMatch = flowFractionRegex.Match (line);  	if (flowFractionMatch.Success) {  		Match semiColonMatch = semiColonRegex.Match (line);  		if (semiColonMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  			if (pure.Success) {  				surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  				surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  			}  			surfaceGroupFirstLine = false;  			semicolonfound = true;  			radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  		}  		else {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  			if (pure.Success) {  				surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  				surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  			}  		}  	}  	if (!semicolonfound)  		radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: if (flowFractionMatch.Success) {  	Match semiColonMatch = semiColonRegex.Match (line);  	if (semiColonMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  		if (pure.Success) {  			surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  			surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  		}  		surfaceGroupFirstLine = false;  		semicolonfound = true;  		radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  	}  	else {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  		if (pure.Success) {  			surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  			surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: if (flowFractionMatch.Success) {  	Match semiColonMatch = semiColonRegex.Match (line);  	if (semiColonMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  		if (pure.Success) {  			surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  			surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  		}  		surfaceGroupFirstLine = false;  		semicolonfound = true;  		radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  	}  	else {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  		if (pure.Success) {  			surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  			surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: if (semiColonMatch.Success) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  	if (pure.Success) {  		surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  		surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  	}  	surfaceGroupFirstLine = false;  	semicolonfound = true;  	radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  }  else {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  	if (pure.Success) {  		surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  		surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: if (semiColonMatch.Success) {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'semicolon';)";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  	if (pure.Success) {  		surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  		surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  	}  	surfaceGroupFirstLine = false;  	semicolonfound = true;  	radSurfaceGroup.surfaceNameAndFF.Add (surfaceName' surfaceFlowFrac);  }  else {  	string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  	Regex purifyRegex = new Regex (purify);  	Match pure = purifyRegex.Match (flowFractionMatch.Groups ["1"].Value);  	if (pure.Success) {  		surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  		surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: if (pure.Success) {  	surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  	surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: if (pure.Success) {  	surfaceFlowFrac = Convert.ToDouble (pure.Groups ["goods"].Value);  	surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeRadSurfaceGroup,The following statement contains a magic number: surfaceFlowFrac = Math.Round (surfaceFlowFrac' 2);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: try {  	Regex fenestrationYes = new Regex (EPlusObjects.EPlusRegexString.startFenestration);  	Regex fenestrationNameRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationName);  	Regex fenestrationParentSurfaceRegex = new Regex (EPlusObjects.EPlusRegexString.parentSurfaceName);  	Regex typicalVertexRegex = new Regex (EPlusObjects.EPlusRegexString.typicalVertex);  	Regex semiColonRegex = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Regex multiplierRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationMultiplier);  	Encoding encoding;  	bool firstLineofFenestration = false;  	bool semicolonfound = false;  	string windowName = "";  	string parentSurfaceName = "";  	using (StreamReader reader = new StreamReader (idfname)) {  		string line;  		encoding = reader.CurrentEncoding;  		bool detailedFenestration = false;  		bool vertexMatching = false;  		int vertexCounter = 1;  		int newWindowCounter = 1;  		while ((line = reader.ReadLine ()) != null) {  			MatchCollection fenStart = fenestrationYes.Matches (line);  			if (fenStart.Count > 0) {  				detailedFenestration = true;  				windowFoundCount++;  				makeWindowLogFile.AppendLine ("Window:" + windowFoundCount.ToString ());  				firstLineofFenestration = true;  				output.AppendLine (line);  				continue;  			}  			if (detailedFenestration) {  				//Match the name of the window  				Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  				if (fenestrationNameMatch.Success) {  					firstLineofFenestration = false;  					//strip off the whitespace and comma  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  					if (pure.Success) {  						windowName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						makeWindowLogFile.AppendLine ("windowName : " + windowName);  						continue;  					}  				}  				Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  				if (parentSurfaceIdMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  					if (pure.Success) {  						parentSurfaceName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  						continue;  					}  				}  				//Get multiplier  				Match multiplierMatch = multiplierRegex.Match (line);  				if (multiplierMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  					if (pure.Success) {  						string frontSpace = "    ";  						string multiplier = pure.Groups ["goods"].Value;  						string newmultiPlier = "1";  						string comma = "'";  						string endString = "                       !- Multiplier";  						output.AppendLine (frontSpace + newmultiPlier + comma + endString);  						makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  						continue;  					}  				}  				//My next match is the coordinates' since the rest I should be able to skip at this point  				Match typicalVertexMatch = typicalVertexRegex.Match (line);  				if (typicalVertexMatch.Success) {  					ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  					//this little bit of code had to be added so that I could prevent extra lines from being written  					//after the first vertex has been discovered  					if (!detailedFenestration)  						continue;  					if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  						#region  						//globally change all the windows to a new window area based on the surface attached  						//get the areas  						//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  						if (window.nameId == windowName) {  							ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  							vertexMatching = true;  							double wallarea = Vector.GetAreaofSurface (surface);  							if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  								Console.Write ("");  							}  							if (surface.numVertices == 4 && window.numVertices == 4) {  								makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  								//this routine is only for square windows  								double wallHeight = GetNormalQuadWallHeight (surface);  								double wallWidth = GetNormalQuadWallWidth (surface);  								double windowWidth = GetNormalQuadWindowWidth (window);  								double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  								double firstSpace = windowSpacing / 4;  								if (newWindowCounter == 1) {  									if (newCoords.Count () == 0) {  										if (window.multiplier > 1) {  											makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  											makeWindowLogFile.AppendLine ("Getting new Coordinates");  											newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  										}  										else  											newCoords = window.coordinateList;  									}  									//once I have the newCoordinates' then I should go on to change the values in the file  									//we can assume that if there are no new coords' then the old file matches the new exactly  									if (newCoords.Count > 0) {  										//make a new vertex point and append it to the line  										if (vertexCounter != newCoords.Count) {  											string frontBlank = "     ";  											string comma = "'";  											string newX = newCoords [vertexCounter - 1].X.ToString ();  											string newY = newCoords [vertexCounter - 1].Y.ToString ();  											string newZ = newCoords [vertexCounter - 1].Z.ToString ();  											string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  											string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  											output.AppendLine (newVertexLine);  											vertexCounter++;  											continue;  										}  										//it is a normal typical vertex line with a semicolon at the end (the last one)  										else {  											string frontBlank = "     ";  											string comma = "'";  											string newX = newCoords [vertexCounter - 1].X.ToString ();  											string newY = newCoords [vertexCounter - 1].Y.ToString ();  											string newZ = newCoords [vertexCounter - 1].Z.ToString ();  											string semicolon = ";";  											string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  											string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  											output.AppendLine (newVertexLine);  											//reset which should prevent the rest of the vertices from being written  											vertexMatching = false;  											detailedFenestration = false;  											newCoords.Clear ();  											vertexCounter = 1;  											if (window.multiplier > 1)  												newWindowCounter++;  											//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  											if (window.multiplier > 1) {  												output.AppendLine ("");  												while (newWindowCounter <= window.multiplier) {  													//make an entirely new window from the original window  													//make coords  													newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  													if (newCoords.Count () == 0) {  														makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  														//newWindowCounter++;  														//continue;  													}  													//now make the new window Text  													//copy the window  													int newMultiplier = 1;  													ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  													//make the window  													output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  													if (newWindowCounter == window.multiplier) {  														detailedFenestration = false;  														vertexMatching = false;  														newWindowCounter = 1;  														newCoords.Clear ();  														break;  													}  													newWindowCounter++;  												}  											}  										}  									}  									else {  										makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  										continue;  									}  								}  								else {  								}  							}  						}  						#endregion  					}  				}  				//this is admittedly a bit sloppy and should be cleaned up  				//basically says' if there is no match' then move append and work on the next line  				else {  					output.AppendLine (line);  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	successfulUpdate = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	bool logWritten = FileMng.CreateLogFile (makeWindowLogFileLocation' makeWindowLogFile' false' encoding);  }  catch (Exception e) {  	Console.WriteLine (e.ToString ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: try {  	Regex fenestrationYes = new Regex (EPlusObjects.EPlusRegexString.startFenestration);  	Regex fenestrationNameRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationName);  	Regex fenestrationParentSurfaceRegex = new Regex (EPlusObjects.EPlusRegexString.parentSurfaceName);  	Regex typicalVertexRegex = new Regex (EPlusObjects.EPlusRegexString.typicalVertex);  	Regex semiColonRegex = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Regex multiplierRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationMultiplier);  	Encoding encoding;  	bool firstLineofFenestration = false;  	bool semicolonfound = false;  	string windowName = "";  	string parentSurfaceName = "";  	using (StreamReader reader = new StreamReader (idfname)) {  		string line;  		encoding = reader.CurrentEncoding;  		bool detailedFenestration = false;  		bool vertexMatching = false;  		int vertexCounter = 1;  		int newWindowCounter = 1;  		while ((line = reader.ReadLine ()) != null) {  			MatchCollection fenStart = fenestrationYes.Matches (line);  			if (fenStart.Count > 0) {  				detailedFenestration = true;  				windowFoundCount++;  				makeWindowLogFile.AppendLine ("Window:" + windowFoundCount.ToString ());  				firstLineofFenestration = true;  				output.AppendLine (line);  				continue;  			}  			if (detailedFenestration) {  				//Match the name of the window  				Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  				if (fenestrationNameMatch.Success) {  					firstLineofFenestration = false;  					//strip off the whitespace and comma  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  					if (pure.Success) {  						windowName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						makeWindowLogFile.AppendLine ("windowName : " + windowName);  						continue;  					}  				}  				Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  				if (parentSurfaceIdMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  					if (pure.Success) {  						parentSurfaceName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  						continue;  					}  				}  				//Get multiplier  				Match multiplierMatch = multiplierRegex.Match (line);  				if (multiplierMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  					if (pure.Success) {  						string frontSpace = "    ";  						string multiplier = pure.Groups ["goods"].Value;  						string newmultiPlier = "1";  						string comma = "'";  						string endString = "                       !- Multiplier";  						output.AppendLine (frontSpace + newmultiPlier + comma + endString);  						makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  						continue;  					}  				}  				//My next match is the coordinates' since the rest I should be able to skip at this point  				Match typicalVertexMatch = typicalVertexRegex.Match (line);  				if (typicalVertexMatch.Success) {  					ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  					//this little bit of code had to be added so that I could prevent extra lines from being written  					//after the first vertex has been discovered  					if (!detailedFenestration)  						continue;  					if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  						#region  						//globally change all the windows to a new window area based on the surface attached  						//get the areas  						//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  						if (window.nameId == windowName) {  							ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  							vertexMatching = true;  							double wallarea = Vector.GetAreaofSurface (surface);  							if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  								Console.Write ("");  							}  							if (surface.numVertices == 4 && window.numVertices == 4) {  								makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  								//this routine is only for square windows  								double wallHeight = GetNormalQuadWallHeight (surface);  								double wallWidth = GetNormalQuadWallWidth (surface);  								double windowWidth = GetNormalQuadWindowWidth (window);  								double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  								double firstSpace = windowSpacing / 4;  								if (newWindowCounter == 1) {  									if (newCoords.Count () == 0) {  										if (window.multiplier > 1) {  											makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  											makeWindowLogFile.AppendLine ("Getting new Coordinates");  											newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  										}  										else  											newCoords = window.coordinateList;  									}  									//once I have the newCoordinates' then I should go on to change the values in the file  									//we can assume that if there are no new coords' then the old file matches the new exactly  									if (newCoords.Count > 0) {  										//make a new vertex point and append it to the line  										if (vertexCounter != newCoords.Count) {  											string frontBlank = "     ";  											string comma = "'";  											string newX = newCoords [vertexCounter - 1].X.ToString ();  											string newY = newCoords [vertexCounter - 1].Y.ToString ();  											string newZ = newCoords [vertexCounter - 1].Z.ToString ();  											string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  											string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  											output.AppendLine (newVertexLine);  											vertexCounter++;  											continue;  										}  										//it is a normal typical vertex line with a semicolon at the end (the last one)  										else {  											string frontBlank = "     ";  											string comma = "'";  											string newX = newCoords [vertexCounter - 1].X.ToString ();  											string newY = newCoords [vertexCounter - 1].Y.ToString ();  											string newZ = newCoords [vertexCounter - 1].Z.ToString ();  											string semicolon = ";";  											string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  											string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  											output.AppendLine (newVertexLine);  											//reset which should prevent the rest of the vertices from being written  											vertexMatching = false;  											detailedFenestration = false;  											newCoords.Clear ();  											vertexCounter = 1;  											if (window.multiplier > 1)  												newWindowCounter++;  											//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  											if (window.multiplier > 1) {  												output.AppendLine ("");  												while (newWindowCounter <= window.multiplier) {  													//make an entirely new window from the original window  													//make coords  													newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  													if (newCoords.Count () == 0) {  														makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  														//newWindowCounter++;  														//continue;  													}  													//now make the new window Text  													//copy the window  													int newMultiplier = 1;  													ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  													//make the window  													output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  													if (newWindowCounter == window.multiplier) {  														detailedFenestration = false;  														vertexMatching = false;  														newWindowCounter = 1;  														newCoords.Clear ();  														break;  													}  													newWindowCounter++;  												}  											}  										}  									}  									else {  										makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  										continue;  									}  								}  								else {  								}  							}  						}  						#endregion  					}  				}  				//this is admittedly a bit sloppy and should be cleaned up  				//basically says' if there is no match' then move append and work on the next line  				else {  					output.AppendLine (line);  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	successfulUpdate = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	bool logWritten = FileMng.CreateLogFile (makeWindowLogFileLocation' makeWindowLogFile' false' encoding);  }  catch (Exception e) {  	Console.WriteLine (e.ToString ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: try {  	Regex fenestrationYes = new Regex (EPlusObjects.EPlusRegexString.startFenestration);  	Regex fenestrationNameRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationName);  	Regex fenestrationParentSurfaceRegex = new Regex (EPlusObjects.EPlusRegexString.parentSurfaceName);  	Regex typicalVertexRegex = new Regex (EPlusObjects.EPlusRegexString.typicalVertex);  	Regex semiColonRegex = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Regex multiplierRegex = new Regex (EPlusObjects.EPlusRegexString.fenestrationMultiplier);  	Encoding encoding;  	bool firstLineofFenestration = false;  	bool semicolonfound = false;  	string windowName = "";  	string parentSurfaceName = "";  	using (StreamReader reader = new StreamReader (idfname)) {  		string line;  		encoding = reader.CurrentEncoding;  		bool detailedFenestration = false;  		bool vertexMatching = false;  		int vertexCounter = 1;  		int newWindowCounter = 1;  		while ((line = reader.ReadLine ()) != null) {  			MatchCollection fenStart = fenestrationYes.Matches (line);  			if (fenStart.Count > 0) {  				detailedFenestration = true;  				windowFoundCount++;  				makeWindowLogFile.AppendLine ("Window:" + windowFoundCount.ToString ());  				firstLineofFenestration = true;  				output.AppendLine (line);  				continue;  			}  			if (detailedFenestration) {  				//Match the name of the window  				Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  				if (fenestrationNameMatch.Success) {  					firstLineofFenestration = false;  					//strip off the whitespace and comma  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  					if (pure.Success) {  						windowName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						makeWindowLogFile.AppendLine ("windowName : " + windowName);  						continue;  					}  				}  				Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  				if (parentSurfaceIdMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  					if (pure.Success) {  						parentSurfaceName = pure.Groups ["goods"].Value;  						output.AppendLine (line);  						makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  						continue;  					}  				}  				//Get multiplier  				Match multiplierMatch = multiplierRegex.Match (line);  				if (multiplierMatch.Success) {  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  					if (pure.Success) {  						string frontSpace = "    ";  						string multiplier = pure.Groups ["goods"].Value;  						string newmultiPlier = "1";  						string comma = "'";  						string endString = "                       !- Multiplier";  						output.AppendLine (frontSpace + newmultiPlier + comma + endString);  						makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  						continue;  					}  				}  				//My next match is the coordinates' since the rest I should be able to skip at this point  				Match typicalVertexMatch = typicalVertexRegex.Match (line);  				if (typicalVertexMatch.Success) {  					ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  					//this little bit of code had to be added so that I could prevent extra lines from being written  					//after the first vertex has been discovered  					if (!detailedFenestration)  						continue;  					if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  						#region  						//globally change all the windows to a new window area based on the surface attached  						//get the areas  						//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  						if (window.nameId == windowName) {  							ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  							vertexMatching = true;  							double wallarea = Vector.GetAreaofSurface (surface);  							if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  								Console.Write ("");  							}  							if (surface.numVertices == 4 && window.numVertices == 4) {  								makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  								//this routine is only for square windows  								double wallHeight = GetNormalQuadWallHeight (surface);  								double wallWidth = GetNormalQuadWallWidth (surface);  								double windowWidth = GetNormalQuadWindowWidth (window);  								double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  								double firstSpace = windowSpacing / 4;  								if (newWindowCounter == 1) {  									if (newCoords.Count () == 0) {  										if (window.multiplier > 1) {  											makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  											makeWindowLogFile.AppendLine ("Getting new Coordinates");  											newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  										}  										else  											newCoords = window.coordinateList;  									}  									//once I have the newCoordinates' then I should go on to change the values in the file  									//we can assume that if there are no new coords' then the old file matches the new exactly  									if (newCoords.Count > 0) {  										//make a new vertex point and append it to the line  										if (vertexCounter != newCoords.Count) {  											string frontBlank = "     ";  											string comma = "'";  											string newX = newCoords [vertexCounter - 1].X.ToString ();  											string newY = newCoords [vertexCounter - 1].Y.ToString ();  											string newZ = newCoords [vertexCounter - 1].Z.ToString ();  											string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  											string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  											output.AppendLine (newVertexLine);  											vertexCounter++;  											continue;  										}  										//it is a normal typical vertex line with a semicolon at the end (the last one)  										else {  											string frontBlank = "     ";  											string comma = "'";  											string newX = newCoords [vertexCounter - 1].X.ToString ();  											string newY = newCoords [vertexCounter - 1].Y.ToString ();  											string newZ = newCoords [vertexCounter - 1].Z.ToString ();  											string semicolon = ";";  											string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  											string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  											output.AppendLine (newVertexLine);  											//reset which should prevent the rest of the vertices from being written  											vertexMatching = false;  											detailedFenestration = false;  											newCoords.Clear ();  											vertexCounter = 1;  											if (window.multiplier > 1)  												newWindowCounter++;  											//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  											if (window.multiplier > 1) {  												output.AppendLine ("");  												while (newWindowCounter <= window.multiplier) {  													//make an entirely new window from the original window  													//make coords  													newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  													if (newCoords.Count () == 0) {  														makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  														//newWindowCounter++;  														//continue;  													}  													//now make the new window Text  													//copy the window  													int newMultiplier = 1;  													ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  													//make the window  													output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  													if (newWindowCounter == window.multiplier) {  														detailedFenestration = false;  														vertexMatching = false;  														newWindowCounter = 1;  														newCoords.Clear ();  														break;  													}  													newWindowCounter++;  												}  											}  										}  									}  									else {  										makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  										continue;  									}  								}  								else {  								}  							}  						}  						#endregion  					}  				}  				//this is admittedly a bit sloppy and should be cleaned up  				//basically says' if there is no match' then move append and work on the next line  				else {  					output.AppendLine (line);  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	successfulUpdate = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	bool logWritten = FileMng.CreateLogFile (makeWindowLogFileLocation' makeWindowLogFile' false' encoding);  }  catch (Exception e) {  	Console.WriteLine (e.ToString ());  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: using (StreamReader reader = new StreamReader (idfname)) {  	string line;  	encoding = reader.CurrentEncoding;  	bool detailedFenestration = false;  	bool vertexMatching = false;  	int vertexCounter = 1;  	int newWindowCounter = 1;  	while ((line = reader.ReadLine ()) != null) {  		MatchCollection fenStart = fenestrationYes.Matches (line);  		if (fenStart.Count > 0) {  			detailedFenestration = true;  			windowFoundCount++;  			makeWindowLogFile.AppendLine ("Window:" + windowFoundCount.ToString ());  			firstLineofFenestration = true;  			output.AppendLine (line);  			continue;  		}  		if (detailedFenestration) {  			//Match the name of the window  			Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  			if (fenestrationNameMatch.Success) {  				firstLineofFenestration = false;  				//strip off the whitespace and comma  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					windowName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					makeWindowLogFile.AppendLine ("windowName : " + windowName);  					continue;  				}  			}  			Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  			if (parentSurfaceIdMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  				if (pure.Success) {  					parentSurfaceName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  					continue;  				}  			}  			//Get multiplier  			Match multiplierMatch = multiplierRegex.Match (line);  			if (multiplierMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  				if (pure.Success) {  					string frontSpace = "    ";  					string multiplier = pure.Groups ["goods"].Value;  					string newmultiPlier = "1";  					string comma = "'";  					string endString = "                       !- Multiplier";  					output.AppendLine (frontSpace + newmultiPlier + comma + endString);  					makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  					continue;  				}  			}  			//My next match is the coordinates' since the rest I should be able to skip at this point  			Match typicalVertexMatch = typicalVertexRegex.Match (line);  			if (typicalVertexMatch.Success) {  				ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  				//this little bit of code had to be added so that I could prevent extra lines from being written  				//after the first vertex has been discovered  				if (!detailedFenestration)  					continue;  				if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  					#region  					//globally change all the windows to a new window area based on the surface attached  					//get the areas  					//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  					if (window.nameId == windowName) {  						ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  						vertexMatching = true;  						double wallarea = Vector.GetAreaofSurface (surface);  						if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  							Console.Write ("");  						}  						if (surface.numVertices == 4 && window.numVertices == 4) {  							makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  							//this routine is only for square windows  							double wallHeight = GetNormalQuadWallHeight (surface);  							double wallWidth = GetNormalQuadWallWidth (surface);  							double windowWidth = GetNormalQuadWindowWidth (window);  							double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  							double firstSpace = windowSpacing / 4;  							if (newWindowCounter == 1) {  								if (newCoords.Count () == 0) {  									if (window.multiplier > 1) {  										makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  										makeWindowLogFile.AppendLine ("Getting new Coordinates");  										newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  									}  									else  										newCoords = window.coordinateList;  								}  								//once I have the newCoordinates' then I should go on to change the values in the file  								//we can assume that if there are no new coords' then the old file matches the new exactly  								if (newCoords.Count > 0) {  									//make a new vertex point and append it to the line  									if (vertexCounter != newCoords.Count) {  										string frontBlank = "     ";  										string comma = "'";  										string newX = newCoords [vertexCounter - 1].X.ToString ();  										string newY = newCoords [vertexCounter - 1].Y.ToString ();  										string newZ = newCoords [vertexCounter - 1].Z.ToString ();  										string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  										string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  										output.AppendLine (newVertexLine);  										vertexCounter++;  										continue;  									}  									//it is a normal typical vertex line with a semicolon at the end (the last one)  									else {  										string frontBlank = "     ";  										string comma = "'";  										string newX = newCoords [vertexCounter - 1].X.ToString ();  										string newY = newCoords [vertexCounter - 1].Y.ToString ();  										string newZ = newCoords [vertexCounter - 1].Z.ToString ();  										string semicolon = ";";  										string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  										string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  										output.AppendLine (newVertexLine);  										//reset which should prevent the rest of the vertices from being written  										vertexMatching = false;  										detailedFenestration = false;  										newCoords.Clear ();  										vertexCounter = 1;  										if (window.multiplier > 1)  											newWindowCounter++;  										//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  										if (window.multiplier > 1) {  											output.AppendLine ("");  											while (newWindowCounter <= window.multiplier) {  												//make an entirely new window from the original window  												//make coords  												newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  												if (newCoords.Count () == 0) {  													makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  													//newWindowCounter++;  													//continue;  												}  												//now make the new window Text  												//copy the window  												int newMultiplier = 1;  												ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  												//make the window  												output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  												if (newWindowCounter == window.multiplier) {  													detailedFenestration = false;  													vertexMatching = false;  													newWindowCounter = 1;  													newCoords.Clear ();  													break;  												}  												newWindowCounter++;  											}  										}  									}  								}  								else {  									makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  									continue;  								}  							}  							else {  							}  						}  					}  					#endregion  				}  			}  			//this is admittedly a bit sloppy and should be cleaned up  			//basically says' if there is no match' then move append and work on the next line  			else {  				output.AppendLine (line);  			}  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: using (StreamReader reader = new StreamReader (idfname)) {  	string line;  	encoding = reader.CurrentEncoding;  	bool detailedFenestration = false;  	bool vertexMatching = false;  	int vertexCounter = 1;  	int newWindowCounter = 1;  	while ((line = reader.ReadLine ()) != null) {  		MatchCollection fenStart = fenestrationYes.Matches (line);  		if (fenStart.Count > 0) {  			detailedFenestration = true;  			windowFoundCount++;  			makeWindowLogFile.AppendLine ("Window:" + windowFoundCount.ToString ());  			firstLineofFenestration = true;  			output.AppendLine (line);  			continue;  		}  		if (detailedFenestration) {  			//Match the name of the window  			Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  			if (fenestrationNameMatch.Success) {  				firstLineofFenestration = false;  				//strip off the whitespace and comma  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					windowName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					makeWindowLogFile.AppendLine ("windowName : " + windowName);  					continue;  				}  			}  			Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  			if (parentSurfaceIdMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  				if (pure.Success) {  					parentSurfaceName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  					continue;  				}  			}  			//Get multiplier  			Match multiplierMatch = multiplierRegex.Match (line);  			if (multiplierMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  				if (pure.Success) {  					string frontSpace = "    ";  					string multiplier = pure.Groups ["goods"].Value;  					string newmultiPlier = "1";  					string comma = "'";  					string endString = "                       !- Multiplier";  					output.AppendLine (frontSpace + newmultiPlier + comma + endString);  					makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  					continue;  				}  			}  			//My next match is the coordinates' since the rest I should be able to skip at this point  			Match typicalVertexMatch = typicalVertexRegex.Match (line);  			if (typicalVertexMatch.Success) {  				ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  				//this little bit of code had to be added so that I could prevent extra lines from being written  				//after the first vertex has been discovered  				if (!detailedFenestration)  					continue;  				if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  					#region  					//globally change all the windows to a new window area based on the surface attached  					//get the areas  					//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  					if (window.nameId == windowName) {  						ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  						vertexMatching = true;  						double wallarea = Vector.GetAreaofSurface (surface);  						if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  							Console.Write ("");  						}  						if (surface.numVertices == 4 && window.numVertices == 4) {  							makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  							//this routine is only for square windows  							double wallHeight = GetNormalQuadWallHeight (surface);  							double wallWidth = GetNormalQuadWallWidth (surface);  							double windowWidth = GetNormalQuadWindowWidth (window);  							double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  							double firstSpace = windowSpacing / 4;  							if (newWindowCounter == 1) {  								if (newCoords.Count () == 0) {  									if (window.multiplier > 1) {  										makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  										makeWindowLogFile.AppendLine ("Getting new Coordinates");  										newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  									}  									else  										newCoords = window.coordinateList;  								}  								//once I have the newCoordinates' then I should go on to change the values in the file  								//we can assume that if there are no new coords' then the old file matches the new exactly  								if (newCoords.Count > 0) {  									//make a new vertex point and append it to the line  									if (vertexCounter != newCoords.Count) {  										string frontBlank = "     ";  										string comma = "'";  										string newX = newCoords [vertexCounter - 1].X.ToString ();  										string newY = newCoords [vertexCounter - 1].Y.ToString ();  										string newZ = newCoords [vertexCounter - 1].Z.ToString ();  										string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  										string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  										output.AppendLine (newVertexLine);  										vertexCounter++;  										continue;  									}  									//it is a normal typical vertex line with a semicolon at the end (the last one)  									else {  										string frontBlank = "     ";  										string comma = "'";  										string newX = newCoords [vertexCounter - 1].X.ToString ();  										string newY = newCoords [vertexCounter - 1].Y.ToString ();  										string newZ = newCoords [vertexCounter - 1].Z.ToString ();  										string semicolon = ";";  										string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  										string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  										output.AppendLine (newVertexLine);  										//reset which should prevent the rest of the vertices from being written  										vertexMatching = false;  										detailedFenestration = false;  										newCoords.Clear ();  										vertexCounter = 1;  										if (window.multiplier > 1)  											newWindowCounter++;  										//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  										if (window.multiplier > 1) {  											output.AppendLine ("");  											while (newWindowCounter <= window.multiplier) {  												//make an entirely new window from the original window  												//make coords  												newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  												if (newCoords.Count () == 0) {  													makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  													//newWindowCounter++;  													//continue;  												}  												//now make the new window Text  												//copy the window  												int newMultiplier = 1;  												ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  												//make the window  												output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  												if (newWindowCounter == window.multiplier) {  													detailedFenestration = false;  													vertexMatching = false;  													newWindowCounter = 1;  													newCoords.Clear ();  													break;  												}  												newWindowCounter++;  											}  										}  									}  								}  								else {  									makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  									continue;  								}  							}  							else {  							}  						}  					}  					#endregion  				}  			}  			//this is admittedly a bit sloppy and should be cleaned up  			//basically says' if there is no match' then move append and work on the next line  			else {  				output.AppendLine (line);  			}  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: using (StreamReader reader = new StreamReader (idfname)) {  	string line;  	encoding = reader.CurrentEncoding;  	bool detailedFenestration = false;  	bool vertexMatching = false;  	int vertexCounter = 1;  	int newWindowCounter = 1;  	while ((line = reader.ReadLine ()) != null) {  		MatchCollection fenStart = fenestrationYes.Matches (line);  		if (fenStart.Count > 0) {  			detailedFenestration = true;  			windowFoundCount++;  			makeWindowLogFile.AppendLine ("Window:" + windowFoundCount.ToString ());  			firstLineofFenestration = true;  			output.AppendLine (line);  			continue;  		}  		if (detailedFenestration) {  			//Match the name of the window  			Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  			if (fenestrationNameMatch.Success) {  				firstLineofFenestration = false;  				//strip off the whitespace and comma  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					windowName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					makeWindowLogFile.AppendLine ("windowName : " + windowName);  					continue;  				}  			}  			Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  			if (parentSurfaceIdMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  				if (pure.Success) {  					parentSurfaceName = pure.Groups ["goods"].Value;  					output.AppendLine (line);  					makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  					continue;  				}  			}  			//Get multiplier  			Match multiplierMatch = multiplierRegex.Match (line);  			if (multiplierMatch.Success) {  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  				if (pure.Success) {  					string frontSpace = "    ";  					string multiplier = pure.Groups ["goods"].Value;  					string newmultiPlier = "1";  					string comma = "'";  					string endString = "                       !- Multiplier";  					output.AppendLine (frontSpace + newmultiPlier + comma + endString);  					makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  					continue;  				}  			}  			//My next match is the coordinates' since the rest I should be able to skip at this point  			Match typicalVertexMatch = typicalVertexRegex.Match (line);  			if (typicalVertexMatch.Success) {  				ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  				//this little bit of code had to be added so that I could prevent extra lines from being written  				//after the first vertex has been discovered  				if (!detailedFenestration)  					continue;  				if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  					#region  					//globally change all the windows to a new window area based on the surface attached  					//get the areas  					//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  					if (window.nameId == windowName) {  						ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  						vertexMatching = true;  						double wallarea = Vector.GetAreaofSurface (surface);  						if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  							Console.Write ("");  						}  						if (surface.numVertices == 4 && window.numVertices == 4) {  							makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  							//this routine is only for square windows  							double wallHeight = GetNormalQuadWallHeight (surface);  							double wallWidth = GetNormalQuadWallWidth (surface);  							double windowWidth = GetNormalQuadWindowWidth (window);  							double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  							double firstSpace = windowSpacing / 4;  							if (newWindowCounter == 1) {  								if (newCoords.Count () == 0) {  									if (window.multiplier > 1) {  										makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  										makeWindowLogFile.AppendLine ("Getting new Coordinates");  										newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  									}  									else  										newCoords = window.coordinateList;  								}  								//once I have the newCoordinates' then I should go on to change the values in the file  								//we can assume that if there are no new coords' then the old file matches the new exactly  								if (newCoords.Count > 0) {  									//make a new vertex point and append it to the line  									if (vertexCounter != newCoords.Count) {  										string frontBlank = "     ";  										string comma = "'";  										string newX = newCoords [vertexCounter - 1].X.ToString ();  										string newY = newCoords [vertexCounter - 1].Y.ToString ();  										string newZ = newCoords [vertexCounter - 1].Z.ToString ();  										string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  										string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  										output.AppendLine (newVertexLine);  										vertexCounter++;  										continue;  									}  									//it is a normal typical vertex line with a semicolon at the end (the last one)  									else {  										string frontBlank = "     ";  										string comma = "'";  										string newX = newCoords [vertexCounter - 1].X.ToString ();  										string newY = newCoords [vertexCounter - 1].Y.ToString ();  										string newZ = newCoords [vertexCounter - 1].Z.ToString ();  										string semicolon = ";";  										string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  										string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  										output.AppendLine (newVertexLine);  										//reset which should prevent the rest of the vertices from being written  										vertexMatching = false;  										detailedFenestration = false;  										newCoords.Clear ();  										vertexCounter = 1;  										if (window.multiplier > 1)  											newWindowCounter++;  										//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  										if (window.multiplier > 1) {  											output.AppendLine ("");  											while (newWindowCounter <= window.multiplier) {  												//make an entirely new window from the original window  												//make coords  												newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  												if (newCoords.Count () == 0) {  													makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  													//newWindowCounter++;  													//continue;  												}  												//now make the new window Text  												//copy the window  												int newMultiplier = 1;  												ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  												//make the window  												output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  												if (newWindowCounter == window.multiplier) {  													detailedFenestration = false;  													vertexMatching = false;  													newWindowCounter = 1;  													newCoords.Clear ();  													break;  												}  												newWindowCounter++;  											}  										}  									}  								}  								else {  									makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  									continue;  								}  							}  							else {  							}  						}  					}  					#endregion  				}  			}  			//this is admittedly a bit sloppy and should be cleaned up  			//basically says' if there is no match' then move append and work on the next line  			else {  				output.AppendLine (line);  			}  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	MatchCollection fenStart = fenestrationYes.Matches (line);  	if (fenStart.Count > 0) {  		detailedFenestration = true;  		windowFoundCount++;  		makeWindowLogFile.AppendLine ("Window:" + windowFoundCount.ToString ());  		firstLineofFenestration = true;  		output.AppendLine (line);  		continue;  	}  	if (detailedFenestration) {  		//Match the name of the window  		Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  		if (fenestrationNameMatch.Success) {  			firstLineofFenestration = false;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				windowName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				makeWindowLogFile.AppendLine ("windowName : " + windowName);  				continue;  			}  		}  		Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  		if (parentSurfaceIdMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  			if (pure.Success) {  				parentSurfaceName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  				continue;  			}  		}  		//Get multiplier  		Match multiplierMatch = multiplierRegex.Match (line);  		if (multiplierMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  			if (pure.Success) {  				string frontSpace = "    ";  				string multiplier = pure.Groups ["goods"].Value;  				string newmultiPlier = "1";  				string comma = "'";  				string endString = "                       !- Multiplier";  				output.AppendLine (frontSpace + newmultiPlier + comma + endString);  				makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  				continue;  			}  		}  		//My next match is the coordinates' since the rest I should be able to skip at this point  		Match typicalVertexMatch = typicalVertexRegex.Match (line);  		if (typicalVertexMatch.Success) {  			ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  			//this little bit of code had to be added so that I could prevent extra lines from being written  			//after the first vertex has been discovered  			if (!detailedFenestration)  				continue;  			if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  				#region  				//globally change all the windows to a new window area based on the surface attached  				//get the areas  				//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  				if (window.nameId == windowName) {  					ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  					vertexMatching = true;  					double wallarea = Vector.GetAreaofSurface (surface);  					if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  						Console.Write ("");  					}  					if (surface.numVertices == 4 && window.numVertices == 4) {  						makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  						//this routine is only for square windows  						double wallHeight = GetNormalQuadWallHeight (surface);  						double wallWidth = GetNormalQuadWallWidth (surface);  						double windowWidth = GetNormalQuadWindowWidth (window);  						double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  						double firstSpace = windowSpacing / 4;  						if (newWindowCounter == 1) {  							if (newCoords.Count () == 0) {  								if (window.multiplier > 1) {  									makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  									makeWindowLogFile.AppendLine ("Getting new Coordinates");  									newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  								}  								else  									newCoords = window.coordinateList;  							}  							//once I have the newCoordinates' then I should go on to change the values in the file  							//we can assume that if there are no new coords' then the old file matches the new exactly  							if (newCoords.Count > 0) {  								//make a new vertex point and append it to the line  								if (vertexCounter != newCoords.Count) {  									string frontBlank = "     ";  									string comma = "'";  									string newX = newCoords [vertexCounter - 1].X.ToString ();  									string newY = newCoords [vertexCounter - 1].Y.ToString ();  									string newZ = newCoords [vertexCounter - 1].Z.ToString ();  									string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  									string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  									output.AppendLine (newVertexLine);  									vertexCounter++;  									continue;  								}  								//it is a normal typical vertex line with a semicolon at the end (the last one)  								else {  									string frontBlank = "     ";  									string comma = "'";  									string newX = newCoords [vertexCounter - 1].X.ToString ();  									string newY = newCoords [vertexCounter - 1].Y.ToString ();  									string newZ = newCoords [vertexCounter - 1].Z.ToString ();  									string semicolon = ";";  									string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  									string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  									output.AppendLine (newVertexLine);  									//reset which should prevent the rest of the vertices from being written  									vertexMatching = false;  									detailedFenestration = false;  									newCoords.Clear ();  									vertexCounter = 1;  									if (window.multiplier > 1)  										newWindowCounter++;  									//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  									if (window.multiplier > 1) {  										output.AppendLine ("");  										while (newWindowCounter <= window.multiplier) {  											//make an entirely new window from the original window  											//make coords  											newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  											if (newCoords.Count () == 0) {  												makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  												//newWindowCounter++;  												//continue;  											}  											//now make the new window Text  											//copy the window  											int newMultiplier = 1;  											ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  											//make the window  											output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  											if (newWindowCounter == window.multiplier) {  												detailedFenestration = false;  												vertexMatching = false;  												newWindowCounter = 1;  												newCoords.Clear ();  												break;  											}  											newWindowCounter++;  										}  									}  								}  							}  							else {  								makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  								continue;  							}  						}  						else {  						}  					}  				}  				#endregion  			}  		}  		//this is admittedly a bit sloppy and should be cleaned up  		//basically says' if there is no match' then move append and work on the next line  		else {  			output.AppendLine (line);  		}  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	MatchCollection fenStart = fenestrationYes.Matches (line);  	if (fenStart.Count > 0) {  		detailedFenestration = true;  		windowFoundCount++;  		makeWindowLogFile.AppendLine ("Window:" + windowFoundCount.ToString ());  		firstLineofFenestration = true;  		output.AppendLine (line);  		continue;  	}  	if (detailedFenestration) {  		//Match the name of the window  		Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  		if (fenestrationNameMatch.Success) {  			firstLineofFenestration = false;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				windowName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				makeWindowLogFile.AppendLine ("windowName : " + windowName);  				continue;  			}  		}  		Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  		if (parentSurfaceIdMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  			if (pure.Success) {  				parentSurfaceName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  				continue;  			}  		}  		//Get multiplier  		Match multiplierMatch = multiplierRegex.Match (line);  		if (multiplierMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  			if (pure.Success) {  				string frontSpace = "    ";  				string multiplier = pure.Groups ["goods"].Value;  				string newmultiPlier = "1";  				string comma = "'";  				string endString = "                       !- Multiplier";  				output.AppendLine (frontSpace + newmultiPlier + comma + endString);  				makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  				continue;  			}  		}  		//My next match is the coordinates' since the rest I should be able to skip at this point  		Match typicalVertexMatch = typicalVertexRegex.Match (line);  		if (typicalVertexMatch.Success) {  			ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  			//this little bit of code had to be added so that I could prevent extra lines from being written  			//after the first vertex has been discovered  			if (!detailedFenestration)  				continue;  			if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  				#region  				//globally change all the windows to a new window area based on the surface attached  				//get the areas  				//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  				if (window.nameId == windowName) {  					ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  					vertexMatching = true;  					double wallarea = Vector.GetAreaofSurface (surface);  					if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  						Console.Write ("");  					}  					if (surface.numVertices == 4 && window.numVertices == 4) {  						makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  						//this routine is only for square windows  						double wallHeight = GetNormalQuadWallHeight (surface);  						double wallWidth = GetNormalQuadWallWidth (surface);  						double windowWidth = GetNormalQuadWindowWidth (window);  						double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  						double firstSpace = windowSpacing / 4;  						if (newWindowCounter == 1) {  							if (newCoords.Count () == 0) {  								if (window.multiplier > 1) {  									makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  									makeWindowLogFile.AppendLine ("Getting new Coordinates");  									newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  								}  								else  									newCoords = window.coordinateList;  							}  							//once I have the newCoordinates' then I should go on to change the values in the file  							//we can assume that if there are no new coords' then the old file matches the new exactly  							if (newCoords.Count > 0) {  								//make a new vertex point and append it to the line  								if (vertexCounter != newCoords.Count) {  									string frontBlank = "     ";  									string comma = "'";  									string newX = newCoords [vertexCounter - 1].X.ToString ();  									string newY = newCoords [vertexCounter - 1].Y.ToString ();  									string newZ = newCoords [vertexCounter - 1].Z.ToString ();  									string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  									string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  									output.AppendLine (newVertexLine);  									vertexCounter++;  									continue;  								}  								//it is a normal typical vertex line with a semicolon at the end (the last one)  								else {  									string frontBlank = "     ";  									string comma = "'";  									string newX = newCoords [vertexCounter - 1].X.ToString ();  									string newY = newCoords [vertexCounter - 1].Y.ToString ();  									string newZ = newCoords [vertexCounter - 1].Z.ToString ();  									string semicolon = ";";  									string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  									string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  									output.AppendLine (newVertexLine);  									//reset which should prevent the rest of the vertices from being written  									vertexMatching = false;  									detailedFenestration = false;  									newCoords.Clear ();  									vertexCounter = 1;  									if (window.multiplier > 1)  										newWindowCounter++;  									//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  									if (window.multiplier > 1) {  										output.AppendLine ("");  										while (newWindowCounter <= window.multiplier) {  											//make an entirely new window from the original window  											//make coords  											newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  											if (newCoords.Count () == 0) {  												makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  												//newWindowCounter++;  												//continue;  											}  											//now make the new window Text  											//copy the window  											int newMultiplier = 1;  											ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  											//make the window  											output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  											if (newWindowCounter == window.multiplier) {  												detailedFenestration = false;  												vertexMatching = false;  												newWindowCounter = 1;  												newCoords.Clear ();  												break;  											}  											newWindowCounter++;  										}  									}  								}  							}  							else {  								makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  								continue;  							}  						}  						else {  						}  					}  				}  				#endregion  			}  		}  		//this is admittedly a bit sloppy and should be cleaned up  		//basically says' if there is no match' then move append and work on the next line  		else {  			output.AppendLine (line);  		}  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	MatchCollection fenStart = fenestrationYes.Matches (line);  	if (fenStart.Count > 0) {  		detailedFenestration = true;  		windowFoundCount++;  		makeWindowLogFile.AppendLine ("Window:" + windowFoundCount.ToString ());  		firstLineofFenestration = true;  		output.AppendLine (line);  		continue;  	}  	if (detailedFenestration) {  		//Match the name of the window  		Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  		if (fenestrationNameMatch.Success) {  			firstLineofFenestration = false;  			//strip off the whitespace and comma  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				windowName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				makeWindowLogFile.AppendLine ("windowName : " + windowName);  				continue;  			}  		}  		Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  		if (parentSurfaceIdMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  			if (pure.Success) {  				parentSurfaceName = pure.Groups ["goods"].Value;  				output.AppendLine (line);  				makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  				continue;  			}  		}  		//Get multiplier  		Match multiplierMatch = multiplierRegex.Match (line);  		if (multiplierMatch.Success) {  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  			if (pure.Success) {  				string frontSpace = "    ";  				string multiplier = pure.Groups ["goods"].Value;  				string newmultiPlier = "1";  				string comma = "'";  				string endString = "                       !- Multiplier";  				output.AppendLine (frontSpace + newmultiPlier + comma + endString);  				makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  				continue;  			}  		}  		//My next match is the coordinates' since the rest I should be able to skip at this point  		Match typicalVertexMatch = typicalVertexRegex.Match (line);  		if (typicalVertexMatch.Success) {  			ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  			//this little bit of code had to be added so that I could prevent extra lines from being written  			//after the first vertex has been discovered  			if (!detailedFenestration)  				continue;  			if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  				#region  				//globally change all the windows to a new window area based on the surface attached  				//get the areas  				//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  				if (window.nameId == windowName) {  					ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  					vertexMatching = true;  					double wallarea = Vector.GetAreaofSurface (surface);  					if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  						Console.Write ("");  					}  					if (surface.numVertices == 4 && window.numVertices == 4) {  						makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  						//this routine is only for square windows  						double wallHeight = GetNormalQuadWallHeight (surface);  						double wallWidth = GetNormalQuadWallWidth (surface);  						double windowWidth = GetNormalQuadWindowWidth (window);  						double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  						double firstSpace = windowSpacing / 4;  						if (newWindowCounter == 1) {  							if (newCoords.Count () == 0) {  								if (window.multiplier > 1) {  									makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  									makeWindowLogFile.AppendLine ("Getting new Coordinates");  									newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  								}  								else  									newCoords = window.coordinateList;  							}  							//once I have the newCoordinates' then I should go on to change the values in the file  							//we can assume that if there are no new coords' then the old file matches the new exactly  							if (newCoords.Count > 0) {  								//make a new vertex point and append it to the line  								if (vertexCounter != newCoords.Count) {  									string frontBlank = "     ";  									string comma = "'";  									string newX = newCoords [vertexCounter - 1].X.ToString ();  									string newY = newCoords [vertexCounter - 1].Y.ToString ();  									string newZ = newCoords [vertexCounter - 1].Z.ToString ();  									string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  									string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  									output.AppendLine (newVertexLine);  									vertexCounter++;  									continue;  								}  								//it is a normal typical vertex line with a semicolon at the end (the last one)  								else {  									string frontBlank = "     ";  									string comma = "'";  									string newX = newCoords [vertexCounter - 1].X.ToString ();  									string newY = newCoords [vertexCounter - 1].Y.ToString ();  									string newZ = newCoords [vertexCounter - 1].Z.ToString ();  									string semicolon = ";";  									string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  									string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  									output.AppendLine (newVertexLine);  									//reset which should prevent the rest of the vertices from being written  									vertexMatching = false;  									detailedFenestration = false;  									newCoords.Clear ();  									vertexCounter = 1;  									if (window.multiplier > 1)  										newWindowCounter++;  									//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  									if (window.multiplier > 1) {  										output.AppendLine ("");  										while (newWindowCounter <= window.multiplier) {  											//make an entirely new window from the original window  											//make coords  											newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  											if (newCoords.Count () == 0) {  												makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  												//newWindowCounter++;  												//continue;  											}  											//now make the new window Text  											//copy the window  											int newMultiplier = 1;  											ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  											//make the window  											output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  											if (newWindowCounter == window.multiplier) {  												detailedFenestration = false;  												vertexMatching = false;  												newWindowCounter = 1;  												newCoords.Clear ();  												break;  											}  											newWindowCounter++;  										}  									}  								}  							}  							else {  								makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  								continue;  							}  						}  						else {  						}  					}  				}  				#endregion  			}  		}  		//this is admittedly a bit sloppy and should be cleaned up  		//basically says' if there is no match' then move append and work on the next line  		else {  			output.AppendLine (line);  		}  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (detailedFenestration) {  	//Match the name of the window  	Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  	if (fenestrationNameMatch.Success) {  		firstLineofFenestration = false;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			windowName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			makeWindowLogFile.AppendLine ("windowName : " + windowName);  			continue;  		}  	}  	Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  	if (parentSurfaceIdMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  		if (pure.Success) {  			parentSurfaceName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  			continue;  		}  	}  	//Get multiplier  	Match multiplierMatch = multiplierRegex.Match (line);  	if (multiplierMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  		if (pure.Success) {  			string frontSpace = "    ";  			string multiplier = pure.Groups ["goods"].Value;  			string newmultiPlier = "1";  			string comma = "'";  			string endString = "                       !- Multiplier";  			output.AppendLine (frontSpace + newmultiPlier + comma + endString);  			makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  			continue;  		}  	}  	//My next match is the coordinates' since the rest I should be able to skip at this point  	Match typicalVertexMatch = typicalVertexRegex.Match (line);  	if (typicalVertexMatch.Success) {  		ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  		//this little bit of code had to be added so that I could prevent extra lines from being written  		//after the first vertex has been discovered  		if (!detailedFenestration)  			continue;  		if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  			#region  			//globally change all the windows to a new window area based on the surface attached  			//get the areas  			//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  			if (window.nameId == windowName) {  				ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  				vertexMatching = true;  				double wallarea = Vector.GetAreaofSurface (surface);  				if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  					Console.Write ("");  				}  				if (surface.numVertices == 4 && window.numVertices == 4) {  					makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  					//this routine is only for square windows  					double wallHeight = GetNormalQuadWallHeight (surface);  					double wallWidth = GetNormalQuadWallWidth (surface);  					double windowWidth = GetNormalQuadWindowWidth (window);  					double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  					double firstSpace = windowSpacing / 4;  					if (newWindowCounter == 1) {  						if (newCoords.Count () == 0) {  							if (window.multiplier > 1) {  								makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  								makeWindowLogFile.AppendLine ("Getting new Coordinates");  								newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  							}  							else  								newCoords = window.coordinateList;  						}  						//once I have the newCoordinates' then I should go on to change the values in the file  						//we can assume that if there are no new coords' then the old file matches the new exactly  						if (newCoords.Count > 0) {  							//make a new vertex point and append it to the line  							if (vertexCounter != newCoords.Count) {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  								output.AppendLine (newVertexLine);  								vertexCounter++;  								continue;  							}  							//it is a normal typical vertex line with a semicolon at the end (the last one)  							else {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string semicolon = ";";  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  								output.AppendLine (newVertexLine);  								//reset which should prevent the rest of the vertices from being written  								vertexMatching = false;  								detailedFenestration = false;  								newCoords.Clear ();  								vertexCounter = 1;  								if (window.multiplier > 1)  									newWindowCounter++;  								//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  								if (window.multiplier > 1) {  									output.AppendLine ("");  									while (newWindowCounter <= window.multiplier) {  										//make an entirely new window from the original window  										//make coords  										newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  										if (newCoords.Count () == 0) {  											makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  											//newWindowCounter++;  											//continue;  										}  										//now make the new window Text  										//copy the window  										int newMultiplier = 1;  										ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  										//make the window  										output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  										if (newWindowCounter == window.multiplier) {  											detailedFenestration = false;  											vertexMatching = false;  											newWindowCounter = 1;  											newCoords.Clear ();  											break;  										}  										newWindowCounter++;  									}  								}  							}  						}  						else {  							makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  							continue;  						}  					}  					else {  					}  				}  			}  			#endregion  		}  	}  	//this is admittedly a bit sloppy and should be cleaned up  	//basically says' if there is no match' then move append and work on the next line  	else {  		output.AppendLine (line);  	}  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (detailedFenestration) {  	//Match the name of the window  	Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  	if (fenestrationNameMatch.Success) {  		firstLineofFenestration = false;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			windowName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			makeWindowLogFile.AppendLine ("windowName : " + windowName);  			continue;  		}  	}  	Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  	if (parentSurfaceIdMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  		if (pure.Success) {  			parentSurfaceName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  			continue;  		}  	}  	//Get multiplier  	Match multiplierMatch = multiplierRegex.Match (line);  	if (multiplierMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  		if (pure.Success) {  			string frontSpace = "    ";  			string multiplier = pure.Groups ["goods"].Value;  			string newmultiPlier = "1";  			string comma = "'";  			string endString = "                       !- Multiplier";  			output.AppendLine (frontSpace + newmultiPlier + comma + endString);  			makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  			continue;  		}  	}  	//My next match is the coordinates' since the rest I should be able to skip at this point  	Match typicalVertexMatch = typicalVertexRegex.Match (line);  	if (typicalVertexMatch.Success) {  		ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  		//this little bit of code had to be added so that I could prevent extra lines from being written  		//after the first vertex has been discovered  		if (!detailedFenestration)  			continue;  		if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  			#region  			//globally change all the windows to a new window area based on the surface attached  			//get the areas  			//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  			if (window.nameId == windowName) {  				ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  				vertexMatching = true;  				double wallarea = Vector.GetAreaofSurface (surface);  				if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  					Console.Write ("");  				}  				if (surface.numVertices == 4 && window.numVertices == 4) {  					makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  					//this routine is only for square windows  					double wallHeight = GetNormalQuadWallHeight (surface);  					double wallWidth = GetNormalQuadWallWidth (surface);  					double windowWidth = GetNormalQuadWindowWidth (window);  					double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  					double firstSpace = windowSpacing / 4;  					if (newWindowCounter == 1) {  						if (newCoords.Count () == 0) {  							if (window.multiplier > 1) {  								makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  								makeWindowLogFile.AppendLine ("Getting new Coordinates");  								newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  							}  							else  								newCoords = window.coordinateList;  						}  						//once I have the newCoordinates' then I should go on to change the values in the file  						//we can assume that if there are no new coords' then the old file matches the new exactly  						if (newCoords.Count > 0) {  							//make a new vertex point and append it to the line  							if (vertexCounter != newCoords.Count) {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  								output.AppendLine (newVertexLine);  								vertexCounter++;  								continue;  							}  							//it is a normal typical vertex line with a semicolon at the end (the last one)  							else {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string semicolon = ";";  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  								output.AppendLine (newVertexLine);  								//reset which should prevent the rest of the vertices from being written  								vertexMatching = false;  								detailedFenestration = false;  								newCoords.Clear ();  								vertexCounter = 1;  								if (window.multiplier > 1)  									newWindowCounter++;  								//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  								if (window.multiplier > 1) {  									output.AppendLine ("");  									while (newWindowCounter <= window.multiplier) {  										//make an entirely new window from the original window  										//make coords  										newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  										if (newCoords.Count () == 0) {  											makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  											//newWindowCounter++;  											//continue;  										}  										//now make the new window Text  										//copy the window  										int newMultiplier = 1;  										ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  										//make the window  										output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  										if (newWindowCounter == window.multiplier) {  											detailedFenestration = false;  											vertexMatching = false;  											newWindowCounter = 1;  											newCoords.Clear ();  											break;  										}  										newWindowCounter++;  									}  								}  							}  						}  						else {  							makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  							continue;  						}  					}  					else {  					}  				}  			}  			#endregion  		}  	}  	//this is admittedly a bit sloppy and should be cleaned up  	//basically says' if there is no match' then move append and work on the next line  	else {  		output.AppendLine (line);  	}  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (detailedFenestration) {  	//Match the name of the window  	Match fenestrationNameMatch = fenestrationNameRegex.Match (line);  	if (fenestrationNameMatch.Success) {  		firstLineofFenestration = false;  		//strip off the whitespace and comma  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			windowName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			makeWindowLogFile.AppendLine ("windowName : " + windowName);  			continue;  		}  	}  	Match parentSurfaceIdMatch = fenestrationParentSurfaceRegex.Match (line);  	if (parentSurfaceIdMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (parentSurfaceIdMatch.Groups ["1"].Value);  		if (pure.Success) {  			parentSurfaceName = pure.Groups ["goods"].Value;  			output.AppendLine (line);  			makeWindowLogFile.AppendLine ("parentSurface : " + parentSurfaceName);  			continue;  		}  	}  	//Get multiplier  	Match multiplierMatch = multiplierRegex.Match (line);  	if (multiplierMatch.Success) {  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (multiplierMatch.Groups ["1"].Value);  		if (pure.Success) {  			string frontSpace = "    ";  			string multiplier = pure.Groups ["goods"].Value;  			string newmultiPlier = "1";  			string comma = "'";  			string endString = "                       !- Multiplier";  			output.AppendLine (frontSpace + newmultiPlier + comma + endString);  			makeWindowLogFile.AppendLine ("multiplier : " + multiplier);  			continue;  		}  	}  	//My next match is the coordinates' since the rest I should be able to skip at this point  	Match typicalVertexMatch = typicalVertexRegex.Match (line);  	if (typicalVertexMatch.Success) {  		ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  		//this little bit of code had to be added so that I could prevent extra lines from being written  		//after the first vertex has been discovered  		if (!detailedFenestration)  			continue;  		if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  			#region  			//globally change all the windows to a new window area based on the surface attached  			//get the areas  			//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  			if (window.nameId == windowName) {  				ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  				vertexMatching = true;  				double wallarea = Vector.GetAreaofSurface (surface);  				if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  					Console.Write ("");  				}  				if (surface.numVertices == 4 && window.numVertices == 4) {  					makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  					//this routine is only for square windows  					double wallHeight = GetNormalQuadWallHeight (surface);  					double wallWidth = GetNormalQuadWallWidth (surface);  					double windowWidth = GetNormalQuadWindowWidth (window);  					double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  					double firstSpace = windowSpacing / 4;  					if (newWindowCounter == 1) {  						if (newCoords.Count () == 0) {  							if (window.multiplier > 1) {  								makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  								makeWindowLogFile.AppendLine ("Getting new Coordinates");  								newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  							}  							else  								newCoords = window.coordinateList;  						}  						//once I have the newCoordinates' then I should go on to change the values in the file  						//we can assume that if there are no new coords' then the old file matches the new exactly  						if (newCoords.Count > 0) {  							//make a new vertex point and append it to the line  							if (vertexCounter != newCoords.Count) {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  								output.AppendLine (newVertexLine);  								vertexCounter++;  								continue;  							}  							//it is a normal typical vertex line with a semicolon at the end (the last one)  							else {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string semicolon = ";";  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  								output.AppendLine (newVertexLine);  								//reset which should prevent the rest of the vertices from being written  								vertexMatching = false;  								detailedFenestration = false;  								newCoords.Clear ();  								vertexCounter = 1;  								if (window.multiplier > 1)  									newWindowCounter++;  								//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  								if (window.multiplier > 1) {  									output.AppendLine ("");  									while (newWindowCounter <= window.multiplier) {  										//make an entirely new window from the original window  										//make coords  										newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  										if (newCoords.Count () == 0) {  											makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  											//newWindowCounter++;  											//continue;  										}  										//now make the new window Text  										//copy the window  										int newMultiplier = 1;  										ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  										//make the window  										output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  										if (newWindowCounter == window.multiplier) {  											detailedFenestration = false;  											vertexMatching = false;  											newWindowCounter = 1;  											newCoords.Clear ();  											break;  										}  										newWindowCounter++;  									}  								}  							}  						}  						else {  							makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  							continue;  						}  					}  					else {  					}  				}  			}  			#endregion  		}  	}  	//this is admittedly a bit sloppy and should be cleaned up  	//basically says' if there is no match' then move append and work on the next line  	else {  		output.AppendLine (line);  	}  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (typicalVertexMatch.Success) {  	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  	//this little bit of code had to be added so that I could prevent extra lines from being written  	//after the first vertex has been discovered  	if (!detailedFenestration)  		continue;  	if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  		#region  		//globally change all the windows to a new window area based on the surface attached  		//get the areas  		//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  		if (window.nameId == windowName) {  			ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  			vertexMatching = true;  			double wallarea = Vector.GetAreaofSurface (surface);  			if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  				Console.Write ("");  			}  			if (surface.numVertices == 4 && window.numVertices == 4) {  				makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  				//this routine is only for square windows  				double wallHeight = GetNormalQuadWallHeight (surface);  				double wallWidth = GetNormalQuadWallWidth (surface);  				double windowWidth = GetNormalQuadWindowWidth (window);  				double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  				double firstSpace = windowSpacing / 4;  				if (newWindowCounter == 1) {  					if (newCoords.Count () == 0) {  						if (window.multiplier > 1) {  							makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  							makeWindowLogFile.AppendLine ("Getting new Coordinates");  							newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  						}  						else  							newCoords = window.coordinateList;  					}  					//once I have the newCoordinates' then I should go on to change the values in the file  					//we can assume that if there are no new coords' then the old file matches the new exactly  					if (newCoords.Count > 0) {  						//make a new vertex point and append it to the line  						if (vertexCounter != newCoords.Count) {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							continue;  						}  						//it is a normal typical vertex line with a semicolon at the end (the last one)  						else {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string semicolon = ";";  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  							output.AppendLine (newVertexLine);  							//reset which should prevent the rest of the vertices from being written  							vertexMatching = false;  							detailedFenestration = false;  							newCoords.Clear ();  							vertexCounter = 1;  							if (window.multiplier > 1)  								newWindowCounter++;  							//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  							if (window.multiplier > 1) {  								output.AppendLine ("");  								while (newWindowCounter <= window.multiplier) {  									//make an entirely new window from the original window  									//make coords  									newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  									if (newCoords.Count () == 0) {  										makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  										//newWindowCounter++;  										//continue;  									}  									//now make the new window Text  									//copy the window  									int newMultiplier = 1;  									ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  									//make the window  									output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  									if (newWindowCounter == window.multiplier) {  										detailedFenestration = false;  										vertexMatching = false;  										newWindowCounter = 1;  										newCoords.Clear ();  										break;  									}  									newWindowCounter++;  								}  							}  						}  					}  					else {  						makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  						continue;  					}  				}  				else {  				}  			}  		}  		#endregion  	}  }  //this is admittedly a bit sloppy and should be cleaned up  //basically says' if there is no match' then move append and work on the next line  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (typicalVertexMatch.Success) {  	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  	//this little bit of code had to be added so that I could prevent extra lines from being written  	//after the first vertex has been discovered  	if (!detailedFenestration)  		continue;  	if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  		#region  		//globally change all the windows to a new window area based on the surface attached  		//get the areas  		//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  		if (window.nameId == windowName) {  			ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  			vertexMatching = true;  			double wallarea = Vector.GetAreaofSurface (surface);  			if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  				Console.Write ("");  			}  			if (surface.numVertices == 4 && window.numVertices == 4) {  				makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  				//this routine is only for square windows  				double wallHeight = GetNormalQuadWallHeight (surface);  				double wallWidth = GetNormalQuadWallWidth (surface);  				double windowWidth = GetNormalQuadWindowWidth (window);  				double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  				double firstSpace = windowSpacing / 4;  				if (newWindowCounter == 1) {  					if (newCoords.Count () == 0) {  						if (window.multiplier > 1) {  							makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  							makeWindowLogFile.AppendLine ("Getting new Coordinates");  							newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  						}  						else  							newCoords = window.coordinateList;  					}  					//once I have the newCoordinates' then I should go on to change the values in the file  					//we can assume that if there are no new coords' then the old file matches the new exactly  					if (newCoords.Count > 0) {  						//make a new vertex point and append it to the line  						if (vertexCounter != newCoords.Count) {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							continue;  						}  						//it is a normal typical vertex line with a semicolon at the end (the last one)  						else {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string semicolon = ";";  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  							output.AppendLine (newVertexLine);  							//reset which should prevent the rest of the vertices from being written  							vertexMatching = false;  							detailedFenestration = false;  							newCoords.Clear ();  							vertexCounter = 1;  							if (window.multiplier > 1)  								newWindowCounter++;  							//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  							if (window.multiplier > 1) {  								output.AppendLine ("");  								while (newWindowCounter <= window.multiplier) {  									//make an entirely new window from the original window  									//make coords  									newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  									if (newCoords.Count () == 0) {  										makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  										//newWindowCounter++;  										//continue;  									}  									//now make the new window Text  									//copy the window  									int newMultiplier = 1;  									ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  									//make the window  									output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  									if (newWindowCounter == window.multiplier) {  										detailedFenestration = false;  										vertexMatching = false;  										newWindowCounter = 1;  										newCoords.Clear ();  										break;  									}  									newWindowCounter++;  								}  							}  						}  					}  					else {  						makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  						continue;  					}  				}  				else {  				}  			}  		}  		#endregion  	}  }  //this is admittedly a bit sloppy and should be cleaned up  //basically says' if there is no match' then move append and work on the next line  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (typicalVertexMatch.Success) {  	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions window = GetOpeningfromStringId (windowName' projectOpenings);  	//this little bit of code had to be added so that I could prevent extra lines from being written  	//after the first vertex has been discovered  	if (!detailedFenestration)  		continue;  	if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  		#region  		//globally change all the windows to a new window area based on the surface attached  		//get the areas  		//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  		if (window.nameId == windowName) {  			ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  			vertexMatching = true;  			double wallarea = Vector.GetAreaofSurface (surface);  			if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  				Console.Write ("");  			}  			if (surface.numVertices == 4 && window.numVertices == 4) {  				makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  				//this routine is only for square windows  				double wallHeight = GetNormalQuadWallHeight (surface);  				double wallWidth = GetNormalQuadWallWidth (surface);  				double windowWidth = GetNormalQuadWindowWidth (window);  				double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  				double firstSpace = windowSpacing / 4;  				if (newWindowCounter == 1) {  					if (newCoords.Count () == 0) {  						if (window.multiplier > 1) {  							makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  							makeWindowLogFile.AppendLine ("Getting new Coordinates");  							newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  						}  						else  							newCoords = window.coordinateList;  					}  					//once I have the newCoordinates' then I should go on to change the values in the file  					//we can assume that if there are no new coords' then the old file matches the new exactly  					if (newCoords.Count > 0) {  						//make a new vertex point and append it to the line  						if (vertexCounter != newCoords.Count) {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							continue;  						}  						//it is a normal typical vertex line with a semicolon at the end (the last one)  						else {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string semicolon = ";";  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  							output.AppendLine (newVertexLine);  							//reset which should prevent the rest of the vertices from being written  							vertexMatching = false;  							detailedFenestration = false;  							newCoords.Clear ();  							vertexCounter = 1;  							if (window.multiplier > 1)  								newWindowCounter++;  							//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  							if (window.multiplier > 1) {  								output.AppendLine ("");  								while (newWindowCounter <= window.multiplier) {  									//make an entirely new window from the original window  									//make coords  									newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  									if (newCoords.Count () == 0) {  										makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  										//newWindowCounter++;  										//continue;  									}  									//now make the new window Text  									//copy the window  									int newMultiplier = 1;  									ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  									//make the window  									output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  									if (newWindowCounter == window.multiplier) {  										detailedFenestration = false;  										vertexMatching = false;  										newWindowCounter = 1;  										newCoords.Clear ();  										break;  									}  									newWindowCounter++;  								}  							}  						}  					}  					else {  						makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  						continue;  					}  				}  				else {  				}  			}  		}  		#endregion  	}  }  //this is admittedly a bit sloppy and should be cleaned up  //basically says' if there is no match' then move append and work on the next line  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  	#region  	//globally change all the windows to a new window area based on the surface attached  	//get the areas  	//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  	if (window.nameId == windowName) {  		ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  		vertexMatching = true;  		double wallarea = Vector.GetAreaofSurface (surface);  		if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  			Console.Write ("");  		}  		if (surface.numVertices == 4 && window.numVertices == 4) {  			makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  			//this routine is only for square windows  			double wallHeight = GetNormalQuadWallHeight (surface);  			double wallWidth = GetNormalQuadWallWidth (surface);  			double windowWidth = GetNormalQuadWindowWidth (window);  			double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  			double firstSpace = windowSpacing / 4;  			if (newWindowCounter == 1) {  				if (newCoords.Count () == 0) {  					if (window.multiplier > 1) {  						makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  						makeWindowLogFile.AppendLine ("Getting new Coordinates");  						newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  					}  					else  						newCoords = window.coordinateList;  				}  				//once I have the newCoordinates' then I should go on to change the values in the file  				//we can assume that if there are no new coords' then the old file matches the new exactly  				if (newCoords.Count > 0) {  					//make a new vertex point and append it to the line  					if (vertexCounter != newCoords.Count) {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						continue;  					}  					//it is a normal typical vertex line with a semicolon at the end (the last one)  					else {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string semicolon = ";";  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  						output.AppendLine (newVertexLine);  						//reset which should prevent the rest of the vertices from being written  						vertexMatching = false;  						detailedFenestration = false;  						newCoords.Clear ();  						vertexCounter = 1;  						if (window.multiplier > 1)  							newWindowCounter++;  						//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  						if (window.multiplier > 1) {  							output.AppendLine ("");  							while (newWindowCounter <= window.multiplier) {  								//make an entirely new window from the original window  								//make coords  								newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  								if (newCoords.Count () == 0) {  									makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  									//newWindowCounter++;  									//continue;  								}  								//now make the new window Text  								//copy the window  								int newMultiplier = 1;  								ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  								//make the window  								output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  								if (newWindowCounter == window.multiplier) {  									detailedFenestration = false;  									vertexMatching = false;  									newWindowCounter = 1;  									newCoords.Clear ();  									break;  								}  								newWindowCounter++;  							}  						}  					}  				}  				else {  					makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  					continue;  				}  			}  			else {  			}  		}  	}  	#endregion  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  	#region  	//globally change all the windows to a new window area based on the surface attached  	//get the areas  	//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  	if (window.nameId == windowName) {  		ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  		vertexMatching = true;  		double wallarea = Vector.GetAreaofSurface (surface);  		if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  			Console.Write ("");  		}  		if (surface.numVertices == 4 && window.numVertices == 4) {  			makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  			//this routine is only for square windows  			double wallHeight = GetNormalQuadWallHeight (surface);  			double wallWidth = GetNormalQuadWallWidth (surface);  			double windowWidth = GetNormalQuadWindowWidth (window);  			double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  			double firstSpace = windowSpacing / 4;  			if (newWindowCounter == 1) {  				if (newCoords.Count () == 0) {  					if (window.multiplier > 1) {  						makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  						makeWindowLogFile.AppendLine ("Getting new Coordinates");  						newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  					}  					else  						newCoords = window.coordinateList;  				}  				//once I have the newCoordinates' then I should go on to change the values in the file  				//we can assume that if there are no new coords' then the old file matches the new exactly  				if (newCoords.Count > 0) {  					//make a new vertex point and append it to the line  					if (vertexCounter != newCoords.Count) {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						continue;  					}  					//it is a normal typical vertex line with a semicolon at the end (the last one)  					else {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string semicolon = ";";  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  						output.AppendLine (newVertexLine);  						//reset which should prevent the rest of the vertices from being written  						vertexMatching = false;  						detailedFenestration = false;  						newCoords.Clear ();  						vertexCounter = 1;  						if (window.multiplier > 1)  							newWindowCounter++;  						//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  						if (window.multiplier > 1) {  							output.AppendLine ("");  							while (newWindowCounter <= window.multiplier) {  								//make an entirely new window from the original window  								//make coords  								newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  								if (newCoords.Count () == 0) {  									makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  									//newWindowCounter++;  									//continue;  								}  								//now make the new window Text  								//copy the window  								int newMultiplier = 1;  								ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  								//make the window  								output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  								if (newWindowCounter == window.multiplier) {  									detailedFenestration = false;  									vertexMatching = false;  									newWindowCounter = 1;  									newCoords.Clear ();  									break;  								}  								newWindowCounter++;  							}  						}  					}  				}  				else {  					makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  					continue;  				}  			}  			else {  			}  		}  	}  	#endregion  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (windowName.Length > 0 && parentSurfaceName.Length > 0) {  	#region  	//globally change all the windows to a new window area based on the surface attached  	//get the areas  	//if(!vertexMatching) window = GetOpeningfromStringId(windowName' projectOpenings);  	if (window.nameId == windowName) {  		ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  		vertexMatching = true;  		double wallarea = Vector.GetAreaofSurface (surface);  		if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  			Console.Write ("");  		}  		if (surface.numVertices == 4 && window.numVertices == 4) {  			makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  			//this routine is only for square windows  			double wallHeight = GetNormalQuadWallHeight (surface);  			double wallWidth = GetNormalQuadWallWidth (surface);  			double windowWidth = GetNormalQuadWindowWidth (window);  			double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  			double firstSpace = windowSpacing / 4;  			if (newWindowCounter == 1) {  				if (newCoords.Count () == 0) {  					if (window.multiplier > 1) {  						makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  						makeWindowLogFile.AppendLine ("Getting new Coordinates");  						newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  					}  					else  						newCoords = window.coordinateList;  				}  				//once I have the newCoordinates' then I should go on to change the values in the file  				//we can assume that if there are no new coords' then the old file matches the new exactly  				if (newCoords.Count > 0) {  					//make a new vertex point and append it to the line  					if (vertexCounter != newCoords.Count) {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						continue;  					}  					//it is a normal typical vertex line with a semicolon at the end (the last one)  					else {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string semicolon = ";";  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  						output.AppendLine (newVertexLine);  						//reset which should prevent the rest of the vertices from being written  						vertexMatching = false;  						detailedFenestration = false;  						newCoords.Clear ();  						vertexCounter = 1;  						if (window.multiplier > 1)  							newWindowCounter++;  						//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  						if (window.multiplier > 1) {  							output.AppendLine ("");  							while (newWindowCounter <= window.multiplier) {  								//make an entirely new window from the original window  								//make coords  								newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  								if (newCoords.Count () == 0) {  									makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  									//newWindowCounter++;  									//continue;  								}  								//now make the new window Text  								//copy the window  								int newMultiplier = 1;  								ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  								//make the window  								output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  								if (newWindowCounter == window.multiplier) {  									detailedFenestration = false;  									vertexMatching = false;  									newWindowCounter = 1;  									newCoords.Clear ();  									break;  								}  								newWindowCounter++;  							}  						}  					}  				}  				else {  					makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  					continue;  				}  			}  			else {  			}  		}  	}  	#endregion  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (window.nameId == windowName) {  	ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  	vertexMatching = true;  	double wallarea = Vector.GetAreaofSurface (surface);  	if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  		Console.Write ("");  	}  	if (surface.numVertices == 4 && window.numVertices == 4) {  		makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  		//this routine is only for square windows  		double wallHeight = GetNormalQuadWallHeight (surface);  		double wallWidth = GetNormalQuadWallWidth (surface);  		double windowWidth = GetNormalQuadWindowWidth (window);  		double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  		double firstSpace = windowSpacing / 4;  		if (newWindowCounter == 1) {  			if (newCoords.Count () == 0) {  				if (window.multiplier > 1) {  					makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  					makeWindowLogFile.AppendLine ("Getting new Coordinates");  					newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  				}  				else  					newCoords = window.coordinateList;  			}  			//once I have the newCoordinates' then I should go on to change the values in the file  			//we can assume that if there are no new coords' then the old file matches the new exactly  			if (newCoords.Count > 0) {  				//make a new vertex point and append it to the line  				if (vertexCounter != newCoords.Count) {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					continue;  				}  				//it is a normal typical vertex line with a semicolon at the end (the last one)  				else {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string semicolon = ";";  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  					output.AppendLine (newVertexLine);  					//reset which should prevent the rest of the vertices from being written  					vertexMatching = false;  					detailedFenestration = false;  					newCoords.Clear ();  					vertexCounter = 1;  					if (window.multiplier > 1)  						newWindowCounter++;  					//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  					if (window.multiplier > 1) {  						output.AppendLine ("");  						while (newWindowCounter <= window.multiplier) {  							//make an entirely new window from the original window  							//make coords  							newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  							if (newCoords.Count () == 0) {  								makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  								//newWindowCounter++;  								//continue;  							}  							//now make the new window Text  							//copy the window  							int newMultiplier = 1;  							ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  							//make the window  							output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  							if (newWindowCounter == window.multiplier) {  								detailedFenestration = false;  								vertexMatching = false;  								newWindowCounter = 1;  								newCoords.Clear ();  								break;  							}  							newWindowCounter++;  						}  					}  				}  			}  			else {  				makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  				continue;  			}  		}  		else {  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (window.nameId == windowName) {  	ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  	vertexMatching = true;  	double wallarea = Vector.GetAreaofSurface (surface);  	if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  		Console.Write ("");  	}  	if (surface.numVertices == 4 && window.numVertices == 4) {  		makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  		//this routine is only for square windows  		double wallHeight = GetNormalQuadWallHeight (surface);  		double wallWidth = GetNormalQuadWallWidth (surface);  		double windowWidth = GetNormalQuadWindowWidth (window);  		double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  		double firstSpace = windowSpacing / 4;  		if (newWindowCounter == 1) {  			if (newCoords.Count () == 0) {  				if (window.multiplier > 1) {  					makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  					makeWindowLogFile.AppendLine ("Getting new Coordinates");  					newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  				}  				else  					newCoords = window.coordinateList;  			}  			//once I have the newCoordinates' then I should go on to change the values in the file  			//we can assume that if there are no new coords' then the old file matches the new exactly  			if (newCoords.Count > 0) {  				//make a new vertex point and append it to the line  				if (vertexCounter != newCoords.Count) {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					continue;  				}  				//it is a normal typical vertex line with a semicolon at the end (the last one)  				else {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string semicolon = ";";  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  					output.AppendLine (newVertexLine);  					//reset which should prevent the rest of the vertices from being written  					vertexMatching = false;  					detailedFenestration = false;  					newCoords.Clear ();  					vertexCounter = 1;  					if (window.multiplier > 1)  						newWindowCounter++;  					//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  					if (window.multiplier > 1) {  						output.AppendLine ("");  						while (newWindowCounter <= window.multiplier) {  							//make an entirely new window from the original window  							//make coords  							newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  							if (newCoords.Count () == 0) {  								makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  								//newWindowCounter++;  								//continue;  							}  							//now make the new window Text  							//copy the window  							int newMultiplier = 1;  							ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  							//make the window  							output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  							if (newWindowCounter == window.multiplier) {  								detailedFenestration = false;  								vertexMatching = false;  								newWindowCounter = 1;  								newCoords.Clear ();  								break;  							}  							newWindowCounter++;  						}  					}  				}  			}  			else {  				makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  				continue;  			}  		}  		else {  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (window.nameId == windowName) {  	ModelingUtilities.BuildingObjects.MemorySafe_Surface surface = GetParentSurface (window.parentSurfaceNameId' projectSurfaces);  	vertexMatching = true;  	double wallarea = Vector.GetAreaofSurface (surface);  	if (window.nameId == "2nd%Floor/1:02%office%N_Wall_3_0_0_0_0_0_Win") {  		Console.Write ("");  	}  	if (surface.numVertices == 4 && window.numVertices == 4) {  		makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  		//this routine is only for square windows  		double wallHeight = GetNormalQuadWallHeight (surface);  		double wallWidth = GetNormalQuadWallWidth (surface);  		double windowWidth = GetNormalQuadWindowWidth (window);  		double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  		double firstSpace = windowSpacing / 4;  		if (newWindowCounter == 1) {  			if (newCoords.Count () == 0) {  				if (window.multiplier > 1) {  					makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  					makeWindowLogFile.AppendLine ("Getting new Coordinates");  					newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  				}  				else  					newCoords = window.coordinateList;  			}  			//once I have the newCoordinates' then I should go on to change the values in the file  			//we can assume that if there are no new coords' then the old file matches the new exactly  			if (newCoords.Count > 0) {  				//make a new vertex point and append it to the line  				if (vertexCounter != newCoords.Count) {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					continue;  				}  				//it is a normal typical vertex line with a semicolon at the end (the last one)  				else {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string semicolon = ";";  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  					output.AppendLine (newVertexLine);  					//reset which should prevent the rest of the vertices from being written  					vertexMatching = false;  					detailedFenestration = false;  					newCoords.Clear ();  					vertexCounter = 1;  					if (window.multiplier > 1)  						newWindowCounter++;  					//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  					if (window.multiplier > 1) {  						output.AppendLine ("");  						while (newWindowCounter <= window.multiplier) {  							//make an entirely new window from the original window  							//make coords  							newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  							if (newCoords.Count () == 0) {  								makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  								//newWindowCounter++;  								//continue;  							}  							//now make the new window Text  							//copy the window  							int newMultiplier = 1;  							ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  							//make the window  							output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  							if (newWindowCounter == window.multiplier) {  								detailedFenestration = false;  								vertexMatching = false;  								newWindowCounter = 1;  								newCoords.Clear ();  								break;  							}  							newWindowCounter++;  						}  					}  				}  			}  			else {  				makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  				continue;  			}  		}  		else {  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (surface.numVertices == 4 && window.numVertices == 4) {  	makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  	//this routine is only for square windows  	double wallHeight = GetNormalQuadWallHeight (surface);  	double wallWidth = GetNormalQuadWallWidth (surface);  	double windowWidth = GetNormalQuadWindowWidth (window);  	double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  	double firstSpace = windowSpacing / 4;  	if (newWindowCounter == 1) {  		if (newCoords.Count () == 0) {  			if (window.multiplier > 1) {  				makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  				makeWindowLogFile.AppendLine ("Getting new Coordinates");  				newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  			}  			else  				newCoords = window.coordinateList;  		}  		//once I have the newCoordinates' then I should go on to change the values in the file  		//we can assume that if there are no new coords' then the old file matches the new exactly  		if (newCoords.Count > 0) {  			//make a new vertex point and append it to the line  			if (vertexCounter != newCoords.Count) {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				continue;  			}  			//it is a normal typical vertex line with a semicolon at the end (the last one)  			else {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string semicolon = ";";  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  				output.AppendLine (newVertexLine);  				//reset which should prevent the rest of the vertices from being written  				vertexMatching = false;  				detailedFenestration = false;  				newCoords.Clear ();  				vertexCounter = 1;  				if (window.multiplier > 1)  					newWindowCounter++;  				//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  				if (window.multiplier > 1) {  					output.AppendLine ("");  					while (newWindowCounter <= window.multiplier) {  						//make an entirely new window from the original window  						//make coords  						newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  						if (newCoords.Count () == 0) {  							makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  							//newWindowCounter++;  							//continue;  						}  						//now make the new window Text  						//copy the window  						int newMultiplier = 1;  						ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  						//make the window  						output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  						if (newWindowCounter == window.multiplier) {  							detailedFenestration = false;  							vertexMatching = false;  							newWindowCounter = 1;  							newCoords.Clear ();  							break;  						}  						newWindowCounter++;  					}  				}  			}  		}  		else {  			makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  			continue;  		}  	}  	else {  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (surface.numVertices == 4 && window.numVertices == 4) {  	makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  	//this routine is only for square windows  	double wallHeight = GetNormalQuadWallHeight (surface);  	double wallWidth = GetNormalQuadWallWidth (surface);  	double windowWidth = GetNormalQuadWindowWidth (window);  	double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  	double firstSpace = windowSpacing / 4;  	if (newWindowCounter == 1) {  		if (newCoords.Count () == 0) {  			if (window.multiplier > 1) {  				makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  				makeWindowLogFile.AppendLine ("Getting new Coordinates");  				newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  			}  			else  				newCoords = window.coordinateList;  		}  		//once I have the newCoordinates' then I should go on to change the values in the file  		//we can assume that if there are no new coords' then the old file matches the new exactly  		if (newCoords.Count > 0) {  			//make a new vertex point and append it to the line  			if (vertexCounter != newCoords.Count) {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				continue;  			}  			//it is a normal typical vertex line with a semicolon at the end (the last one)  			else {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string semicolon = ";";  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  				output.AppendLine (newVertexLine);  				//reset which should prevent the rest of the vertices from being written  				vertexMatching = false;  				detailedFenestration = false;  				newCoords.Clear ();  				vertexCounter = 1;  				if (window.multiplier > 1)  					newWindowCounter++;  				//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  				if (window.multiplier > 1) {  					output.AppendLine ("");  					while (newWindowCounter <= window.multiplier) {  						//make an entirely new window from the original window  						//make coords  						newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  						if (newCoords.Count () == 0) {  							makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  							//newWindowCounter++;  							//continue;  						}  						//now make the new window Text  						//copy the window  						int newMultiplier = 1;  						ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  						//make the window  						output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  						if (newWindowCounter == window.multiplier) {  							detailedFenestration = false;  							vertexMatching = false;  							newWindowCounter = 1;  							newCoords.Clear ();  							break;  						}  						newWindowCounter++;  					}  				}  			}  		}  		else {  			makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  			continue;  		}  	}  	else {  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakePunchedWindowFromMultiples,The following statement contains a magic number: if (surface.numVertices == 4 && window.numVertices == 4) {  	makeWindowLogFile.AppendLine ("Surface and window is normal quad..........");  	//this routine is only for square windows  	double wallHeight = GetNormalQuadWallHeight (surface);  	double wallWidth = GetNormalQuadWallWidth (surface);  	double windowWidth = GetNormalQuadWindowWidth (window);  	double windowSpacing = (wallWidth - (windowWidth * window.multiplier)) / window.multiplier;  	double firstSpace = windowSpacing / 4;  	if (newWindowCounter == 1) {  		if (newCoords.Count () == 0) {  			if (window.multiplier > 1) {  				makeWindowLogFile.AppendLine ("Window Multiplier is > 1");  				makeWindowLogFile.AppendLine ("Getting new Coordinates");  				newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  			}  			else  				newCoords = window.coordinateList;  		}  		//once I have the newCoordinates' then I should go on to change the values in the file  		//we can assume that if there are no new coords' then the old file matches the new exactly  		if (newCoords.Count > 0) {  			//make a new vertex point and append it to the line  			if (vertexCounter != newCoords.Count) {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				continue;  			}  			//it is a normal typical vertex line with a semicolon at the end (the last one)  			else {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string semicolon = ";";  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  				output.AppendLine (newVertexLine);  				//reset which should prevent the rest of the vertices from being written  				vertexMatching = false;  				detailedFenestration = false;  				newCoords.Clear ();  				vertexCounter = 1;  				if (window.multiplier > 1)  					newWindowCounter++;  				//Now that the original Window is Complete' make the new Window(s) if multiplier needs to  				if (window.multiplier > 1) {  					output.AppendLine ("");  					while (newWindowCounter <= window.multiplier) {  						//make an entirely new window from the original window  						//make coords  						newCoords = GetNewNormalQuadPunchedWindowCoordinates (surface' window' firstSpace' windowSpacing' windowWidth' newWindowCounter);  						if (newCoords.Count () == 0) {  							makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  							//newWindowCounter++;  							//continue;  						}  						//now make the new window Text  						//copy the window  						int newMultiplier = 1;  						ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions newWindow = new ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions (window' newMultiplier);  						//make the window  						output = MakePunchedWindowDuplicates (newWindow' newCoords' output' newWindowCounter);  						if (newWindowCounter == window.multiplier) {  							detailedFenestration = false;  							vertexMatching = false;  							newWindowCounter = 1;  							newCoords.Clear ();  							break;  						}  						newWindowCounter++;  					}  				}  			}  		}  		else {  			makeWindowLogFile.AppendLine ("No window was created in the idf because newCoordinates not within parent surface Bound");  			continue;  		}  	}  	else {  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.CartCoord> coordLIsts in dlWindowCoords) {  		Vector.CartVect RHRVector = new Vector.CartVect ();  		RHRVector = Vector.GetRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  		List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		viewShadeCoord.Add (viewCoord);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		viewShadeCoord.Add (viewCoord);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		dLShadeCoord.Add (dlCoord);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		dLShadeCoord.Add (dlCoord);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.CartCoord> shadingCoords in ShadeCoords) {  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.CartCoord> coordLIsts in dlWindowCoords) {  		Vector.CartVect RHRVector = new Vector.CartVect ();  		RHRVector = Vector.GetRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  		List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		viewShadeCoord.Add (viewCoord);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		viewShadeCoord.Add (viewCoord);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		dLShadeCoord.Add (dlCoord);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		dLShadeCoord.Add (dlCoord);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.CartCoord> shadingCoords in ShadeCoords) {  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.CartCoord> coordLIsts in dlWindowCoords) {  		Vector.CartVect RHRVector = new Vector.CartVect ();  		RHRVector = Vector.GetRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  		List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		viewShadeCoord.Add (viewCoord);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		viewShadeCoord.Add (viewCoord);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		dLShadeCoord.Add (dlCoord);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		dLShadeCoord.Add (dlCoord);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.CartCoord> shadingCoords in ShadeCoords) {  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.CartCoord> coordLIsts in dlWindowCoords) {  		Vector.CartVect RHRVector = new Vector.CartVect ();  		RHRVector = Vector.GetRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  		List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		viewShadeCoord.Add (viewCoord);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		viewShadeCoord.Add (viewCoord);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		dLShadeCoord.Add (dlCoord);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		dLShadeCoord.Add (dlCoord);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.CartCoord> shadingCoords in ShadeCoords) {  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.CartCoord> coordLIsts in dlWindowCoords) {  		Vector.CartVect RHRVector = new Vector.CartVect ();  		RHRVector = Vector.GetRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  		List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		viewShadeCoord.Add (viewCoord);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		viewShadeCoord.Add (viewCoord);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		dLShadeCoord.Add (dlCoord);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		dLShadeCoord.Add (dlCoord);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.CartCoord> shadingCoords in ShadeCoords) {  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.CartCoord> coordLIsts in dlWindowCoords) {  		Vector.CartVect RHRVector = new Vector.CartVect ();  		RHRVector = Vector.GetRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  		List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		viewShadeCoord.Add (viewCoord);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		viewShadeCoord.Add (viewCoord);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		dLShadeCoord.Add (dlCoord);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		dLShadeCoord.Add (dlCoord);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.CartCoord> shadingCoords in ShadeCoords) {  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.CartCoord> coordLIsts in dlWindowCoords) {  		Vector.CartVect RHRVector = new Vector.CartVect ();  		RHRVector = Vector.GetRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  		List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		viewShadeCoord.Add (viewCoord);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		viewShadeCoord.Add (viewCoord);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		dLShadeCoord.Add (dlCoord);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		dLShadeCoord.Add (dlCoord);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.CartCoord> shadingCoords in ShadeCoords) {  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.CartCoord> coordLIsts in dlWindowCoords) {  		Vector.CartVect RHRVector = new Vector.CartVect ();  		RHRVector = Vector.GetRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  		List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		viewShadeCoord.Add (viewCoord);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		viewShadeCoord.Add (viewCoord);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		dLShadeCoord.Add (dlCoord);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		dLShadeCoord.Add (dlCoord);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.CartCoord> shadingCoords in ShadeCoords) {  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.CartCoord> coordLIsts in dlWindowCoords) {  		Vector.CartVect RHRVector = new Vector.CartVect ();  		RHRVector = Vector.GetRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  		List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		viewShadeCoord.Add (viewCoord);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		viewShadeCoord.Add (viewCoord);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		dLShadeCoord.Add (dlCoord);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		dLShadeCoord.Add (dlCoord);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.CartCoord> shadingCoords in ShadeCoords) {  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  	if (coordLists.Count > 4) {  		Console.WriteLine ("");  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: if (coordLists.Count > 4) {  	Console.WriteLine ("");  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  	List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	viewShadeCoord.Add (viewCoord);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	viewShadeCoord.Add (viewCoord);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	dLShadeCoord.Add (dlCoord);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	dLShadeCoord.Add (dlCoord);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  	List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	viewShadeCoord.Add (viewCoord);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	viewShadeCoord.Add (viewCoord);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	dLShadeCoord.Add (dlCoord);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	dLShadeCoord.Add (dlCoord);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  	List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	viewShadeCoord.Add (viewCoord);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	viewShadeCoord.Add (viewCoord);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	dLShadeCoord.Add (dlCoord);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	dLShadeCoord.Add (dlCoord);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  	List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	viewShadeCoord.Add (viewCoord);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	viewShadeCoord.Add (viewCoord);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	dLShadeCoord.Add (dlCoord);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	dLShadeCoord.Add (dlCoord);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  	List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	viewShadeCoord.Add (viewCoord);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	viewShadeCoord.Add (viewCoord);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	dLShadeCoord.Add (dlCoord);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	dLShadeCoord.Add (dlCoord);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  	List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	viewShadeCoord.Add (viewCoord);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	viewShadeCoord.Add (viewCoord);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	dLShadeCoord.Add (dlCoord);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	dLShadeCoord.Add (dlCoord);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  	List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	viewShadeCoord.Add (viewCoord);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	viewShadeCoord.Add (viewCoord);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	dLShadeCoord.Add (dlCoord);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	dLShadeCoord.Add (dlCoord);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.CartCoord> viewShadeCoord = new List<Vector.CartCoord> ();  	List<Vector.CartCoord> dLShadeCoord = new List<Vector.CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	viewShadeCoord.Add (viewCoord);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	viewShadeCoord.Add (viewCoord);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	dLShadeCoord.Add (dlCoord);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	dLShadeCoord.Add (dlCoord);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.Z = coordLists [2].Z;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.Z = coordLists [3].Z;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dLShadeCoord.Add (coordLists [3]);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dLShadeCoord.Add (coordLists [2]);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.MemorySafe_CartCoord> coordLIsts in dlWindowCoords) {  		Vector.MemorySafe_CartVect RHRVector = Vector.GetMemRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord1);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord2);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord1);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord2);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  							double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  							ShadeLog.AppendLine (area.ToString ());  							for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  								Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  								string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  								string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  								ShadeLog.AppendLine (vecCoords);  								ShadeLog.AppendLine (distance);  							}  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	using (StreamWriter writer = new StreamWriter (shadeFileLoc' false)) {  		writer.Write (ShadeLog.ToString ());  	}  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.MemorySafe_CartCoord> coordLIsts in dlWindowCoords) {  		Vector.MemorySafe_CartVect RHRVector = Vector.GetMemRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord1);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord2);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord1);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord2);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  							double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  							ShadeLog.AppendLine (area.ToString ());  							for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  								Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  								string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  								string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  								ShadeLog.AppendLine (vecCoords);  								ShadeLog.AppendLine (distance);  							}  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	using (StreamWriter writer = new StreamWriter (shadeFileLoc' false)) {  		writer.Write (ShadeLog.ToString ());  	}  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.MemorySafe_CartCoord> coordLIsts in dlWindowCoords) {  		Vector.MemorySafe_CartVect RHRVector = Vector.GetMemRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord1);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord2);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord1);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord2);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  							double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  							ShadeLog.AppendLine (area.ToString ());  							for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  								Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  								string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  								string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  								ShadeLog.AppendLine (vecCoords);  								ShadeLog.AppendLine (distance);  							}  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	using (StreamWriter writer = new StreamWriter (shadeFileLoc' false)) {  		writer.Write (ShadeLog.ToString ());  	}  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.MemorySafe_CartCoord> coordLIsts in dlWindowCoords) {  		Vector.MemorySafe_CartVect RHRVector = Vector.GetMemRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord1);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord2);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord1);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord2);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  							double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  							ShadeLog.AppendLine (area.ToString ());  							for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  								Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  								string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  								string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  								ShadeLog.AppendLine (vecCoords);  								ShadeLog.AppendLine (distance);  							}  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	using (StreamWriter writer = new StreamWriter (shadeFileLoc' false)) {  		writer.Write (ShadeLog.ToString ());  	}  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.MemorySafe_CartCoord> coordLIsts in dlWindowCoords) {  		Vector.MemorySafe_CartVect RHRVector = Vector.GetMemRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord1);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord2);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord1);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord2);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  							double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  							ShadeLog.AppendLine (area.ToString ());  							for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  								Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  								string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  								string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  								ShadeLog.AppendLine (vecCoords);  								ShadeLog.AppendLine (distance);  							}  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	using (StreamWriter writer = new StreamWriter (shadeFileLoc' false)) {  		writer.Write (ShadeLog.ToString ());  	}  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.MemorySafe_CartCoord> coordLIsts in dlWindowCoords) {  		Vector.MemorySafe_CartVect RHRVector = Vector.GetMemRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord1);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord2);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord1);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord2);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  							double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  							ShadeLog.AppendLine (area.ToString ());  							for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  								Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  								string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  								string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  								ShadeLog.AppendLine (vecCoords);  								ShadeLog.AppendLine (distance);  							}  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	using (StreamWriter writer = new StreamWriter (shadeFileLoc' false)) {  		writer.Write (ShadeLog.ToString ());  	}  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.MemorySafe_CartCoord> coordLIsts in dlWindowCoords) {  		Vector.MemorySafe_CartVect RHRVector = Vector.GetMemRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord1);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord2);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord1);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord2);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  							double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  							ShadeLog.AppendLine (area.ToString ());  							for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  								Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  								string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  								string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  								ShadeLog.AppendLine (vecCoords);  								ShadeLog.AppendLine (distance);  							}  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	using (StreamWriter writer = new StreamWriter (shadeFileLoc' false)) {  		writer.Write (ShadeLog.ToString ());  	}  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.MemorySafe_CartCoord> coordLIsts in dlWindowCoords) {  		Vector.MemorySafe_CartVect RHRVector = Vector.GetMemRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord1);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord2);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord1);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord2);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  							double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  							ShadeLog.AppendLine (area.ToString ());  							for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  								Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  								string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  								string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  								ShadeLog.AppendLine (vecCoords);  								ShadeLog.AppendLine (distance);  							}  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	using (StreamWriter writer = new StreamWriter (shadeFileLoc' false)) {  		writer.Write (ShadeLog.ToString ());  	}  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.MemorySafe_CartCoord> coordLIsts in dlWindowCoords) {  		Vector.MemorySafe_CartVect RHRVector = Vector.GetMemRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord1);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord2);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord1);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord2);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  							double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  							ShadeLog.AppendLine (area.ToString ());  							for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  								Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  								string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  								string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  								ShadeLog.AppendLine (vecCoords);  								ShadeLog.AppendLine (distance);  							}  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	using (StreamWriter writer = new StreamWriter (shadeFileLoc' false)) {  		writer.Write (ShadeLog.ToString ());  	}  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.MemorySafe_CartCoord> coordLIsts in dlWindowCoords) {  		Vector.MemorySafe_CartVect RHRVector = Vector.GetMemRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord1);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord2);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord1);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord2);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  							double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  							ShadeLog.AppendLine (area.ToString ());  							for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  								Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  								string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  								string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  								ShadeLog.AppendLine (vecCoords);  								ShadeLog.AppendLine (distance);  							}  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	using (StreamWriter writer = new StreamWriter (shadeFileLoc' false)) {  		writer.Write (ShadeLog.ToString ());  	}  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: try {  	string dLRegexString = ".*(_DL)";  	Regex dLRegex = new Regex (dLRegexString);  	foreach (ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions opening in projectOpenings) {  		Match dLOpeningMatch = dLRegex.Match (opening.nameId);  		if (dLOpeningMatch.Success) {  			dlWindowCoords.Add (opening.coordinateList);  		}  	}  	//sanity check  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		if (coordLists.Count > 4) {  			Console.WriteLine ("");  		}  	}  	//make the RHR vectors  	foreach (List<Vector.MemorySafe_CartCoord> coordLIsts in dlWindowCoords) {  		Vector.MemorySafe_CartVect RHRVector = Vector.GetMemRHR (coordLIsts);  		RHRVector = Vector.UnitVector (RHRVector);  		normalVectors.Add (RHRVector);  	}  	int dlCoordListCounter = 0;  	foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  		Vector.CartCoord viewCoord = new Vector.CartCoord ();  		Vector.CartCoord dlCoord = new Vector.CartCoord ();  		List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  		double zlow = 0;  		double zHigh = 0;  		//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  		for (int i = 0; i < coordLists.Count; i++) {  			if (coordLists [i].Z < zlow)  				zlow = coordLists [i].Z;  			if (coordLists [i].Z > zHigh)  				zHigh = coordLists [i].Z;  		}  		//second pass to make the coordinates for the overhang  		//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  		//first the view shade  		viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [1].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord1);  		viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  		viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  		viewCoord.Z = coordLists [0].Z;  		Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  		viewShadeCoord.Add (viewShadeCoord2);  		viewShadeCoord.Add (coordLists [0]);  		viewShadeCoord.Add (coordLists [1]);  		ShadeCoords.Add (viewShadeCoord);  		//next the DL shade  		dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [2].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord1);  		dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  		dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  		dlCoord.Z = coordLists [3].Z;  		Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  		dLShadeCoord.Add (dlShadeCoord2);  		dLShadeCoord.Add (coordLists [3]);  		dLShadeCoord.Add (coordLists [2]);  		ShadeCoords.Add (dLShadeCoord);  		dlCoordListCounter++;  	}  	//make the new file with the appropriate overhangs.  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex frameAndDividerDescYes = new Regex (EPlusObjects.EPlusRegexString.startWindowFrameDesc);  	Regex detailedBuildingShadeYes = new Regex (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	Regex commentStartYes = new Regex (EPlusObjects.EPlusRegexString.commentStart);  	Regex semiColonYes = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool frameAndDividerStart = false;  	bool lastFrameAndDivider = false;  	bool semiColonFound = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				frameAndDividerStart = true;  				output.AppendLine (line);  				continue;  			}  			if (frameAndDividerStart) {  				Match semiColonMatch = semiColonYes.Match (line);  				if (semiColonMatch.Success) {  					semiColonFound = true;  					output.AppendLine (line);  					frameAndDividerStart = false;  					continue;  				}  				else {  					output.AppendLine (line);  					continue;  				}  			}  			if (semiColonFound) {  				detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  				if (detailedFrameAndDivideMatch.Success) {  					semiColonFound = false;  					frameAndDividerStart = true;  					output.AppendLine (line);  				}  				else if (line == "")  					output.AppendLine (line);  				else {  					semiColonFound = false;  					Match commentStartMatch = commentStartYes.Match (line);  					if (commentStartMatch.Success) {  						//dont write this line yet' insert the shading objects.  We assume it is empty  						output.AppendLine ("!- CHarriman Shading Surfaces");  						output.AppendLine ("");  						int coordSetCounter = 1;  						foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  							double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  							ShadeLog.AppendLine (area.ToString ());  							for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  								Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  								string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  								string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  								ShadeLog.AppendLine (vecCoords);  								ShadeLog.AppendLine (distance);  							}  							//write the shading device basics  							output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  							output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  							output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  							output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  							//write the coordinates  							int coordCounter = 1;  							foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  								output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  								output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  								if (coordCounter < shadingCoords.Count) {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								}  								else {  									output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  									output.AppendLine ("");  								}  								coordCounter++;  							}  							coordSetCounter++;  						}  						output.AppendLine (line);  					}  				}  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	success = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	using (StreamWriter writer = new StreamWriter (shadeFileLoc' false)) {  		writer.Write (ShadeLog.ToString ());  	}  }  catch (Exception e) {  	success = false;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  	if (coordLists.Count > 4) {  		Console.WriteLine ("");  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: if (coordLists.Count > 4) {  	Console.WriteLine ("");  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord1);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord2);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord1);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord2);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord1);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord2);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord1);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord2);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord1);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord2);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord1);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord2);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord1);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord2);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord1);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord2);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord1);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord2);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord1);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord2);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord1);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord2);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord1);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord2);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord1);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord2);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord1);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord2);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.MemorySafe_CartCoord> coordLists in dlWindowCoords) {  	Vector.CartCoord viewCoord = new Vector.CartCoord ();  	Vector.CartCoord dlCoord = new Vector.CartCoord ();  	List<Vector.MemorySafe_CartCoord> viewShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	List<Vector.MemorySafe_CartCoord> dLShadeCoord = new List<Vector.MemorySafe_CartCoord> ();  	double zlow = 0;  	double zHigh = 0;  	//find the top and bottom of the coordinates.  The top is for DL' bottom is for view  	for (int i = 0; i < coordLists.Count; i++) {  		if (coordLists [i].Z < zlow)  			zlow = coordLists [i].Z;  		if (coordLists [i].Z > zHigh)  			zHigh = coordLists [i].Z;  	}  	//second pass to make the coordinates for the overhang  	//this is a hack based on what I know about the sequence of coordinates.  This could definitely break  	//first the view shade  	viewCoord.X = coordLists [1].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [1].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [1].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord1 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord1);  	viewCoord.X = coordLists [0].X + normalVectors [dlCoordListCounter].X * viewOHDepth;  	viewCoord.Y = coordLists [0].Y + normalVectors [dlCoordListCounter].Y * viewOHDepth;  	viewCoord.Z = coordLists [0].Z;  	Vector.MemorySafe_CartCoord viewShadeCoord2 = Vector.convertToMemorySafeCoord (viewCoord);  	viewShadeCoord.Add (viewShadeCoord2);  	viewShadeCoord.Add (coordLists [0]);  	viewShadeCoord.Add (coordLists [1]);  	ShadeCoords.Add (viewShadeCoord);  	//next the DL shade  	dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [2].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord1 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord1);  	dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  	dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  	dlCoord.Z = coordLists [3].Z;  	Vector.MemorySafe_CartCoord dlShadeCoord2 = Vector.convertToMemorySafeCoord (dlCoord);  	dLShadeCoord.Add (dlShadeCoord2);  	dLShadeCoord.Add (coordLists [3]);  	dLShadeCoord.Add (coordLists [2]);  	ShadeCoords.Add (dLShadeCoord);  	dlCoordListCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.X = coordLists [2].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.Y = coordLists [2].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.Z = coordLists [2].Z;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.X = coordLists [3].X + normalVectors [dlCoordListCounter].X * dlOHDepth;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.Y = coordLists [3].Y + normalVectors [dlCoordListCounter].Y * dlOHDepth;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dlCoord.Z = coordLists [3].Z;  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dLShadeCoord.Add (coordLists [3]);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: dLShadeCoord.Add (coordLists [2]);  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: using (StreamReader reader = new StreamReader (tempFileLocation)) {  	encoding = reader.CurrentEncoding;  	//set up the surface  	while ((line = reader.ReadLine ()) != null) {  		Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  		if (detailedFrameAndDivideMatch.Success) {  			frameAndDividerStart = true;  			output.AppendLine (line);  			continue;  		}  		if (frameAndDividerStart) {  			Match semiColonMatch = semiColonYes.Match (line);  			if (semiColonMatch.Success) {  				semiColonFound = true;  				output.AppendLine (line);  				frameAndDividerStart = false;  				continue;  			}  			else {  				output.AppendLine (line);  				continue;  			}  		}  		if (semiColonFound) {  			detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				semiColonFound = false;  				frameAndDividerStart = true;  				output.AppendLine (line);  			}  			else if (line == "")  				output.AppendLine (line);  			else {  				semiColonFound = false;  				Match commentStartMatch = commentStartYes.Match (line);  				if (commentStartMatch.Success) {  					//dont write this line yet' insert the shading objects.  We assume it is empty  					output.AppendLine ("!- CHarriman Shading Surfaces");  					output.AppendLine ("");  					int coordSetCounter = 1;  					foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  						double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  						ShadeLog.AppendLine (area.ToString ());  						for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  							Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  							string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  							string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  							ShadeLog.AppendLine (vecCoords);  							ShadeLog.AppendLine (distance);  						}  						//write the shading device basics  						output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  						output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  						output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  						output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  						//write the coordinates  						int coordCounter = 1;  						foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  							output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  							output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  							if (coordCounter < shadingCoords.Count) {  								output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  							}  							else {  								output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								output.AppendLine ("");  							}  							coordCounter++;  						}  						coordSetCounter++;  					}  					output.AppendLine (line);  				}  			}  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: using (StreamReader reader = new StreamReader (tempFileLocation)) {  	encoding = reader.CurrentEncoding;  	//set up the surface  	while ((line = reader.ReadLine ()) != null) {  		Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  		if (detailedFrameAndDivideMatch.Success) {  			frameAndDividerStart = true;  			output.AppendLine (line);  			continue;  		}  		if (frameAndDividerStart) {  			Match semiColonMatch = semiColonYes.Match (line);  			if (semiColonMatch.Success) {  				semiColonFound = true;  				output.AppendLine (line);  				frameAndDividerStart = false;  				continue;  			}  			else {  				output.AppendLine (line);  				continue;  			}  		}  		if (semiColonFound) {  			detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  			if (detailedFrameAndDivideMatch.Success) {  				semiColonFound = false;  				frameAndDividerStart = true;  				output.AppendLine (line);  			}  			else if (line == "")  				output.AppendLine (line);  			else {  				semiColonFound = false;  				Match commentStartMatch = commentStartYes.Match (line);  				if (commentStartMatch.Success) {  					//dont write this line yet' insert the shading objects.  We assume it is empty  					output.AppendLine ("!- CHarriman Shading Surfaces");  					output.AppendLine ("");  					int coordSetCounter = 1;  					foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  						double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  						ShadeLog.AppendLine (area.ToString ());  						for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  							Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  							string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  							string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  							ShadeLog.AppendLine (vecCoords);  							ShadeLog.AppendLine (distance);  						}  						//write the shading device basics  						output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  						output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  						output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  						output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  						//write the coordinates  						int coordCounter = 1;  						foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  							output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  							output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  							if (coordCounter < shadingCoords.Count) {  								output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  							}  							else {  								output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  								output.AppendLine ("");  							}  							coordCounter++;  						}  						coordSetCounter++;  					}  					output.AppendLine (line);  				}  			}  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  	if (detailedFrameAndDivideMatch.Success) {  		frameAndDividerStart = true;  		output.AppendLine (line);  		continue;  	}  	if (frameAndDividerStart) {  		Match semiColonMatch = semiColonYes.Match (line);  		if (semiColonMatch.Success) {  			semiColonFound = true;  			output.AppendLine (line);  			frameAndDividerStart = false;  			continue;  		}  		else {  			output.AppendLine (line);  			continue;  		}  	}  	if (semiColonFound) {  		detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  		if (detailedFrameAndDivideMatch.Success) {  			semiColonFound = false;  			frameAndDividerStart = true;  			output.AppendLine (line);  		}  		else if (line == "")  			output.AppendLine (line);  		else {  			semiColonFound = false;  			Match commentStartMatch = commentStartYes.Match (line);  			if (commentStartMatch.Success) {  				//dont write this line yet' insert the shading objects.  We assume it is empty  				output.AppendLine ("!- CHarriman Shading Surfaces");  				output.AppendLine ("");  				int coordSetCounter = 1;  				foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  					double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  					ShadeLog.AppendLine (area.ToString ());  					for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  						Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  						string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  						string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  						ShadeLog.AppendLine (vecCoords);  						ShadeLog.AppendLine (distance);  					}  					//write the shading device basics  					output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  					output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  					output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  					output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  					//write the coordinates  					int coordCounter = 1;  					foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  						output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  						output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  						if (coordCounter < shadingCoords.Count) {  							output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  						}  						else {  							output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  							output.AppendLine ("");  						}  						coordCounter++;  					}  					coordSetCounter++;  				}  				output.AppendLine (line);  			}  		}  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	Match detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  	if (detailedFrameAndDivideMatch.Success) {  		frameAndDividerStart = true;  		output.AppendLine (line);  		continue;  	}  	if (frameAndDividerStart) {  		Match semiColonMatch = semiColonYes.Match (line);  		if (semiColonMatch.Success) {  			semiColonFound = true;  			output.AppendLine (line);  			frameAndDividerStart = false;  			continue;  		}  		else {  			output.AppendLine (line);  			continue;  		}  	}  	if (semiColonFound) {  		detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  		if (detailedFrameAndDivideMatch.Success) {  			semiColonFound = false;  			frameAndDividerStart = true;  			output.AppendLine (line);  		}  		else if (line == "")  			output.AppendLine (line);  		else {  			semiColonFound = false;  			Match commentStartMatch = commentStartYes.Match (line);  			if (commentStartMatch.Success) {  				//dont write this line yet' insert the shading objects.  We assume it is empty  				output.AppendLine ("!- CHarriman Shading Surfaces");  				output.AppendLine ("");  				int coordSetCounter = 1;  				foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  					double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  					ShadeLog.AppendLine (area.ToString ());  					for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  						Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  						string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  						string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  						ShadeLog.AppendLine (vecCoords);  						ShadeLog.AppendLine (distance);  					}  					//write the shading device basics  					output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  					output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  					output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  					output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  					//write the coordinates  					int coordCounter = 1;  					foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  						output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  						output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  						if (coordCounter < shadingCoords.Count) {  							output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  						}  						else {  							output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  							output.AppendLine ("");  						}  						coordCounter++;  					}  					coordSetCounter++;  				}  				output.AppendLine (line);  			}  		}  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: if (semiColonFound) {  	detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  	if (detailedFrameAndDivideMatch.Success) {  		semiColonFound = false;  		frameAndDividerStart = true;  		output.AppendLine (line);  	}  	else if (line == "")  		output.AppendLine (line);  	else {  		semiColonFound = false;  		Match commentStartMatch = commentStartYes.Match (line);  		if (commentStartMatch.Success) {  			//dont write this line yet' insert the shading objects.  We assume it is empty  			output.AppendLine ("!- CHarriman Shading Surfaces");  			output.AppendLine ("");  			int coordSetCounter = 1;  			foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  				double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  				ShadeLog.AppendLine (area.ToString ());  				for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  					Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  					string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  					string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  					ShadeLog.AppendLine (vecCoords);  					ShadeLog.AppendLine (distance);  				}  				//write the shading device basics  				output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  				output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  				output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  				output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  				//write the coordinates  				int coordCounter = 1;  				foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  					output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  					output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  					if (coordCounter < shadingCoords.Count) {  						output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  					}  					else {  						output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  						output.AppendLine ("");  					}  					coordCounter++;  				}  				coordSetCounter++;  			}  			output.AppendLine (line);  		}  	}  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: if (semiColonFound) {  	detailedFrameAndDivideMatch = frameAndDividerDescYes.Match (line);  	if (detailedFrameAndDivideMatch.Success) {  		semiColonFound = false;  		frameAndDividerStart = true;  		output.AppendLine (line);  	}  	else if (line == "")  		output.AppendLine (line);  	else {  		semiColonFound = false;  		Match commentStartMatch = commentStartYes.Match (line);  		if (commentStartMatch.Success) {  			//dont write this line yet' insert the shading objects.  We assume it is empty  			output.AppendLine ("!- CHarriman Shading Surfaces");  			output.AppendLine ("");  			int coordSetCounter = 1;  			foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  				double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  				ShadeLog.AppendLine (area.ToString ());  				for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  					Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  					string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  					string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  					ShadeLog.AppendLine (vecCoords);  					ShadeLog.AppendLine (distance);  				}  				//write the shading device basics  				output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  				output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  				output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  				output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  				//write the coordinates  				int coordCounter = 1;  				foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  					output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  					output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  					if (coordCounter < shadingCoords.Count) {  						output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  					}  					else {  						output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  						output.AppendLine ("");  					}  					coordCounter++;  				}  				coordSetCounter++;  			}  			output.AppendLine (line);  		}  	}  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: if (detailedFrameAndDivideMatch.Success) {  	semiColonFound = false;  	frameAndDividerStart = true;  	output.AppendLine (line);  }  else if (line == "")  	output.AppendLine (line);  else {  	semiColonFound = false;  	Match commentStartMatch = commentStartYes.Match (line);  	if (commentStartMatch.Success) {  		//dont write this line yet' insert the shading objects.  We assume it is empty  		output.AppendLine ("!- CHarriman Shading Surfaces");  		output.AppendLine ("");  		int coordSetCounter = 1;  		foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  			double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  			ShadeLog.AppendLine (area.ToString ());  			for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  				Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  				string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  				string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  				ShadeLog.AppendLine (vecCoords);  				ShadeLog.AppendLine (distance);  			}  			//write the shading device basics  			output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  			output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  			output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  			output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  			//write the coordinates  			int coordCounter = 1;  			foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  				output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  				output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  				if (coordCounter < shadingCoords.Count) {  					output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  				}  				else {  					output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  					output.AppendLine ("");  				}  				coordCounter++;  			}  			coordSetCounter++;  		}  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: if (detailedFrameAndDivideMatch.Success) {  	semiColonFound = false;  	frameAndDividerStart = true;  	output.AppendLine (line);  }  else if (line == "")  	output.AppendLine (line);  else {  	semiColonFound = false;  	Match commentStartMatch = commentStartYes.Match (line);  	if (commentStartMatch.Success) {  		//dont write this line yet' insert the shading objects.  We assume it is empty  		output.AppendLine ("!- CHarriman Shading Surfaces");  		output.AppendLine ("");  		int coordSetCounter = 1;  		foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  			double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  			ShadeLog.AppendLine (area.ToString ());  			for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  				Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  				string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  				string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  				ShadeLog.AppendLine (vecCoords);  				ShadeLog.AppendLine (distance);  			}  			//write the shading device basics  			output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  			output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  			output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  			output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  			//write the coordinates  			int coordCounter = 1;  			foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  				output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  				output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  				if (coordCounter < shadingCoords.Count) {  					output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  				}  				else {  					output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  					output.AppendLine ("");  				}  				coordCounter++;  			}  			coordSetCounter++;  		}  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: if (line == "")  	output.AppendLine (line);  else {  	semiColonFound = false;  	Match commentStartMatch = commentStartYes.Match (line);  	if (commentStartMatch.Success) {  		//dont write this line yet' insert the shading objects.  We assume it is empty  		output.AppendLine ("!- CHarriman Shading Surfaces");  		output.AppendLine ("");  		int coordSetCounter = 1;  		foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  			double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  			ShadeLog.AppendLine (area.ToString ());  			for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  				Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  				string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  				string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  				ShadeLog.AppendLine (vecCoords);  				ShadeLog.AppendLine (distance);  			}  			//write the shading device basics  			output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  			output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  			output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  			output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  			//write the coordinates  			int coordCounter = 1;  			foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  				output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  				output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  				if (coordCounter < shadingCoords.Count) {  					output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  				}  				else {  					output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  					output.AppendLine ("");  				}  				coordCounter++;  			}  			coordSetCounter++;  		}  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: if (line == "")  	output.AppendLine (line);  else {  	semiColonFound = false;  	Match commentStartMatch = commentStartYes.Match (line);  	if (commentStartMatch.Success) {  		//dont write this line yet' insert the shading objects.  We assume it is empty  		output.AppendLine ("!- CHarriman Shading Surfaces");  		output.AppendLine ("");  		int coordSetCounter = 1;  		foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  			double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  			ShadeLog.AppendLine (area.ToString ());  			for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  				Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  				string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  				string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  				ShadeLog.AppendLine (vecCoords);  				ShadeLog.AppendLine (distance);  			}  			//write the shading device basics  			output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  			output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  			output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  			output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  			//write the coordinates  			int coordCounter = 1;  			foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  				output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  				output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  				if (coordCounter < shadingCoords.Count) {  					output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  				}  				else {  					output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  					output.AppendLine ("");  				}  				coordCounter++;  			}  			coordSetCounter++;  		}  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: if (commentStartMatch.Success) {  	//dont write this line yet' insert the shading objects.  We assume it is empty  	output.AppendLine ("!- CHarriman Shading Surfaces");  	output.AppendLine ("");  	int coordSetCounter = 1;  	foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  		double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  		ShadeLog.AppendLine (area.ToString ());  		for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  			Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  			string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  			string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  			ShadeLog.AppendLine (vecCoords);  			ShadeLog.AppendLine (distance);  		}  		//write the shading device basics  		output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  		output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  		output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  		output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  		//write the coordinates  		int coordCounter = 1;  		foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  			output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  			output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  			if (coordCounter < shadingCoords.Count) {  				output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  			}  			else {  				output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  				output.AppendLine ("");  			}  			coordCounter++;  		}  		coordSetCounter++;  	}  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: if (commentStartMatch.Success) {  	//dont write this line yet' insert the shading objects.  We assume it is empty  	output.AppendLine ("!- CHarriman Shading Surfaces");  	output.AppendLine ("");  	int coordSetCounter = 1;  	foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  		double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  		ShadeLog.AppendLine (area.ToString ());  		for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  			Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  			string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  			string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  			ShadeLog.AppendLine (vecCoords);  			ShadeLog.AppendLine (distance);  		}  		//write the shading device basics  		output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  		output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  		output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  		output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  		//write the coordinates  		int coordCounter = 1;  		foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  			output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  			output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  			if (coordCounter < shadingCoords.Count) {  				output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  			}  			else {  				output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  				output.AppendLine ("");  			}  			coordCounter++;  		}  		coordSetCounter++;  	}  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  	double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  	ShadeLog.AppendLine (area.ToString ());  	for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  		Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  		string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  		string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  		ShadeLog.AppendLine (vecCoords);  		ShadeLog.AppendLine (distance);  	}  	//write the shading device basics  	output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  	output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  	output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  	//write the coordinates  	int coordCounter = 1;  	foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  		output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  		output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  		if (coordCounter < shadingCoords.Count) {  			output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  		}  		else {  			output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  			output.AppendLine ("");  		}  		coordCounter++;  	}  	coordSetCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: foreach (List<Vector.MemorySafe_CartCoord> shadingCoords in ShadeCoords) {  	double area = Vector.GetAreaFrom2DPolyLoop (shadingCoords);  	ShadeLog.AppendLine (area.ToString ());  	for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  		Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  		string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  		string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  		ShadeLog.AppendLine (vecCoords);  		ShadeLog.AppendLine (distance);  	}  	//write the shading device basics  	output.AppendLine (EPlusObjects.EPlusRegexString.startDetailedBuildingShade);  	output.AppendLine ("     Shade-" + coordSetCounter.ToString () + "'    !-Name");  	output.AppendLine ("    Transmittance schedule for Extrnl Shades'   !- Transmittance Schedule Name");  	output.AppendLine ("    " + shadingCoords.Count.ToString () + "'    !- Number of Vertices");  	//write the coordinates  	int coordCounter = 1;  	foreach (Vector.MemorySafe_CartCoord shadingCoord in shadingCoords) {  		output.AppendLine ("     " + shadingCoord.X.ToString () + "'          !- Vertex " + coordCounter.ToString () + " X-Coordinate {m}");  		output.AppendLine ("     " + shadingCoord.Y.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Y-Coordinate {m}");  		if (coordCounter < shadingCoords.Count) {  			output.AppendLine ("     " + shadingCoord.Z.ToString () + "'          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  		}  		else {  			output.AppendLine ("     " + shadingCoord.Z.ToString () + ";          !- Vertex " + coordCounter.ToString () + " Z-Coordinate {m}");  			output.AppendLine ("");  		}  		coordCounter++;  	}  	coordSetCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  	Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  	string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  	string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  	ShadeLog.AppendLine (vecCoords);  	ShadeLog.AppendLine (distance);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,MakeSouthOverhangs,The following statement contains a magic number: for (int i = 0; i < (shadingCoords.Count () - 1); i++) {  	Vector.MemorySafe_CartVect vector = Vector.CreateMemorySafe_Vector (shadingCoords [i]' shadingCoords [i + 1]);  	string vecCoords = vector.X.ToString () + ''' + vector.Y.ToString () + ''' + vector.Z.ToString ();  	string distance = (Math.Sqrt (Math.Pow (vector.X' 2) + Math.Pow (vector.Y' 2))).ToString ();  	ShadeLog.AppendLine (vecCoords);  	ShadeLog.AppendLine (distance);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: try {  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex detailedSurfaceYes = new Regex (EPlusObjects.EPlusRegexString.startSurface);  	Regex detailedFenestrationYes = new Regex (EPlusObjects.EPlusRegexString.startFenestration);  	Regex detailedObjectNameRegex = new Regex (EPlusObjects.EPlusRegexString.Name);  	Regex constructionNameRegex = new Regex (EPlusObjects.EPlusRegexString.constructionName);  	Regex typicalVertexRegex = new Regex (EPlusObjects.EPlusRegexString.typicalVertex);  	Regex semiColonRegex = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool detailedFenestrationbool = false;  	bool isSouth = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  			if (detailedFenestrationMatch.Success) {  				detailedFenestrationbool = true;  				output.AppendLine (line);  				continue;  			}  			if (detailedFenestrationbool) {  				#region  				//match name  				Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  				//once I get a match' set up a bunch of the variables that I will need   				string currentOpeningName = "";  				if (fenestrationNameMatch.Success) {  					#region  					//tease out the name using purify  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  					if (pure.Success) {  						currentOpeningName = pure.Groups ["goods"].Value;  					}  					//I do not know which orientation this is facing yet' but I can use the objects to figure it out  					#endregion  				}  				ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  				isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  				ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  				//this essentially tells the loop to go back into its normal cycle  				if (!isSouth) {  					detailedFenestrationbool = false;  				}  				//My next match is the coordinates' since the rest I should be able to skip at this point  				Match typicalVertexMatch = typicalVertexRegex.Match (line);  				if (typicalVertexMatch.Success) {  					//if a south window' then make these changes  					if (isSouth) {  						#region  						//only use this for quad windows and only capture when starting (vertexCounter == 1)  						if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  							//these functions work well for square walls  							wallHeight = GetNormalQuadWallHeight (parentSurface);  							//these variables could be stored by the computer  							//.2140 is the wwr of the daylight window  							dlHeight = wallHeight * dlWWR;  							//.209 is the wwr of the vision window  							visionHeight = wallHeight * visionWWR;  							//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  							//makes a new window based on   							newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  						}  						if (newCoords.Count > 0) {  							//make a new vertex point and append it to the line  							//do a check for the semicolon now because this changes the type of exchange that we make  							Match semicolonMatch = semiColonRegex.Match (line);  							if (semicolonMatch.Success) {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string semicolon = ";";  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  								output.AppendLine (newVertexLine);  								//ok' this window is done' so we are now going to make another one  								//that will sit right above it' in the same window...  								//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  								output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  								//reset  								detailedFenestrationbool = false;  								vertexCounter = 1;  								newCoords.Clear ();  								isSouth = false;  								continue;  							}  							//it is a normal typical vertex line  							else {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  								output.AppendLine (newVertexLine);  								vertexCounter++;  								continue;  							}  						}  						#endregion  					}  				}  				#endregion  				//in the case where I do not find a match but I am in detailedFenestration mode  				//not a vertex match  				//vertex match but not a southern window  				output.AppendLine (line);  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	successful = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	return successful;  }  catch (Exception e) {  	return successful;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: try {  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex detailedSurfaceYes = new Regex (EPlusObjects.EPlusRegexString.startSurface);  	Regex detailedFenestrationYes = new Regex (EPlusObjects.EPlusRegexString.startFenestration);  	Regex detailedObjectNameRegex = new Regex (EPlusObjects.EPlusRegexString.Name);  	Regex constructionNameRegex = new Regex (EPlusObjects.EPlusRegexString.constructionName);  	Regex typicalVertexRegex = new Regex (EPlusObjects.EPlusRegexString.typicalVertex);  	Regex semiColonRegex = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool detailedFenestrationbool = false;  	bool isSouth = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  			if (detailedFenestrationMatch.Success) {  				detailedFenestrationbool = true;  				output.AppendLine (line);  				continue;  			}  			if (detailedFenestrationbool) {  				#region  				//match name  				Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  				//once I get a match' set up a bunch of the variables that I will need   				string currentOpeningName = "";  				if (fenestrationNameMatch.Success) {  					#region  					//tease out the name using purify  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  					if (pure.Success) {  						currentOpeningName = pure.Groups ["goods"].Value;  					}  					//I do not know which orientation this is facing yet' but I can use the objects to figure it out  					#endregion  				}  				ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  				isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  				ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  				//this essentially tells the loop to go back into its normal cycle  				if (!isSouth) {  					detailedFenestrationbool = false;  				}  				//My next match is the coordinates' since the rest I should be able to skip at this point  				Match typicalVertexMatch = typicalVertexRegex.Match (line);  				if (typicalVertexMatch.Success) {  					//if a south window' then make these changes  					if (isSouth) {  						#region  						//only use this for quad windows and only capture when starting (vertexCounter == 1)  						if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  							//these functions work well for square walls  							wallHeight = GetNormalQuadWallHeight (parentSurface);  							//these variables could be stored by the computer  							//.2140 is the wwr of the daylight window  							dlHeight = wallHeight * dlWWR;  							//.209 is the wwr of the vision window  							visionHeight = wallHeight * visionWWR;  							//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  							//makes a new window based on   							newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  						}  						if (newCoords.Count > 0) {  							//make a new vertex point and append it to the line  							//do a check for the semicolon now because this changes the type of exchange that we make  							Match semicolonMatch = semiColonRegex.Match (line);  							if (semicolonMatch.Success) {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string semicolon = ";";  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  								output.AppendLine (newVertexLine);  								//ok' this window is done' so we are now going to make another one  								//that will sit right above it' in the same window...  								//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  								output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  								//reset  								detailedFenestrationbool = false;  								vertexCounter = 1;  								newCoords.Clear ();  								isSouth = false;  								continue;  							}  							//it is a normal typical vertex line  							else {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  								output.AppendLine (newVertexLine);  								vertexCounter++;  								continue;  							}  						}  						#endregion  					}  				}  				#endregion  				//in the case where I do not find a match but I am in detailedFenestration mode  				//not a vertex match  				//vertex match but not a southern window  				output.AppendLine (line);  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	successful = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	return successful;  }  catch (Exception e) {  	return successful;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: using (StreamReader reader = new StreamReader (tempFileLocation)) {  	encoding = reader.CurrentEncoding;  	//set up the surface  	while ((line = reader.ReadLine ()) != null) {  		Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  		if (detailedFenestrationMatch.Success) {  			detailedFenestrationbool = true;  			output.AppendLine (line);  			continue;  		}  		if (detailedFenestrationbool) {  			#region  			//match name  			Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  			//once I get a match' set up a bunch of the variables that I will need   			string currentOpeningName = "";  			if (fenestrationNameMatch.Success) {  				#region  				//tease out the name using purify  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					currentOpeningName = pure.Groups ["goods"].Value;  				}  				//I do not know which orientation this is facing yet' but I can use the objects to figure it out  				#endregion  			}  			ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  			isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  			ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  			//this essentially tells the loop to go back into its normal cycle  			if (!isSouth) {  				detailedFenestrationbool = false;  			}  			//My next match is the coordinates' since the rest I should be able to skip at this point  			Match typicalVertexMatch = typicalVertexRegex.Match (line);  			if (typicalVertexMatch.Success) {  				//if a south window' then make these changes  				if (isSouth) {  					#region  					//only use this for quad windows and only capture when starting (vertexCounter == 1)  					if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  						//these functions work well for square walls  						wallHeight = GetNormalQuadWallHeight (parentSurface);  						//these variables could be stored by the computer  						//.2140 is the wwr of the daylight window  						dlHeight = wallHeight * dlWWR;  						//.209 is the wwr of the vision window  						visionHeight = wallHeight * visionWWR;  						//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  						//makes a new window based on   						newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  					}  					if (newCoords.Count > 0) {  						//make a new vertex point and append it to the line  						//do a check for the semicolon now because this changes the type of exchange that we make  						Match semicolonMatch = semiColonRegex.Match (line);  						if (semicolonMatch.Success) {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string semicolon = ";";  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  							output.AppendLine (newVertexLine);  							//ok' this window is done' so we are now going to make another one  							//that will sit right above it' in the same window...  							//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  							output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  							//reset  							detailedFenestrationbool = false;  							vertexCounter = 1;  							newCoords.Clear ();  							isSouth = false;  							continue;  						}  						//it is a normal typical vertex line  						else {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							continue;  						}  					}  					#endregion  				}  			}  			#endregion  			//in the case where I do not find a match but I am in detailedFenestration mode  			//not a vertex match  			//vertex match but not a southern window  			output.AppendLine (line);  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: using (StreamReader reader = new StreamReader (tempFileLocation)) {  	encoding = reader.CurrentEncoding;  	//set up the surface  	while ((line = reader.ReadLine ()) != null) {  		Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  		if (detailedFenestrationMatch.Success) {  			detailedFenestrationbool = true;  			output.AppendLine (line);  			continue;  		}  		if (detailedFenestrationbool) {  			#region  			//match name  			Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  			//once I get a match' set up a bunch of the variables that I will need   			string currentOpeningName = "";  			if (fenestrationNameMatch.Success) {  				#region  				//tease out the name using purify  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					currentOpeningName = pure.Groups ["goods"].Value;  				}  				//I do not know which orientation this is facing yet' but I can use the objects to figure it out  				#endregion  			}  			ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  			isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  			ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  			//this essentially tells the loop to go back into its normal cycle  			if (!isSouth) {  				detailedFenestrationbool = false;  			}  			//My next match is the coordinates' since the rest I should be able to skip at this point  			Match typicalVertexMatch = typicalVertexRegex.Match (line);  			if (typicalVertexMatch.Success) {  				//if a south window' then make these changes  				if (isSouth) {  					#region  					//only use this for quad windows and only capture when starting (vertexCounter == 1)  					if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  						//these functions work well for square walls  						wallHeight = GetNormalQuadWallHeight (parentSurface);  						//these variables could be stored by the computer  						//.2140 is the wwr of the daylight window  						dlHeight = wallHeight * dlWWR;  						//.209 is the wwr of the vision window  						visionHeight = wallHeight * visionWWR;  						//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  						//makes a new window based on   						newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  					}  					if (newCoords.Count > 0) {  						//make a new vertex point and append it to the line  						//do a check for the semicolon now because this changes the type of exchange that we make  						Match semicolonMatch = semiColonRegex.Match (line);  						if (semicolonMatch.Success) {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string semicolon = ";";  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  							output.AppendLine (newVertexLine);  							//ok' this window is done' so we are now going to make another one  							//that will sit right above it' in the same window...  							//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  							output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  							//reset  							detailedFenestrationbool = false;  							vertexCounter = 1;  							newCoords.Clear ();  							isSouth = false;  							continue;  						}  						//it is a normal typical vertex line  						else {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							continue;  						}  					}  					#endregion  				}  			}  			#endregion  			//in the case where I do not find a match but I am in detailedFenestration mode  			//not a vertex match  			//vertex match but not a southern window  			output.AppendLine (line);  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  	if (detailedFenestrationMatch.Success) {  		detailedFenestrationbool = true;  		output.AppendLine (line);  		continue;  	}  	if (detailedFenestrationbool) {  		#region  		//match name  		Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  		//once I get a match' set up a bunch of the variables that I will need   		string currentOpeningName = "";  		if (fenestrationNameMatch.Success) {  			#region  			//tease out the name using purify  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentOpeningName = pure.Groups ["goods"].Value;  			}  			//I do not know which orientation this is facing yet' but I can use the objects to figure it out  			#endregion  		}  		ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  		isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  		ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  		//this essentially tells the loop to go back into its normal cycle  		if (!isSouth) {  			detailedFenestrationbool = false;  		}  		//My next match is the coordinates' since the rest I should be able to skip at this point  		Match typicalVertexMatch = typicalVertexRegex.Match (line);  		if (typicalVertexMatch.Success) {  			//if a south window' then make these changes  			if (isSouth) {  				#region  				//only use this for quad windows and only capture when starting (vertexCounter == 1)  				if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  					//these functions work well for square walls  					wallHeight = GetNormalQuadWallHeight (parentSurface);  					//these variables could be stored by the computer  					//.2140 is the wwr of the daylight window  					dlHeight = wallHeight * dlWWR;  					//.209 is the wwr of the vision window  					visionHeight = wallHeight * visionWWR;  					//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  					//makes a new window based on   					newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  				}  				if (newCoords.Count > 0) {  					//make a new vertex point and append it to the line  					//do a check for the semicolon now because this changes the type of exchange that we make  					Match semicolonMatch = semiColonRegex.Match (line);  					if (semicolonMatch.Success) {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string semicolon = ";";  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  						output.AppendLine (newVertexLine);  						//ok' this window is done' so we are now going to make another one  						//that will sit right above it' in the same window...  						//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  						output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  						//reset  						detailedFenestrationbool = false;  						vertexCounter = 1;  						newCoords.Clear ();  						isSouth = false;  						continue;  					}  					//it is a normal typical vertex line  					else {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						continue;  					}  				}  				#endregion  			}  		}  		#endregion  		//in the case where I do not find a match but I am in detailedFenestration mode  		//not a vertex match  		//vertex match but not a southern window  		output.AppendLine (line);  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  	if (detailedFenestrationMatch.Success) {  		detailedFenestrationbool = true;  		output.AppendLine (line);  		continue;  	}  	if (detailedFenestrationbool) {  		#region  		//match name  		Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  		//once I get a match' set up a bunch of the variables that I will need   		string currentOpeningName = "";  		if (fenestrationNameMatch.Success) {  			#region  			//tease out the name using purify  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentOpeningName = pure.Groups ["goods"].Value;  			}  			//I do not know which orientation this is facing yet' but I can use the objects to figure it out  			#endregion  		}  		ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  		isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  		ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  		//this essentially tells the loop to go back into its normal cycle  		if (!isSouth) {  			detailedFenestrationbool = false;  		}  		//My next match is the coordinates' since the rest I should be able to skip at this point  		Match typicalVertexMatch = typicalVertexRegex.Match (line);  		if (typicalVertexMatch.Success) {  			//if a south window' then make these changes  			if (isSouth) {  				#region  				//only use this for quad windows and only capture when starting (vertexCounter == 1)  				if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  					//these functions work well for square walls  					wallHeight = GetNormalQuadWallHeight (parentSurface);  					//these variables could be stored by the computer  					//.2140 is the wwr of the daylight window  					dlHeight = wallHeight * dlWWR;  					//.209 is the wwr of the vision window  					visionHeight = wallHeight * visionWWR;  					//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  					//makes a new window based on   					newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  				}  				if (newCoords.Count > 0) {  					//make a new vertex point and append it to the line  					//do a check for the semicolon now because this changes the type of exchange that we make  					Match semicolonMatch = semiColonRegex.Match (line);  					if (semicolonMatch.Success) {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string semicolon = ";";  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  						output.AppendLine (newVertexLine);  						//ok' this window is done' so we are now going to make another one  						//that will sit right above it' in the same window...  						//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  						output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  						//reset  						detailedFenestrationbool = false;  						vertexCounter = 1;  						newCoords.Clear ();  						isSouth = false;  						continue;  					}  					//it is a normal typical vertex line  					else {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						continue;  					}  				}  				#endregion  			}  		}  		#endregion  		//in the case where I do not find a match but I am in detailedFenestration mode  		//not a vertex match  		//vertex match but not a southern window  		output.AppendLine (line);  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: if (detailedFenestrationbool) {  	#region  	//match name  	Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  	//once I get a match' set up a bunch of the variables that I will need   	string currentOpeningName = "";  	if (fenestrationNameMatch.Success) {  		#region  		//tease out the name using purify  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentOpeningName = pure.Groups ["goods"].Value;  		}  		//I do not know which orientation this is facing yet' but I can use the objects to figure it out  		#endregion  	}  	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  	isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  	ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  	//this essentially tells the loop to go back into its normal cycle  	if (!isSouth) {  		detailedFenestrationbool = false;  	}  	//My next match is the coordinates' since the rest I should be able to skip at this point  	Match typicalVertexMatch = typicalVertexRegex.Match (line);  	if (typicalVertexMatch.Success) {  		//if a south window' then make these changes  		if (isSouth) {  			#region  			//only use this for quad windows and only capture when starting (vertexCounter == 1)  			if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  				//these functions work well for square walls  				wallHeight = GetNormalQuadWallHeight (parentSurface);  				//these variables could be stored by the computer  				//.2140 is the wwr of the daylight window  				dlHeight = wallHeight * dlWWR;  				//.209 is the wwr of the vision window  				visionHeight = wallHeight * visionWWR;  				//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  				//makes a new window based on   				newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  			}  			if (newCoords.Count > 0) {  				//make a new vertex point and append it to the line  				//do a check for the semicolon now because this changes the type of exchange that we make  				Match semicolonMatch = semiColonRegex.Match (line);  				if (semicolonMatch.Success) {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string semicolon = ";";  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  					output.AppendLine (newVertexLine);  					//ok' this window is done' so we are now going to make another one  					//that will sit right above it' in the same window...  					//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  					output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  					//reset  					detailedFenestrationbool = false;  					vertexCounter = 1;  					newCoords.Clear ();  					isSouth = false;  					continue;  				}  				//it is a normal typical vertex line  				else {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					continue;  				}  			}  			#endregion  		}  	}  	#endregion  	//in the case where I do not find a match but I am in detailedFenestration mode  	//not a vertex match  	//vertex match but not a southern window  	output.AppendLine (line);  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: if (detailedFenestrationbool) {  	#region  	//match name  	Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  	//once I get a match' set up a bunch of the variables that I will need   	string currentOpeningName = "";  	if (fenestrationNameMatch.Success) {  		#region  		//tease out the name using purify  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentOpeningName = pure.Groups ["goods"].Value;  		}  		//I do not know which orientation this is facing yet' but I can use the objects to figure it out  		#endregion  	}  	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  	isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  	ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  	//this essentially tells the loop to go back into its normal cycle  	if (!isSouth) {  		detailedFenestrationbool = false;  	}  	//My next match is the coordinates' since the rest I should be able to skip at this point  	Match typicalVertexMatch = typicalVertexRegex.Match (line);  	if (typicalVertexMatch.Success) {  		//if a south window' then make these changes  		if (isSouth) {  			#region  			//only use this for quad windows and only capture when starting (vertexCounter == 1)  			if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  				//these functions work well for square walls  				wallHeight = GetNormalQuadWallHeight (parentSurface);  				//these variables could be stored by the computer  				//.2140 is the wwr of the daylight window  				dlHeight = wallHeight * dlWWR;  				//.209 is the wwr of the vision window  				visionHeight = wallHeight * visionWWR;  				//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  				//makes a new window based on   				newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  			}  			if (newCoords.Count > 0) {  				//make a new vertex point and append it to the line  				//do a check for the semicolon now because this changes the type of exchange that we make  				Match semicolonMatch = semiColonRegex.Match (line);  				if (semicolonMatch.Success) {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string semicolon = ";";  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  					output.AppendLine (newVertexLine);  					//ok' this window is done' so we are now going to make another one  					//that will sit right above it' in the same window...  					//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  					output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  					//reset  					detailedFenestrationbool = false;  					vertexCounter = 1;  					newCoords.Clear ();  					isSouth = false;  					continue;  				}  				//it is a normal typical vertex line  				else {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					continue;  				}  			}  			#endregion  		}  	}  	#endregion  	//in the case where I do not find a match but I am in detailedFenestration mode  	//not a vertex match  	//vertex match but not a southern window  	output.AppendLine (line);  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: if (typicalVertexMatch.Success) {  	//if a south window' then make these changes  	if (isSouth) {  		#region  		//only use this for quad windows and only capture when starting (vertexCounter == 1)  		if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  			//these functions work well for square walls  			wallHeight = GetNormalQuadWallHeight (parentSurface);  			//these variables could be stored by the computer  			//.2140 is the wwr of the daylight window  			dlHeight = wallHeight * dlWWR;  			//.209 is the wwr of the vision window  			visionHeight = wallHeight * visionWWR;  			//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  			//makes a new window based on   			newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  		}  		if (newCoords.Count > 0) {  			//make a new vertex point and append it to the line  			//do a check for the semicolon now because this changes the type of exchange that we make  			Match semicolonMatch = semiColonRegex.Match (line);  			if (semicolonMatch.Success) {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string semicolon = ";";  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  				output.AppendLine (newVertexLine);  				//ok' this window is done' so we are now going to make another one  				//that will sit right above it' in the same window...  				//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  				output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  				//reset  				detailedFenestrationbool = false;  				vertexCounter = 1;  				newCoords.Clear ();  				isSouth = false;  				continue;  			}  			//it is a normal typical vertex line  			else {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				continue;  			}  		}  		#endregion  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: if (typicalVertexMatch.Success) {  	//if a south window' then make these changes  	if (isSouth) {  		#region  		//only use this for quad windows and only capture when starting (vertexCounter == 1)  		if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  			//these functions work well for square walls  			wallHeight = GetNormalQuadWallHeight (parentSurface);  			//these variables could be stored by the computer  			//.2140 is the wwr of the daylight window  			dlHeight = wallHeight * dlWWR;  			//.209 is the wwr of the vision window  			visionHeight = wallHeight * visionWWR;  			//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  			//makes a new window based on   			newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  		}  		if (newCoords.Count > 0) {  			//make a new vertex point and append it to the line  			//do a check for the semicolon now because this changes the type of exchange that we make  			Match semicolonMatch = semiColonRegex.Match (line);  			if (semicolonMatch.Success) {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string semicolon = ";";  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  				output.AppendLine (newVertexLine);  				//ok' this window is done' so we are now going to make another one  				//that will sit right above it' in the same window...  				//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  				output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  				//reset  				detailedFenestrationbool = false;  				vertexCounter = 1;  				newCoords.Clear ();  				isSouth = false;  				continue;  			}  			//it is a normal typical vertex line  			else {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				continue;  			}  		}  		#endregion  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: if (isSouth) {  	#region  	//only use this for quad windows and only capture when starting (vertexCounter == 1)  	if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  		//these functions work well for square walls  		wallHeight = GetNormalQuadWallHeight (parentSurface);  		//these variables could be stored by the computer  		//.2140 is the wwr of the daylight window  		dlHeight = wallHeight * dlWWR;  		//.209 is the wwr of the vision window  		visionHeight = wallHeight * visionWWR;  		//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  		//makes a new window based on   		newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  	}  	if (newCoords.Count > 0) {  		//make a new vertex point and append it to the line  		//do a check for the semicolon now because this changes the type of exchange that we make  		Match semicolonMatch = semiColonRegex.Match (line);  		if (semicolonMatch.Success) {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string semicolon = ";";  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  			output.AppendLine (newVertexLine);  			//ok' this window is done' so we are now going to make another one  			//that will sit right above it' in the same window...  			//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  			output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  			//reset  			detailedFenestrationbool = false;  			vertexCounter = 1;  			newCoords.Clear ();  			isSouth = false;  			continue;  		}  		//it is a normal typical vertex line  		else {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			continue;  		}  	}  	#endregion  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: if (isSouth) {  	#region  	//only use this for quad windows and only capture when starting (vertexCounter == 1)  	if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  		//these functions work well for square walls  		wallHeight = GetNormalQuadWallHeight (parentSurface);  		//these variables could be stored by the computer  		//.2140 is the wwr of the daylight window  		dlHeight = wallHeight * dlWWR;  		//.209 is the wwr of the vision window  		visionHeight = wallHeight * visionWWR;  		//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  		//makes a new window based on   		newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  	}  	if (newCoords.Count > 0) {  		//make a new vertex point and append it to the line  		//do a check for the semicolon now because this changes the type of exchange that we make  		Match semicolonMatch = semiColonRegex.Match (line);  		if (semicolonMatch.Success) {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string semicolon = ";";  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  			output.AppendLine (newVertexLine);  			//ok' this window is done' so we are now going to make another one  			//that will sit right above it' in the same window...  			//output = MakeDaylightWindow(parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings);  			output = MakePunchedDaylightWindow (tempOpening' newCoords' visionHeight' dlHeight' output);  			//reset  			detailedFenestrationbool = false;  			vertexCounter = 1;  			newCoords.Clear ();  			isSouth = false;  			continue;  		}  		//it is a normal typical vertex line  		else {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			continue;  		}  	}  	#endregion  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  	//these functions work well for square walls  	wallHeight = GetNormalQuadWallHeight (parentSurface);  	//these variables could be stored by the computer  	//.2140 is the wwr of the daylight window  	dlHeight = wallHeight * dlWWR;  	//.209 is the wwr of the vision window  	visionHeight = wallHeight * visionWWR;  	//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  	//makes a new window based on   	newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacade,The following statement contains a magic number: if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  	//these functions work well for square walls  	wallHeight = GetNormalQuadWallHeight (parentSurface);  	//these variables could be stored by the computer  	//.2140 is the wwr of the daylight window  	dlHeight = wallHeight * dlWWR;  	//.209 is the wwr of the vision window  	visionHeight = wallHeight * visionWWR;  	//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  	//makes a new window based on   	newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: try {  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex detailedSurfaceYes = new Regex (EPlusObjects.EPlusRegexString.startSurface);  	Regex detailedFenestrationYes = new Regex (EPlusObjects.EPlusRegexString.startFenestration);  	Regex detailedObjectNameRegex = new Regex (EPlusObjects.EPlusRegexString.Name);  	Regex constructionNameRegex = new Regex (EPlusObjects.EPlusRegexString.constructionName);  	Regex typicalVertexRegex = new Regex (EPlusObjects.EPlusRegexString.typicalVertex);  	Regex semiColonRegex = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool detailedFenestrationbool = false;  	bool isSouth = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  			if (detailedFenestrationMatch.Success) {  				detailedFenestrationbool = true;  				output.AppendLine (line);  				continue;  			}  			if (detailedFenestrationbool) {  				#region  				//match name  				Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  				//once I get a match' set up a bunch of the variables that I will need   				if (fenestrationNameMatch.Success) {  					#region  					//tease out the name using purify  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  					if (pure.Success) {  						currentOpeningName = pure.Groups ["goods"].Value;  					}  					//if it is not eligible' don't do it.  Just continue and forget the rest  					bool eligible = GetEligibility (currentOpeningName' allowableZones);  					if (!eligible) {  						output.AppendLine (line);  						detailedFenestrationbool = false;  						continue;  					}  					#endregion  				}  				ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  				isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  				ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  				//this essentially tells the loop to go back into its normal cycle  				if (!isSouth) {  					detailedFenestrationbool = false;  				}  				//My next match is the coordinates' since the rest I should be able to skip at this point  				Match typicalVertexMatch = typicalVertexRegex.Match (line);  				if (typicalVertexMatch.Success) {  					//if a south window' then make these changes  					if (isSouth) {  						#region  						//only use this for quad windows and only capture when starting (vertexCounter == 1)  						if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  							//these functions work well for square walls  							List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  							double zLow = zLowandHeight [0];  							wallHeight = zLowandHeight [1];  							//because this will be a strip window' this is an easy calculation  							dlHeight = wallHeight * dlWWR;  							//calculate the sill height  							//Height of wall - dlHeight-viewwindowHeight = sill height  							//assuming we want to push the dL window to the top of the window  							double wallArea = Vector.GetAreaofSurface (parentSurface);  							double windowWidth = GetNormalQuadWindowWidth (currentOpening);  							visionHeight = visionWWR * wallArea / windowWidth;  							sillHeight = wallHeight - dlHeight - visionHeight;  							//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  							//makes a new punched window of a slightly smaller size  							newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  						}  						if (newCoords.Count > 0) {  							//make a new vertex point and append it to the line  							//do a check for the semicolon now because this changes the type of exchange that we make  							Match semicolonMatch = semiColonRegex.Match (line);  							if (semicolonMatch.Success) {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string semicolon = ";";  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  								output.AppendLine (newVertexLine);  								//ok' this window is done' so we are now going to make another one  								//that will sit right above it' in the same window...  								output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  								//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  								//reset  								detailedFenestrationbool = false;  								vertexCounter = 1;  								newCoords.Clear ();  								isSouth = false;  								continue;  							}  							//it is a normal typical vertex line  							else {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  								output.AppendLine (newVertexLine);  								vertexCounter++;  								continue;  							}  						}  						#endregion  					}  				}  				#endregion  				//in the case where I do not find a match but I am in detailedFenestration mode  				//not a vertex match  				//vertex match but not a southern window  				output.AppendLine (line);  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	successful = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	return successful;  }  catch (Exception e) {  	return successful;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: try {  	//set up a stringbuilder  	StringBuilder output = new StringBuilder ();  	//make the regex objects  	Regex detailedSurfaceYes = new Regex (EPlusObjects.EPlusRegexString.startSurface);  	Regex detailedFenestrationYes = new Regex (EPlusObjects.EPlusRegexString.startFenestration);  	Regex detailedObjectNameRegex = new Regex (EPlusObjects.EPlusRegexString.Name);  	Regex constructionNameRegex = new Regex (EPlusObjects.EPlusRegexString.constructionName);  	Regex typicalVertexRegex = new Regex (EPlusObjects.EPlusRegexString.typicalVertex);  	Regex semiColonRegex = new Regex (EPlusObjects.EPlusRegexString.semicolon);  	Encoding encoding;  	string line;  	//bools as needed  	bool detailedFenestrationbool = false;  	bool isSouth = false;  	using (StreamReader reader = new StreamReader (tempFileLocation)) {  		encoding = reader.CurrentEncoding;  		//set up the surface  		while ((line = reader.ReadLine ()) != null) {  			Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  			if (detailedFenestrationMatch.Success) {  				detailedFenestrationbool = true;  				output.AppendLine (line);  				continue;  			}  			if (detailedFenestrationbool) {  				#region  				//match name  				Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  				//once I get a match' set up a bunch of the variables that I will need   				if (fenestrationNameMatch.Success) {  					#region  					//tease out the name using purify  					string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  					Regex purifyRegex = new Regex (purify);  					Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  					if (pure.Success) {  						currentOpeningName = pure.Groups ["goods"].Value;  					}  					//if it is not eligible' don't do it.  Just continue and forget the rest  					bool eligible = GetEligibility (currentOpeningName' allowableZones);  					if (!eligible) {  						output.AppendLine (line);  						detailedFenestrationbool = false;  						continue;  					}  					#endregion  				}  				ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  				isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  				ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  				//this essentially tells the loop to go back into its normal cycle  				if (!isSouth) {  					detailedFenestrationbool = false;  				}  				//My next match is the coordinates' since the rest I should be able to skip at this point  				Match typicalVertexMatch = typicalVertexRegex.Match (line);  				if (typicalVertexMatch.Success) {  					//if a south window' then make these changes  					if (isSouth) {  						#region  						//only use this for quad windows and only capture when starting (vertexCounter == 1)  						if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  							//these functions work well for square walls  							List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  							double zLow = zLowandHeight [0];  							wallHeight = zLowandHeight [1];  							//because this will be a strip window' this is an easy calculation  							dlHeight = wallHeight * dlWWR;  							//calculate the sill height  							//Height of wall - dlHeight-viewwindowHeight = sill height  							//assuming we want to push the dL window to the top of the window  							double wallArea = Vector.GetAreaofSurface (parentSurface);  							double windowWidth = GetNormalQuadWindowWidth (currentOpening);  							visionHeight = visionWWR * wallArea / windowWidth;  							sillHeight = wallHeight - dlHeight - visionHeight;  							//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  							//makes a new punched window of a slightly smaller size  							newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  						}  						if (newCoords.Count > 0) {  							//make a new vertex point and append it to the line  							//do a check for the semicolon now because this changes the type of exchange that we make  							Match semicolonMatch = semiColonRegex.Match (line);  							if (semicolonMatch.Success) {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string semicolon = ";";  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  								output.AppendLine (newVertexLine);  								//ok' this window is done' so we are now going to make another one  								//that will sit right above it' in the same window...  								output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  								//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  								//reset  								detailedFenestrationbool = false;  								vertexCounter = 1;  								newCoords.Clear ();  								isSouth = false;  								continue;  							}  							//it is a normal typical vertex line  							else {  								string frontBlank = "     ";  								string comma = "'";  								string newX = newCoords [vertexCounter - 1].X.ToString ();  								string newY = newCoords [vertexCounter - 1].Y.ToString ();  								string newZ = newCoords [vertexCounter - 1].Z.ToString ();  								string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  								string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  								output.AppendLine (newVertexLine);  								vertexCounter++;  								continue;  							}  						}  						#endregion  					}  				}  				#endregion  				//in the case where I do not find a match but I am in detailedFenestration mode  				//not a vertex match  				//vertex match but not a southern window  				output.AppendLine (line);  			}  			else {  				output.AppendLine (line);  			}  		}  	}  	successful = FileMng.UpdateTmpFile (tempFileLocation' output' false' encoding);  	return successful;  }  catch (Exception e) {  	return successful;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: using (StreamReader reader = new StreamReader (tempFileLocation)) {  	encoding = reader.CurrentEncoding;  	//set up the surface  	while ((line = reader.ReadLine ()) != null) {  		Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  		if (detailedFenestrationMatch.Success) {  			detailedFenestrationbool = true;  			output.AppendLine (line);  			continue;  		}  		if (detailedFenestrationbool) {  			#region  			//match name  			Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  			//once I get a match' set up a bunch of the variables that I will need   			if (fenestrationNameMatch.Success) {  				#region  				//tease out the name using purify  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					currentOpeningName = pure.Groups ["goods"].Value;  				}  				//if it is not eligible' don't do it.  Just continue and forget the rest  				bool eligible = GetEligibility (currentOpeningName' allowableZones);  				if (!eligible) {  					output.AppendLine (line);  					detailedFenestrationbool = false;  					continue;  				}  				#endregion  			}  			ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  			isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  			ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  			//this essentially tells the loop to go back into its normal cycle  			if (!isSouth) {  				detailedFenestrationbool = false;  			}  			//My next match is the coordinates' since the rest I should be able to skip at this point  			Match typicalVertexMatch = typicalVertexRegex.Match (line);  			if (typicalVertexMatch.Success) {  				//if a south window' then make these changes  				if (isSouth) {  					#region  					//only use this for quad windows and only capture when starting (vertexCounter == 1)  					if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  						//these functions work well for square walls  						List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  						double zLow = zLowandHeight [0];  						wallHeight = zLowandHeight [1];  						//because this will be a strip window' this is an easy calculation  						dlHeight = wallHeight * dlWWR;  						//calculate the sill height  						//Height of wall - dlHeight-viewwindowHeight = sill height  						//assuming we want to push the dL window to the top of the window  						double wallArea = Vector.GetAreaofSurface (parentSurface);  						double windowWidth = GetNormalQuadWindowWidth (currentOpening);  						visionHeight = visionWWR * wallArea / windowWidth;  						sillHeight = wallHeight - dlHeight - visionHeight;  						//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  						//makes a new punched window of a slightly smaller size  						newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  					}  					if (newCoords.Count > 0) {  						//make a new vertex point and append it to the line  						//do a check for the semicolon now because this changes the type of exchange that we make  						Match semicolonMatch = semiColonRegex.Match (line);  						if (semicolonMatch.Success) {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string semicolon = ";";  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  							output.AppendLine (newVertexLine);  							//ok' this window is done' so we are now going to make another one  							//that will sit right above it' in the same window...  							output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  							//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  							//reset  							detailedFenestrationbool = false;  							vertexCounter = 1;  							newCoords.Clear ();  							isSouth = false;  							continue;  						}  						//it is a normal typical vertex line  						else {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							continue;  						}  					}  					#endregion  				}  			}  			#endregion  			//in the case where I do not find a match but I am in detailedFenestration mode  			//not a vertex match  			//vertex match but not a southern window  			output.AppendLine (line);  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: using (StreamReader reader = new StreamReader (tempFileLocation)) {  	encoding = reader.CurrentEncoding;  	//set up the surface  	while ((line = reader.ReadLine ()) != null) {  		Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  		if (detailedFenestrationMatch.Success) {  			detailedFenestrationbool = true;  			output.AppendLine (line);  			continue;  		}  		if (detailedFenestrationbool) {  			#region  			//match name  			Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  			//once I get a match' set up a bunch of the variables that I will need   			if (fenestrationNameMatch.Success) {  				#region  				//tease out the name using purify  				string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  				Regex purifyRegex = new Regex (purify);  				Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  				if (pure.Success) {  					currentOpeningName = pure.Groups ["goods"].Value;  				}  				//if it is not eligible' don't do it.  Just continue and forget the rest  				bool eligible = GetEligibility (currentOpeningName' allowableZones);  				if (!eligible) {  					output.AppendLine (line);  					detailedFenestrationbool = false;  					continue;  				}  				#endregion  			}  			ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  			isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  			ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  			//this essentially tells the loop to go back into its normal cycle  			if (!isSouth) {  				detailedFenestrationbool = false;  			}  			//My next match is the coordinates' since the rest I should be able to skip at this point  			Match typicalVertexMatch = typicalVertexRegex.Match (line);  			if (typicalVertexMatch.Success) {  				//if a south window' then make these changes  				if (isSouth) {  					#region  					//only use this for quad windows and only capture when starting (vertexCounter == 1)  					if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  						//these functions work well for square walls  						List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  						double zLow = zLowandHeight [0];  						wallHeight = zLowandHeight [1];  						//because this will be a strip window' this is an easy calculation  						dlHeight = wallHeight * dlWWR;  						//calculate the sill height  						//Height of wall - dlHeight-viewwindowHeight = sill height  						//assuming we want to push the dL window to the top of the window  						double wallArea = Vector.GetAreaofSurface (parentSurface);  						double windowWidth = GetNormalQuadWindowWidth (currentOpening);  						visionHeight = visionWWR * wallArea / windowWidth;  						sillHeight = wallHeight - dlHeight - visionHeight;  						//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  						//makes a new punched window of a slightly smaller size  						newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  					}  					if (newCoords.Count > 0) {  						//make a new vertex point and append it to the line  						//do a check for the semicolon now because this changes the type of exchange that we make  						Match semicolonMatch = semiColonRegex.Match (line);  						if (semicolonMatch.Success) {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string semicolon = ";";  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  							output.AppendLine (newVertexLine);  							//ok' this window is done' so we are now going to make another one  							//that will sit right above it' in the same window...  							output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  							//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  							//reset  							detailedFenestrationbool = false;  							vertexCounter = 1;  							newCoords.Clear ();  							isSouth = false;  							continue;  						}  						//it is a normal typical vertex line  						else {  							string frontBlank = "     ";  							string comma = "'";  							string newX = newCoords [vertexCounter - 1].X.ToString ();  							string newY = newCoords [vertexCounter - 1].Y.ToString ();  							string newZ = newCoords [vertexCounter - 1].Z.ToString ();  							string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  							string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  							output.AppendLine (newVertexLine);  							vertexCounter++;  							continue;  						}  					}  					#endregion  				}  			}  			#endregion  			//in the case where I do not find a match but I am in detailedFenestration mode  			//not a vertex match  			//vertex match but not a southern window  			output.AppendLine (line);  		}  		else {  			output.AppendLine (line);  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  	if (detailedFenestrationMatch.Success) {  		detailedFenestrationbool = true;  		output.AppendLine (line);  		continue;  	}  	if (detailedFenestrationbool) {  		#region  		//match name  		Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  		//once I get a match' set up a bunch of the variables that I will need   		if (fenestrationNameMatch.Success) {  			#region  			//tease out the name using purify  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentOpeningName = pure.Groups ["goods"].Value;  			}  			//if it is not eligible' don't do it.  Just continue and forget the rest  			bool eligible = GetEligibility (currentOpeningName' allowableZones);  			if (!eligible) {  				output.AppendLine (line);  				detailedFenestrationbool = false;  				continue;  			}  			#endregion  		}  		ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  		isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  		ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  		//this essentially tells the loop to go back into its normal cycle  		if (!isSouth) {  			detailedFenestrationbool = false;  		}  		//My next match is the coordinates' since the rest I should be able to skip at this point  		Match typicalVertexMatch = typicalVertexRegex.Match (line);  		if (typicalVertexMatch.Success) {  			//if a south window' then make these changes  			if (isSouth) {  				#region  				//only use this for quad windows and only capture when starting (vertexCounter == 1)  				if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  					//these functions work well for square walls  					List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  					double zLow = zLowandHeight [0];  					wallHeight = zLowandHeight [1];  					//because this will be a strip window' this is an easy calculation  					dlHeight = wallHeight * dlWWR;  					//calculate the sill height  					//Height of wall - dlHeight-viewwindowHeight = sill height  					//assuming we want to push the dL window to the top of the window  					double wallArea = Vector.GetAreaofSurface (parentSurface);  					double windowWidth = GetNormalQuadWindowWidth (currentOpening);  					visionHeight = visionWWR * wallArea / windowWidth;  					sillHeight = wallHeight - dlHeight - visionHeight;  					//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  					//makes a new punched window of a slightly smaller size  					newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  				}  				if (newCoords.Count > 0) {  					//make a new vertex point and append it to the line  					//do a check for the semicolon now because this changes the type of exchange that we make  					Match semicolonMatch = semiColonRegex.Match (line);  					if (semicolonMatch.Success) {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string semicolon = ";";  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  						output.AppendLine (newVertexLine);  						//ok' this window is done' so we are now going to make another one  						//that will sit right above it' in the same window...  						output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  						//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  						//reset  						detailedFenestrationbool = false;  						vertexCounter = 1;  						newCoords.Clear ();  						isSouth = false;  						continue;  					}  					//it is a normal typical vertex line  					else {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						continue;  					}  				}  				#endregion  			}  		}  		#endregion  		//in the case where I do not find a match but I am in detailedFenestration mode  		//not a vertex match  		//vertex match but not a southern window  		output.AppendLine (line);  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: while ((line = reader.ReadLine ()) != null) {  	Match detailedFenestrationMatch = detailedFenestrationYes.Match (line);  	if (detailedFenestrationMatch.Success) {  		detailedFenestrationbool = true;  		output.AppendLine (line);  		continue;  	}  	if (detailedFenestrationbool) {  		#region  		//match name  		Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  		//once I get a match' set up a bunch of the variables that I will need   		if (fenestrationNameMatch.Success) {  			#region  			//tease out the name using purify  			string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  			Regex purifyRegex = new Regex (purify);  			Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  			if (pure.Success) {  				currentOpeningName = pure.Groups ["goods"].Value;  			}  			//if it is not eligible' don't do it.  Just continue and forget the rest  			bool eligible = GetEligibility (currentOpeningName' allowableZones);  			if (!eligible) {  				output.AppendLine (line);  				detailedFenestrationbool = false;  				continue;  			}  			#endregion  		}  		ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  		isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  		ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  		//this essentially tells the loop to go back into its normal cycle  		if (!isSouth) {  			detailedFenestrationbool = false;  		}  		//My next match is the coordinates' since the rest I should be able to skip at this point  		Match typicalVertexMatch = typicalVertexRegex.Match (line);  		if (typicalVertexMatch.Success) {  			//if a south window' then make these changes  			if (isSouth) {  				#region  				//only use this for quad windows and only capture when starting (vertexCounter == 1)  				if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  					//these functions work well for square walls  					List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  					double zLow = zLowandHeight [0];  					wallHeight = zLowandHeight [1];  					//because this will be a strip window' this is an easy calculation  					dlHeight = wallHeight * dlWWR;  					//calculate the sill height  					//Height of wall - dlHeight-viewwindowHeight = sill height  					//assuming we want to push the dL window to the top of the window  					double wallArea = Vector.GetAreaofSurface (parentSurface);  					double windowWidth = GetNormalQuadWindowWidth (currentOpening);  					visionHeight = visionWWR * wallArea / windowWidth;  					sillHeight = wallHeight - dlHeight - visionHeight;  					//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  					//makes a new punched window of a slightly smaller size  					newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  				}  				if (newCoords.Count > 0) {  					//make a new vertex point and append it to the line  					//do a check for the semicolon now because this changes the type of exchange that we make  					Match semicolonMatch = semiColonRegex.Match (line);  					if (semicolonMatch.Success) {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string semicolon = ";";  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  						output.AppendLine (newVertexLine);  						//ok' this window is done' so we are now going to make another one  						//that will sit right above it' in the same window...  						output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  						//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  						//reset  						detailedFenestrationbool = false;  						vertexCounter = 1;  						newCoords.Clear ();  						isSouth = false;  						continue;  					}  					//it is a normal typical vertex line  					else {  						string frontBlank = "     ";  						string comma = "'";  						string newX = newCoords [vertexCounter - 1].X.ToString ();  						string newY = newCoords [vertexCounter - 1].Y.ToString ();  						string newZ = newCoords [vertexCounter - 1].Z.ToString ();  						string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  						string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  						output.AppendLine (newVertexLine);  						vertexCounter++;  						continue;  					}  				}  				#endregion  			}  		}  		#endregion  		//in the case where I do not find a match but I am in detailedFenestration mode  		//not a vertex match  		//vertex match but not a southern window  		output.AppendLine (line);  	}  	else {  		output.AppendLine (line);  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: if (detailedFenestrationbool) {  	#region  	//match name  	Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  	//once I get a match' set up a bunch of the variables that I will need   	if (fenestrationNameMatch.Success) {  		#region  		//tease out the name using purify  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentOpeningName = pure.Groups ["goods"].Value;  		}  		//if it is not eligible' don't do it.  Just continue and forget the rest  		bool eligible = GetEligibility (currentOpeningName' allowableZones);  		if (!eligible) {  			output.AppendLine (line);  			detailedFenestrationbool = false;  			continue;  		}  		#endregion  	}  	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  	isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  	ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  	//this essentially tells the loop to go back into its normal cycle  	if (!isSouth) {  		detailedFenestrationbool = false;  	}  	//My next match is the coordinates' since the rest I should be able to skip at this point  	Match typicalVertexMatch = typicalVertexRegex.Match (line);  	if (typicalVertexMatch.Success) {  		//if a south window' then make these changes  		if (isSouth) {  			#region  			//only use this for quad windows and only capture when starting (vertexCounter == 1)  			if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  				//these functions work well for square walls  				List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  				double zLow = zLowandHeight [0];  				wallHeight = zLowandHeight [1];  				//because this will be a strip window' this is an easy calculation  				dlHeight = wallHeight * dlWWR;  				//calculate the sill height  				//Height of wall - dlHeight-viewwindowHeight = sill height  				//assuming we want to push the dL window to the top of the window  				double wallArea = Vector.GetAreaofSurface (parentSurface);  				double windowWidth = GetNormalQuadWindowWidth (currentOpening);  				visionHeight = visionWWR * wallArea / windowWidth;  				sillHeight = wallHeight - dlHeight - visionHeight;  				//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  				//makes a new punched window of a slightly smaller size  				newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  			}  			if (newCoords.Count > 0) {  				//make a new vertex point and append it to the line  				//do a check for the semicolon now because this changes the type of exchange that we make  				Match semicolonMatch = semiColonRegex.Match (line);  				if (semicolonMatch.Success) {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string semicolon = ";";  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  					output.AppendLine (newVertexLine);  					//ok' this window is done' so we are now going to make another one  					//that will sit right above it' in the same window...  					output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  					//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  					//reset  					detailedFenestrationbool = false;  					vertexCounter = 1;  					newCoords.Clear ();  					isSouth = false;  					continue;  				}  				//it is a normal typical vertex line  				else {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					continue;  				}  			}  			#endregion  		}  	}  	#endregion  	//in the case where I do not find a match but I am in detailedFenestration mode  	//not a vertex match  	//vertex match but not a southern window  	output.AppendLine (line);  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: if (detailedFenestrationbool) {  	#region  	//match name  	Match fenestrationNameMatch = detailedObjectNameRegex.Match (line);  	//once I get a match' set up a bunch of the variables that I will need   	if (fenestrationNameMatch.Success) {  		#region  		//tease out the name using purify  		string purify = @"(?'ws'\s*)(?'goods'.*)(?'comma'')";  		Regex purifyRegex = new Regex (purify);  		Match pure = purifyRegex.Match (fenestrationNameMatch.Groups ["1"].Value);  		if (pure.Success) {  			currentOpeningName = pure.Groups ["goods"].Value;  		}  		//if it is not eligible' don't do it.  Just continue and forget the rest  		bool eligible = GetEligibility (currentOpeningName' allowableZones);  		if (!eligible) {  			output.AppendLine (line);  			detailedFenestrationbool = false;  			continue;  		}  		#endregion  	}  	ModelingUtilities.BuildingObjects.MemorySafe_OpeningDefinitions currentOpening = GetOpeningfromStringId (currentOpeningName' projectOpenings);  	isSouth = ModelingUtilities.OrientationUtil.isSouth (currentOpening' 0);  	ModelingUtilities.BuildingObjects.MemorySafe_Surface parentSurface = GetParentSurface (currentOpening.parentSurfaceNameId' projectSurfaces);  	//this essentially tells the loop to go back into its normal cycle  	if (!isSouth) {  		detailedFenestrationbool = false;  	}  	//My next match is the coordinates' since the rest I should be able to skip at this point  	Match typicalVertexMatch = typicalVertexRegex.Match (line);  	if (typicalVertexMatch.Success) {  		//if a south window' then make these changes  		if (isSouth) {  			#region  			//only use this for quad windows and only capture when starting (vertexCounter == 1)  			if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  				//these functions work well for square walls  				List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  				double zLow = zLowandHeight [0];  				wallHeight = zLowandHeight [1];  				//because this will be a strip window' this is an easy calculation  				dlHeight = wallHeight * dlWWR;  				//calculate the sill height  				//Height of wall - dlHeight-viewwindowHeight = sill height  				//assuming we want to push the dL window to the top of the window  				double wallArea = Vector.GetAreaofSurface (parentSurface);  				double windowWidth = GetNormalQuadWindowWidth (currentOpening);  				visionHeight = visionWWR * wallArea / windowWidth;  				sillHeight = wallHeight - dlHeight - visionHeight;  				//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  				//makes a new punched window of a slightly smaller size  				newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  			}  			if (newCoords.Count > 0) {  				//make a new vertex point and append it to the line  				//do a check for the semicolon now because this changes the type of exchange that we make  				Match semicolonMatch = semiColonRegex.Match (line);  				if (semicolonMatch.Success) {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string semicolon = ";";  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  					output.AppendLine (newVertexLine);  					//ok' this window is done' so we are now going to make another one  					//that will sit right above it' in the same window...  					output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  					//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  					//reset  					detailedFenestrationbool = false;  					vertexCounter = 1;  					newCoords.Clear ();  					isSouth = false;  					continue;  				}  				//it is a normal typical vertex line  				else {  					string frontBlank = "     ";  					string comma = "'";  					string newX = newCoords [vertexCounter - 1].X.ToString ();  					string newY = newCoords [vertexCounter - 1].Y.ToString ();  					string newZ = newCoords [vertexCounter - 1].Z.ToString ();  					string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  					string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  					output.AppendLine (newVertexLine);  					vertexCounter++;  					continue;  				}  			}  			#endregion  		}  	}  	#endregion  	//in the case where I do not find a match but I am in detailedFenestration mode  	//not a vertex match  	//vertex match but not a southern window  	output.AppendLine (line);  }  else {  	output.AppendLine (line);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: if (typicalVertexMatch.Success) {  	//if a south window' then make these changes  	if (isSouth) {  		#region  		//only use this for quad windows and only capture when starting (vertexCounter == 1)  		if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  			//these functions work well for square walls  			List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  			double zLow = zLowandHeight [0];  			wallHeight = zLowandHeight [1];  			//because this will be a strip window' this is an easy calculation  			dlHeight = wallHeight * dlWWR;  			//calculate the sill height  			//Height of wall - dlHeight-viewwindowHeight = sill height  			//assuming we want to push the dL window to the top of the window  			double wallArea = Vector.GetAreaofSurface (parentSurface);  			double windowWidth = GetNormalQuadWindowWidth (currentOpening);  			visionHeight = visionWWR * wallArea / windowWidth;  			sillHeight = wallHeight - dlHeight - visionHeight;  			//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  			//makes a new punched window of a slightly smaller size  			newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  		}  		if (newCoords.Count > 0) {  			//make a new vertex point and append it to the line  			//do a check for the semicolon now because this changes the type of exchange that we make  			Match semicolonMatch = semiColonRegex.Match (line);  			if (semicolonMatch.Success) {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string semicolon = ";";  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  				output.AppendLine (newVertexLine);  				//ok' this window is done' so we are now going to make another one  				//that will sit right above it' in the same window...  				output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  				//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  				//reset  				detailedFenestrationbool = false;  				vertexCounter = 1;  				newCoords.Clear ();  				isSouth = false;  				continue;  			}  			//it is a normal typical vertex line  			else {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				continue;  			}  		}  		#endregion  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: if (typicalVertexMatch.Success) {  	//if a south window' then make these changes  	if (isSouth) {  		#region  		//only use this for quad windows and only capture when starting (vertexCounter == 1)  		if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  			//these functions work well for square walls  			List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  			double zLow = zLowandHeight [0];  			wallHeight = zLowandHeight [1];  			//because this will be a strip window' this is an easy calculation  			dlHeight = wallHeight * dlWWR;  			//calculate the sill height  			//Height of wall - dlHeight-viewwindowHeight = sill height  			//assuming we want to push the dL window to the top of the window  			double wallArea = Vector.GetAreaofSurface (parentSurface);  			double windowWidth = GetNormalQuadWindowWidth (currentOpening);  			visionHeight = visionWWR * wallArea / windowWidth;  			sillHeight = wallHeight - dlHeight - visionHeight;  			//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  			//makes a new punched window of a slightly smaller size  			newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  		}  		if (newCoords.Count > 0) {  			//make a new vertex point and append it to the line  			//do a check for the semicolon now because this changes the type of exchange that we make  			Match semicolonMatch = semiColonRegex.Match (line);  			if (semicolonMatch.Success) {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string semicolon = ";";  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  				output.AppendLine (newVertexLine);  				//ok' this window is done' so we are now going to make another one  				//that will sit right above it' in the same window...  				output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  				//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  				//reset  				detailedFenestrationbool = false;  				vertexCounter = 1;  				newCoords.Clear ();  				isSouth = false;  				continue;  			}  			//it is a normal typical vertex line  			else {  				string frontBlank = "     ";  				string comma = "'";  				string newX = newCoords [vertexCounter - 1].X.ToString ();  				string newY = newCoords [vertexCounter - 1].Y.ToString ();  				string newZ = newCoords [vertexCounter - 1].Z.ToString ();  				string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  				string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  				output.AppendLine (newVertexLine);  				vertexCounter++;  				continue;  			}  		}  		#endregion  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: if (isSouth) {  	#region  	//only use this for quad windows and only capture when starting (vertexCounter == 1)  	if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  		//these functions work well for square walls  		List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  		double zLow = zLowandHeight [0];  		wallHeight = zLowandHeight [1];  		//because this will be a strip window' this is an easy calculation  		dlHeight = wallHeight * dlWWR;  		//calculate the sill height  		//Height of wall - dlHeight-viewwindowHeight = sill height  		//assuming we want to push the dL window to the top of the window  		double wallArea = Vector.GetAreaofSurface (parentSurface);  		double windowWidth = GetNormalQuadWindowWidth (currentOpening);  		visionHeight = visionWWR * wallArea / windowWidth;  		sillHeight = wallHeight - dlHeight - visionHeight;  		//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  		//makes a new punched window of a slightly smaller size  		newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  	}  	if (newCoords.Count > 0) {  		//make a new vertex point and append it to the line  		//do a check for the semicolon now because this changes the type of exchange that we make  		Match semicolonMatch = semiColonRegex.Match (line);  		if (semicolonMatch.Success) {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string semicolon = ";";  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  			output.AppendLine (newVertexLine);  			//ok' this window is done' so we are now going to make another one  			//that will sit right above it' in the same window...  			output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  			//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  			//reset  			detailedFenestrationbool = false;  			vertexCounter = 1;  			newCoords.Clear ();  			isSouth = false;  			continue;  		}  		//it is a normal typical vertex line  		else {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			continue;  		}  	}  	#endregion  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: if (isSouth) {  	#region  	//only use this for quad windows and only capture when starting (vertexCounter == 1)  	if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  		//these functions work well for square walls  		List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  		double zLow = zLowandHeight [0];  		wallHeight = zLowandHeight [1];  		//because this will be a strip window' this is an easy calculation  		dlHeight = wallHeight * dlWWR;  		//calculate the sill height  		//Height of wall - dlHeight-viewwindowHeight = sill height  		//assuming we want to push the dL window to the top of the window  		double wallArea = Vector.GetAreaofSurface (parentSurface);  		double windowWidth = GetNormalQuadWindowWidth (currentOpening);  		visionHeight = visionWWR * wallArea / windowWidth;  		sillHeight = wallHeight - dlHeight - visionHeight;  		//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  		//makes a new punched window of a slightly smaller size  		newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  	}  	if (newCoords.Count > 0) {  		//make a new vertex point and append it to the line  		//do a check for the semicolon now because this changes the type of exchange that we make  		Match semicolonMatch = semiColonRegex.Match (line);  		if (semicolonMatch.Success) {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string semicolon = ";";  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + semicolon + remainder;  			output.AppendLine (newVertexLine);  			//ok' this window is done' so we are now going to make another one  			//that will sit right above it' in the same window...  			output = MakeDaylightWindow (parentSurface' currentOpening' newCoords' dlHeight' wallHeight' output' projectOpenings' dlBuffer);  			//output = MakePunchedDaylightWindow(currentOpening' newCoords' visionHeight' dlHeight' output);  			//reset  			detailedFenestrationbool = false;  			vertexCounter = 1;  			newCoords.Clear ();  			isSouth = false;  			continue;  		}  		//it is a normal typical vertex line  		else {  			string frontBlank = "     ";  			string comma = "'";  			string newX = newCoords [vertexCounter - 1].X.ToString ();  			string newY = newCoords [vertexCounter - 1].Y.ToString ();  			string newZ = newCoords [vertexCounter - 1].Z.ToString ();  			string remainder = "   !- X'Y'Z ==> Vertex " + vertexCounter.ToString () + " {m}";  			string newVertexLine = frontBlank + newX + comma + newY + comma + newZ + comma + remainder;  			output.AppendLine (newVertexLine);  			vertexCounter++;  			continue;  		}  	}  	#endregion  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  	//these functions work well for square walls  	List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  	double zLow = zLowandHeight [0];  	wallHeight = zLowandHeight [1];  	//because this will be a strip window' this is an easy calculation  	dlHeight = wallHeight * dlWWR;  	//calculate the sill height  	//Height of wall - dlHeight-viewwindowHeight = sill height  	//assuming we want to push the dL window to the top of the window  	double wallArea = Vector.GetAreaofSurface (parentSurface);  	double windowWidth = GetNormalQuadWindowWidth (currentOpening);  	visionHeight = visionWWR * wallArea / windowWidth;  	sillHeight = wallHeight - dlHeight - visionHeight;  	//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  	//makes a new punched window of a slightly smaller size  	newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,UpdateSouthFacadePunchedWindows,The following statement contains a magic number: if (currentOpening.numVertices == 4 && parentSurface.numVertices == 4 && vertexCounter == 1) {  	//these functions work well for square walls  	List<double> zLowandHeight = GetNormalQuadWallZLowandHeight (parentSurface);  	double zLow = zLowandHeight [0];  	wallHeight = zLowandHeight [1];  	//because this will be a strip window' this is an easy calculation  	dlHeight = wallHeight * dlWWR;  	//calculate the sill height  	//Height of wall - dlHeight-viewwindowHeight = sill height  	//assuming we want to push the dL window to the top of the window  	double wallArea = Vector.GetAreaofSurface (parentSurface);  	double windowWidth = GetNormalQuadWindowWidth (currentOpening);  	visionHeight = visionWWR * wallArea / windowWidth;  	sillHeight = wallHeight - dlHeight - visionHeight;  	//newCoords = GetNewNormalQuadStripWindowCoordinates(parentSurface' visionWWR' sillHeight' wallHeight);  	//makes a new punched window of a slightly smaller size  	newCoords = GetNewNormalQuadPunchedWindowCoordinates (currentOpening' visionHeight' sillHeight' zLow' dlBuffer);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentSurface.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight;  		zLow = parentSurface.SurfaceCoords [i].Z;  		break;  	case 1:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight;  		if (zLow > parentSurface.SurfaceCoords [i].Z)  			zLow = parentSurface.SurfaceCoords [i].Z;  		break;  	case 2:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		if (zLow > parentSurface.SurfaceCoords [i].Z)  			zLow = parentSurface.SurfaceCoords [i].Z;  		newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight;  		break;  	case 3:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentSurface.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight;  		zLow = parentSurface.SurfaceCoords [i].Z;  		break;  	case 1:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight;  		if (zLow > parentSurface.SurfaceCoords [i].Z)  			zLow = parentSurface.SurfaceCoords [i].Z;  		break;  	case 2:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		if (zLow > parentSurface.SurfaceCoords [i].Z)  			zLow = parentSurface.SurfaceCoords [i].Z;  		newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight;  		break;  	case 3:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight;  	zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 1:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 2:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight;  	break;  case 3:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight;  	zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 1:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 2:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight;  	break;  case 3:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentSurface.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight - dlBuffer;  		zLow = parentSurface.SurfaceCoords [i].Z;  		break;  	case 1:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight - dlBuffer;  		if (zLow > parentSurface.SurfaceCoords [i].Z)  			zLow = parentSurface.SurfaceCoords [i].Z;  		break;  	case 2:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		if (zLow > parentSurface.SurfaceCoords [i].Z)  			zLow = parentSurface.SurfaceCoords [i].Z;  		newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight - dlBuffer;  		break;  	case 3:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight - dlBuffer;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentSurface.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight - dlBuffer;  		zLow = parentSurface.SurfaceCoords [i].Z;  		break;  	case 1:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight - dlBuffer;  		if (zLow > parentSurface.SurfaceCoords [i].Z)  			zLow = parentSurface.SurfaceCoords [i].Z;  		break;  	case 2:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		if (zLow > parentSurface.SurfaceCoords [i].Z)  			zLow = parentSurface.SurfaceCoords [i].Z;  		newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight - dlBuffer;  		break;  	case 3:  		newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  		newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  		newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight - dlBuffer;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight - dlBuffer;  	zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 1:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight - dlBuffer;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 2:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight - dlBuffer;  	break;  case 3:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight - dlBuffer;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight - dlBuffer;  	zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 1:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight - dlBuffer;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 2:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight - dlBuffer;  	break;  case 3:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight - dlBuffer;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentWindow.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = zLow + sillHeight;  		windowZLow = newWindowCoord.Z;  		break;  	case 1:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = zLow + sillHeight;  		if (windowZLow > newWindowCoord.Z)  			windowZLow = newWindowCoord.Z;  		break;  	case 2:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	case 3:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentWindow.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = zLow + sillHeight;  		windowZLow = newWindowCoord.Z;  		break;  	case 1:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = zLow + sillHeight;  		if (windowZLow > newWindowCoord.Z)  			windowZLow = newWindowCoord.Z;  		break;  	case 2:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	case 3:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight;  	windowZLow = newWindowCoord.Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight;  	if (windowZLow > newWindowCoord.Z)  		windowZLow = newWindowCoord.Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight;  	windowZLow = newWindowCoord.Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight;  	if (windowZLow > newWindowCoord.Z)  		windowZLow = newWindowCoord.Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentWindow.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = zLow + sillHeight - dlBuffer;  		windowZLow = newWindowCoord.Z;  		break;  	case 1:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = zLow + sillHeight - dlBuffer;  		if (windowZLow > newWindowCoord.Z)  			windowZLow = newWindowCoord.Z;  		break;  	case 2:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight - dlBuffer;  		break;  	case 3:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight - dlBuffer;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentWindow.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = zLow + sillHeight - dlBuffer;  		windowZLow = newWindowCoord.Z;  		break;  	case 1:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = zLow + sillHeight - dlBuffer;  		if (windowZLow > newWindowCoord.Z)  			windowZLow = newWindowCoord.Z;  		break;  	case 2:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight - dlBuffer;  		break;  	case 3:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight - dlBuffer;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight - dlBuffer;  	windowZLow = newWindowCoord.Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight - dlBuffer;  	if (windowZLow > newWindowCoord.Z)  		windowZLow = newWindowCoord.Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight - dlBuffer;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight - dlBuffer;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight - dlBuffer;  	windowZLow = newWindowCoord.Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight - dlBuffer;  	if (windowZLow > newWindowCoord.Z)  		windowZLow = newWindowCoord.Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight - dlBuffer;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight - dlBuffer;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentWindow.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = parentWindow.coordinateList [i].Z;  		windowZLow = parentWindow.coordinateList [i].Z;  		break;  	case 1:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = parentWindow.coordinateList [i].Z;  		if (windowZLow > parentWindow.coordinateList [i].Z)  			windowZLow = parentWindow.coordinateList [i].Z;  		break;  	case 2:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	case 3:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentWindow.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = parentWindow.coordinateList [i].Z;  		windowZLow = parentWindow.coordinateList [i].Z;  		break;  	case 1:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = parentWindow.coordinateList [i].Z;  		if (windowZLow > parentWindow.coordinateList [i].Z)  			windowZLow = parentWindow.coordinateList [i].Z;  		break;  	case 2:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	case 3:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	if (windowZLow > parentWindow.coordinateList [i].Z)  		windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	if (windowZLow > parentWindow.coordinateList [i].Z)  		windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentWindow.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = parentWindow.coordinateList [i].Z;  		windowZLow = parentWindow.coordinateList [i].Z;  		break;  	case 1:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = parentWindow.coordinateList [i].Z;  		if (windowZLow > parentWindow.coordinateList [i].Z)  			windowZLow = parentWindow.coordinateList [i].Z;  		break;  	case 2:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	case 3:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < parentWindow.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = parentWindow.coordinateList [i].Z;  		windowZLow = parentWindow.coordinateList [i].Z;  		break;  	case 1:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = parentWindow.coordinateList [i].Z;  		if (windowZLow > parentWindow.coordinateList [i].Z)  			windowZLow = parentWindow.coordinateList [i].Z;  		break;  	case 2:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	case 3:  		newWindowCoord.X = parentWindow.coordinateList [i].X;  		newWindowCoord.Y = parentWindow.coordinateList [i].Y;  		newWindowCoord.Z = windowZLow + visionHeight;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	if (windowZLow > parentWindow.coordinateList [i].Z)  		windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	if (windowZLow > parentWindow.coordinateList [i].Z)  		windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < window.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		if (multiplier == 1) {  			newWindowCoord.X = window.coordinateList [i].X;  			newWindowCoord.Y = window.coordinateList [i].Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		else {  			newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  			newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		break;  	case 1:  		if (multiplier == 1) {  			newWindowCoord.X = window.coordinateList [i].X;  			newWindowCoord.Y = window.coordinateList [i].Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		else {  			newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  			newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		break;  	case 2:  		if (multiplier == 1) {  			newWindowCoord.X = window.coordinateList [i].X;  			newWindowCoord.Y = window.coordinateList [i].Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		else {  			newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  			newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		break;  	case 3:  		if (multiplier == 1) {  			newWindowCoord.X = window.coordinateList [i].X;  			newWindowCoord.Y = window.coordinateList [i].Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		else {  			newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  			newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < window.numVertices; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		if (multiplier == 1) {  			newWindowCoord.X = window.coordinateList [i].X;  			newWindowCoord.Y = window.coordinateList [i].Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		else {  			newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  			newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		break;  	case 1:  		if (multiplier == 1) {  			newWindowCoord.X = window.coordinateList [i].X;  			newWindowCoord.Y = window.coordinateList [i].Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		else {  			newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  			newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		break;  	case 2:  		if (multiplier == 1) {  			newWindowCoord.X = window.coordinateList [i].X;  			newWindowCoord.Y = window.coordinateList [i].Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		else {  			newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  			newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		break;  	case 3:  		if (multiplier == 1) {  			newWindowCoord.X = window.coordinateList [i].X;  			newWindowCoord.Y = window.coordinateList [i].Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		else {  			newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  			newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  			newWindowCoord.Z = window.coordinateList [i].Z;  		}  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  case 1:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  case 2:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  case 3:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  case 1:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  case 2:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  case 3:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: for (int i = 0; i < surfaceCoords.Count () - 1; i++) {  	Vector.CartVect vector = Vector.CreateVector (surfaceCoords [i]' surfaceCoords [i + 1]);  	localX = Vector.UnitVector (localX);  	vector = Vector.UnitVector (vector);  	//this means they are parallel and pointing in the same direction  	if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < .0001)) {  		if (localX.X > 0) {  			surfaceXMin = surfaceCoords [i].X;  			surfaceXMax = surfaceCoords [i + 1].X;  		}  		else {  			surfaceXMin = surfaceCoords [i + 1].X;  			surfaceXMax = surfaceCoords [i].X;  		}  		if (localX.Y > 0) {  			surfaceYMin = surfaceCoords [i].Y;  			surfaceYMax = surfaceCoords [i + 1].Y;  		}  		else {  			surfaceYMin = surfaceCoords [i + 1].Y;  			surfaceYMax = surfaceCoords [i].Y;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: for (int i = 0; i < surfaceCoords.Count () - 1; i++) {  	Vector.CartVect vector = Vector.CreateVector (surfaceCoords [i]' surfaceCoords [i + 1]);  	localX = Vector.UnitVector (localX);  	vector = Vector.UnitVector (vector);  	//this means they are parallel and pointing in the same direction  	if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < .0001)) {  		if (localX.X > 0) {  			surfaceXMin = surfaceCoords [i].X;  			surfaceXMax = surfaceCoords [i + 1].X;  		}  		else {  			surfaceXMin = surfaceCoords [i + 1].X;  			surfaceXMax = surfaceCoords [i].X;  		}  		if (localX.Y > 0) {  			surfaceYMin = surfaceCoords [i].Y;  			surfaceYMax = surfaceCoords [i + 1].Y;  		}  		else {  			surfaceYMin = surfaceCoords [i + 1].Y;  			surfaceYMax = surfaceCoords [i].Y;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < .0001)) {  	if (localX.X > 0) {  		surfaceXMin = surfaceCoords [i].X;  		surfaceXMax = surfaceCoords [i + 1].X;  	}  	else {  		surfaceXMin = surfaceCoords [i + 1].X;  		surfaceXMax = surfaceCoords [i].X;  	}  	if (localX.Y > 0) {  		surfaceYMin = surfaceCoords [i].Y;  		surfaceYMax = surfaceCoords [i + 1].Y;  	}  	else {  		surfaceYMin = surfaceCoords [i + 1].Y;  		surfaceYMax = surfaceCoords [i].Y;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < .0001)) {  	if (localX.X > 0) {  		surfaceXMin = surfaceCoords [i].X;  		surfaceXMax = surfaceCoords [i + 1].X;  	}  	else {  		surfaceXMin = surfaceCoords [i + 1].X;  		surfaceXMax = surfaceCoords [i].X;  	}  	if (localX.Y > 0) {  		surfaceYMin = surfaceCoords [i].Y;  		surfaceYMax = surfaceCoords [i + 1].Y;  	}  	else {  		surfaceYMin = surfaceCoords [i + 1].Y;  		surfaceYMax = surfaceCoords [i].Y;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: for (int i = 0; i < windowCoords.Count () - 1; i++) {  	Vector.CartVect vector = Vector.CreateVector (windowCoords [i]' windowCoords [i + 1]);  	localX = Vector.UnitVector (localX);  	vector = Vector.UnitVector (vector);  	//this means they are parallel and pointing in the same direction  	if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < 0.0001)) {  		//if localX axis X component is positive  		//it must be true that the second window coordinate X value is greater than the first's  		if (localX.X > 0) {  			windowXMin = windowCoords [i].X;  			windowXMax = windowCoords [i + 1].X;  		}  		else {  			windowXMin = windowCoords [i + 1].X;  			windowXMax = windowCoords [i].X;  		}  		//same for the Y value  		if (localX.Y > 0) {  			windowYMin = windowCoords [i].Y;  			windowYMax = windowCoords [i + 1].Y;  		}  		else {  			windowYMin = windowCoords [i + 1].Y;  			windowYMax = windowCoords [i].Y;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: for (int i = 0; i < windowCoords.Count () - 1; i++) {  	Vector.CartVect vector = Vector.CreateVector (windowCoords [i]' windowCoords [i + 1]);  	localX = Vector.UnitVector (localX);  	vector = Vector.UnitVector (vector);  	//this means they are parallel and pointing in the same direction  	if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < 0.0001)) {  		//if localX axis X component is positive  		//it must be true that the second window coordinate X value is greater than the first's  		if (localX.X > 0) {  			windowXMin = windowCoords [i].X;  			windowXMax = windowCoords [i + 1].X;  		}  		else {  			windowXMin = windowCoords [i + 1].X;  			windowXMax = windowCoords [i].X;  		}  		//same for the Y value  		if (localX.Y > 0) {  			windowYMin = windowCoords [i].Y;  			windowYMax = windowCoords [i + 1].Y;  		}  		else {  			windowYMin = windowCoords [i + 1].Y;  			windowYMax = windowCoords [i].Y;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < 0.0001)) {  	//if localX axis X component is positive  	//it must be true that the second window coordinate X value is greater than the first's  	if (localX.X > 0) {  		windowXMin = windowCoords [i].X;  		windowXMax = windowCoords [i + 1].X;  	}  	else {  		windowXMin = windowCoords [i + 1].X;  		windowXMax = windowCoords [i].X;  	}  	//same for the Y value  	if (localX.Y > 0) {  		windowYMin = windowCoords [i].Y;  		windowYMax = windowCoords [i + 1].Y;  	}  	else {  		windowYMin = windowCoords [i + 1].Y;  		windowYMax = windowCoords [i].Y;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < 0.0001)) {  	//if localX axis X component is positive  	//it must be true that the second window coordinate X value is greater than the first's  	if (localX.X > 0) {  		windowXMin = windowCoords [i].X;  		windowXMax = windowCoords [i + 1].X;  	}  	else {  		windowXMin = windowCoords [i + 1].X;  		windowXMax = windowCoords [i].X;  	}  	//same for the Y value  	if (localX.Y > 0) {  		windowYMin = windowCoords [i].Y;  		windowYMax = windowCoords [i + 1].Y;  	}  	else {  		windowYMin = windowCoords [i + 1].Y;  		windowYMax = windowCoords [i].Y;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: for (int i = 0; i < surfaceCoords.Count () - 1; i++) {  	Vector.CartVect vector = Vector.CreateVector (surfaceCoords [i]' surfaceCoords [i + 1]);  	localX = Vector.UnitVector (localX);  	vector = Vector.UnitVector (vector);  	//this means they are parallel and pointing in the same direction  	if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < .0001)) {  		if (localX.X > 0) {  			surfaceXMin = surfaceCoords [i].X;  			surfaceXMax = surfaceCoords [i + 1].X;  		}  		else {  			surfaceXMin = surfaceCoords [i + 1].X;  			surfaceXMax = surfaceCoords [i].X;  		}  		if (localX.Y > 0) {  			surfaceYMin = surfaceCoords [i].Y;  			surfaceYMax = surfaceCoords [i + 1].Y;  		}  		else {  			surfaceYMin = surfaceCoords [i + 1].Y;  			surfaceYMax = surfaceCoords [i].Y;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: for (int i = 0; i < surfaceCoords.Count () - 1; i++) {  	Vector.CartVect vector = Vector.CreateVector (surfaceCoords [i]' surfaceCoords [i + 1]);  	localX = Vector.UnitVector (localX);  	vector = Vector.UnitVector (vector);  	//this means they are parallel and pointing in the same direction  	if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < .0001)) {  		if (localX.X > 0) {  			surfaceXMin = surfaceCoords [i].X;  			surfaceXMax = surfaceCoords [i + 1].X;  		}  		else {  			surfaceXMin = surfaceCoords [i + 1].X;  			surfaceXMax = surfaceCoords [i].X;  		}  		if (localX.Y > 0) {  			surfaceYMin = surfaceCoords [i].Y;  			surfaceYMax = surfaceCoords [i + 1].Y;  		}  		else {  			surfaceYMin = surfaceCoords [i + 1].Y;  			surfaceYMax = surfaceCoords [i].Y;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < .0001)) {  	if (localX.X > 0) {  		surfaceXMin = surfaceCoords [i].X;  		surfaceXMax = surfaceCoords [i + 1].X;  	}  	else {  		surfaceXMin = surfaceCoords [i + 1].X;  		surfaceXMax = surfaceCoords [i].X;  	}  	if (localX.Y > 0) {  		surfaceYMin = surfaceCoords [i].Y;  		surfaceYMax = surfaceCoords [i + 1].Y;  	}  	else {  		surfaceYMin = surfaceCoords [i + 1].Y;  		surfaceYMax = surfaceCoords [i].Y;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < .0001)) {  	if (localX.X > 0) {  		surfaceXMin = surfaceCoords [i].X;  		surfaceXMax = surfaceCoords [i + 1].X;  	}  	else {  		surfaceXMin = surfaceCoords [i + 1].X;  		surfaceXMax = surfaceCoords [i].X;  	}  	if (localX.Y > 0) {  		surfaceYMin = surfaceCoords [i].Y;  		surfaceYMax = surfaceCoords [i + 1].Y;  	}  	else {  		surfaceYMin = surfaceCoords [i + 1].Y;  		surfaceYMax = surfaceCoords [i].Y;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: for (int i = 0; i < windowCoords.Count () - 1; i++) {  	Vector.CartVect vector = Vector.CreateVector (windowCoords [i]' windowCoords [i + 1]);  	localX = Vector.UnitVector (localX);  	vector = Vector.UnitVector (vector);  	//this means they are parallel and pointing in the same direction  	if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < 0.0001)) {  		//if localX axis X component is positive  		//it must be true that the second window coordinate X value is greater than the first's  		if (localX.X > 0) {  			windowXMin = windowCoords [i].X;  			windowXMax = windowCoords [i + 1].X;  		}  		else {  			windowXMin = windowCoords [i + 1].X;  			windowXMax = windowCoords [i].X;  		}  		//same for the Y value  		if (localX.Y > 0) {  			windowYMin = windowCoords [i].Y;  			windowYMax = windowCoords [i + 1].Y;  		}  		else {  			windowYMin = windowCoords [i + 1].Y;  			windowYMax = windowCoords [i].Y;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: for (int i = 0; i < windowCoords.Count () - 1; i++) {  	Vector.CartVect vector = Vector.CreateVector (windowCoords [i]' windowCoords [i + 1]);  	localX = Vector.UnitVector (localX);  	vector = Vector.UnitVector (vector);  	//this means they are parallel and pointing in the same direction  	if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < 0.0001)) {  		//if localX axis X component is positive  		//it must be true that the second window coordinate X value is greater than the first's  		if (localX.X > 0) {  			windowXMin = windowCoords [i].X;  			windowXMax = windowCoords [i + 1].X;  		}  		else {  			windowXMin = windowCoords [i + 1].X;  			windowXMax = windowCoords [i].X;  		}  		//same for the Y value  		if (localX.Y > 0) {  			windowYMin = windowCoords [i].Y;  			windowYMax = windowCoords [i + 1].Y;  		}  		else {  			windowYMin = windowCoords [i + 1].Y;  			windowYMax = windowCoords [i].Y;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < 0.0001)) {  	//if localX axis X component is positive  	//it must be true that the second window coordinate X value is greater than the first's  	if (localX.X > 0) {  		windowXMin = windowCoords [i].X;  		windowXMax = windowCoords [i + 1].X;  	}  	else {  		windowXMin = windowCoords [i + 1].X;  		windowXMax = windowCoords [i].X;  	}  	//same for the Y value  	if (localX.Y > 0) {  		windowYMin = windowCoords [i].Y;  		windowYMax = windowCoords [i + 1].Y;  	}  	else {  		windowYMin = windowCoords [i + 1].Y;  		windowYMax = windowCoords [i].Y;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if ((Math.Abs (vector.X - localX.X) < .0001) && (Math.Abs (vector.Y - localX.Y) < 0.0001)) {  	//if localX axis X component is positive  	//it must be true that the second window coordinate X value is greater than the first's  	if (localX.X > 0) {  		windowXMin = windowCoords [i].X;  		windowXMax = windowCoords [i + 1].X;  	}  	else {  		windowXMin = windowCoords [i + 1].X;  		windowXMax = windowCoords [i].X;  	}  	//same for the Y value  	if (localX.Y > 0) {  		windowYMin = windowCoords [i].Y;  		windowYMax = windowCoords [i + 1].Y;  	}  	else {  		windowYMin = windowCoords [i + 1].Y;  		windowYMax = windowCoords [i].Y;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distancetoLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distancetoLR = Math.Sqrt (distancetoLR);  	if (distanceToLL < distancetoLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X > 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y < 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  else if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetWindowWriteDirectionGeneral,The following statement contains a magic number: if (localX.X < 0 && localX.Y > 0) {  	double distanceToLL = Math.Pow (Math.Abs (surfaceXMax - windowXMax)' 2) + Math.Pow (Math.Abs (surfaceYMin - windowYMin)' 2);  	distanceToLL = Math.Sqrt (distanceToLL);  	double distanceToLR = Math.Pow (Math.Abs (surfaceXMin - windowXMin)' 2) + Math.Pow (Math.Abs (surfaceYMax - windowYMax)' 2);  	distanceToLR = Math.Sqrt (distanceToLR);  	if (distanceToLL < distanceToLR) {  		writeForward = true;  		return writeForward;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4));  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4));  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4));  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: foreach (Vector.CartVect vector in windowVect) {  	double tripleXProduct = vector.X * xProduct.X + vector.Y * xProduct.Y + vector.Z * xProduct.Z;  	if (Math.Abs (tripleXProduct) <= 0.0001)  		isInPlane = true;  	else {  		isInPlane = false;  		makeWindowLogFile.AppendLine ("Window is not in Surface Plane at window Vector: " + windowVectorCounter);  		//isBound is false  		return isBound;  	}  	windowVectorCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (Math.Abs (tripleXProduct) <= 0.0001)  	isInPlane = true;  else {  	isInPlane = false;  	makeWindowLogFile.AppendLine ("Window is not in Surface Plane at window Vector: " + windowVectorCounter);  	//isBound is false  	return isBound;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4));  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4));  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4));  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: foreach (Vector.CartVect vector in windowVect) {  	double tripleXProduct = vector.X * xProduct.X + vector.Y * xProduct.Y + vector.Z * xProduct.Z;  	if (Math.Abs (tripleXProduct) <= 0.0001)  		isInPlane = true;  	else {  		isInPlane = false;  		makeWindowLogFile.AppendLine ("Window is not in Surface Plane at window Vector: " + windowVectorCounter);  		//isBound is false  		return isBound;  	}  	windowVectorCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (Math.Abs (tripleXProduct) <= 0.0001)  	isInPlane = true;  else {  	isInPlane = false;  	makeWindowLogFile.AppendLine ("Window is not in Surface Plane at window Vector: " + windowVectorCounter);  	//isBound is false  	return isBound;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: for (int i = 0; i < windowCoordinates.Count (); i++) {  	if (i == windowCoordinates.Count () - 1) {  		isBound = true;  		makeWindowLogFile.AppendLine ("Window Coordinates are Bound by the Surface Coordinates");  		return isBound;  	}  	if (windowCoordinates [i].X < minX) {  		if (Math.Abs (windowCoordinates [i].X - minX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too small");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].X > maxX) {  		if (Math.Abs (windowCoordinates [i].X - maxX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y < minY) {  		if (Math.Abs (windowCoordinates [i].Y - minY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y > maxY) {  		if (Math.Abs (windowCoordinates [i].Y - maxY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z < minZ) {  		if (Math.Abs (windowCoordinates [i].Z - minZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too large.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z > maxZ) {  		if (Math.Abs (windowCoordinates [i].Z - maxZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: for (int i = 0; i < windowCoordinates.Count (); i++) {  	if (i == windowCoordinates.Count () - 1) {  		isBound = true;  		makeWindowLogFile.AppendLine ("Window Coordinates are Bound by the Surface Coordinates");  		return isBound;  	}  	if (windowCoordinates [i].X < minX) {  		if (Math.Abs (windowCoordinates [i].X - minX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too small");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].X > maxX) {  		if (Math.Abs (windowCoordinates [i].X - maxX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y < minY) {  		if (Math.Abs (windowCoordinates [i].Y - minY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y > maxY) {  		if (Math.Abs (windowCoordinates [i].Y - maxY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z < minZ) {  		if (Math.Abs (windowCoordinates [i].Z - minZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too large.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z > maxZ) {  		if (Math.Abs (windowCoordinates [i].Z - maxZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: for (int i = 0; i < windowCoordinates.Count (); i++) {  	if (i == windowCoordinates.Count () - 1) {  		isBound = true;  		makeWindowLogFile.AppendLine ("Window Coordinates are Bound by the Surface Coordinates");  		return isBound;  	}  	if (windowCoordinates [i].X < minX) {  		if (Math.Abs (windowCoordinates [i].X - minX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too small");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].X > maxX) {  		if (Math.Abs (windowCoordinates [i].X - maxX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y < minY) {  		if (Math.Abs (windowCoordinates [i].Y - minY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y > maxY) {  		if (Math.Abs (windowCoordinates [i].Y - maxY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z < minZ) {  		if (Math.Abs (windowCoordinates [i].Z - minZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too large.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z > maxZ) {  		if (Math.Abs (windowCoordinates [i].Z - maxZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: for (int i = 0; i < windowCoordinates.Count (); i++) {  	if (i == windowCoordinates.Count () - 1) {  		isBound = true;  		makeWindowLogFile.AppendLine ("Window Coordinates are Bound by the Surface Coordinates");  		return isBound;  	}  	if (windowCoordinates [i].X < minX) {  		if (Math.Abs (windowCoordinates [i].X - minX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too small");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].X > maxX) {  		if (Math.Abs (windowCoordinates [i].X - maxX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y < minY) {  		if (Math.Abs (windowCoordinates [i].Y - minY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y > maxY) {  		if (Math.Abs (windowCoordinates [i].Y - maxY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z < minZ) {  		if (Math.Abs (windowCoordinates [i].Z - minZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too large.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z > maxZ) {  		if (Math.Abs (windowCoordinates [i].Z - maxZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: for (int i = 0; i < windowCoordinates.Count (); i++) {  	if (i == windowCoordinates.Count () - 1) {  		isBound = true;  		makeWindowLogFile.AppendLine ("Window Coordinates are Bound by the Surface Coordinates");  		return isBound;  	}  	if (windowCoordinates [i].X < minX) {  		if (Math.Abs (windowCoordinates [i].X - minX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too small");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].X > maxX) {  		if (Math.Abs (windowCoordinates [i].X - maxX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y < minY) {  		if (Math.Abs (windowCoordinates [i].Y - minY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y > maxY) {  		if (Math.Abs (windowCoordinates [i].Y - maxY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z < minZ) {  		if (Math.Abs (windowCoordinates [i].Z - minZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too large.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z > maxZ) {  		if (Math.Abs (windowCoordinates [i].Z - maxZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: for (int i = 0; i < windowCoordinates.Count (); i++) {  	if (i == windowCoordinates.Count () - 1) {  		isBound = true;  		makeWindowLogFile.AppendLine ("Window Coordinates are Bound by the Surface Coordinates");  		return isBound;  	}  	if (windowCoordinates [i].X < minX) {  		if (Math.Abs (windowCoordinates [i].X - minX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too small");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].X > maxX) {  		if (Math.Abs (windowCoordinates [i].X - maxX) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y < minY) {  		if (Math.Abs (windowCoordinates [i].Y - minY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too large");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Y > maxY) {  		if (Math.Abs (windowCoordinates [i].Y - maxY) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z < minZ) {  		if (Math.Abs (windowCoordinates [i].Z - minZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too large.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  	if (windowCoordinates [i].Z > maxZ) {  		if (Math.Abs (windowCoordinates [i].Z - maxZ) > 0.000001) {  			isBound = false;  			makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too small.");  			makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  			return isBound;  		}  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (windowCoordinates [i].X < minX) {  	if (Math.Abs (windowCoordinates [i].X - minX) > 0.000001) {  		isBound = false;  		makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too small");  		makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  		return isBound;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (Math.Abs (windowCoordinates [i].X - minX) > 0.000001) {  	isBound = false;  	makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too small");  	makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  	return isBound;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (windowCoordinates [i].X > maxX) {  	if (Math.Abs (windowCoordinates [i].X - maxX) > 0.000001) {  		isBound = false;  		makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too large");  		makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  		return isBound;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (Math.Abs (windowCoordinates [i].X - maxX) > 0.000001) {  	isBound = false;  	makeWindowLogFile.AppendLine ("Window X is out of bounds.  Too large");  	makeWindowLogFile.AppendLine (windowCoordinates [i].X.ToString ());  	return isBound;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (windowCoordinates [i].Y < minY) {  	if (Math.Abs (windowCoordinates [i].Y - minY) > 0.000001) {  		isBound = false;  		makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too large");  		makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  		return isBound;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (Math.Abs (windowCoordinates [i].Y - minY) > 0.000001) {  	isBound = false;  	makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too large");  	makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  	return isBound;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (windowCoordinates [i].Y > maxY) {  	if (Math.Abs (windowCoordinates [i].Y - maxY) > 0.000001) {  		isBound = false;  		makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too small.");  		makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  		return isBound;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (Math.Abs (windowCoordinates [i].Y - maxY) > 0.000001) {  	isBound = false;  	makeWindowLogFile.AppendLine ("Window Y is out of bounds.  Too small.");  	makeWindowLogFile.AppendLine (windowCoordinates [i].Y.ToString ());  	return isBound;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (windowCoordinates [i].Z < minZ) {  	if (Math.Abs (windowCoordinates [i].Z - minZ) > 0.000001) {  		isBound = false;  		makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too large.");  		makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  		return isBound;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (Math.Abs (windowCoordinates [i].Z - minZ) > 0.000001) {  	isBound = false;  	makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too large.");  	makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  	return isBound;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (windowCoordinates [i].Z > maxZ) {  	if (Math.Abs (windowCoordinates [i].Z - maxZ) > 0.000001) {  		isBound = false;  		makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too small.");  		makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  		return isBound;  	}  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (Math.Abs (windowCoordinates [i].Z - maxZ) > 0.000001) {  	isBound = false;  	makeWindowLogFile.AppendLine ("Window Z is out of bounds.  Too small.");  	makeWindowLogFile.AppendLine (windowCoordinates [i].Z.ToString ());  	return isBound;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4));  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4));  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: makeWindowLogFile.AppendLine ("Parent RHR Vector is [" + Math.Round (xProduct.X' 4) + "'" + Math.Round (xProduct.Y' 4) + "'" + Math.Round (xProduct.Z' 4));  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: foreach (Vector.CartVect vector in windowVect) {  	double tripleXProduct = vector.X * xProduct.X + vector.Y * xProduct.Y + vector.Z * xProduct.Z;  	if (Math.Abs (tripleXProduct) <= 0.0001)  		isInPlane = true;  	else {  		isInPlane = false;  		makeWindowLogFile.AppendLine ("Window is not in Surface Plane at window Vector: " + windowVectorCounter);  		//isBound is false  		return isBound;  	}  	windowVectorCounter++;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,isWindowBound,The following statement contains a magic number: if (Math.Abs (tripleXProduct) <= 0.0001)  	isInPlane = true;  else {  	isInPlane = false;  	makeWindowLogFile.AppendLine ("Window is not in Surface Plane at window Vector: " + windowVectorCounter);  	//isBound is false  	return isBound;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewDLUpperQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < viewOpeningCoords.Count; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = viewOpeningCoords [i].X;  		newWindowCoord.Y = viewOpeningCoords [i].Y;  		newWindowCoord.Z = viewOpeningCoords [i].Z + visionHeight;  		break;  	case 1:  		newWindowCoord.X = viewOpeningCoords [i].X;  		newWindowCoord.Y = viewOpeningCoords [i].Y;  		newWindowCoord.Z = viewOpeningCoords [i].Z + visionHeight;  		break;  	case 2:  		newWindowCoord.X = viewOpeningCoords [i].X;  		newWindowCoord.Y = viewOpeningCoords [i].Y;  		newWindowCoord.Z = viewOpeningCoords [i].Z + dlHeight;  		break;  	case 3:  		newWindowCoord.X = viewOpeningCoords [i].X;  		newWindowCoord.Y = viewOpeningCoords [i].Y;  		newWindowCoord.Z = viewOpeningCoords [i].Z + dlHeight;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewDLUpperQuadPunchedWindowCoordinates,The following statement contains a magic number: for (int i = 0; i < viewOpeningCoords.Count; i++) {  	Vector.CartCoord newWindowCoord = new Vector.CartCoord ();  	//assume that the coordinates both go in the same order  	switch (i) {  	case 0:  		newWindowCoord.X = viewOpeningCoords [i].X;  		newWindowCoord.Y = viewOpeningCoords [i].Y;  		newWindowCoord.Z = viewOpeningCoords [i].Z + visionHeight;  		break;  	case 1:  		newWindowCoord.X = viewOpeningCoords [i].X;  		newWindowCoord.Y = viewOpeningCoords [i].Y;  		newWindowCoord.Z = viewOpeningCoords [i].Z + visionHeight;  		break;  	case 2:  		newWindowCoord.X = viewOpeningCoords [i].X;  		newWindowCoord.Y = viewOpeningCoords [i].Y;  		newWindowCoord.Z = viewOpeningCoords [i].Z + dlHeight;  		break;  	case 3:  		newWindowCoord.X = viewOpeningCoords [i].X;  		newWindowCoord.Y = viewOpeningCoords [i].Y;  		newWindowCoord.Z = viewOpeningCoords [i].Z + dlHeight;  		break;  	}  	newCoords.Add (newWindowCoord);  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewDLUpperQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + visionHeight;  	break;  case 1:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + visionHeight;  	break;  case 2:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + dlHeight;  	break;  case 3:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + dlHeight;  	break;  }  
Magic Number,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewDLUpperQuadPunchedWindowCoordinates,The following statement contains a magic number: switch (i) {  case 0:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + visionHeight;  	break;  case 1:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + visionHeight;  	break;  case 2:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + dlHeight;  	break;  case 3:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + dlHeight;  	break;  }  
Missing Default,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,ModifyWWR,The following switch statement is missing a default case: switch (i) {  case 0:  	double X = surface.SurfaceCoords [i].X;  	double Y = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z = surface.SurfaceCoords [i].Z + sillHeight;  	Vector.MemorySafe_CartCoord newWindowCoord = new Vector.MemorySafe_CartCoord (X' Y' Z);  	newCoords.Add (newWindowCoord);  	break;  case 1:  	double X1 = surface.SurfaceCoords [i].X;  	double Y1 = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z1 = surface.SurfaceCoords [i].Z + sillHeight;  	Vector.MemorySafe_CartCoord newWindowCoord1 = new Vector.MemorySafe_CartCoord (X1' Y1' Z1);  	newCoords.Add (newWindowCoord1);  	break;  case 2:  	double X2 = surface.SurfaceCoords [i].X;  	double Y2 = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z2 = zlow + sillHeight + desiredUserWWR * wallHeight;  	Vector.MemorySafe_CartCoord newWindowCoord2 = new Vector.MemorySafe_CartCoord (X2' Y2' Z2);  	newCoords.Add (newWindowCoord2);  	break;  case 3:  	double X3 = surface.SurfaceCoords [i].X;  	double Y3 = surface.SurfaceCoords [i].Y;  	//this should be settable  	double Z3 = zlow + sillHeight + desiredUserWWR * wallHeight;  	Vector.MemorySafe_CartCoord newWindowCoord3 = new Vector.MemorySafe_CartCoord (X3' Y3' Z3);  	newCoords.Add (newWindowCoord3);  	break;  }  
Missing Default,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,The following switch statement is missing a default case: switch (i) {  case 0:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight;  	zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 1:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 2:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight;  	break;  case 3:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight;  	break;  }  
Missing Default,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadStripWindowCoordinates,The following switch statement is missing a default case: switch (i) {  case 0:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight - dlBuffer;  	zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 1:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = parentSurface.SurfaceCoords [i].Z + sillHeight - dlBuffer;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	break;  case 2:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	if (zLow > parentSurface.SurfaceCoords [i].Z)  		zLow = parentSurface.SurfaceCoords [i].Z;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight - dlBuffer;  	break;  case 3:  	newWindowCoord.X = parentSurface.SurfaceCoords [i].X;  	newWindowCoord.Y = parentSurface.SurfaceCoords [i].Y;  	newWindowCoord.Z = zLow + sillHeight + projectWWR * wallHeight - dlBuffer;  	break;  }  
Missing Default,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following switch statement is missing a default case: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight;  	windowZLow = newWindowCoord.Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight;  	if (windowZLow > newWindowCoord.Z)  		windowZLow = newWindowCoord.Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  }  
Missing Default,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following switch statement is missing a default case: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight - dlBuffer;  	windowZLow = newWindowCoord.Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = zLow + sillHeight - dlBuffer;  	if (windowZLow > newWindowCoord.Z)  		windowZLow = newWindowCoord.Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight - dlBuffer;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight - dlBuffer;  	break;  }  
Missing Default,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following switch statement is missing a default case: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	if (windowZLow > parentWindow.coordinateList [i].Z)  		windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  }  
Missing Default,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following switch statement is missing a default case: switch (i) {  case 0:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 1:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = parentWindow.coordinateList [i].Z;  	if (windowZLow > parentWindow.coordinateList [i].Z)  		windowZLow = parentWindow.coordinateList [i].Z;  	break;  case 2:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  case 3:  	newWindowCoord.X = parentWindow.coordinateList [i].X;  	newWindowCoord.Y = parentWindow.coordinateList [i].Y;  	newWindowCoord.Z = windowZLow + visionHeight;  	break;  }  
Missing Default,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewNormalQuadPunchedWindowCoordinates,The following switch statement is missing a default case: switch (i) {  case 0:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  case 1:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  case 2:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  case 3:  	if (multiplier == 1) {  		newWindowCoord.X = window.coordinateList [i].X;  		newWindowCoord.Y = window.coordinateList [i].Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	else {  		newWindowCoord.X = window.coordinateList [i].X + (windowSpacing + windowWidth) * (multiplier - 1) * localX.X;  		newWindowCoord.Y = window.coordinateList [i].Y + (windowSpacing + windowWidth) * (multiplier - 1) * localX.Y;  		newWindowCoord.Z = window.coordinateList [i].Z;  	}  	break;  }  
Missing Default,EnergyPlus,EPlusFunctions,C:\repos\chiensiTB_EnergyPlusTextParser\EnergyPlus\EPlusObjects.cs,GetNewDLUpperQuadPunchedWindowCoordinates,The following switch statement is missing a default case: switch (i) {  case 0:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + visionHeight;  	break;  case 1:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + visionHeight;  	break;  case 2:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + dlHeight;  	break;  case 3:  	newWindowCoord.X = viewOpeningCoords [i].X;  	newWindowCoord.Y = viewOpeningCoords [i].Y;  	newWindowCoord.Z = viewOpeningCoords [i].Z + dlHeight;  	break;  }  
