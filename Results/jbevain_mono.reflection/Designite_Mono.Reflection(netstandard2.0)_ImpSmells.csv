Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Mono.Reflection,Image,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\Image.cs,IsManagedAssembly,Cyclomatic complexity of the method is 8
Complex Method,Mono.Reflection,MethodBodyReader,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\MethodBodyReader.cs,ReadOperand,Cyclomatic complexity of the method is 17
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt16,The following statement contains a magic number: CheckCanRead (2);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt16,The following statement contains a magic number: short value = (short) (buffer [position]  				| (buffer [position + 1] << 8));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt16,The following statement contains a magic number: position += 2;
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt32,The following statement contains a magic number: CheckCanRead (4);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt32,The following statement contains a magic number: int value = buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt32,The following statement contains a magic number: int value = buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt32,The following statement contains a magic number: int value = buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt32,The following statement contains a magic number: int value = buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt32,The following statement contains a magic number: int value = buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt32,The following statement contains a magic number: position += 4;
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: CheckCanRead (8);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint low = (uint) (buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint low = (uint) (buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint low = (uint) (buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint low = (uint) (buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint low = (uint) (buffer [position]  				| (buffer [position + 1] << 8)  				| (buffer [position + 2] << 16)  				| (buffer [position + 3] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint high = (uint) (buffer [position + 4]  				| (buffer [position + 5] << 8)  				| (buffer [position + 6] << 16)  				| (buffer [position + 7] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint high = (uint) (buffer [position + 4]  				| (buffer [position + 5] << 8)  				| (buffer [position + 6] << 16)  				| (buffer [position + 7] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint high = (uint) (buffer [position + 4]  				| (buffer [position + 5] << 8)  				| (buffer [position + 6] << 16)  				| (buffer [position + 7] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint high = (uint) (buffer [position + 4]  				| (buffer [position + 5] << 8)  				| (buffer [position + 6] << 16)  				| (buffer [position + 7] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint high = (uint) (buffer [position + 4]  				| (buffer [position + 5] << 8)  				| (buffer [position + 6] << 16)  				| (buffer [position + 7] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint high = (uint) (buffer [position + 4]  				| (buffer [position + 5] << 8)  				| (buffer [position + 6] << 16)  				| (buffer [position + 7] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: uint high = (uint) (buffer [position + 4]  				| (buffer [position + 5] << 8)  				| (buffer [position + 6] << 16)  				| (buffer [position + 7] << 24));
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: long value = (((long) high) << 32) | low;
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadInt64,The following statement contains a magic number: position += 8;
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadSingle,The following statement contains a magic number: var bytes = ReadBytes (4);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadSingle,The following statement contains a magic number: CheckCanRead (4);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadSingle,The following statement contains a magic number: position += 4;
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadDouble,The following statement contains a magic number: var bytes = ReadBytes (8);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadDouble,The following statement contains a magic number: CheckCanRead (8);
Magic Number,Mono.Reflection,ByteBuffer,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\ByteBuffer.cs,ReadDouble,The following statement contains a magic number: position += 8;
Magic Number,Mono.Reflection,Image,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\Image.cs,ReadUInt16,The following statement contains a magic number: return (ushort) (stream.ReadByte ()  				| (stream.ReadByte () << 8));
Magic Number,Mono.Reflection,Image,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\Image.cs,ReadUInt32,The following statement contains a magic number: return (uint) (stream.ReadByte ()  				| (stream.ReadByte () << 8)  				| (stream.ReadByte () << 16)  				| (stream.ReadByte () << 24));
Magic Number,Mono.Reflection,Image,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\Image.cs,ReadUInt32,The following statement contains a magic number: return (uint) (stream.ReadByte ()  				| (stream.ReadByte () << 8)  				| (stream.ReadByte () << 16)  				| (stream.ReadByte () << 24));
Magic Number,Mono.Reflection,Image,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\Image.cs,ReadUInt32,The following statement contains a magic number: return (uint) (stream.ReadByte ()  				| (stream.ReadByte () << 8)  				| (stream.ReadByte () << 16)  				| (stream.ReadByte () << 24));
Magic Number,Mono.Reflection,Image,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\Image.cs,IsManagedAssembly,The following statement contains a magic number: stream.Length < 318
Magic Number,Mono.Reflection,Image,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\Image.cs,IsManagedAssembly,The following statement contains a magic number: !Advance (58)
Magic Number,Mono.Reflection,Image,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\Image.cs,IsManagedAssembly,The following statement contains a magic number: !Advance (20)
Magic Number,Mono.Reflection,Image,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\Image.cs,IsManagedAssembly,The following statement contains a magic number: !Advance (ReadUInt16 () == 0x20b ? 222 : 206)
Magic Number,Mono.Reflection,Image,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\Image.cs,IsManagedAssembly,The following statement contains a magic number: !Advance (ReadUInt16 () == 0x20b ? 222 : 206)
Magic Number,Mono.Reflection,MethodBodyReader,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\MethodBodyReader.cs,MethodBodyReader,The following statement contains a magic number: this.instructions = new List<Instruction> ((bytes.Length + 1) / 2);
Magic Number,Mono.Reflection,MethodBodyReader,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\MethodBodyReader.cs,ReadOperand,The following statement contains a magic number: switch (instruction.OpCode.OperandType) {  			case OperandType.InlineNone:  				break;  			case OperandType.InlineSwitch:  				int length = il.ReadInt32 ();  				int base_offset = il.position + (4 * length);  				int [] branches = new int [length];  				for (int i = 0; i < length; i++)  					branches [i] = il.ReadInt32 () + base_offset;    				instruction.Operand = branches;  				break;  			case OperandType.ShortInlineBrTarget:  				instruction.Operand = (((sbyte) il.ReadByte ()) + il.position);  				break;  			case OperandType.InlineBrTarget:  				instruction.Operand = il.ReadInt32 () + il.position;  				break;  			case OperandType.ShortInlineI:  				if (instruction.OpCode == OpCodes.Ldc_I4_S)  					instruction.Operand = (sbyte) il.ReadByte ();  				else  					instruction.Operand = il.ReadByte ();  				break;  			case OperandType.InlineI:  				instruction.Operand = il.ReadInt32 ();  				break;  			case OperandType.ShortInlineR:  				instruction.Operand = il.ReadSingle ();  				break;  			case OperandType.InlineR:  				instruction.Operand = il.ReadDouble ();  				break;  			case OperandType.InlineI8:  				instruction.Operand = il.ReadInt64 ();  				break;  			case OperandType.InlineSig:  				instruction.Operand = module.ResolveSignature (il.ReadInt32 ());  				break;  			case OperandType.InlineString:  				instruction.Operand = module.ResolveString (il.ReadInt32 ());  				break;  			case OperandType.InlineTok:  			case OperandType.InlineType:  			case OperandType.InlineMethod:  			case OperandType.InlineField:  				instruction.Operand = module.ResolveMember (il.ReadInt32 ()' type_arguments' method_arguments);  				break;  			case OperandType.ShortInlineVar:  				instruction.Operand = GetVariable (instruction' il.ReadByte ());  				break;  			case OperandType.InlineVar:  				instruction.Operand = GetVariable (instruction' il.ReadInt16 ());  				break;  			default:  				throw new NotSupportedException ();  			}
Magic Number,Mono.Reflection,MethodBodyReader,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\MethodBodyReader.cs,GetInstruction,The following statement contains a magic number: int mid = min + ((max - min) / 2);
Missing Default,Mono.Reflection,MethodBodyReader,D:\research\architectureSmells\repos\jbevain_mono.reflection\Mono.Reflection\MethodBodyReader.cs,ResolveBranches,The following switch statement is missing a default case: switch (instruction.OpCode.OperandType) {  				case OperandType.ShortInlineBrTarget:  				case OperandType.InlineBrTarget:  					instruction.Operand = GetInstruction (instructions' (int) instruction.Operand);  					break;  				case OperandType.InlineSwitch:  					var offsets = (int []) instruction.Operand;  					var branches = new Instruction [offsets.Length];  					for (int j = 0; j < offsets.Length; j++)  						branches [j] = GetInstruction (instructions' offsets [j]);    					instruction.Operand = branches;  					break;  				}
