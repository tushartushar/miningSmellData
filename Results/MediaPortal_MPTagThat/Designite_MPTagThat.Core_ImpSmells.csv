Implementation smell,Namespace,Class,File,Method,Description
Long Method,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The method has 117 lines of code.
Long Method,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,Create,The method has 295 lines of code.
Long Method,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,SaveFile,The method has 355 lines of code.
Long Method,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The method has 133 lines of code.
Long Method,MPTagThat.Core,ObjectParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\SettingsManager\ObjectParser.cs,Serialize,The method has 116 lines of code.
Long Method,MPTagThat.Core,Options,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Settings\Options.cs,Options,The method has 109 lines of code.
Long Method,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The method has 119 lines of code.
Long Method,MPTagThat.Core,MP3Val,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\MP3Val.cs,ValidateMp3File,The method has 110 lines of code.
Long Method,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,ReplaceParametersWithTrackValues,The method has 107 lines of code.
Long Method,MPTagThat.Core.AudioEncoder,AudioEncoder,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\AudioEncoder\AudioEncoder.cs,SetEncoderSettings,The method has 118 lines of code.
Long Method,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseDescriptionForMediaInfo,The method has 117 lines of code.
Long Method,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,animationTimerTick,The method has 113 lines of code.
Long Method,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The method has 218 lines of code.
Long Method,Stepi.UI,ExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\ExtendedPanel.cs,CollapsingHandler,The method has 176 lines of code.
Long Method,Raccoom.Windows.Forms,TreeViewFolderBrowserDataProviderMusicDb,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewFolderBrowserDataProviderMusicDb.cs,RequestSubDirs,The method has 103 lines of code.
Long Method,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The method has 101 lines of code.
Long Method,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,InitVariables,The method has 142 lines of code.
Complex Method,MPTagThat.Core.AlbumInfo.AlbumSites,Amazon,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSites\Amazon.cs,FillAlbum,Cyclomatic complexity of the method is 16
Complex Method,MPTagThat.Core,ActionHandler,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ActionHandler\ActionHandler.cs,LoadKeyMap,Cyclomatic complexity of the method is 8
Complex Method,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,Create,Cyclomatic complexity of the method is 23
Complex Method,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,SaveFile,Cyclomatic complexity of the method is 38
Complex Method,MPTagThat.Core,ObjectParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\SettingsManager\ObjectParser.cs,Serialize,Cyclomatic complexity of the method is 10
Complex Method,MPTagThat.Core,ObjectParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\SettingsManager\ObjectParser.cs,Deserialize,Cyclomatic complexity of the method is 31
Complex Method,MPTagThat.Core,XmlSettingsProvider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\SettingsManager\XmlSettingsProvider.cs,Save,Cyclomatic complexity of the method is 9
Complex Method,MPTagThat.Core,XmlSettingsProvider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\SettingsManager\XmlSettingsProvider.cs,SetValue,Cyclomatic complexity of the method is 10
Complex Method,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,CheckParameterFormat,Cyclomatic complexity of the method is 13
Complex Method,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,ReplaceParametersWithTrackValues,Cyclomatic complexity of the method is 27
Complex Method,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,RelativePathTo,Cyclomatic complexity of the method is 11
Complex Method,MPTagThat.Core.MusicBrainz,MusicBrainzAlbumInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzAlbumInfo.cs,GetMusicBrainzAlbumById,Cyclomatic complexity of the method is 18
Complex Method,MPTagThat.Core.MusicBrainz,MusicBrainzTrackInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzTrackInfo.cs,ParseMusicBrainzQueryResult,Cyclomatic complexity of the method is 13
Complex Method,Raccoom.Windows.Forms,TreeViewFolderBrowser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewBrowser.cs,ShowFolder,Cyclomatic complexity of the method is 10
Complex Method,Raccoom.Windows.Forms,TreeViewFolderBrowser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewBrowser.cs,MarkNode,Cyclomatic complexity of the method is 9
Complex Method,Raccoom.Windows.Forms,TreeViewFolderBrowserDataProviderMusicDb,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewFolderBrowserDataProviderMusicDb.cs,RequestSubDirs,Cyclomatic complexity of the method is 11
Complex Method,Raccoom.Windows.Forms,TreeViewFolderBrowserDataProviderShell32,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewFolderBrowserDataProviderShell32.cs,FillMyComputer,Cyclomatic complexity of the method is 8
Complex Method,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,Cyclomatic complexity of the method is 13
Complex Method,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,InitVariables,Cyclomatic complexity of the method is 8
Long Parameter List,MPTagThat.Core.AlbumInfo.AlbumSites,AlbumSiteFactory,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSites\AlbumSiteFactory.cs,Create,The method has 5 parameters. Parameters: identifier' artist' album' mEventStopSiteSearches' timeLimit
Long Parameter List,MPTagThat.Core.AlbumInfo.AlbumSites,AlbumSiteFactory,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSites\AlbumSiteFactory.cs,Create,The method has 5 parameters. Parameters: type' artist' album' mEventStopSiteSearches' timeLimit
Long Parameter List,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The method has 9 parameters. Parameters: e' thumbOuterColorPaint' thumbInnerColorPaint' thumbPenColorPaint' barOuterColorPaint' barInnerColorPaint' barPenColorPaint' elapsedOuterColorPaint' elapsedInnerColorPaint
Long Parameter List,MPTagThat.Core,DatagridViewCheckBoxHeaderCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DatagridViewCheckBoxHeaderCell.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' dataGridViewElementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,GetFormattedValue,The method has 6 parameters. Parameters: value' rowIndex' cellStyle' valueTypeConverter' formattedValueTypeConverter' context
Long Parameter List,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The method has 11 parameters. Parameters: g' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,GetFormattedValue,The method has 6 parameters. Parameters: value' rowIndex' cellStyle' valueTypeConverter' formattedValueTypeConverter' context
Long Parameter List,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The method has 11 parameters. Parameters: g' clipBounds' cellBounds' rowIndex' cellState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,GetFormattedValue,The method has 6 parameters. Parameters: value' rowIndex' cellStyle' valueTypeConverter' formattedValueTypeConverter' context
Long Parameter List,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,Paint,The method has 11 parameters. Parameters: graphics' clipBounds' cellBounds' rowIndex' elementState' value' formattedValue' errorText' cellStyle' advancedBorderStyle' paintParts
Long Parameter List,MPTagThat.Core,GridViewColumn,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\GridViewColumn.cs,GridViewColumn,The method has 7 parameters. Parameters: name' type' width' display' readOnly' bound' frozen
Long Parameter List,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,MoveWindow,The method has 6 parameters. Parameters: hWnd' x' y' cx' cy' repaint
Long Parameter List,MPTagThat.Core.MusicBrainz,NativeMethods,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\NativeMethods.cs,ofa_create_print,The method has 6 parameters. Parameters: fingerprint' samples' byteOrder' size' sRate' stereo
Long Parameter List,MPTagThat.Core.Burning,DriveFeatures,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DriveFeatures.cs,DriveFeatures,The method has 14 parameters. Parameters: aReadsCDR' aWriteCDR' aReadsCDRW' aWriteCDRW' aReadsDVDRom' aReadsDVDR' aWriteDVDR' aReadsDVDRam' aWriteDVDRam' aReadsBRRom' aAllowsDummyWrite' aSupportsBurnFree' aMaxReadSpeed' aMaxWriteSpeed
Long Parameter List,MPTagThat.Core.Burning,MediaInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaInfo.cs,MediaInfo,The method has 10 parameters. Parameters: aMediaType' aIsErasable' aDataType' aDiskStatus' aSessionStatus' aBgFormatStatus' aFirstTrack' aTotalSessions' aIsRestricted' aSize
Long Parameter List,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,MediaTypeSupport,The method has 10 parameters. Parameters: aWriteDlDVDRam' aWriteDVDRam' aWriteDlDVDplusR' aWriteDVDplusR' aWriteDVDplusRW' aWriteDlDVDminusR' aWriteDVDminusRW' aWriteDVDminusR' aWriteCDRW' aWriteCDR
Long Parameter List,Stepi.UI,Win32Wrapper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\WIN32Wrapper.cs,SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' X' Y' cx' cy' uFlags
Long Parameter List,Raccoom.Windows.Forms,TreeViewFolderBrowserHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewBrowser.cs,CreateTreeNode,The method has 5 parameters. Parameters: text' path' addDummyNode' forceChecked' isSpecialFolder
Long Parameter List,Raccoom.Windows.Forms,TreeViewFolderBrowserDataProvider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewFolderBrowserDataProvider.cs,CreateTreeNode,The method has 6 parameters. Parameters: helper' text' path' addDummyNode' forceChecked' isSpecialFolder
Long Parameter List,Raccoom.Windows.Forms,TreeViewFolderBrowserDataProviderMusicDb,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewFolderBrowserDataProviderMusicDb.cs,CreateTreeNode,The method has 6 parameters. Parameters: helper' text' path' addDummyNode' forceChecked' isSpecialFolder
Long Parameter List,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,Chkdsk,The method has 6 parameters. Parameters: FixErrors' ForceDismount' OkToRunAtBootUp' RecoverBadSectors' SkipFolderCycle' VigorousIndexCheck
Long Parameter List,Raccoom.Win32,SystemImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,SHParseDisplayName,The method has 5 parameters. Parameters: pszName' pbc' ppidl' sfgaoIn' psfgaoOut
Long Parameter List,Raccoom.Win32,SystemImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,SHGetFileInfo,The method has 5 parameters. Parameters: pszPath' dwFileAttributes' psfi' cbFileInfo' uFlags
Long Parameter List,Raccoom.Win32,SystemImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,SHGetFileInfo,The method has 5 parameters. Parameters: pidl' dwFileAttributes' psfi' cbFileInfo' uFlags
Long Parameter List,Raccoom.Win32,SystemImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,FormatMessage,The method has 7 parameters. Parameters: dwFlags' lpSource' dwMessageId' dwLanguageId' lpBuffer' nSize' argumentsLong
Long Parameter List,Raccoom.Win32,SystemImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,ImageList_Draw,The method has 6 parameters. Parameters: hIml' i' hdcDst' x' y' fStyle
Long Parameter List,Raccoom.Win32,SystemImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,DrawImage,The method has 5 parameters. Parameters: hdc' index' x' y' flags
Long Parameter List,Raccoom.Win32,SystemImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,DrawImage,The method has 7 parameters. Parameters: hdc' index' x' y' flags' cx' cy
Long Parameter List,Raccoom.Win32,SystemImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,DrawImage,The method has 11 parameters. Parameters: hdc' index' x' y' flags' cx' cy' foreColor' stateFlags' saturateColorOrAlpha' glowOrShadowColor
Long Parameter List,Raccoom.Win32,IImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,Merge,The method has 7 parameters. Parameters: i1' punk2' i2' dx' dy' riid' ppv
Long Parameter List,MPTagThat.Core.Freedb,CDInfoDetail,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\CDInfoDetail.cs,CDInfoDetail,The method has 9 parameters. Parameters: discID' artist' title' genre' year' duration' tracks' extd' playorder
Long Parameter List,MPTagThat.Core.Freedb,CDTrackDetail,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\CDTrackDetail.cs,CDTrackDetail,The method has 6 parameters. Parameters: songTitle' artist' extt' trackNumber' offset' duration
Long Parameter List,MPTagThat.Core.Freedb,FreeDBSite,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBSite.cs,FreeDBSite,The method has 7 parameters. Parameters: host' proto' port' uri' latitude' longitude' location
Long Parameter List,MPTagThat.Core.ShellLib,IShellFolder,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\IShellFolder.cs,ParseDisplayName,The method has 6 parameters. Parameters: hwnd' pbc' pszDisplayName' pchEaten' ppidl' pdwAttributes
Long Parameter List,MPTagThat.Core.ShellLib,IShellFolder,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\IShellFolder.cs,GetUIObjectOf,The method has 6 parameters. Parameters: hwndOwner' cidl' apidl' riid' rgfReserved' ppv
Long Parameter List,MPTagThat.Core.ShellLib,IShellFolder,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\IShellFolder.cs,SetNameOf,The method has 5 parameters. Parameters: hwnd' pidl' pszName' uFlags' ppidlOut
Long Parameter List,MPTagThat.Core.ShellLib,ShellApi,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ShellApi.cs,SHGetFolderLocation,The method has 5 parameters. Parameters: hwndOwner' nFolder' hToken' dwReserved' ppidl
Long Parameter List,MPTagThat.Core.ShellLib,ShellApi,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ShellApi.cs,SHGetFolderPath,The method has 5 parameters. Parameters: hwndOwner' nFolder' hToken' dwFlags' pszPath
Long Parameter List,MPTagThat.Core.ShellLib,ShellApi,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ShellApi.cs,SHParseDisplayName,The method has 5 parameters. Parameters: pszName' pbc' ppidl' sfgaoIn' psfgaoOut
Long Parameter List,MPTagThat.Core.ShellLib,ShellApi,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ShellApi.cs,ShellExecute,The method has 6 parameters. Parameters: hwnd' lpOperation' lpFile' lpParameters' lpDirectory' nShowCmd
Long Parameter List,MPTagThat.Core.ShellLib,ShellApi,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ShellApi.cs,SHInvokePrinterCommand,The method has 5 parameters. Parameters: hwnd' uAction' lpBuf1' lpBuf2' fModal
Long Identifier,MPTagThat.Core.AlbumInfo.AlbumSites,AlbumSiteFactory,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSites\AlbumSiteFactory.cs,,The length of the parameter NoPaymentprocessorHasBeenRegisteredWithTheIdentifier is 52.
Long Identifier,Stepi.UI,ExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\ExtendedPanel.cs,,The length of the parameter callbackNotifyAnimationFinished is 31.
Long Identifier,Raccoom.Win32,SystemImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,,The length of the parameter FORMAT_MESSAGE_ALLOCATE_BUFFER is 30.
Long Statement,MPTagThat.Core.AlbumInfo,AlbumSearch,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSearch.cs,RunSearchForSiteInThread,The length of the statement  "        var albumSearchSite = AlbumSiteFactory.Create(albumInfoSite' _artist' _albumTitle' _mEventStopSiteSearches' TimeLimitForSite); " is 126.
Long Statement,MPTagThat.Core.AlbumInfo,AlbumSearch,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSearch.cs,ValidateSearchOutput,The length of the statement  "					ServiceScope.Get<ILogger>().GetLogger.Debug("{0} Albums: {1} Searched: {2} Sites Count: {3}"' site' albums.Count' _mSitesSearched' AlbumSites.Count); " is 149.
Long Statement,MPTagThat.Core.AlbumInfo.AlbumSites,LastFM,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSites\LastFM.cs,GetAlbumInfoWithTimer,The length of the statement  "				album.MediumImageUrl = lastfmAlbum.Images.First(image => image.ImageSize == LastFMImage.LastFMImageSize.Large).ImageURL; " is 120.
Long Statement,MPTagThat.Core.AlbumInfo.AlbumSites,MusicBrainz,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSites\MusicBrainz.cs,GetAlbumQuery,The length of the statement  "			var mbAlbum = albums.Items.FirstOrDefault(r => (r.Title != null && r.Title.ToLower() == albumName.ToLower()) && (r.Country != null && r.Country.ToLower() == Options.MainSettings.AmazonSite.ToLower())); " is 201.
Long Statement,MPTagThat.Core.AlbumInfo.AlbumSites,MusicBrainz,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSites\MusicBrainz.cs,GetAlbumQuery,The length of the statement  "				mbAlbum = albums.Items.FirstOrDefault(r => (r.Title != null && r.Title.ToLower() == albumName.ToLower()) && (r.Country != null && r.Country.ToLower() == "xe")); " is 160.
Long Statement,MPTagThat.Core.AlbumInfo.AlbumSites,MusicBrainz,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSites\MusicBrainz.cs,GetAlbumQuery,The length of the statement  "					mbAlbum = albums.Items.FirstOrDefault(r => (r.Title != null && r.Title.ToLower() == albumName.ToLower()) && (r.Country != null && r.Country.ToLower() == "us")); " is 160.
Long Statement,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The length of the statement  "      this.labelHeader.Font = new System.Drawing.Font("Microsoft Sans Serif"' 12F' System.Drawing.FontStyle.Regular' System.Drawing.GraphicsUnit.Point' ((byte)(0))); " is 159.
Long Statement,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,Create,The length of the statement  "        track.ReplayGainTrack = double.IsNaN(file.Tag.ReplayGainTrackGain) ? "" : file.Tag.ReplayGainTrackGain.ToString(CultureInfo.InvariantCulture); " is 142.
Long Statement,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,Create,The length of the statement  "        track.ReplayGainTrackPeak = double.IsNaN(file.Tag.ReplayGainTrackPeak) ? "" : file.Tag.ReplayGainTrackPeak.ToString(CultureInfo.InvariantCulture); " is 146.
Long Statement,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,Create,The length of the statement  "        track.ReplayGainAlbum = double.IsNaN(file.Tag.ReplayGainAlbumGain) ? "" : file.Tag.ReplayGainAlbumGain.ToString(CultureInfo.InvariantCulture); " is 142.
Long Statement,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,Create,The length of the statement  "        track.ReplayGainAlbumPeak = double.IsNaN(file.Tag.ReplayGainAlbumPeak) ? "" : file.Tag.ReplayGainAlbumPeak.ToString(CultureInfo.InvariantCulture); " is 146.
Long Statement,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The length of the statement  "              using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation)) " is 151.
Long Statement,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,InitializeComponent,The length of the statement  "      this.labelResize.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 150.
Long Statement,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,InitializeComponent,The length of the statement  "      this.labelResize.Font = new System.Drawing.Font("Marlett"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(2))); " is 145.
Long Statement,MPTagThat.Core,FileLogger,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Logger\FileLogger.cs,ReplaceNumber,The length of the statement  "      return pattern.Substring(0' firstPart) + Convert.ToString(value' 10).PadLeft(numDigits' '0') + pattern.Substring(lastPart); " is 123.
Long Statement,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,GetAvailableDrives,The length of the statement  "              "BurnManager: Drive {0} available for reading only. Supporting CD: {1}' DVD: {2}' DVD-RAM: {3}' BD-ROM: {4}' MaxReadSpeed: {5}"' " is 128.
Long Statement,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,ExecuteProcReturnStdOut,The length of the statement  "              //CdrProc.PriorityClass = ProcessPriorityClass.BelowNormal;            // Execute all processes in the background so movies' etc stay fluent " is 140.
Long Statement,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,InitVariables,The length of the statement  "      /*Tracks from compilation-like albums have their own nomenclature in FreeDB (cf. http://www.freedb.org/modules.php?name=Sections&sop=viewarticle&artid=26#2-2)' track tags have to be pre-processed " is 195.
Long Statement,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,InitVariables,The length of the statement  "      The only difficulty here is whether or not some Artist or Title names may contain legitimate " / "' regarding FreeDB nomenclature it is illegal " is 143.
Long Statement,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,InitVariables,The length of the statement  "      We split the string even if we're not sure this CD is a real compilation: it is usually no use to try to figure out if the CD is an actual compilation by looking at its Artist tag (album Artist tag = "((Various)|(Assorted))(Artists)?") because most annotators don't tag it that way " is 281.
Long Statement,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,InitVariables,The length of the statement  "      Extended to the detection of " - " as well' a lot of FreeDB annotators do not follow the above rule and split the Artist from the Title name this way; this workaround is a hell more tricky' a few legitimate tags may be badly cut " is 228.
Long Statement,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,extendedParseTrackTitle,The length of the statement  "        //A lot of annotators don't use the standard " / " to split the Artist name from the Title name' instead they rely on the unconventional " - " delimiter " is 152.
Long Statement,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,extendedParseTrackArtist,The length of the statement  "        //A lot of annotators don't use the standard " / " to split the Artist name from the Title name' instead they rely on the unconventional " - " delimiter " is 152.
Long Statement,MPTagThat.Core.Services.MusicDatabase,MusicDatabase,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MusicDatabase\MusicDatabase.cs,UpdateTrack,The length of the statement  "        var dbTracks = _session.Advanced.DocumentQuery<TrackData' DefaultSearchIndex>().WhereEquals("Query"' originalFileName).ToList(); " is 128.
Long Statement,MPTagThat.Core.Services.MusicDatabase,MusicDatabase,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MusicDatabase\MusicDatabase.cs,ScanShare_Completed,The length of the statement  "        Util.SendProgress(string.Format(ServiceScope.Get<ILocalisation>().ToString("Database"' "DBScanFinished")' _audioFiles' ts.Hours' ts.Minutes' ts.Seconds)); " is 154.
Complex Conditional,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,SaveFile,The conditional expression  "track.Readonly && !Options.MainSettings.ChangeReadOnlyAttributte &&              (Options.ReadOnlyFileHandling == 0 || Options.ReadOnlyFileHandling == 2)"  is complex.
Complex Conditional,MPTagThat.Core,DatagridViewCheckBoxHeaderCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DatagridViewCheckBoxHeaderCell.cs,OnMouseClick,The conditional expression  "p.X >= checkBoxLocation.X && p.X <=                                         checkBoxLocation.X + checkBoxSize.Width            && p.Y >= checkBoxLocation.Y && p.Y <=            checkBoxLocation.Y + checkBoxSize.Height"  is complex.
Complex Conditional,MPTagThat.Core,ObjectParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\SettingsManager\ObjectParser.cs,isCLRType,The conditional expression  "(aType == typeof (int))            || (aType == typeof (string))            || (aType == typeof (bool))            || (aType == typeof (float))            || (aType == typeof (double))            || (aType == typeof (UInt32))            || (aType == typeof (UInt64))            || (aType == typeof (UInt16))            || (aType == typeof (DateTime))            //|| (aType == typeof(string?))            || (aType == typeof (bool?))            || (aType == typeof (float?))            || (aType == typeof (double?))            || (aType == typeof (UInt32?))            || (aType == typeof (UInt64?))            || (aType == typeof (UInt16?))            || (aType == typeof (Int32?))            || (aType == typeof (Int64?))            || (aType == typeof (Int16?))"  is complex.
Complex Conditional,MPTagThat.Core,XmlNoNamespaceWriter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\SettingsManager\XmlNoNamespaceWriter.cs,WriteStartAttribute,The conditional expression  "(prefix != null && prefix.CompareTo("xmlns") == 0) ||            (localName != null && localName.CompareTo("xmlns") == 0)"  is complex.
Complex Conditional,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,CheckParameterFormat,The conditional expression  "formattype == Options.ParameterFormat.FileNameToTag || formattype == Options.ParameterFormat.TagToFileName ||            formattype == Options.ParameterFormat.RipFileName || formattype == Options.ParameterFormat.Organise"  is complex.
Complex Conditional,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,CheckParameterFormat,The conditional expression  "(str.IndexOf("<") >= 0 || str.IndexOf(">") >= 0) ||            (str.IndexOf("\x0001\x0001") >= 0 && formattype == Options.ParameterFormat.FileNameToTag)"  is complex.
Complex Conditional,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnMouseMove,The conditional expression  "e.X >= rr.X && e.X <= rr.X + rr.Width && e.Y >= rr.Y && e.Y <= rr.Y + rr.Height"  is complex.
Complex Conditional,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnClick,The conditional expression  "controlToHide != null && hot &&            currentState != SplitterState.Collapsing &&            currentState != SplitterState.Expanding"  is complex.
Complex Conditional,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The conditional expression  "(Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)"  is complex.
Complex Conditional,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The conditional expression  "(Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)"  is complex.
Complex Conditional,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The conditional expression  "(Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)"  is complex.
Complex Conditional,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The conditional expression  "(Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)"  is complex.
Complex Conditional,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The conditional expression  "((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0))"  is complex.
Empty Catch Block,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,Create,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,Create,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,Create,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core,LocalisationProvider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Localisation\LocalisationProvider.cs,ToString,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core,LocalisationProvider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Localisation\LocalisationProvider.cs,GetAvailableLangauges,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core,FileLogger,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Logger\FileLogger.cs,ArchiveLogs,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core,FileLogger,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Logger\FileLogger.cs,ArchiveLogs,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core,ObjectParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\SettingsManager\ObjectParser.cs,Deserialize,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core,ObjectParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\SettingsManager\ObjectParser.cs,Deserialize,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core,XmlSettingsProvider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\SettingsManager\XmlSettingsProvider.cs,Save,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,CalcTotalBytesOfDirInfo,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,StdErrDataReceived,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Burning,DriveFeatures,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DriveFeatures.cs,ParseSpeed,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Common,Picture,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Picture.cs,ImageFromData,The method has an empty catch block.
Empty Catch Block,Raccoom.Windows.Forms,TreeViewFolderBrowser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewBrowser.cs,MarkNode,The method has an empty catch block.
Empty Catch Block,Raccoom.Windows.Forms,TreeViewFolderBrowserDataProvider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewFolderBrowserDataProvider.cs,RequestSubDirs,The method has an empty catch block.
Empty Catch Block,Raccoom.Windows.Forms,MenuItemShellVerb,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewFolderBrowserDataProviderShell32.cs,OnClick,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetStreamFromSite,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,InitVariables,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,parseOffsets,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,parseLength,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,parseRevision,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,parseYear,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,parsePlayOrder,The method has an empty catch block.
Empty Catch Block,MPTagThat.Core.Services.MusicDatabase,MusicDatabase,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MusicDatabase\MusicDatabase.cs,StoreCoverArt,The method has an empty catch block.
Magic Number,MPTagThat.Core.AlbumInfo.AlbumSites,Amazon,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSites\Amazon.cs,GetAlbumInfoWithTimer,The following statement contains a magic number: while (Complete == false)        {          if (MEventStopSiteSearches.WaitOne(500' true))          {            Complete = true;          }        }
Magic Number,MPTagThat.Core.AlbumInfo.AlbumSites,LastFM,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSites\LastFM.cs,SwitchArtist,The following statement contains a magic number: if (iPos > 0)  			{  				artist = String.Format("{0} {1}"' artist.Substring(iPos + 2)' artist.Substring(0' iPos));  			}
Magic Number,MPTagThat.Core.AlbumInfo.AlbumSites,MusicBrainz,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\AlbumInfo\AlbumSites\MusicBrainz.cs,SwitchArtist,The following statement contains a magic number: if (iPos > 0)  			{  				artist = String.Format("{0} {1}"' artist.Substring(iPos + 2)' artist.Substring(0' iPos));  			}
Magic Number,MPTagThat.Core,SongList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\SongList.cs,CopyLIstToDatabase,The following statement contains a magic number: BulkInsertOptions bulkInsertOptions = new BulkInsertOptions        {          BatchSize = 1000'          OverwriteExisting = true        };
Magic Number,MPTagThat.Core,ActionHandler,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ActionHandler\ActionHandler.cs,GetAction,The following statement contains a magic number: if ((int)key > 47 && (int)key < 91) return false;
Magic Number,MPTagThat.Core,ActionHandler,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ActionHandler\ActionHandler.cs,GetAction,The following statement contains a magic number: if ((int)key > 47 && (int)key < 91) return false;
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.labelHeader.Location = new System.Drawing.Point(21' 19);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.labelHeader.Location = new System.Drawing.Point(21' 19);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.labelHeader.Size = new System.Drawing.Size(62' 20);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.labelHeader.Size = new System.Drawing.Size(62' 20);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.labelHeader.TabIndex = 24;
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.lbExplanation.Location = new System.Drawing.Point(21' 89);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.lbExplanation.Location = new System.Drawing.Point(21' 89);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.lbExplanation.Size = new System.Drawing.Size(529' 61);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.lbExplanation.Size = new System.Drawing.Size(529' 61);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.lbExplanation.TabIndex = 25;
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btYes.Location = new System.Drawing.Point(32' 163);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btYes.Location = new System.Drawing.Point(32' 163);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btYes.Size = new System.Drawing.Size(104' 23);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btYes.Size = new System.Drawing.Size(104' 23);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btYes.TabIndex = 26;
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btYesToAll.Location = new System.Drawing.Point(170' 163);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btYesToAll.Location = new System.Drawing.Point(170' 163);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btYesToAll.Size = new System.Drawing.Size(104' 23);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btYesToAll.Size = new System.Drawing.Size(104' 23);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btYesToAll.TabIndex = 27;
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btNo.Location = new System.Drawing.Point(308' 163);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btNo.Location = new System.Drawing.Point(308' 163);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btNo.Size = new System.Drawing.Size(104' 23);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btNo.Size = new System.Drawing.Size(104' 23);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btNo.TabIndex = 28;
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btNoToAll.Location = new System.Drawing.Point(446' 163);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btNoToAll.Location = new System.Drawing.Point(446' 163);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btNoToAll.Size = new System.Drawing.Size(104' 23);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btNoToAll.Size = new System.Drawing.Size(104' 23);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.btNoToAll.TabIndex = 30;
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.lbFile.Location = new System.Drawing.Point(21' 52);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.lbFile.Location = new System.Drawing.Point(21' 52);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.lbFile.Size = new System.Drawing.Size(529' 24);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.lbFile.Size = new System.Drawing.Size(529' 24);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.lbFile.TabIndex = 31;
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(587' 214);
Magic Number,MPTagThat.Core,ReadOnlyDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\ReadOnlyDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(587' 214);
Magic Number,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,Create,The following statement contains a magic number: try        {          track.DurationTimespan = file.Properties.Duration;            int fileLength = (int)(fi.Length / 1024);          track.FileSize = fileLength.ToString();            track.BitRate = file.Properties.AudioBitrate.ToString();          track.SampleRate = file.Properties.AudioSampleRate.ToString();          track.Channels = file.Properties.AudioChannels.ToString();          track.Version = file.Properties.Description;          track.CreationTime = string.Format("{0:yyyy-MM-dd HH:mm:ss}"' fi.CreationTime);          track.LastWriteTime = string.Format("{0:yyyy-MM-dd HH:mm:ss}"' fi.LastWriteTime);        }        catch (Exception ex)        {          log.Error("Exception setting Properties for file: {0}. {1}"' fileName' ex.Message);        }
Magic Number,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,SaveFile,The following statement contains a magic number: if (track.Readonly && !Options.MainSettings.ChangeReadOnlyAttributte &&              (Options.ReadOnlyFileHandling == 0 || Options.ReadOnlyFileHandling == 2))        {          Form dlg = new ReadOnlyDialog(track.FullFileName);          DialogResult dlgResult = dlg.ShowDialog();            switch (dlgResult)          {            case DialogResult.Yes:              Options.ReadOnlyFileHandling = 0; // Yes               break;              case DialogResult.OK:              Options.ReadOnlyFileHandling = 1; // Yes to All               break;              case DialogResult.No:              Options.ReadOnlyFileHandling = 2; // No               break;              case DialogResult.Cancel:              Options.ReadOnlyFileHandling = 3; // No to All               break;          }        }
Magic Number,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,SaveFile,The following statement contains a magic number: if (track.Readonly && !Options.MainSettings.ChangeReadOnlyAttributte &&              (Options.ReadOnlyFileHandling == 0 || Options.ReadOnlyFileHandling == 2))        {          Form dlg = new ReadOnlyDialog(track.FullFileName);          DialogResult dlgResult = dlg.ShowDialog();            switch (dlgResult)          {            case DialogResult.Yes:              Options.ReadOnlyFileHandling = 0; // Yes               break;              case DialogResult.OK:              Options.ReadOnlyFileHandling = 1; // Yes to All               break;              case DialogResult.No:              Options.ReadOnlyFileHandling = 2; // No               break;              case DialogResult.Cancel:              Options.ReadOnlyFileHandling = 3; // No to All               break;          }        }
Magic Number,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,SaveFile,The following statement contains a magic number: if (track.Readonly && !Options.MainSettings.ChangeReadOnlyAttributte &&              (Options.ReadOnlyFileHandling == 0 || Options.ReadOnlyFileHandling == 2))        {          Form dlg = new ReadOnlyDialog(track.FullFileName);          DialogResult dlgResult = dlg.ShowDialog();            switch (dlgResult)          {            case DialogResult.Yes:              Options.ReadOnlyFileHandling = 0; // Yes               break;              case DialogResult.OK:              Options.ReadOnlyFileHandling = 1; // Yes to All               break;              case DialogResult.No:              Options.ReadOnlyFileHandling = 2; // No               break;              case DialogResult.Cancel:              Options.ReadOnlyFileHandling = 3; // No to All               break;          }        }
Magic Number,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,SaveFile,The following statement contains a magic number: try        {          // Get the ID3 Frame for ID3 specifc frame handling          TagLib.Id3v1.Tag id3v1tag = null;          TagLib.Id3v2.Tag id3v2tag = null;          if (track.IsMp3)          {            id3v1tag = file.GetTag(TagTypes.Id3v1' true) as TagLib.Id3v1.Tag;            id3v2tag = file.GetTag(TagTypes.Id3v2' true) as TagLib.Id3v2.Tag;          }            // Remove Tags' if they have been removed in TagEdit Panel          foreach (TagLib.TagTypes tagType in track.TagsRemoved)          {            file.RemoveTags(tagType);          }              if (file.Tag != null)          {            #region Main Tags              string[] splitValues = track.Artist.Split(new[] {';'' '|'});            file.Tag.Performers = splitValues;              splitValues = track.AlbumArtist.Split(new[] {';'' '|'});            file.Tag.AlbumArtists = splitValues;              file.Tag.Album = track.Album.Trim();            file.Tag.BeatsPerMinute = (uint) track.BPM;                if (track.Comment != "")            {              file.Tag.Comment = "";              if (track.IsMp3)              {                id3v1tag.Comment = track.Comment;                foreach (Comment comment in track.ID3Comments)                {                  CommentsFrame commentsframe = CommentsFrame.Get(id3v2tag' comment.Description' comment.Language' true);                  commentsframe.Text = comment.Text;                  commentsframe.Description = comment.Description;                  commentsframe.Language = comment.Language;                }              }              else              {                file.Tag.Comment = track.Comment;              }            }            else            {              if (track.IsMp3 && id3v2tag != null)              {                id3v2tag.RemoveFrames("COMM");              }              else              {                file.Tag.Comment = "";              }            }              if (track.IsMp3)            {              id3v2tag.IsCompilation = track.Compilation;            }              file.Tag.Disc = track.DiscNumber;            file.Tag.DiscCount = track.DiscCount;              splitValues = track.Genre.Split(new[] {';'' '|'});            file.Tag.Genres = splitValues;              file.Tag.Title = track.Title;              file.Tag.Track = track.TrackNumber;            file.Tag.TrackCount = track.TrackCount;              file.Tag.Year = (uint) track.Year;              double gain;            if (Double.TryParse(track.ReplayGainTrack' out gain))            {              file.Tag.ReplayGainTrackGain = gain;            }            if (Double.TryParse(track.ReplayGainTrackPeak' out gain))            {              file.Tag.ReplayGainTrackPeak = gain;            }            if (Double.TryParse(track.ReplayGainAlbum' out gain))            {              file.Tag.ReplayGainAlbumGain = gain;            }            if (Double.TryParse(track.ReplayGainAlbumPeak' out gain))            {              file.Tag.ReplayGainAlbumPeak = gain;            }              #endregion              #region Detailed Information              splitValues = track.Composer.Split(new[] {';'' '|'});            file.Tag.Composers = splitValues;            file.Tag.Conductor = track.Conductor;            file.Tag.Copyright = track.Copyright;            file.Tag.Grouping = track.Grouping;              splitValues = track.ArtistSortName.Split(new[] {';'' '|'});            file.Tag.PerformersSort = splitValues;            splitValues = track.AlbumArtistSortName.Split(new[] {';'' '|'});            file.Tag.AlbumArtistsSort = splitValues;            file.Tag.AlbumSort = track.AlbumSortName;            file.Tag.TitleSort = track.TitleSortName;              #endregion              #region Picture              List<TagLib.Picture> pics = new List<TagLib.Picture>();            foreach (Picture pic in track.Pictures)            {              TagLib.Picture tagPic = new TagLib.Picture();                try              {                byte[] byteArray = pic.Data;                ByteVector data = new ByteVector(byteArray);                tagPic.Data = data;                tagPic.Description = pic.Description;                tagPic.MimeType = "image/jpg";                tagPic.Type = pic.Type;                pics.Add(tagPic);              }              catch (Exception ex)              {                log.Error("Error saving Picture: {0}"' ex.Message);              }                file.Tag.Pictures = pics.ToArray();            }              // Clear the picture            if (track.Pictures.Count == 0)            {              file.Tag.Pictures = pics.ToArray();            }              #endregion              #region Lyrics              if (track.Lyrics != null && track.Lyrics != "")            {              file.Tag.Lyrics = track.Lyrics;              if (track.IsMp3)              {                foreach (Lyric lyric in track.LyricsFrames)                {                  UnsynchronisedLyricsFrame lyricframe = UnsynchronisedLyricsFrame.Get(id3v2tag' lyric.Description'                    lyric.Language' true);                  lyricframe.Text = lyric.Text;                  lyricframe.Description = lyric.Description;                  lyricframe.Language = lyric.Language;                }              }              else                file.Tag.Lyrics = track.Lyrics;            }            else            {              file.Tag.Lyrics = "";            }              #endregion              #region Ratings              if (track.IsMp3)            {              if (track.Ratings.Count > 0)              {                foreach (PopmFrame rating in track.Ratings)                {                  PopularimeterFrame popmFrame = PopularimeterFrame.Get(id3v2tag' rating.User' true);                  popmFrame.Rating = Convert.ToByte(rating.Rating);                  popmFrame.PlayCount = Convert.ToUInt32(rating.PlayCount);                }              }              else              {                id3v2tag.RemoveFrames("POPM");              }            }            else if (track.TagType == "ogg" || track.TagType == "flac")            {              if (track.Ratings.Count > 0)              {                XiphComment xiph = file.GetTag(TagLib.TagTypes.Xiph' true) as XiphComment;                xiph.SetField("RATING"' track.Rating.ToString());              }            }              #endregion              #region Non- Standard Taglib and User Defined Frames              if (Options.MainSettings.ClearUserFrames)            {              foreach (Frame frame in track.UserFrames)              {                ByteVector frameId = new ByteVector(frame.Id);                  if (frame.Id == "TXXX")                {                  id3v2tag.SetUserTextAsString(frame.Description' "");                }                else                {                  id3v2tag.SetTextFrame(frameId' "");                }              }            }              List<Frame> allFrames = new List<Frame>();            allFrames.AddRange(track.Frames);              // The only way to avoid duplicates of User Frames is to delete them by assigning blank values to them            if (track.SavedUserFrames != null && !Options.MainSettings.ClearUserFrames)            {              // Clean the previously saved Userframes' to avoid duplicates              foreach (Frame frame in track.SavedUserFrames)              {                ByteVector frameId = new ByteVector(frame.Id);                  if (frame.Id == "TXXX")                {                  id3v2tag.SetUserTextAsString(frame.Description' "");                }                else                {                  id3v2tag.SetTextFrame(frameId' "");                }              }                allFrames.AddRange(track.UserFrames);            }              foreach (Frame frame in allFrames)            {              ByteVector frameId = new ByteVector(frame.Id);                // The only way to avoid duplicates of User Frames is to delete them by assigning blank values to them              if (frame.Id == "TXXX")              {                if (frame.Description != "")                {                  id3v2tag.SetUserTextAsString(frame.Description' "");                  id3v2tag.SetUserTextAsString(frame.Description' frame.Value);                }              }              else              {                id3v2tag.SetTextFrame(frameId' "");                id3v2tag.SetTextFrame(frameId' frame.Value);              }            }              #endregion                // Now' depending on which frames the user wants to save' we will remove the other Frames            file = Util.FormatID3Tag(file);              // Set the encoding for ID3 Tags            if (track.IsMp3)            {              TagLib.Id3v2.Tag.ForceDefaultEncoding = true;              switch (Options.MainSettings.CharacterEncoding)              {                case 0:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.Latin1;                  break;                  case 1:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16;                  break;                  case 2:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16BE;                  break;                  case 3:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF8;                  break;                  case 4:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16LE;                  break;              }            }          }          // Save the file          file.Save();        }        catch (Exception ex)        {          log.Error("File Save: Error processing file: {0} {1}"' track.FullFileName' ex.Message);          errorMessage = ServiceScope.Get<ILocalisation>().ToString("message"' "ErrorSave");          error = true;        }
Magic Number,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,SaveFile,The following statement contains a magic number: try        {          // Get the ID3 Frame for ID3 specifc frame handling          TagLib.Id3v1.Tag id3v1tag = null;          TagLib.Id3v2.Tag id3v2tag = null;          if (track.IsMp3)          {            id3v1tag = file.GetTag(TagTypes.Id3v1' true) as TagLib.Id3v1.Tag;            id3v2tag = file.GetTag(TagTypes.Id3v2' true) as TagLib.Id3v2.Tag;          }            // Remove Tags' if they have been removed in TagEdit Panel          foreach (TagLib.TagTypes tagType in track.TagsRemoved)          {            file.RemoveTags(tagType);          }              if (file.Tag != null)          {            #region Main Tags              string[] splitValues = track.Artist.Split(new[] {';'' '|'});            file.Tag.Performers = splitValues;              splitValues = track.AlbumArtist.Split(new[] {';'' '|'});            file.Tag.AlbumArtists = splitValues;              file.Tag.Album = track.Album.Trim();            file.Tag.BeatsPerMinute = (uint) track.BPM;                if (track.Comment != "")            {              file.Tag.Comment = "";              if (track.IsMp3)              {                id3v1tag.Comment = track.Comment;                foreach (Comment comment in track.ID3Comments)                {                  CommentsFrame commentsframe = CommentsFrame.Get(id3v2tag' comment.Description' comment.Language' true);                  commentsframe.Text = comment.Text;                  commentsframe.Description = comment.Description;                  commentsframe.Language = comment.Language;                }              }              else              {                file.Tag.Comment = track.Comment;              }            }            else            {              if (track.IsMp3 && id3v2tag != null)              {                id3v2tag.RemoveFrames("COMM");              }              else              {                file.Tag.Comment = "";              }            }              if (track.IsMp3)            {              id3v2tag.IsCompilation = track.Compilation;            }              file.Tag.Disc = track.DiscNumber;            file.Tag.DiscCount = track.DiscCount;              splitValues = track.Genre.Split(new[] {';'' '|'});            file.Tag.Genres = splitValues;              file.Tag.Title = track.Title;              file.Tag.Track = track.TrackNumber;            file.Tag.TrackCount = track.TrackCount;              file.Tag.Year = (uint) track.Year;              double gain;            if (Double.TryParse(track.ReplayGainTrack' out gain))            {              file.Tag.ReplayGainTrackGain = gain;            }            if (Double.TryParse(track.ReplayGainTrackPeak' out gain))            {              file.Tag.ReplayGainTrackPeak = gain;            }            if (Double.TryParse(track.ReplayGainAlbum' out gain))            {              file.Tag.ReplayGainAlbumGain = gain;            }            if (Double.TryParse(track.ReplayGainAlbumPeak' out gain))            {              file.Tag.ReplayGainAlbumPeak = gain;            }              #endregion              #region Detailed Information              splitValues = track.Composer.Split(new[] {';'' '|'});            file.Tag.Composers = splitValues;            file.Tag.Conductor = track.Conductor;            file.Tag.Copyright = track.Copyright;            file.Tag.Grouping = track.Grouping;              splitValues = track.ArtistSortName.Split(new[] {';'' '|'});            file.Tag.PerformersSort = splitValues;            splitValues = track.AlbumArtistSortName.Split(new[] {';'' '|'});            file.Tag.AlbumArtistsSort = splitValues;            file.Tag.AlbumSort = track.AlbumSortName;            file.Tag.TitleSort = track.TitleSortName;              #endregion              #region Picture              List<TagLib.Picture> pics = new List<TagLib.Picture>();            foreach (Picture pic in track.Pictures)            {              TagLib.Picture tagPic = new TagLib.Picture();                try              {                byte[] byteArray = pic.Data;                ByteVector data = new ByteVector(byteArray);                tagPic.Data = data;                tagPic.Description = pic.Description;                tagPic.MimeType = "image/jpg";                tagPic.Type = pic.Type;                pics.Add(tagPic);              }              catch (Exception ex)              {                log.Error("Error saving Picture: {0}"' ex.Message);              }                file.Tag.Pictures = pics.ToArray();            }              // Clear the picture            if (track.Pictures.Count == 0)            {              file.Tag.Pictures = pics.ToArray();            }              #endregion              #region Lyrics              if (track.Lyrics != null && track.Lyrics != "")            {              file.Tag.Lyrics = track.Lyrics;              if (track.IsMp3)              {                foreach (Lyric lyric in track.LyricsFrames)                {                  UnsynchronisedLyricsFrame lyricframe = UnsynchronisedLyricsFrame.Get(id3v2tag' lyric.Description'                    lyric.Language' true);                  lyricframe.Text = lyric.Text;                  lyricframe.Description = lyric.Description;                  lyricframe.Language = lyric.Language;                }              }              else                file.Tag.Lyrics = track.Lyrics;            }            else            {              file.Tag.Lyrics = "";            }              #endregion              #region Ratings              if (track.IsMp3)            {              if (track.Ratings.Count > 0)              {                foreach (PopmFrame rating in track.Ratings)                {                  PopularimeterFrame popmFrame = PopularimeterFrame.Get(id3v2tag' rating.User' true);                  popmFrame.Rating = Convert.ToByte(rating.Rating);                  popmFrame.PlayCount = Convert.ToUInt32(rating.PlayCount);                }              }              else              {                id3v2tag.RemoveFrames("POPM");              }            }            else if (track.TagType == "ogg" || track.TagType == "flac")            {              if (track.Ratings.Count > 0)              {                XiphComment xiph = file.GetTag(TagLib.TagTypes.Xiph' true) as XiphComment;                xiph.SetField("RATING"' track.Rating.ToString());              }            }              #endregion              #region Non- Standard Taglib and User Defined Frames              if (Options.MainSettings.ClearUserFrames)            {              foreach (Frame frame in track.UserFrames)              {                ByteVector frameId = new ByteVector(frame.Id);                  if (frame.Id == "TXXX")                {                  id3v2tag.SetUserTextAsString(frame.Description' "");                }                else                {                  id3v2tag.SetTextFrame(frameId' "");                }              }            }              List<Frame> allFrames = new List<Frame>();            allFrames.AddRange(track.Frames);              // The only way to avoid duplicates of User Frames is to delete them by assigning blank values to them            if (track.SavedUserFrames != null && !Options.MainSettings.ClearUserFrames)            {              // Clean the previously saved Userframes' to avoid duplicates              foreach (Frame frame in track.SavedUserFrames)              {                ByteVector frameId = new ByteVector(frame.Id);                  if (frame.Id == "TXXX")                {                  id3v2tag.SetUserTextAsString(frame.Description' "");                }                else                {                  id3v2tag.SetTextFrame(frameId' "");                }              }                allFrames.AddRange(track.UserFrames);            }              foreach (Frame frame in allFrames)            {              ByteVector frameId = new ByteVector(frame.Id);                // The only way to avoid duplicates of User Frames is to delete them by assigning blank values to them              if (frame.Id == "TXXX")              {                if (frame.Description != "")                {                  id3v2tag.SetUserTextAsString(frame.Description' "");                  id3v2tag.SetUserTextAsString(frame.Description' frame.Value);                }              }              else              {                id3v2tag.SetTextFrame(frameId' "");                id3v2tag.SetTextFrame(frameId' frame.Value);              }            }              #endregion                // Now' depending on which frames the user wants to save' we will remove the other Frames            file = Util.FormatID3Tag(file);              // Set the encoding for ID3 Tags            if (track.IsMp3)            {              TagLib.Id3v2.Tag.ForceDefaultEncoding = true;              switch (Options.MainSettings.CharacterEncoding)              {                case 0:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.Latin1;                  break;                  case 1:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16;                  break;                  case 2:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16BE;                  break;                  case 3:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF8;                  break;                  case 4:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16LE;                  break;              }            }          }          // Save the file          file.Save();        }        catch (Exception ex)        {          log.Error("File Save: Error processing file: {0} {1}"' track.FullFileName' ex.Message);          errorMessage = ServiceScope.Get<ILocalisation>().ToString("message"' "ErrorSave");          error = true;        }
Magic Number,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,SaveFile,The following statement contains a magic number: try        {          // Get the ID3 Frame for ID3 specifc frame handling          TagLib.Id3v1.Tag id3v1tag = null;          TagLib.Id3v2.Tag id3v2tag = null;          if (track.IsMp3)          {            id3v1tag = file.GetTag(TagTypes.Id3v1' true) as TagLib.Id3v1.Tag;            id3v2tag = file.GetTag(TagTypes.Id3v2' true) as TagLib.Id3v2.Tag;          }            // Remove Tags' if they have been removed in TagEdit Panel          foreach (TagLib.TagTypes tagType in track.TagsRemoved)          {            file.RemoveTags(tagType);          }              if (file.Tag != null)          {            #region Main Tags              string[] splitValues = track.Artist.Split(new[] {';'' '|'});            file.Tag.Performers = splitValues;              splitValues = track.AlbumArtist.Split(new[] {';'' '|'});            file.Tag.AlbumArtists = splitValues;              file.Tag.Album = track.Album.Trim();            file.Tag.BeatsPerMinute = (uint) track.BPM;                if (track.Comment != "")            {              file.Tag.Comment = "";              if (track.IsMp3)              {                id3v1tag.Comment = track.Comment;                foreach (Comment comment in track.ID3Comments)                {                  CommentsFrame commentsframe = CommentsFrame.Get(id3v2tag' comment.Description' comment.Language' true);                  commentsframe.Text = comment.Text;                  commentsframe.Description = comment.Description;                  commentsframe.Language = comment.Language;                }              }              else              {                file.Tag.Comment = track.Comment;              }            }            else            {              if (track.IsMp3 && id3v2tag != null)              {                id3v2tag.RemoveFrames("COMM");              }              else              {                file.Tag.Comment = "";              }            }              if (track.IsMp3)            {              id3v2tag.IsCompilation = track.Compilation;            }              file.Tag.Disc = track.DiscNumber;            file.Tag.DiscCount = track.DiscCount;              splitValues = track.Genre.Split(new[] {';'' '|'});            file.Tag.Genres = splitValues;              file.Tag.Title = track.Title;              file.Tag.Track = track.TrackNumber;            file.Tag.TrackCount = track.TrackCount;              file.Tag.Year = (uint) track.Year;              double gain;            if (Double.TryParse(track.ReplayGainTrack' out gain))            {              file.Tag.ReplayGainTrackGain = gain;            }            if (Double.TryParse(track.ReplayGainTrackPeak' out gain))            {              file.Tag.ReplayGainTrackPeak = gain;            }            if (Double.TryParse(track.ReplayGainAlbum' out gain))            {              file.Tag.ReplayGainAlbumGain = gain;            }            if (Double.TryParse(track.ReplayGainAlbumPeak' out gain))            {              file.Tag.ReplayGainAlbumPeak = gain;            }              #endregion              #region Detailed Information              splitValues = track.Composer.Split(new[] {';'' '|'});            file.Tag.Composers = splitValues;            file.Tag.Conductor = track.Conductor;            file.Tag.Copyright = track.Copyright;            file.Tag.Grouping = track.Grouping;              splitValues = track.ArtistSortName.Split(new[] {';'' '|'});            file.Tag.PerformersSort = splitValues;            splitValues = track.AlbumArtistSortName.Split(new[] {';'' '|'});            file.Tag.AlbumArtistsSort = splitValues;            file.Tag.AlbumSort = track.AlbumSortName;            file.Tag.TitleSort = track.TitleSortName;              #endregion              #region Picture              List<TagLib.Picture> pics = new List<TagLib.Picture>();            foreach (Picture pic in track.Pictures)            {              TagLib.Picture tagPic = new TagLib.Picture();                try              {                byte[] byteArray = pic.Data;                ByteVector data = new ByteVector(byteArray);                tagPic.Data = data;                tagPic.Description = pic.Description;                tagPic.MimeType = "image/jpg";                tagPic.Type = pic.Type;                pics.Add(tagPic);              }              catch (Exception ex)              {                log.Error("Error saving Picture: {0}"' ex.Message);              }                file.Tag.Pictures = pics.ToArray();            }              // Clear the picture            if (track.Pictures.Count == 0)            {              file.Tag.Pictures = pics.ToArray();            }              #endregion              #region Lyrics              if (track.Lyrics != null && track.Lyrics != "")            {              file.Tag.Lyrics = track.Lyrics;              if (track.IsMp3)              {                foreach (Lyric lyric in track.LyricsFrames)                {                  UnsynchronisedLyricsFrame lyricframe = UnsynchronisedLyricsFrame.Get(id3v2tag' lyric.Description'                    lyric.Language' true);                  lyricframe.Text = lyric.Text;                  lyricframe.Description = lyric.Description;                  lyricframe.Language = lyric.Language;                }              }              else                file.Tag.Lyrics = track.Lyrics;            }            else            {              file.Tag.Lyrics = "";            }              #endregion              #region Ratings              if (track.IsMp3)            {              if (track.Ratings.Count > 0)              {                foreach (PopmFrame rating in track.Ratings)                {                  PopularimeterFrame popmFrame = PopularimeterFrame.Get(id3v2tag' rating.User' true);                  popmFrame.Rating = Convert.ToByte(rating.Rating);                  popmFrame.PlayCount = Convert.ToUInt32(rating.PlayCount);                }              }              else              {                id3v2tag.RemoveFrames("POPM");              }            }            else if (track.TagType == "ogg" || track.TagType == "flac")            {              if (track.Ratings.Count > 0)              {                XiphComment xiph = file.GetTag(TagLib.TagTypes.Xiph' true) as XiphComment;                xiph.SetField("RATING"' track.Rating.ToString());              }            }              #endregion              #region Non- Standard Taglib and User Defined Frames              if (Options.MainSettings.ClearUserFrames)            {              foreach (Frame frame in track.UserFrames)              {                ByteVector frameId = new ByteVector(frame.Id);                  if (frame.Id == "TXXX")                {                  id3v2tag.SetUserTextAsString(frame.Description' "");                }                else                {                  id3v2tag.SetTextFrame(frameId' "");                }              }            }              List<Frame> allFrames = new List<Frame>();            allFrames.AddRange(track.Frames);              // The only way to avoid duplicates of User Frames is to delete them by assigning blank values to them            if (track.SavedUserFrames != null && !Options.MainSettings.ClearUserFrames)            {              // Clean the previously saved Userframes' to avoid duplicates              foreach (Frame frame in track.SavedUserFrames)              {                ByteVector frameId = new ByteVector(frame.Id);                  if (frame.Id == "TXXX")                {                  id3v2tag.SetUserTextAsString(frame.Description' "");                }                else                {                  id3v2tag.SetTextFrame(frameId' "");                }              }                allFrames.AddRange(track.UserFrames);            }              foreach (Frame frame in allFrames)            {              ByteVector frameId = new ByteVector(frame.Id);                // The only way to avoid duplicates of User Frames is to delete them by assigning blank values to them              if (frame.Id == "TXXX")              {                if (frame.Description != "")                {                  id3v2tag.SetUserTextAsString(frame.Description' "");                  id3v2tag.SetUserTextAsString(frame.Description' frame.Value);                }              }              else              {                id3v2tag.SetTextFrame(frameId' "");                id3v2tag.SetTextFrame(frameId' frame.Value);              }            }              #endregion                // Now' depending on which frames the user wants to save' we will remove the other Frames            file = Util.FormatID3Tag(file);              // Set the encoding for ID3 Tags            if (track.IsMp3)            {              TagLib.Id3v2.Tag.ForceDefaultEncoding = true;              switch (Options.MainSettings.CharacterEncoding)              {                case 0:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.Latin1;                  break;                  case 1:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16;                  break;                  case 2:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16BE;                  break;                  case 3:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF8;                  break;                  case 4:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16LE;                  break;              }            }          }          // Save the file          file.Save();        }        catch (Exception ex)        {          log.Error("File Save: Error processing file: {0} {1}"' track.FullFileName' ex.Message);          errorMessage = ServiceScope.Get<ILocalisation>().ToString("message"' "ErrorSave");          error = true;        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnPaint,The following statement contains a magic number: if (!Enabled)        {          Color[] desaturatedColors = DesaturateColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                       barOuterColor' barInnerColor' barPenColor'                                                       elapsedOuterColor' elapsedInnerColor);          DrawColorSlider(e' desaturatedColors[0]' desaturatedColors[1]' desaturatedColors[2]'                          desaturatedColors[3]'                          desaturatedColors[4]' desaturatedColors[5]' desaturatedColors[6]' desaturatedColors[7]);        }        else        {          if (mouseEffects && mouseInRegion)          {            Color[] lightenedColors = LightenColors(thumbOuterColor' thumbInnerColor' thumbPenColor'                                                    barOuterColor' barInnerColor' barPenColor'                                                    elapsedOuterColor' elapsedInnerColor);            DrawColorSlider(e' lightenedColors[0]' lightenedColors[1]' lightenedColors[2]' lightenedColors[3]'                            lightenedColors[4]' lightenedColors[5]' lightenedColors[6]' lightenedColors[7]);          }          else          {            DrawColorSlider(e' thumbOuterColor' thumbInnerColor' thumbPenColor'                            barOuterColor' barInnerColor' barPenColor'                            elapsedOuterColor' elapsedInnerColor);          }        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DrawColorSlider,The following statement contains a magic number: try        {          //set up thumbRect aproprietly          if (barOrientation == Orientation.Horizontal)          {            int TrackX = (((trackerValue - barMinimum) * (ClientRectangle.Width - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(TrackX' 1' thumbSize - 1' ClientRectangle.Height - 3);          }          else          {            int TrackY = (((trackerValue - barMinimum) * (ClientRectangle.Height - thumbSize)) / (barMaximum - barMinimum));            thumbRect = new Rectangle(1' TrackY' ClientRectangle.Width - 3' thumbSize - 1);          }            //adjust drawing rects          barRect = ClientRectangle;          thumbHalfRect = thumbRect;          LinearGradientMode gradientOrientation;          if (barOrientation == Orientation.Horizontal)          {            barRect.Inflate(-1' -barRect.Height / 3);            barHalfRect = barRect;            barHalfRect.Height /= 2;            gradientOrientation = LinearGradientMode.Vertical;            thumbHalfRect.Height /= 2;            elapsedRect = barRect;            elapsedRect.Width = thumbRect.Left + thumbSize / 2;          }          else          {            barRect.Inflate(-barRect.Width / 3' -1);            barHalfRect = barRect;            barHalfRect.Width /= 2;            gradientOrientation = LinearGradientMode.Horizontal;            thumbHalfRect.Width /= 2;            elapsedRect = barRect;            elapsedRect.Height = thumbRect.Top + thumbSize / 2;          }          //get thumb shape path           GraphicsPath thumbPath;          if (thumbCustomShape == null)            thumbPath = CreateRoundRectPath(thumbRect' thumbRoundRectSize);          else          {            thumbPath = thumbCustomShape;            Matrix m = new Matrix();            m.Translate(thumbRect.Left - thumbPath.GetBounds().Left' thumbRect.Top - thumbPath.GetBounds().Top);            thumbPath.Transform(m);          }            //draw bar          using (            LinearGradientBrush lgbBar =              new LinearGradientBrush(barHalfRect' barOuterColorPaint' barInnerColorPaint' gradientOrientation)            )          {            lgbBar.WrapMode = WrapMode.TileFlipXY;            e.Graphics.FillRectangle(lgbBar' barRect);            //draw elapsed bar            using (              LinearGradientBrush lgbElapsed =                new LinearGradientBrush(barHalfRect' elapsedOuterColorPaint' elapsedInnerColorPaint'                                        gradientOrientation))            {              lgbElapsed.WrapMode = WrapMode.TileFlipXY;              if (Capture && drawSemitransparentThumb)              {                Region elapsedReg = new Region(elapsedRect);                elapsedReg.Exclude(thumbPath);                e.Graphics.FillRegion(lgbElapsed' elapsedReg);              }              else                e.Graphics.FillRectangle(lgbElapsed' elapsedRect);            }            //draw bar band                                using (Pen barPen = new Pen(barPenColorPaint' 0.5f))            {              e.Graphics.DrawRectangle(barPen' barRect);            }          }            //draw thumb          Color newthumbOuterColorPaint = thumbOuterColorPaint' newthumbInnerColorPaint = thumbInnerColorPaint;          if (Capture && drawSemitransparentThumb)          {            newthumbOuterColorPaint = Color.FromArgb(175' thumbOuterColorPaint);            newthumbInnerColorPaint = Color.FromArgb(175' thumbInnerColorPaint);          }          using (            LinearGradientBrush lgbThumb =              new LinearGradientBrush(thumbHalfRect' newthumbOuterColorPaint' newthumbInnerColorPaint'                                      gradientOrientation))          {            lgbThumb.WrapMode = WrapMode.TileFlipXY;            e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;            e.Graphics.FillPath(lgbThumb' thumbPath);            //draw thumb band            Color newThumbPenColor = thumbPenColorPaint;            if (mouseEffects && (Capture || mouseInThumbRegion))              newThumbPenColor = ControlPaint.Dark(newThumbPenColor);            using (Pen thumbPen = new Pen(newThumbPenColor))            {              e.Graphics.DrawPath(thumbPen' thumbPath);            }            //gp.Dispose();                                /*if (Capture || mouseInThumbRegion)                using (LinearGradientBrush lgbThumb2 = new LinearGradientBrush(thumbHalfRect' Color.FromArgb(150' Color.Blue)' Color.Transparent' gradientOrientation))                {                    lgbThumb2.WrapMode = WrapMode.TileFlipXY;                    e.Graphics.FillPath(lgbThumb2' gp);                }*/          }            //draw focusing rectangle          if (Focused & drawFocusRectangle)            using (Pen p = new Pen(Color.FromArgb(200' barPenColorPaint)))            {              p.DashStyle = DashStyle.Dot;              Rectangle r = ClientRectangle;              r.Width -= 2;              r.Height--;              r.X++;              //ControlPaint.DrawFocusRectangle(e.Graphics' r);                                      using (GraphicsPath gpBorder = CreateRoundRectPath(r' borderRoundRectSize))              {                e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                e.Graphics.DrawPath(p' gpBorder);              }            }        }        catch (Exception Err)        {          Console.WriteLine("DrawBackGround Error in " + Name + ":" + Err.Message);        }        finally {}
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnMouseMove,The following statement contains a magic number: if (Capture & e.Button == MouseButtons.Left)        {          ScrollEventType set = ScrollEventType.ThumbPosition;          Point pt = e.Location;          int p = barOrientation == Orientation.Horizontal ? pt.X : pt.Y;          int margin = thumbSize >> 1;          p -= margin;          float coef = (barMaximum - barMinimum) /                       (float)                       ((barOrientation == Orientation.Horizontal ? ClientSize.Width : ClientSize.Height) -                        2 * margin);          trackerValue = (int)(p * coef + barMinimum);            if (trackerValue <= barMinimum)          {            trackerValue = barMinimum;            set = ScrollEventType.First;          }          else if (trackerValue >= barMaximum)          {            trackerValue = barMaximum;            set = ScrollEventType.Last;          }            if (Scroll != null) Scroll(this' new ScrollEventArgs(set' trackerValue));          if (ValueChanged != null) ValueChanged(this' new EventArgs());        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnMouseWheel,The following statement contains a magic number: int v = e.Delta / 120 * (barMaximum - barMinimum) / mouseWheelBarPartitions;
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddLine(rect.Left + size.Width / 2' rect.Top' rect.Right - size.Width / 2' rect.Top);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddLine(rect.Left + size.Width / 2' rect.Top' rect.Right - size.Width / 2' rect.Top);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddArc(rect.Right - size.Width' rect.Top' size.Width' size.Height' 270' 90);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddArc(rect.Right - size.Width' rect.Top' size.Width' size.Height' 270' 90);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddLine(rect.Right' rect.Top + size.Height / 2' rect.Right' rect.Bottom - size.Width / 2);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddLine(rect.Right' rect.Top + size.Height / 2' rect.Right' rect.Bottom - size.Width / 2);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddArc(rect.Right - size.Width' rect.Bottom - size.Height' size.Width' size.Height' 0' 90);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddLine(rect.Right - size.Width / 2' rect.Bottom' rect.Left + size.Width / 2' rect.Bottom);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddLine(rect.Right - size.Width / 2' rect.Bottom' rect.Left + size.Width / 2' rect.Bottom);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddArc(rect.Left' rect.Bottom - size.Height' size.Width' size.Height' 90' 90);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddArc(rect.Left' rect.Bottom - size.Height' size.Width' size.Height' 90' 90);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddLine(rect.Left' rect.Bottom - size.Height / 2' rect.Left' rect.Top + size.Height / 2);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddLine(rect.Left' rect.Bottom - size.Height / 2' rect.Left' rect.Top + size.Height / 2);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddArc(rect.Left' rect.Top' size.Width' size.Height' 180' 90);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,CreateRoundRectPath,The following statement contains a magic number: gp.AddArc(rect.Left' rect.Top' size.Width' size.Height' 180' 90);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DesaturateColors,The following statement contains a magic number: for (int i = 0; i < colorsToDesaturate.Length; i++)        {          //use NTSC weighted avarage          int gray =            (int)(colorsToDesaturate[i].R * 0.3 + colorsToDesaturate[i].G * 0.6 + colorsToDesaturate[i].B * 0.1);          colorsToReturn[i] = Color.FromArgb(-0x010101 * (255 - gray) - 1);        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DesaturateColors,The following statement contains a magic number: for (int i = 0; i < colorsToDesaturate.Length; i++)        {          //use NTSC weighted avarage          int gray =            (int)(colorsToDesaturate[i].R * 0.3 + colorsToDesaturate[i].G * 0.6 + colorsToDesaturate[i].B * 0.1);          colorsToReturn[i] = Color.FromArgb(-0x010101 * (255 - gray) - 1);        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DesaturateColors,The following statement contains a magic number: for (int i = 0; i < colorsToDesaturate.Length; i++)        {          //use NTSC weighted avarage          int gray =            (int)(colorsToDesaturate[i].R * 0.3 + colorsToDesaturate[i].G * 0.6 + colorsToDesaturate[i].B * 0.1);          colorsToReturn[i] = Color.FromArgb(-0x010101 * (255 - gray) - 1);        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,DesaturateColors,The following statement contains a magic number: for (int i = 0; i < colorsToDesaturate.Length; i++)        {          //use NTSC weighted avarage          int gray =            (int)(colorsToDesaturate[i].R * 0.3 + colorsToDesaturate[i].G * 0.6 + colorsToDesaturate[i].B * 0.1);          colorsToReturn[i] = Color.FromArgb(-0x010101 * (255 - gray) - 1);        }
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(200' 30);
Magic Number,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(200' 30);
Magic Number,MPTagThat.Core,DatagridViewCheckBoxHeaderCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DatagridViewCheckBoxHeaderCell.cs,Paint,The following statement contains a magic number: p.X = cellBounds.Location.X +              (cellBounds.Width / 2) - (s.Width / 2);
Magic Number,MPTagThat.Core,DatagridViewCheckBoxHeaderCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DatagridViewCheckBoxHeaderCell.cs,Paint,The following statement contains a magic number: p.X = cellBounds.Location.X +              (cellBounds.Width / 2) - (s.Width / 2);
Magic Number,MPTagThat.Core,DatagridViewCheckBoxHeaderCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DatagridViewCheckBoxHeaderCell.cs,Paint,The following statement contains a magic number: p.Y = cellBounds.Location.Y +              (cellBounds.Height / 2) - (s.Height / 2);
Magic Number,MPTagThat.Core,DatagridViewCheckBoxHeaderCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DatagridViewCheckBoxHeaderCell.cs,Paint,The following statement contains a magic number: p.Y = cellBounds.Location.Y +              (cellBounds.Height / 2) - (s.Height / 2);
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,DataGridViewProgressCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewProgressColumn.cs,Paint,The following statement contains a magic number: if (percentage > 0.0)        {          // Draw the progress bar and the text          g.FillRectangle(new SolidBrush(Color.FromArgb(163' 189' 242))' cellBounds.X + 2' cellBounds.Y + 2'                          Convert.ToInt32((percentage * cellBounds.Width - 4))' cellBounds.Height - 4);          g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }        else        {          // draw the text          if (DataGridView.CurrentRow.Index == rowIndex)            g.DrawString(progressVal + "%"' cellStyle.Font' new SolidBrush(cellStyle.SelectionForeColor)' cellBounds.X + 6'                         cellBounds.Y + 2);          else            g.DrawString(progressVal + "%"' cellStyle.Font' foreColorBrush' cellBounds.X + 6' cellBounds.Y + 2);        }
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,RatingCell,The following statement contains a magic number: starImages = new Image[6];
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,RatingCell,The following statement contains a magic number: starHotImages = new Image[6];
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,RatingCell,The following statement contains a magic number: for (int i = 0; i <= 5; i++)          starImages[i] = (Image)Resources.ResourceManager.GetObject("star" + i);
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,RatingCell,The following statement contains a magic number: for (int i = 0; i <= 5; i++)          starHotImages[i] = (Image)Resources.ResourceManager.GetObject("starhot" + i);
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,GetFormattedValue,The following statement contains a magic number: if ((int)value < 0 || (int)value > 5)          return starImages[0];
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,Paint,The following statement contains a magic number: if (starNumber > -1 && starNumber < 6)          cellImage = starHotImages[starNumber];
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,Paint,The following statement contains a magic number: if (DataGridView.Rows[rowIndex].Selected)        {          cellStyle.BackColor =            ServiceScope.Get<IThemeManager>().CurrentTheme.SelectionBackColor;          }        else        {          if ((string)this.DataGridView.Rows[rowIndex].Tag == "Changed")          {            cellStyle.BackColor =              ServiceScope.Get<IThemeManager>().CurrentTheme.ChangedBackColor;          }          else          {            if (rowIndex % 2 == 0)              cellStyle.BackColor =                ServiceScope.Get<IThemeManager>().CurrentTheme.DefaultBackColor;            else              cellStyle.BackColor =                ServiceScope.Get<IThemeManager>().CurrentTheme.AlternatingRowBackColor;          }        }
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,GetStarFromMouse,The following statement contains a magic number: if (cellBounds.Contains(mouseLocation))        {          int mouseXRelativeToCell = (mouseLocation.X - cellBounds.X);          int imageXArea = (cellBounds.Width / 2) - (IMAGEWIDTH / 2);          if (((mouseXRelativeToCell + 4) < imageXArea) || (mouseXRelativeToCell >= (imageXArea + IMAGEWIDTH)))            return -1;          else          {            int oo =              (int)              Math.Round((((mouseXRelativeToCell - imageXArea + 5) / (float)IMAGEWIDTH) * 5f)'                         MidpointRounding.AwayFromZero);            if (oo > 5 || oo < 0) Debugger.Break();            return oo;          }        }        else          return -1;
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,GetStarFromMouse,The following statement contains a magic number: if (cellBounds.Contains(mouseLocation))        {          int mouseXRelativeToCell = (mouseLocation.X - cellBounds.X);          int imageXArea = (cellBounds.Width / 2) - (IMAGEWIDTH / 2);          if (((mouseXRelativeToCell + 4) < imageXArea) || (mouseXRelativeToCell >= (imageXArea + IMAGEWIDTH)))            return -1;          else          {            int oo =              (int)              Math.Round((((mouseXRelativeToCell - imageXArea + 5) / (float)IMAGEWIDTH) * 5f)'                         MidpointRounding.AwayFromZero);            if (oo > 5 || oo < 0) Debugger.Break();            return oo;          }        }        else          return -1;
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,GetStarFromMouse,The following statement contains a magic number: if (cellBounds.Contains(mouseLocation))        {          int mouseXRelativeToCell = (mouseLocation.X - cellBounds.X);          int imageXArea = (cellBounds.Width / 2) - (IMAGEWIDTH / 2);          if (((mouseXRelativeToCell + 4) < imageXArea) || (mouseXRelativeToCell >= (imageXArea + IMAGEWIDTH)))            return -1;          else          {            int oo =              (int)              Math.Round((((mouseXRelativeToCell - imageXArea + 5) / (float)IMAGEWIDTH) * 5f)'                         MidpointRounding.AwayFromZero);            if (oo > 5 || oo < 0) Debugger.Break();            return oo;          }        }        else          return -1;
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,GetStarFromMouse,The following statement contains a magic number: if (cellBounds.Contains(mouseLocation))        {          int mouseXRelativeToCell = (mouseLocation.X - cellBounds.X);          int imageXArea = (cellBounds.Width / 2) - (IMAGEWIDTH / 2);          if (((mouseXRelativeToCell + 4) < imageXArea) || (mouseXRelativeToCell >= (imageXArea + IMAGEWIDTH)))            return -1;          else          {            int oo =              (int)              Math.Round((((mouseXRelativeToCell - imageXArea + 5) / (float)IMAGEWIDTH) * 5f)'                         MidpointRounding.AwayFromZero);            if (oo > 5 || oo < 0) Debugger.Break();            return oo;          }        }        else          return -1;
Magic Number,MPTagThat.Core,RatingCell,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\DataGridViewRatingColumn.cs,GetStarFromMouse,The following statement contains a magic number: if (cellBounds.Contains(mouseLocation))        {          int mouseXRelativeToCell = (mouseLocation.X - cellBounds.X);          int imageXArea = (cellBounds.Width / 2) - (IMAGEWIDTH / 2);          if (((mouseXRelativeToCell + 4) < imageXArea) || (mouseXRelativeToCell >= (imageXArea + IMAGEWIDTH)))            return -1;          else          {            int oo =              (int)              Math.Round((((mouseXRelativeToCell - imageXArea + 5) / (float)IMAGEWIDTH) * 5f)'                         MidpointRounding.AwayFromZero);            if (oo > 5 || oo < 0) Debugger.Break();            return oo;          }        }        else          return -1;
Magic Number,MPTagThat.Core,MarqueeLabel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\MarqueeLabel.cs,MarqueeLabel,The following statement contains a magic number: Size = new Size(360' 104);
Magic Number,MPTagThat.Core,MarqueeLabel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\MarqueeLabel.cs,MarqueeLabel,The following statement contains a magic number: Size = new Size(360' 104);
Magic Number,MPTagThat.Core,MarqueeLabel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\MarqueeLabel.cs,OnPaint,The following statement contains a magic number: if (_position > 0)        {          _scrollDirection = -_scrollDirection;          _wait = 3; // Pause 3 cycles        }
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,OnLoad,The following statement contains a magic number: if (!base.DesignMode)        {          if (_resizeable)          {            labelResize.MouseDown += labelResize_MouseDown;            labelResize.MouseMove += labelResize_MouseMove;            labelResize.MouseUp += labelResize_MouseUp;            labelResize.Location = new Point(ClientSize.Width - 21' ClientSize.Height - 18);            labelResize.Visible = true;          }          else          {            labelResize.Visible = false;          }          Region = new Region(FormShape);          base.OnLoad(e);        }        else        {          labelResize.Visible = false;        }
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,OnLoad,The following statement contains a magic number: if (!base.DesignMode)        {          if (_resizeable)          {            labelResize.MouseDown += labelResize_MouseDown;            labelResize.MouseMove += labelResize_MouseMove;            labelResize.MouseUp += labelResize_MouseUp;            labelResize.Location = new Point(ClientSize.Width - 21' ClientSize.Height - 18);            labelResize.Visible = true;          }          else          {            labelResize.Visible = false;          }          Region = new Region(FormShape);          base.OnLoad(e);        }        else        {          labelResize.Visible = false;        }
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,labelResize_MouseMove,The following statement contains a magic number: if (_sizing)        {          //Clip cursor to dissallow sizing of form below 100x100          Rectangle ClipRectangle = RectangleToScreen(new Rectangle(100' 100' Width' Height));          ClipRectangle.Offset(_sizeOffset);          Cursor.Clip = ClipRectangle;          ClientSize = new Size(Cursor.Position.X + _sizeOffset.X - Location.X'                                Cursor.Position.Y + _sizeOffset.Y - Location.Y);          labelResize.Location = new Point(Cursor.Position.X + _sizeOffset.X - Location.X - 21'                                           Cursor.Position.Y + _sizeOffset.Y - Location.Y - 18);          Invalidate();        }
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,labelResize_MouseMove,The following statement contains a magic number: if (_sizing)        {          //Clip cursor to dissallow sizing of form below 100x100          Rectangle ClipRectangle = RectangleToScreen(new Rectangle(100' 100' Width' Height));          ClipRectangle.Offset(_sizeOffset);          Cursor.Clip = ClipRectangle;          ClientSize = new Size(Cursor.Position.X + _sizeOffset.X - Location.X'                                Cursor.Position.Y + _sizeOffset.Y - Location.Y);          labelResize.Location = new Point(Cursor.Position.X + _sizeOffset.X - Location.X - 21'                                           Cursor.Position.Y + _sizeOffset.Y - Location.Y - 18);          Invalidate();        }
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,labelResize_MouseMove,The following statement contains a magic number: if (_sizing)        {          //Clip cursor to dissallow sizing of form below 100x100          Rectangle ClipRectangle = RectangleToScreen(new Rectangle(100' 100' Width' Height));          ClipRectangle.Offset(_sizeOffset);          Cursor.Clip = ClipRectangle;          ClientSize = new Size(Cursor.Position.X + _sizeOffset.X - Location.X'                                Cursor.Position.Y + _sizeOffset.Y - Location.Y);          labelResize.Location = new Point(Cursor.Position.X + _sizeOffset.X - Location.X - 21'                                           Cursor.Position.Y + _sizeOffset.Y - Location.Y - 18);          Invalidate();        }
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,labelResize_MouseMove,The following statement contains a magic number: if (_sizing)        {          //Clip cursor to dissallow sizing of form below 100x100          Rectangle ClipRectangle = RectangleToScreen(new Rectangle(100' 100' Width' Height));          ClipRectangle.Offset(_sizeOffset);          Cursor.Clip = ClipRectangle;          ClientSize = new Size(Cursor.Position.X + _sizeOffset.X - Location.X'                                Cursor.Position.Y + _sizeOffset.Y - Location.Y);          labelResize.Location = new Point(Cursor.Position.X + _sizeOffset.X - Location.X - 21'                                           Cursor.Position.Y + _sizeOffset.Y - Location.Y - 18);          Invalidate();        }
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,InitializeComponent,The following statement contains a magic number: this.labelResize.Font = new System.Drawing.Font("Marlett"' 8.25F' System.Drawing.FontStyle.Bold' System.Drawing.GraphicsUnit.Point' ((byte)(2)));
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,InitializeComponent,The following statement contains a magic number: this.labelResize.Location = new System.Drawing.Point(253' 232);
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,InitializeComponent,The following statement contains a magic number: this.labelResize.Location = new System.Drawing.Point(253' 232);
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,InitializeComponent,The following statement contains a magic number: this.labelResize.Size = new System.Drawing.Size(17' 11);
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,InitializeComponent,The following statement contains a magic number: this.labelResize.Size = new System.Drawing.Size(17' 11);
Magic Number,MPTagThat.Core,ShapedForm,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ShapedForm.cs,InitializeComponent,The following statement contains a magic number: this.labelResize.TabIndex = 3;
Magic Number,MPTagThat.Core,LocalisationProvider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Localisation\LocalisationProvider.cs,Clear,The following statement contains a magic number: _characters = 255;
Magic Number,MPTagThat.Core,FileLogger,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Logger\FileLogger.cs,ReplaceNumber,The following statement contains a magic number: int lastPart = pattern.IndexOf("#}"' StringComparison.Ordinal) + 2;
Magic Number,MPTagThat.Core,FileLogger,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Logger\FileLogger.cs,ReplaceNumber,The following statement contains a magic number: int numDigits = lastPart - firstPart - 2;
Magic Number,MPTagThat.Core,FileLogger,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Logger\FileLogger.cs,ReplaceNumber,The following statement contains a magic number: return pattern.Substring(0' firstPart) + Convert.ToString(value' 10).PadLeft(numDigits' '0') + pattern.Substring(lastPart);
Magic Number,MPTagThat.Core,ScriptManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ScriptManager\ScriptManager.cs,GetDescription,The following statement contains a magic number: string[] description = new string[3];
Magic Number,MPTagThat.Core,ScriptManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ScriptManager\ScriptManager.cs,GetDescription,The following statement contains a magic number: try        {          file = File.OpenText(fileName);          string line1 = file.ReadLine();          string line2 = file.ReadLine();            description[0] = Path.GetFileName(fileName);          if (line1.StartsWith("// Title:"))            description[1] = line1.Substring(9).Trim();          else            description[1] = String.Empty;            if (line2.StartsWith("// Description:"))            description[2] = line2.Substring(15).Trim();          else            description[2] = String.Empty;            return description;        }        catch (Exception)        {          return null;        }
Magic Number,MPTagThat.Core,ScriptManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ScriptManager\ScriptManager.cs,GetDescription,The following statement contains a magic number: try        {          file = File.OpenText(fileName);          string line1 = file.ReadLine();          string line2 = file.ReadLine();            description[0] = Path.GetFileName(fileName);          if (line1.StartsWith("// Title:"))            description[1] = line1.Substring(9).Trim();          else            description[1] = String.Empty;            if (line2.StartsWith("// Description:"))            description[2] = line2.Substring(15).Trim();          else            description[2] = String.Empty;            return description;        }        catch (Exception)        {          return null;        }
Magic Number,MPTagThat.Core,ScriptManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ScriptManager\ScriptManager.cs,GetDescription,The following statement contains a magic number: try        {          file = File.OpenText(fileName);          string line1 = file.ReadLine();          string line2 = file.ReadLine();            description[0] = Path.GetFileName(fileName);          if (line1.StartsWith("// Title:"))            description[1] = line1.Substring(9).Trim();          else            description[1] = String.Empty;            if (line2.StartsWith("// Description:"))            description[2] = line2.Substring(15).Trim();          else            description[2] = String.Empty;            return description;        }        catch (Exception)        {          return null;        }
Magic Number,MPTagThat.Core,ScriptManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ScriptManager\ScriptManager.cs,GetDescription,The following statement contains a magic number: try        {          file = File.OpenText(fileName);          string line1 = file.ReadLine();          string line2 = file.ReadLine();            description[0] = Path.GetFileName(fileName);          if (line1.StartsWith("// Title:"))            description[1] = line1.Substring(9).Trim();          else            description[1] = String.Empty;            if (line2.StartsWith("// Description:"))            description[2] = line2.Substring(15).Trim();          else            description[2] = String.Empty;            return description;        }        catch (Exception)        {          return null;        }
Magic Number,MPTagThat.Core,ObjectParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\SettingsManager\ObjectParser.cs,Serialize,The following statement contains a magic number: foreach (PropertyInfo property in obj.GetType().GetProperties())        {          Type thisType = property.PropertyType;          string defaultval = "";            #region CLR Typed property            if (isCLRType(thisType))          {            object[] attributes = property.GetCustomAttributes(typeof (SettingAttribute)' false);            SettingScope scope = SettingScope.Global;            if (attributes.Length != 0)            {              SettingAttribute attribute = (SettingAttribute)attributes[0];              scope = attribute.SettingScope;              defaultval = attribute.DefaultValue;            }            else            {              scope = SettingScope.Global;              defaultval = "";            }            string value = defaultval;              if (!isFirstSave) //else default value will be used if it exists            {              if (obj.GetType().GetProperty(property.Name).GetValue(obj' null) != null)              {                value = obj.GetType().GetProperty(property.Name).GetValue(obj' null).ToString();              }              if (scope == SettingScope.User)              {                userSettingsList.Add(property.Name' value);              }              else              {                globalSettingsList.Add(property.Name' value);              }            }            else            {              if (scope == SettingScope.Global) globalSettingsList.Add(property.Name' value);              if (scope == SettingScope.User) userSettingsList.Add(property.Name' value);            }          }            #endregion              #region not CLR Typed property            else          {            XmlSerializer xmlSerial = new XmlSerializer(thisType);            StringBuilder sb = new StringBuilder();            StringWriter strWriter = new StringWriter(sb);            XmlTextWriter writer = new XmlNoNamespaceWriter(strWriter);            writer.Formatting = Formatting.Indented;            object propertyValue = obj.GetType().GetProperty(property.Name).GetValue(obj' null);            xmlSerial.Serialize(writer' propertyValue);            strWriter.Close();            strWriter.Dispose();            // remove unneeded encoding tag            sb.Remove(0' 41);            object[] attributes = property.GetCustomAttributes(typeof (SettingAttribute)' false);            SettingScope scope = SettingScope.Global;            if (attributes.Length != 0)            {              SettingAttribute attribute = (SettingAttribute)attributes[0];              scope = attribute.SettingScope;              defaultval = attribute.DefaultValue;            }            else            {              scope = SettingScope.Global;              defaultval = "";            }            string value = defaultval;            /// a changer            if (!isFirstSave || defaultval == "") value = sb.ToString();            if (scope == SettingScope.User)            {              userSettingsList.Add(property.Name' value);            }            else            {              globalSettingsList.Add(property.Name' value);            }          }            #endregion        }
Magic Number,MPTagThat.Core,Options,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Settings\Options.cs,Options,The following statement contains a magic number: ReadOnlyFileHandling = 2;
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following statement contains a magic number: foreach (XmlNode themeNode in themesList)        {          XmlAttributeCollection attributes = themeNode.Attributes;          if (attributes.GetNamedItem("name").Value == aTheme)          {            Theme theme = new Theme();            theme.ThemeName = aTheme;            string[] colorArray = attributes.GetNamedItem("BackColor").Value.Split(''');            theme.BackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                             Convert.ToInt16(colorArray[2]));              foreach (XmlNode attr in themeNode.ChildNodes)            {              switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }            }            _currentTheme = theme;            _selectedTheme = aTheme;          }        }
Magic Number,MPTagThat.Core,TrackData,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\TrackData.cs,TrackData,The following statement contains a magic number: ID3Version = 3;
Magic Number,MPTagThat.Core,MP3Val,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\MP3Val.cs,ValidateMp3File,The following statement contains a magic number: if (StdOutList.Count > 2)        {          if (StdOutList[StdOutList.Count - 2].Contains(@"FIXED:"))          {            error = Util.MP3Error.Fixed;          }        }
Magic Number,MPTagThat.Core,MP3Val,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\MP3Val.cs,ValidateMp3File,The following statement contains a magic number: if (StdOutList.Count > 2)        {          if (StdOutList[StdOutList.Count - 2].Contains(@"FIXED:"))          {            error = Util.MP3Error.Fixed;          }        }
Magic Number,MPTagThat.Core,MP3Val,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\MP3Val.cs,FixMp3File,The following statement contains a magic number: if (StdOutList.Count > 2)        {          if (StdOutList[StdOutList.Count - 2].Contains(@"FIXED:"))          {            error = Util.MP3Error.Fixed;          }        }
Magic Number,MPTagThat.Core,MP3Val,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\MP3Val.cs,FixMp3File,The following statement contains a magic number: if (StdOutList.Count > 2)        {          if (StdOutList[StdOutList.Count - 2].Contains(@"FIXED:"))          {            error = Util.MP3Error.Fixed;          }        }
Magic Number,MPTagThat.Core,MP3Val,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\MP3Val.cs,ValidateOrFixFile,The following statement contains a magic number: return ExecuteProcReturnStdOut(parm' 3000);
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,CheckParmWithLengthIndicator,The following statement contains a magic number: char c = s1[3];
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,CheckParmWithLengthIndicator,The following statement contains a magic number: if (s1.Length > 5)          retVal = false;
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,Drive2BassID,The following statement contains a magic number: for (int i = 0; i < 25; i++)        {          if (BassCd.BASS_CD_GetInfo(i' cdinfo))          {            if (cdinfo.DriveLetter == driveLetter)              return i;          }        }
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,FormatID3Tag,The following statement contains a magic number: if (file.MimeType == "taglib/mp3")        {          Tag id3v2_tag = file.GetTag(TagTypes.Id3v2) as Tag;          if (id3v2_tag != null && Options.MainSettings.ID3V2Version > 0)            id3v2_tag.Version = (byte)Options.MainSettings.ID3V2Version;            // Remove V1 Tags' if checked or "Save V2 only checked"          if (Options.MainSettings.RemoveID3V1 || Options.MainSettings.ID3Version == 2)            file.RemoveTags(TagTypes.Id3v1);            // Remove V2 Tags' if checked or "Save V1 only checked"          if (Options.MainSettings.RemoveID3V2 || Options.MainSettings.ID3Version == 1)            file.RemoveTags(TagTypes.Id3v2);            // Remove V2 Tags' if Ape checked          if (Options.MainSettings.ID3V2Version == 0)          {            file.RemoveTags(TagTypes.Id3v2);          }          else          {            file.RemoveTags(TagTypes.Ape);          }        }
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,ReadFullStream,The following statement contains a magic number: if (initialLength < 1)        {          initialLength = 32768;        }
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,ReadFullStream,The following statement contains a magic number: while ((chunk = stream.Read(buffer' read' buffer.Length - read)) > 0)        {          read += chunk;            // If we've reached the end of our buffer' check to see if there's          // any more information          if (read == buffer.Length)          {            int nextByte = stream.ReadByte();              // End of stream? If so' we're done            if (nextByte == -1)            {              return buffer;            }              // Nope. Resize the buffer' put in the byte we've just            // read' and continue            byte[] newBuffer = new byte[buffer.Length * 2];            Array.Copy(buffer' newBuffer' buffer.Length);            newBuffer[read] = (byte)nextByte;            buffer = newBuffer;            read++;          }        }
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,ReplaceStringWithLengthIndicator,The following statement contains a magic number: int strLength = Convert.ToInt32(s1.Substring(3' 1));
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,DurationToSeconds,The following statement contains a magic number: while (index > -1)        {          if (i == 0)          {            // We've got seconds            duration = Convert.ToInt32(durationString.Substring(index + 1));          }          else          {            duration += Convert.ToInt32(durationString.Substring(index + 1)) * (int)Math.Pow(60.0' i);          }            durationString = durationString.Substring(0' index);          index = durationString.LastIndexOf(":");          i++;        }
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,DurationToSeconds,The following statement contains a magic number: if (durationString.Length > 0)        {          duration += Convert.ToInt32(durationString) * (int)Math.Pow(60.0' i);        }
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,SecondsToHMSString,The following statement contains a magic number: int hh = lSeconds / 3600;
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,SecondsToHMSString,The following statement contains a magic number: lSeconds = lSeconds % 3600;
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,SecondsToHMSString,The following statement contains a magic number: int mm = lSeconds / 60;
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,SecondsToHMSString,The following statement contains a magic number: int ss = lSeconds % 60;
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,GetQualifiedFilename,The following statement contains a magic number: if (strFileName.Length <= 2) return;
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,GetQualifiedFilename,The following statement contains a magic number: while (strFileName.StartsWith(@"..\") || strFileName.StartsWith("../"))        {          strFileName = strFileName.Substring(3);          int pos = strBasePath.LastIndexOf(@"\");          if (pos > 0)          {            strBasePath = strBasePath.Substring(0' pos);          }          else          {            pos = strBasePath.LastIndexOf(@"/");            if (pos > 0)            {              strBasePath = strBasePath.Substring(0' pos);            }          }        }
Magic Number,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,GetQualifiedFilename,The following statement contains a magic number: if (strBasePath.Length == 2 && strBasePath[1] == ':')          strBasePath += @"\";
Magic Number,MPTagThat.Core.MusicBrainz,MusicBrainzAlbumInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzAlbumInfo.cs,GetMusicBrainzAlbumById,The following statement contains a magic number: if (nodes != null && nodes.Count > 0)        {          string year = nodes[0].InnerText;          if (year.Length > 4)          {            year = year.Substring(0' 4);          }          album.Year = year;        }        else        {          album.Year = string.Empty;        }
Magic Number,MPTagThat.Core.MusicBrainz,MusicBrainzAlbumInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzAlbumInfo.cs,GetMusicBrainzAlbumById,The following statement contains a magic number: if (nodes != null && nodes.Count > 0)        {          string year = nodes[0].InnerText;          if (year.Length > 4)          {            year = year.Substring(0' 4);          }          album.Year = year;        }        else        {          album.Year = string.Empty;        }
Magic Number,MPTagThat.Core.MusicBrainz,MusicBrainzTrackInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzTrackInfo.cs,GetFingerPrint,The following statement contains a magic number: List<string> fingerPrint = ExecuteProcReturnStdOut("fpcalc.exe"' fopsParam' 40000);
Magic Number,MPTagThat.Core.MusicBrainz,MusicBrainzTrackInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzTrackInfo.cs,GetFingerPrint,The following statement contains a magic number: if (fingerPrint.Count == 3)        {          duration = Convert.ToInt32(fingerPrint[1].Substring(9));          return fingerPrint[2].Substring(12);        }
Magic Number,MPTagThat.Core.MusicBrainz,MusicBrainzTrackInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzTrackInfo.cs,GetFingerPrint,The following statement contains a magic number: if (fingerPrint.Count == 3)        {          duration = Convert.ToInt32(fingerPrint[1].Substring(9));          return fingerPrint[2].Substring(12);        }
Magic Number,MPTagThat.Core.MusicBrainz,MusicBrainzTrackInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzTrackInfo.cs,GetFingerPrint,The following statement contains a magic number: if (fingerPrint.Count == 3)        {          duration = Convert.ToInt32(fingerPrint[1].Substring(9));          return fingerPrint[2].Substring(12);        }
Magic Number,MPTagThat.Core.MusicBrainz,MusicBrainzTrackInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzTrackInfo.cs,GetFingerPrint,The following statement contains a magic number: if (fingerPrint.Count == 3)        {          duration = Convert.ToInt32(fingerPrint[1].Substring(9));          return fingerPrint[2].Substring(12);        }
Magic Number,MPTagThat.Core.MusicBrainz,MusicBrainzTrackInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzTrackInfo.cs,ParseMusicBrainzQueryResult,The following statement contains a magic number: if (nodes != null && nodes.Count > 0)        {          track.Duration = Convert.ToInt32(nodes[0].InnerText) / 1000;        }
Magic Number,MPTagThat.Core.MusicBrainz,MusicBrainzTrackInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzTrackInfo.cs,ParseMusicBrainzQueryResult,The following statement contains a magic number: if (nodes != null)        {          foreach (XmlNode node in nodes)          {            var release = new MusicBrainzRelease();            release.AlbumId = node.Attributes["id"].Value;            foreach (XmlNode childNode in node)            {              if (childNode.Name == "title")                release.Album = childNode.InnerText;                if (childNode.Name == "country")                release.Country = childNode.InnerText;                if (childNode.Name == "date")              {                string year = childNode.InnerText;                if (year.Length > 4)                {                  year = year.Substring(0' 4);                }                release.Year = Convert.ToInt32(year);              }            }            track.Releases.Add(release);          }        }
Magic Number,MPTagThat.Core.MusicBrainz,MusicBrainzTrackInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\MusicBrainz\MusicBrainzTrackInfo.cs,ParseMusicBrainzQueryResult,The following statement contains a magic number: if (nodes != null)        {          foreach (XmlNode node in nodes)          {            var release = new MusicBrainzRelease();            release.AlbumId = node.Attributes["id"].Value;            foreach (XmlNode childNode in node)            {              if (childNode.Name == "title")                release.Album = childNode.InnerText;                if (childNode.Name == "country")                release.Country = childNode.InnerText;                if (childNode.Name == "date")              {                string year = childNode.InnerText;                if (year.Length > 4)                {                  year = year.Substring(0' 4);                }                release.Year = Convert.ToInt32(year);              }            }            track.Releases.Add(release);          }        }
Magic Number,MPTagThat.Core.AudioEncoder,AudioEncoder,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\AudioEncoder\AudioEncoder.cs,StartEncoding,The following statement contains a magic number: byte[] encBuffer = new byte[60000];
Magic Number,MPTagThat.Core.AudioEncoder,AudioEncoder,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\AudioEncoder\AudioEncoder.cs,StartEncoding,The following statement contains a magic number: while (Bass.BASS_ChannelIsActive(stream) == BASSActive.BASS_ACTIVE_PLAYING && !_isAborted)        {          // getting sample data will automatically feed the encoder          int len = Bass.BASS_ChannelGetData(stream' encBuffer' encBuffer.Length);          pos = Bass.BASS_ChannelGetPosition(stream);          double percentComplete = pos / (double)chanLength * 100.0;            // Send the message          msg.MessageData["action"] = "progress";          msg.MessageData["percent"] = percentComplete;          msg.MessageData["rowindex"] = rowIndex;          queue.Send(msg);        }
Magic Number,MPTagThat.Core.AudioEncoder,AudioEncoder,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\AudioEncoder\AudioEncoder.cs,SetEncoderSettings,The following statement contains a magic number: switch (_encoder)        {          case "mp3":            EncoderLAME encLame = new EncoderLAME(stream);            if (Options.MainSettings.RipLameExpert.Length > 0)            {              encLame.LAME_CustomOptions = Options.MainSettings.RipLameExpert;              encLame.LAME_UseCustomOptionsOnly = true;            }            else            {              if (Options.MainSettings.RipLamePreset == (int)Options.LamePreset.ABR)                encLame.LAME_PresetName = Options.MainSettings.RipLameABRBitRate.ToString();              else                encLame.LAME_PresetName =                  Enum.GetName(typeof (Options.LamePreset)' Options.MainSettings.RipLamePreset).ToLower();            }            encoder = encLame;            break;            case "ogg":            EncoderOGG encOgg = new EncoderOGG(stream);            if (Options.MainSettings.RipOggExpert.Length > 0)            {              encOgg.OGG_CustomOptions = Options.MainSettings.RipOggExpert;              encOgg.OGG_UseCustomOptionsOnly = true;            }            else            {              encOgg.OGG_Quality = Convert.ToInt32(Options.MainSettings.RipOggQuality);            }            encoder = encOgg;            break;            case "flac":            EncoderFLAC encFlac = new EncoderFLAC(stream);            if (Options.MainSettings.RipFlacExpert.Length > 0)            {              encFlac.FLAC_CustomOptions = Options.MainSettings.RipFlacExpert;              encFlac.FLAC_UseCustomOptionsOnly = true;            }            else            {              encFlac.FLAC_CompressionLevel = Options.MainSettings.RipFlacQuality;            }            // put a 1k padding block for Tagging in front            encFlac.FLAC_Padding = 1024;            encoder = encFlac;            break;            case "m4a":            EncoderFAAC encAAC = new EncoderFAAC(stream);              int bitrate =              Convert.ToInt32(Options.MainSettings.RipEncoderAACBitRate.Substring(0'                                                                                  Options.MainSettings.                                                                                    RipEncoderAACBitRate.IndexOf(' ')));            encAAC.FAAC_Bitrate = bitrate;            encAAC.FAAC_Quality = 100;            encAAC.FAAC_UseQualityMode = true;            encAAC.FAAC_WrapMP4 = true;              encoder = encAAC;            break;            case "wav":            EncoderWAV encWav = new EncoderWAV(stream);            encoder = encWav;            break;            case "wma":            EncoderWMA encWma = new EncoderWMA(stream);            string[] sampleFormat = Options.MainSettings.RipEncoderWMASample.Split(''');            string encoderFormat = Options.MainSettings.RipEncoderWMA;            if (encoderFormat == "wmapro" || encoderFormat == "wmalossless")              encWma.WMA_UsePro = true;            else              encWma.WMA_ForceStandard = true;              if (Options.MainSettings.RipEncoderWMACbrVbr == "Vbr")            {              encWma.WMA_UseVBR = true;              encWma.WMA_VBRQuality = Convert.ToInt32(Options.MainSettings.RipEncoderWMABitRate);            }            else              encWma.WMA_Bitrate = Convert.ToInt32(Options.MainSettings.RipEncoderWMABitRate) / 1000;                if (sampleFormat[0] == "24")              encWma.WMA_Use24Bit = true;              encoder = encWma;            break;            case "mpc":            EncoderMPC encMpc = new EncoderMPC(stream);            if (Options.MainSettings.RipEncoderMPCExpert.Length > 0)            {              encMpc.MPC_CustomOptions = Options.MainSettings.RipEncoderMPCExpert;              encMpc.MPC_UseCustomOptionsOnly = true;            }            else            {              encMpc.MPC_Preset =                (EncoderMPC.MPCPreset)Enum.Parse(typeof (EncoderMPC.MPCPreset)' Options.MainSettings.RipEncoderMPCPreset);            }            encoder = encMpc;            break;            case "wv":            EncoderWavPack encWv = new EncoderWavPack(stream);            if (Options.MainSettings.RipEncoderWVExpert.Length > 0)            {              encWv.WV_CustomOptions = Options.MainSettings.RipEncoderWVExpert;              encWv.WV_UseCustomOptionsOnly = true;            }            else            {              if (Options.MainSettings.RipEncoderWVPreset == "-f")                encWv.WV_FastMode = true;              else                encWv.WV_HighQuality = true;            }            encoder = encWv;            break;        }
Magic Number,MPTagThat.Core.AudioEncoder,AudioEncoder,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\AudioEncoder\AudioEncoder.cs,SetEncoderSettings,The following statement contains a magic number: switch (_encoder)        {          case "mp3":            EncoderLAME encLame = new EncoderLAME(stream);            if (Options.MainSettings.RipLameExpert.Length > 0)            {              encLame.LAME_CustomOptions = Options.MainSettings.RipLameExpert;              encLame.LAME_UseCustomOptionsOnly = true;            }            else            {              if (Options.MainSettings.RipLamePreset == (int)Options.LamePreset.ABR)                encLame.LAME_PresetName = Options.MainSettings.RipLameABRBitRate.ToString();              else                encLame.LAME_PresetName =                  Enum.GetName(typeof (Options.LamePreset)' Options.MainSettings.RipLamePreset).ToLower();            }            encoder = encLame;            break;            case "ogg":            EncoderOGG encOgg = new EncoderOGG(stream);            if (Options.MainSettings.RipOggExpert.Length > 0)            {              encOgg.OGG_CustomOptions = Options.MainSettings.RipOggExpert;              encOgg.OGG_UseCustomOptionsOnly = true;            }            else            {              encOgg.OGG_Quality = Convert.ToInt32(Options.MainSettings.RipOggQuality);            }            encoder = encOgg;            break;            case "flac":            EncoderFLAC encFlac = new EncoderFLAC(stream);            if (Options.MainSettings.RipFlacExpert.Length > 0)            {              encFlac.FLAC_CustomOptions = Options.MainSettings.RipFlacExpert;              encFlac.FLAC_UseCustomOptionsOnly = true;            }            else            {              encFlac.FLAC_CompressionLevel = Options.MainSettings.RipFlacQuality;            }            // put a 1k padding block for Tagging in front            encFlac.FLAC_Padding = 1024;            encoder = encFlac;            break;            case "m4a":            EncoderFAAC encAAC = new EncoderFAAC(stream);              int bitrate =              Convert.ToInt32(Options.MainSettings.RipEncoderAACBitRate.Substring(0'                                                                                  Options.MainSettings.                                                                                    RipEncoderAACBitRate.IndexOf(' ')));            encAAC.FAAC_Bitrate = bitrate;            encAAC.FAAC_Quality = 100;            encAAC.FAAC_UseQualityMode = true;            encAAC.FAAC_WrapMP4 = true;              encoder = encAAC;            break;            case "wav":            EncoderWAV encWav = new EncoderWAV(stream);            encoder = encWav;            break;            case "wma":            EncoderWMA encWma = new EncoderWMA(stream);            string[] sampleFormat = Options.MainSettings.RipEncoderWMASample.Split(''');            string encoderFormat = Options.MainSettings.RipEncoderWMA;            if (encoderFormat == "wmapro" || encoderFormat == "wmalossless")              encWma.WMA_UsePro = true;            else              encWma.WMA_ForceStandard = true;              if (Options.MainSettings.RipEncoderWMACbrVbr == "Vbr")            {              encWma.WMA_UseVBR = true;              encWma.WMA_VBRQuality = Convert.ToInt32(Options.MainSettings.RipEncoderWMABitRate);            }            else              encWma.WMA_Bitrate = Convert.ToInt32(Options.MainSettings.RipEncoderWMABitRate) / 1000;                if (sampleFormat[0] == "24")              encWma.WMA_Use24Bit = true;              encoder = encWma;            break;            case "mpc":            EncoderMPC encMpc = new EncoderMPC(stream);            if (Options.MainSettings.RipEncoderMPCExpert.Length > 0)            {              encMpc.MPC_CustomOptions = Options.MainSettings.RipEncoderMPCExpert;              encMpc.MPC_UseCustomOptionsOnly = true;            }            else            {              encMpc.MPC_Preset =                (EncoderMPC.MPCPreset)Enum.Parse(typeof (EncoderMPC.MPCPreset)' Options.MainSettings.RipEncoderMPCPreset);            }            encoder = encMpc;            break;            case "wv":            EncoderWavPack encWv = new EncoderWavPack(stream);            if (Options.MainSettings.RipEncoderWVExpert.Length > 0)            {              encWv.WV_CustomOptions = Options.MainSettings.RipEncoderWVExpert;              encWv.WV_UseCustomOptionsOnly = true;            }            else            {              if (Options.MainSettings.RipEncoderWVPreset == "-f")                encWv.WV_FastMode = true;              else                encWv.WV_HighQuality = true;            }            encoder = encWv;            break;        }
Magic Number,MPTagThat.Core.AudioEncoder,AudioEncoder,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\AudioEncoder\AudioEncoder.cs,SetEncoderSettings,The following statement contains a magic number: switch (_encoder)        {          case "mp3":            EncoderLAME encLame = new EncoderLAME(stream);            if (Options.MainSettings.RipLameExpert.Length > 0)            {              encLame.LAME_CustomOptions = Options.MainSettings.RipLameExpert;              encLame.LAME_UseCustomOptionsOnly = true;            }            else            {              if (Options.MainSettings.RipLamePreset == (int)Options.LamePreset.ABR)                encLame.LAME_PresetName = Options.MainSettings.RipLameABRBitRate.ToString();              else                encLame.LAME_PresetName =                  Enum.GetName(typeof (Options.LamePreset)' Options.MainSettings.RipLamePreset).ToLower();            }            encoder = encLame;            break;            case "ogg":            EncoderOGG encOgg = new EncoderOGG(stream);            if (Options.MainSettings.RipOggExpert.Length > 0)            {              encOgg.OGG_CustomOptions = Options.MainSettings.RipOggExpert;              encOgg.OGG_UseCustomOptionsOnly = true;            }            else            {              encOgg.OGG_Quality = Convert.ToInt32(Options.MainSettings.RipOggQuality);            }            encoder = encOgg;            break;            case "flac":            EncoderFLAC encFlac = new EncoderFLAC(stream);            if (Options.MainSettings.RipFlacExpert.Length > 0)            {              encFlac.FLAC_CustomOptions = Options.MainSettings.RipFlacExpert;              encFlac.FLAC_UseCustomOptionsOnly = true;            }            else            {              encFlac.FLAC_CompressionLevel = Options.MainSettings.RipFlacQuality;            }            // put a 1k padding block for Tagging in front            encFlac.FLAC_Padding = 1024;            encoder = encFlac;            break;            case "m4a":            EncoderFAAC encAAC = new EncoderFAAC(stream);              int bitrate =              Convert.ToInt32(Options.MainSettings.RipEncoderAACBitRate.Substring(0'                                                                                  Options.MainSettings.                                                                                    RipEncoderAACBitRate.IndexOf(' ')));            encAAC.FAAC_Bitrate = bitrate;            encAAC.FAAC_Quality = 100;            encAAC.FAAC_UseQualityMode = true;            encAAC.FAAC_WrapMP4 = true;              encoder = encAAC;            break;            case "wav":            EncoderWAV encWav = new EncoderWAV(stream);            encoder = encWav;            break;            case "wma":            EncoderWMA encWma = new EncoderWMA(stream);            string[] sampleFormat = Options.MainSettings.RipEncoderWMASample.Split(''');            string encoderFormat = Options.MainSettings.RipEncoderWMA;            if (encoderFormat == "wmapro" || encoderFormat == "wmalossless")              encWma.WMA_UsePro = true;            else              encWma.WMA_ForceStandard = true;              if (Options.MainSettings.RipEncoderWMACbrVbr == "Vbr")            {              encWma.WMA_UseVBR = true;              encWma.WMA_VBRQuality = Convert.ToInt32(Options.MainSettings.RipEncoderWMABitRate);            }            else              encWma.WMA_Bitrate = Convert.ToInt32(Options.MainSettings.RipEncoderWMABitRate) / 1000;                if (sampleFormat[0] == "24")              encWma.WMA_Use24Bit = true;              encoder = encWma;            break;            case "mpc":            EncoderMPC encMpc = new EncoderMPC(stream);            if (Options.MainSettings.RipEncoderMPCExpert.Length > 0)            {              encMpc.MPC_CustomOptions = Options.MainSettings.RipEncoderMPCExpert;              encMpc.MPC_UseCustomOptionsOnly = true;            }            else            {              encMpc.MPC_Preset =                (EncoderMPC.MPCPreset)Enum.Parse(typeof (EncoderMPC.MPCPreset)' Options.MainSettings.RipEncoderMPCPreset);            }            encoder = encMpc;            break;            case "wv":            EncoderWavPack encWv = new EncoderWavPack(stream);            if (Options.MainSettings.RipEncoderWVExpert.Length > 0)            {              encWv.WV_CustomOptions = Options.MainSettings.RipEncoderWVExpert;              encWv.WV_UseCustomOptionsOnly = true;            }            else            {              if (Options.MainSettings.RipEncoderWVPreset == "-f")                encWv.WV_FastMode = true;              else                encWv.WV_HighQuality = true;            }            encoder = encWv;            break;        }
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,GetCurrentMediaStatus,The following statement contains a magic number: List<string> MediaDescription = new List<string>(94);
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,GetCurrentMediaStatus,The following statement contains a magic number: MediaDescription = DeviceHelper.ExecuteProcReturnStdOut("cdrecord.exe"' cdrParam' 40000);
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseDescriptionForMediaInfo,The following statement contains a magic number: lock (this)        {          if (MediaInfoDescription.Count > 5)          {            for (int i = 0; i < MediaInfoDescription.Count; i++)            {              string checkStr = MediaInfoDescription[i];                if (checkStr.Contains(@"Mounted media type"))              {                // Mounted media type:       DVD+R/DL                // Using generic SCSI-3/mmc-3 DVD+RW driver (mmc_dvdplusrw).                int checkPos = checkStr.IndexOf(@":");                if (checkPos >= 0)                {                  // Assume a disc is there (cdr will close the tray) - if not present it will be set later                  fHasMedia = true;                  string mounted = (checkStr.Substring(checkPos + 1)).Trim();                  checkPos = mounted.IndexOf(@" ");                  if (checkPos >= 0)                    mounted = (mounted.Remove(checkPos));                    switch (mounted)                  {                    case "DVD+R/DL":                      aMediaInfo.CurrentMediaType = MediaType.DlDVDplusR;                      break;                    case "DVD-R/DL":                      aMediaInfo.CurrentMediaType = MediaType.DlDVDminusR;                      break;                    case "DVD+RW":                      aMediaInfo.CurrentMediaType = MediaType.DVDplusRW;                      break;                    case "DVD+R":                      aMediaInfo.CurrentMediaType = MediaType.DVDplusR;                      break;                    case "DVD-RW":                      aMediaInfo.CurrentMediaType = MediaType.DVDminusRW;                      break;                    case "DVD-R":                      aMediaInfo.CurrentMediaType = MediaType.DVDminusR;                      break;                    case "DVD-RAM":                      aMediaInfo.CurrentMediaType = MediaType.DVDRam;                      break;                    case "DVD-ROM":                      aMediaInfo.CurrentMediaType = MediaType.ReadOnly;                      break;                    case "CD-RW":                      aMediaInfo.CurrentMediaType = MediaType.CDRW;                      break;                    case "CD-R":                      aMediaInfo.CurrentMediaType = MediaType.CDR;                      break;                    case "CD-ROM":                      aMediaInfo.CurrentMediaType = MediaType.ReadOnly;                      break;                      default:                      ServiceScope.Get<ILogger>().GetLogger.Debug("Burner: Could not recognize media type: {0}"' mounted);                      aMediaInfo.CurrentMediaType = MediaType.None;                      fHasMedia = false;                      break;                  }                }                else                  aMediaInfo.CurrentMediaType = MediaType.None;              }              else if (checkStr.Contains(@"Disk Is erasable"))              {                aMediaInfo.IsErasable = true;                // cdrecord will use the mmc_cdr driver for CDRW as well                if (aMediaInfo.CurrentMediaType == MediaType.CDR)                  aMediaInfo.CurrentMediaType = MediaType.CDRW;              }              else if (checkStr.Contains(@"data type:"))              {                // data type:                standard                string dataType = checkStr.Substring(11).Trim(trimchars);                aMediaInfo.DataType = dataType;              }              else if (checkStr.Contains(@"disk status:"))              {                // disk status:              empty                string diskStatus = checkStr.Substring(13).Trim(trimchars);                if (diskStatus != "empty")                  aMediaInfo.DiskStatus = BlankStatus.complete;              }              else if (checkStr.Contains(@"session status:"))              {                // session status:           empty                string sessionStatus = checkStr.Substring(16).Trim(trimchars);                if (sessionStatus != "empty")                  aMediaInfo.SessionStatus = BlankStatus.complete;              }              else if (checkStr.Contains(@"Disk Is not unrestricted"))                aMediaInfo.IsRestricted = true; // false reports here?              else              {                //     Capacity  Blklen/Sparesz.  Format-type  Type                //       352965             2048         0x00  Formatted Media                 if (checkStr.Contains(@"Capacity  Blklen/Sparesz."))                {                  string capacity = MediaInfoDescription[i + 1].Trim().Substring(0'                                                                                 MediaInfoDescription[i + 1].Trim().                                                                                   IndexOf(" "));                  aMediaInfo.Size = Convert.ToInt32(capacity);                }              }            }          }          else // Less than 5 lines of info? Tray must be empty          {            fHasMedia = false;            aMediaInfo.CurrentMediaType = MediaType.None;          }            fCurrentMediaInfo = aMediaInfo;        }
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseDescriptionForMediaInfo,The following statement contains a magic number: lock (this)        {          if (MediaInfoDescription.Count > 5)          {            for (int i = 0; i < MediaInfoDescription.Count; i++)            {              string checkStr = MediaInfoDescription[i];                if (checkStr.Contains(@"Mounted media type"))              {                // Mounted media type:       DVD+R/DL                // Using generic SCSI-3/mmc-3 DVD+RW driver (mmc_dvdplusrw).                int checkPos = checkStr.IndexOf(@":");                if (checkPos >= 0)                {                  // Assume a disc is there (cdr will close the tray) - if not present it will be set later                  fHasMedia = true;                  string mounted = (checkStr.Substring(checkPos + 1)).Trim();                  checkPos = mounted.IndexOf(@" ");                  if (checkPos >= 0)                    mounted = (mounted.Remove(checkPos));                    switch (mounted)                  {                    case "DVD+R/DL":                      aMediaInfo.CurrentMediaType = MediaType.DlDVDplusR;                      break;                    case "DVD-R/DL":                      aMediaInfo.CurrentMediaType = MediaType.DlDVDminusR;                      break;                    case "DVD+RW":                      aMediaInfo.CurrentMediaType = MediaType.DVDplusRW;                      break;                    case "DVD+R":                      aMediaInfo.CurrentMediaType = MediaType.DVDplusR;                      break;                    case "DVD-RW":                      aMediaInfo.CurrentMediaType = MediaType.DVDminusRW;                      break;                    case "DVD-R":                      aMediaInfo.CurrentMediaType = MediaType.DVDminusR;                      break;                    case "DVD-RAM":                      aMediaInfo.CurrentMediaType = MediaType.DVDRam;                      break;                    case "DVD-ROM":                      aMediaInfo.CurrentMediaType = MediaType.ReadOnly;                      break;                    case "CD-RW":                      aMediaInfo.CurrentMediaType = MediaType.CDRW;                      break;                    case "CD-R":                      aMediaInfo.CurrentMediaType = MediaType.CDR;                      break;                    case "CD-ROM":                      aMediaInfo.CurrentMediaType = MediaType.ReadOnly;                      break;                      default:                      ServiceScope.Get<ILogger>().GetLogger.Debug("Burner: Could not recognize media type: {0}"' mounted);                      aMediaInfo.CurrentMediaType = MediaType.None;                      fHasMedia = false;                      break;                  }                }                else                  aMediaInfo.CurrentMediaType = MediaType.None;              }              else if (checkStr.Contains(@"Disk Is erasable"))              {                aMediaInfo.IsErasable = true;                // cdrecord will use the mmc_cdr driver for CDRW as well                if (aMediaInfo.CurrentMediaType == MediaType.CDR)                  aMediaInfo.CurrentMediaType = MediaType.CDRW;              }              else if (checkStr.Contains(@"data type:"))              {                // data type:                standard                string dataType = checkStr.Substring(11).Trim(trimchars);                aMediaInfo.DataType = dataType;              }              else if (checkStr.Contains(@"disk status:"))              {                // disk status:              empty                string diskStatus = checkStr.Substring(13).Trim(trimchars);                if (diskStatus != "empty")                  aMediaInfo.DiskStatus = BlankStatus.complete;              }              else if (checkStr.Contains(@"session status:"))              {                // session status:           empty                string sessionStatus = checkStr.Substring(16).Trim(trimchars);                if (sessionStatus != "empty")                  aMediaInfo.SessionStatus = BlankStatus.complete;              }              else if (checkStr.Contains(@"Disk Is not unrestricted"))                aMediaInfo.IsRestricted = true; // false reports here?              else              {                //     Capacity  Blklen/Sparesz.  Format-type  Type                //       352965             2048         0x00  Formatted Media                 if (checkStr.Contains(@"Capacity  Blklen/Sparesz."))                {                  string capacity = MediaInfoDescription[i + 1].Trim().Substring(0'                                                                                 MediaInfoDescription[i + 1].Trim().                                                                                   IndexOf(" "));                  aMediaInfo.Size = Convert.ToInt32(capacity);                }              }            }          }          else // Less than 5 lines of info? Tray must be empty          {            fHasMedia = false;            aMediaInfo.CurrentMediaType = MediaType.None;          }            fCurrentMediaInfo = aMediaInfo;        }
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseDescriptionForMediaInfo,The following statement contains a magic number: lock (this)        {          if (MediaInfoDescription.Count > 5)          {            for (int i = 0; i < MediaInfoDescription.Count; i++)            {              string checkStr = MediaInfoDescription[i];                if (checkStr.Contains(@"Mounted media type"))              {                // Mounted media type:       DVD+R/DL                // Using generic SCSI-3/mmc-3 DVD+RW driver (mmc_dvdplusrw).                int checkPos = checkStr.IndexOf(@":");                if (checkPos >= 0)                {                  // Assume a disc is there (cdr will close the tray) - if not present it will be set later                  fHasMedia = true;                  string mounted = (checkStr.Substring(checkPos + 1)).Trim();                  checkPos = mounted.IndexOf(@" ");                  if (checkPos >= 0)                    mounted = (mounted.Remove(checkPos));                    switch (mounted)                  {                    case "DVD+R/DL":                      aMediaInfo.CurrentMediaType = MediaType.DlDVDplusR;                      break;                    case "DVD-R/DL":                      aMediaInfo.CurrentMediaType = MediaType.DlDVDminusR;                      break;                    case "DVD+RW":                      aMediaInfo.CurrentMediaType = MediaType.DVDplusRW;                      break;                    case "DVD+R":                      aMediaInfo.CurrentMediaType = MediaType.DVDplusR;                      break;                    case "DVD-RW":                      aMediaInfo.CurrentMediaType = MediaType.DVDminusRW;                      break;                    case "DVD-R":                      aMediaInfo.CurrentMediaType = MediaType.DVDminusR;                      break;                    case "DVD-RAM":                      aMediaInfo.CurrentMediaType = MediaType.DVDRam;                      break;                    case "DVD-ROM":                      aMediaInfo.CurrentMediaType = MediaType.ReadOnly;                      break;                    case "CD-RW":                      aMediaInfo.CurrentMediaType = MediaType.CDRW;                      break;                    case "CD-R":                      aMediaInfo.CurrentMediaType = MediaType.CDR;                      break;                    case "CD-ROM":                      aMediaInfo.CurrentMediaType = MediaType.ReadOnly;                      break;                      default:                      ServiceScope.Get<ILogger>().GetLogger.Debug("Burner: Could not recognize media type: {0}"' mounted);                      aMediaInfo.CurrentMediaType = MediaType.None;                      fHasMedia = false;                      break;                  }                }                else                  aMediaInfo.CurrentMediaType = MediaType.None;              }              else if (checkStr.Contains(@"Disk Is erasable"))              {                aMediaInfo.IsErasable = true;                // cdrecord will use the mmc_cdr driver for CDRW as well                if (aMediaInfo.CurrentMediaType == MediaType.CDR)                  aMediaInfo.CurrentMediaType = MediaType.CDRW;              }              else if (checkStr.Contains(@"data type:"))              {                // data type:                standard                string dataType = checkStr.Substring(11).Trim(trimchars);                aMediaInfo.DataType = dataType;              }              else if (checkStr.Contains(@"disk status:"))              {                // disk status:              empty                string diskStatus = checkStr.Substring(13).Trim(trimchars);                if (diskStatus != "empty")                  aMediaInfo.DiskStatus = BlankStatus.complete;              }              else if (checkStr.Contains(@"session status:"))              {                // session status:           empty                string sessionStatus = checkStr.Substring(16).Trim(trimchars);                if (sessionStatus != "empty")                  aMediaInfo.SessionStatus = BlankStatus.complete;              }              else if (checkStr.Contains(@"Disk Is not unrestricted"))                aMediaInfo.IsRestricted = true; // false reports here?              else              {                //     Capacity  Blklen/Sparesz.  Format-type  Type                //       352965             2048         0x00  Formatted Media                 if (checkStr.Contains(@"Capacity  Blklen/Sparesz."))                {                  string capacity = MediaInfoDescription[i + 1].Trim().Substring(0'                                                                                 MediaInfoDescription[i + 1].Trim().                                                                                   IndexOf(" "));                  aMediaInfo.Size = Convert.ToInt32(capacity);                }              }            }          }          else // Less than 5 lines of info? Tray must be empty          {            fHasMedia = false;            aMediaInfo.CurrentMediaType = MediaType.None;          }            fCurrentMediaInfo = aMediaInfo;        }
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseDescriptionForMediaInfo,The following statement contains a magic number: lock (this)        {          if (MediaInfoDescription.Count > 5)          {            for (int i = 0; i < MediaInfoDescription.Count; i++)            {              string checkStr = MediaInfoDescription[i];                if (checkStr.Contains(@"Mounted media type"))              {                // Mounted media type:       DVD+R/DL                // Using generic SCSI-3/mmc-3 DVD+RW driver (mmc_dvdplusrw).                int checkPos = checkStr.IndexOf(@":");                if (checkPos >= 0)                {                  // Assume a disc is there (cdr will close the tray) - if not present it will be set later                  fHasMedia = true;                  string mounted = (checkStr.Substring(checkPos + 1)).Trim();                  checkPos = mounted.IndexOf(@" ");                  if (checkPos >= 0)                    mounted = (mounted.Remove(checkPos));                    switch (mounted)                  {                    case "DVD+R/DL":                      aMediaInfo.CurrentMediaType = MediaType.DlDVDplusR;                      break;                    case "DVD-R/DL":                      aMediaInfo.CurrentMediaType = MediaType.DlDVDminusR;                      break;                    case "DVD+RW":                      aMediaInfo.CurrentMediaType = MediaType.DVDplusRW;                      break;                    case "DVD+R":                      aMediaInfo.CurrentMediaType = MediaType.DVDplusR;                      break;                    case "DVD-RW":                      aMediaInfo.CurrentMediaType = MediaType.DVDminusRW;                      break;                    case "DVD-R":                      aMediaInfo.CurrentMediaType = MediaType.DVDminusR;                      break;                    case "DVD-RAM":                      aMediaInfo.CurrentMediaType = MediaType.DVDRam;                      break;                    case "DVD-ROM":                      aMediaInfo.CurrentMediaType = MediaType.ReadOnly;                      break;                    case "CD-RW":                      aMediaInfo.CurrentMediaType = MediaType.CDRW;                      break;                    case "CD-R":                      aMediaInfo.CurrentMediaType = MediaType.CDR;                      break;                    case "CD-ROM":                      aMediaInfo.CurrentMediaType = MediaType.ReadOnly;                      break;                      default:                      ServiceScope.Get<ILogger>().GetLogger.Debug("Burner: Could not recognize media type: {0}"' mounted);                      aMediaInfo.CurrentMediaType = MediaType.None;                      fHasMedia = false;                      break;                  }                }                else                  aMediaInfo.CurrentMediaType = MediaType.None;              }              else if (checkStr.Contains(@"Disk Is erasable"))              {                aMediaInfo.IsErasable = true;                // cdrecord will use the mmc_cdr driver for CDRW as well                if (aMediaInfo.CurrentMediaType == MediaType.CDR)                  aMediaInfo.CurrentMediaType = MediaType.CDRW;              }              else if (checkStr.Contains(@"data type:"))              {                // data type:                standard                string dataType = checkStr.Substring(11).Trim(trimchars);                aMediaInfo.DataType = dataType;              }              else if (checkStr.Contains(@"disk status:"))              {                // disk status:              empty                string diskStatus = checkStr.Substring(13).Trim(trimchars);                if (diskStatus != "empty")                  aMediaInfo.DiskStatus = BlankStatus.complete;              }              else if (checkStr.Contains(@"session status:"))              {                // session status:           empty                string sessionStatus = checkStr.Substring(16).Trim(trimchars);                if (sessionStatus != "empty")                  aMediaInfo.SessionStatus = BlankStatus.complete;              }              else if (checkStr.Contains(@"Disk Is not unrestricted"))                aMediaInfo.IsRestricted = true; // false reports here?              else              {                //     Capacity  Blklen/Sparesz.  Format-type  Type                //       352965             2048         0x00  Formatted Media                 if (checkStr.Contains(@"Capacity  Blklen/Sparesz."))                {                  string capacity = MediaInfoDescription[i + 1].Trim().Substring(0'                                                                                 MediaInfoDescription[i + 1].Trim().                                                                                   IndexOf(" "));                  aMediaInfo.Size = Convert.ToInt32(capacity);                }              }            }          }          else // Less than 5 lines of info? Tray must be empty          {            fHasMedia = false;            aMediaInfo.CurrentMediaType = MediaType.None;          }            fCurrentMediaInfo = aMediaInfo;        }
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,GetFeatures,The following statement contains a magic number: List<string> FeatureDescription = new List<string>(85);
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,GetFeatures,The following statement contains a magic number: FeatureDescription = DeviceHelper.ExecuteProcReturnStdOut("cdrecord.exe"' cdrParam' 20000);
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseDescriptionForFeatures,The following statement contains a magic number: lock (this)        {          DriveFeatures currentFeatures = new DriveFeatures(false' false' false' false' false' false' false' false' false'                                                            false' false' false' string.Empty' string.Empty);          MediaTypeSupport currentProfile = new MediaTypeSupport(false' false' false' false' false' false' false' false'                                                                 false' false);            for (int i = 0; i < FeatureDescription.Count; i++)          {            string checkStr = FeatureDescription[i];              if (checkStr.Contains(@"Does read CD-R media"))              currentFeatures.ReadsCDR = true;            else if (checkStr.Contains(@"Does write CD-R media"))              currentFeatures.WriteCDR = true;            else if (checkStr.Contains(@"Does read CD-RW media"))              currentFeatures.ReadsCDRW = true;            else if (checkStr.Contains(@"Does write CD-RW"))              currentFeatures.WriteCDRW = true;            else if (checkStr.Contains(@"Does read DVD-ROM"))              currentFeatures.ReadsDVDRom = true;            else if (checkStr.Contains(@"Does read DVD-R"))              currentFeatures.ReadsDVDR = true;            else if (checkStr.Contains(@"Does write DVD-R"))              currentFeatures.WriteDVDR = true;            else if (checkStr.Contains(@"Does read DVD-RAM"))              currentFeatures.ReadsDVDRam = true;            else if (checkStr.Contains(@"Does write DVD-RAM"))              currentFeatures.WriteDVDRam = true;            else if (checkStr.Contains(@"Does support Buffer-Underrun-Free recording"))              currentFeatures.SupportsBurnFree = true;            else if (checkStr.Contains(@"Does support test writing"))              currentFeatures.AllowsDummyWrite = true;            else if (checkStr.Contains(@"Maximum read"))              currentFeatures.MaxReadSpeed = checkStr.Substring(23).Trim(trimchars);            else if (checkStr.Contains(@"Maximum write"))              currentFeatures.MaxWriteSpeed = checkStr.Substring(23).Trim(trimchars);            else if (checkStr.Contains(@"Vendor_info"))              fDeviceVendor = checkStr.Substring(16).Trim(trimchars);            else if (checkStr.Contains(@"Identifikation : "))              fDeviceName = checkStr.Substring(16).Trim(trimchars);            else if (checkStr.Contains(@" DVD+R/DL"))              currentProfile.WriteDlDVDplusR = true;            else if (checkStr.Contains(@" DVD+RW"))              currentProfile.WriteDVDplusRW = true;            else if (checkStr.Contains(@" DVD+R"))              currentProfile.WriteDVDplusR = true;            else if (checkStr.Contains(@" DVD-RW"))              currentProfile.WriteDVDminusRW = true;            else if (checkStr.Contains(@" DVD-R"))              currentProfile.WriteDVDminusR = true;            else if (checkStr.Contains(@" CD-RW"))              currentProfile.WriteCDRW = true;            else if (checkStr.Contains(@" CD-R"))              currentProfile.WriteCDR = true;            else if (checkStr.Contains(@"BD-ROM"))              currentFeatures.ReadsBRRom = true;          }            fDriveFeatures = currentFeatures;          fMediaFeatures = currentProfile;        }
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseDescriptionForFeatures,The following statement contains a magic number: lock (this)        {          DriveFeatures currentFeatures = new DriveFeatures(false' false' false' false' false' false' false' false' false'                                                            false' false' false' string.Empty' string.Empty);          MediaTypeSupport currentProfile = new MediaTypeSupport(false' false' false' false' false' false' false' false'                                                                 false' false);            for (int i = 0; i < FeatureDescription.Count; i++)          {            string checkStr = FeatureDescription[i];              if (checkStr.Contains(@"Does read CD-R media"))              currentFeatures.ReadsCDR = true;            else if (checkStr.Contains(@"Does write CD-R media"))              currentFeatures.WriteCDR = true;            else if (checkStr.Contains(@"Does read CD-RW media"))              currentFeatures.ReadsCDRW = true;            else if (checkStr.Contains(@"Does write CD-RW"))              currentFeatures.WriteCDRW = true;            else if (checkStr.Contains(@"Does read DVD-ROM"))              currentFeatures.ReadsDVDRom = true;            else if (checkStr.Contains(@"Does read DVD-R"))              currentFeatures.ReadsDVDR = true;            else if (checkStr.Contains(@"Does write DVD-R"))              currentFeatures.WriteDVDR = true;            else if (checkStr.Contains(@"Does read DVD-RAM"))              currentFeatures.ReadsDVDRam = true;            else if (checkStr.Contains(@"Does write DVD-RAM"))              currentFeatures.WriteDVDRam = true;            else if (checkStr.Contains(@"Does support Buffer-Underrun-Free recording"))              currentFeatures.SupportsBurnFree = true;            else if (checkStr.Contains(@"Does support test writing"))              currentFeatures.AllowsDummyWrite = true;            else if (checkStr.Contains(@"Maximum read"))              currentFeatures.MaxReadSpeed = checkStr.Substring(23).Trim(trimchars);            else if (checkStr.Contains(@"Maximum write"))              currentFeatures.MaxWriteSpeed = checkStr.Substring(23).Trim(trimchars);            else if (checkStr.Contains(@"Vendor_info"))              fDeviceVendor = checkStr.Substring(16).Trim(trimchars);            else if (checkStr.Contains(@"Identifikation : "))              fDeviceName = checkStr.Substring(16).Trim(trimchars);            else if (checkStr.Contains(@" DVD+R/DL"))              currentProfile.WriteDlDVDplusR = true;            else if (checkStr.Contains(@" DVD+RW"))              currentProfile.WriteDVDplusRW = true;            else if (checkStr.Contains(@" DVD+R"))              currentProfile.WriteDVDplusR = true;            else if (checkStr.Contains(@" DVD-RW"))              currentProfile.WriteDVDminusRW = true;            else if (checkStr.Contains(@" DVD-R"))              currentProfile.WriteDVDminusR = true;            else if (checkStr.Contains(@" CD-RW"))              currentProfile.WriteCDRW = true;            else if (checkStr.Contains(@" CD-R"))              currentProfile.WriteCDR = true;            else if (checkStr.Contains(@"BD-ROM"))              currentFeatures.ReadsBRRom = true;          }            fDriveFeatures = currentFeatures;          fMediaFeatures = currentProfile;        }
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseDescriptionForFeatures,The following statement contains a magic number: lock (this)        {          DriveFeatures currentFeatures = new DriveFeatures(false' false' false' false' false' false' false' false' false'                                                            false' false' false' string.Empty' string.Empty);          MediaTypeSupport currentProfile = new MediaTypeSupport(false' false' false' false' false' false' false' false'                                                                 false' false);            for (int i = 0; i < FeatureDescription.Count; i++)          {            string checkStr = FeatureDescription[i];              if (checkStr.Contains(@"Does read CD-R media"))              currentFeatures.ReadsCDR = true;            else if (checkStr.Contains(@"Does write CD-R media"))              currentFeatures.WriteCDR = true;            else if (checkStr.Contains(@"Does read CD-RW media"))              currentFeatures.ReadsCDRW = true;            else if (checkStr.Contains(@"Does write CD-RW"))              currentFeatures.WriteCDRW = true;            else if (checkStr.Contains(@"Does read DVD-ROM"))              currentFeatures.ReadsDVDRom = true;            else if (checkStr.Contains(@"Does read DVD-R"))              currentFeatures.ReadsDVDR = true;            else if (checkStr.Contains(@"Does write DVD-R"))              currentFeatures.WriteDVDR = true;            else if (checkStr.Contains(@"Does read DVD-RAM"))              currentFeatures.ReadsDVDRam = true;            else if (checkStr.Contains(@"Does write DVD-RAM"))              currentFeatures.WriteDVDRam = true;            else if (checkStr.Contains(@"Does support Buffer-Underrun-Free recording"))              currentFeatures.SupportsBurnFree = true;            else if (checkStr.Contains(@"Does support test writing"))              currentFeatures.AllowsDummyWrite = true;            else if (checkStr.Contains(@"Maximum read"))              currentFeatures.MaxReadSpeed = checkStr.Substring(23).Trim(trimchars);            else if (checkStr.Contains(@"Maximum write"))              currentFeatures.MaxWriteSpeed = checkStr.Substring(23).Trim(trimchars);            else if (checkStr.Contains(@"Vendor_info"))              fDeviceVendor = checkStr.Substring(16).Trim(trimchars);            else if (checkStr.Contains(@"Identifikation : "))              fDeviceName = checkStr.Substring(16).Trim(trimchars);            else if (checkStr.Contains(@" DVD+R/DL"))              currentProfile.WriteDlDVDplusR = true;            else if (checkStr.Contains(@" DVD+RW"))              currentProfile.WriteDVDplusRW = true;            else if (checkStr.Contains(@" DVD+R"))              currentProfile.WriteDVDplusR = true;            else if (checkStr.Contains(@" DVD-RW"))              currentProfile.WriteDVDminusRW = true;            else if (checkStr.Contains(@" DVD-R"))              currentProfile.WriteDVDminusR = true;            else if (checkStr.Contains(@" CD-RW"))              currentProfile.WriteCDRW = true;            else if (checkStr.Contains(@" CD-R"))              currentProfile.WriteCDR = true;            else if (checkStr.Contains(@"BD-ROM"))              currentFeatures.ReadsBRRom = true;          }            fDriveFeatures = currentFeatures;          fMediaFeatures = currentProfile;        }
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseDescriptionForFeatures,The following statement contains a magic number: lock (this)        {          DriveFeatures currentFeatures = new DriveFeatures(false' false' false' false' false' false' false' false' false'                                                            false' false' false' string.Empty' string.Empty);          MediaTypeSupport currentProfile = new MediaTypeSupport(false' false' false' false' false' false' false' false'                                                                 false' false);            for (int i = 0; i < FeatureDescription.Count; i++)          {            string checkStr = FeatureDescription[i];              if (checkStr.Contains(@"Does read CD-R media"))              currentFeatures.ReadsCDR = true;            else if (checkStr.Contains(@"Does write CD-R media"))              currentFeatures.WriteCDR = true;            else if (checkStr.Contains(@"Does read CD-RW media"))              currentFeatures.ReadsCDRW = true;            else if (checkStr.Contains(@"Does write CD-RW"))              currentFeatures.WriteCDRW = true;            else if (checkStr.Contains(@"Does read DVD-ROM"))              currentFeatures.ReadsDVDRom = true;            else if (checkStr.Contains(@"Does read DVD-R"))              currentFeatures.ReadsDVDR = true;            else if (checkStr.Contains(@"Does write DVD-R"))              currentFeatures.WriteDVDR = true;            else if (checkStr.Contains(@"Does read DVD-RAM"))              currentFeatures.ReadsDVDRam = true;            else if (checkStr.Contains(@"Does write DVD-RAM"))              currentFeatures.WriteDVDRam = true;            else if (checkStr.Contains(@"Does support Buffer-Underrun-Free recording"))              currentFeatures.SupportsBurnFree = true;            else if (checkStr.Contains(@"Does support test writing"))              currentFeatures.AllowsDummyWrite = true;            else if (checkStr.Contains(@"Maximum read"))              currentFeatures.MaxReadSpeed = checkStr.Substring(23).Trim(trimchars);            else if (checkStr.Contains(@"Maximum write"))              currentFeatures.MaxWriteSpeed = checkStr.Substring(23).Trim(trimchars);            else if (checkStr.Contains(@"Vendor_info"))              fDeviceVendor = checkStr.Substring(16).Trim(trimchars);            else if (checkStr.Contains(@"Identifikation : "))              fDeviceName = checkStr.Substring(16).Trim(trimchars);            else if (checkStr.Contains(@" DVD+R/DL"))              currentProfile.WriteDlDVDplusR = true;            else if (checkStr.Contains(@" DVD+RW"))              currentProfile.WriteDVDplusRW = true;            else if (checkStr.Contains(@" DVD+R"))              currentProfile.WriteDVDplusR = true;            else if (checkStr.Contains(@" DVD-RW"))              currentProfile.WriteDVDminusRW = true;            else if (checkStr.Contains(@" DVD-R"))              currentProfile.WriteDVDminusR = true;            else if (checkStr.Contains(@" CD-RW"))              currentProfile.WriteCDRW = true;            else if (checkStr.Contains(@" CD-R"))              currentProfile.WriteCDR = true;            else if (checkStr.Contains(@"BD-ROM"))              currentFeatures.ReadsBRRom = true;          }            fDriveFeatures = currentFeatures;          fMediaFeatures = currentProfile;        }
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseSupportedDriveSpeed,The following statement contains a magic number: FeatureDescription = DeviceHelper.ExecuteProcReturnStdOut("cdrecord.exe"' cdrParam' 20000);
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseSupportedDriveSpeed,The following statement contains a magic number: for (int i = 0; i < FeatureDescription.Count; i++)        {          string checkStr = FeatureDescription[i];          if (checkStr.Contains(@"Write speed #"))          {            int start = checkStr.IndexOf("(CD");            string s = checkStr.Substring(start + 4' checkStr.IndexOf("'"' start) - start - 4).Trim();            if (s != savedSpeed)            {              savedSpeed = s;              speed.Add(s);            }          }        }
Magic Number,MPTagThat.Core.Burning,Burner,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\Burner.cs,ParseSupportedDriveSpeed,The following statement contains a magic number: for (int i = 0; i < FeatureDescription.Count; i++)        {          string checkStr = FeatureDescription[i];          if (checkStr.Contains(@"Write speed #"))          {            int start = checkStr.IndexOf("(CD");            string s = checkStr.Substring(start + 4' checkStr.IndexOf("'"' start) - start - 4).Trim();            if (s != savedSpeed)            {              savedSpeed = s;              speed.Add(s);            }          }        }
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,GetDrives,The following statement contains a magic number: if (AvailableDrives.Count < 1)          // maybe the system was not ready yet - try again...          Thread.Sleep(2000);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,GetTotalMbForPath,The following statement contains a magic number: return (int)(CalcTotalBytesOfDirInfo(pathInfo) / 1000000);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,BlankDisk,The following statement contains a magic number: DeviceHelper.ExecuteProcReturnStdOut("cdrecord.exe"' MyBlankArgs' 900000);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,BurnFolder,The following statement contains a magic number: DeviceHelper.ExecuteProcReturnStdOut("mkisofs.exe"' IsoBuildArgs' 1800000);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,BurnAudioCd,The following statement contains a magic number: List<string> MyCommandOutput = new List<string>(50);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,BurnAudioCd,The following statement contains a magic number: MyCommandOutput = DeviceHelper.ExecuteProcReturnStdOut("cdrecord.exe"' burnCdArgs' 3600000);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,BurnCdClone,The following statement contains a magic number: DeviceHelper.ExecuteProcReturnStdOut("readcd.exe"' readCdArgs' 900000);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,BurnCdClone,The following statement contains a magic number: DeviceHelper.ExecuteProcReturnStdOut("cdrecord.exe"' "dev=" + CurrentDrive.BusId + " -eject"' 10000);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,BurnCdClone,The following statement contains a magic number: Thread.Sleep(15000);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,BurnIsoToDisk,The following statement contains a magic number: List<string> MyCommandOutput = new List<string>(50);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,BurnIsoToDisk,The following statement contains a magic number: try        {          FileInfo fileInfo = new FileInfo(aIsoToBurn);          isoSize = (int)(fileInfo.Length / 1048576); // GetMB        }        catch (Exception)        {          return BurnResult.ErrorConverting;        }
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,BurnIsoToDisk,The following statement contains a magic number: MyCommandOutput = DeviceHelper.ExecuteProcReturnStdOut("cdrecord.exe"' IsoArgs' 3600000);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,CheckInsertedMediaCapacity,The following statement contains a magic number: int currentSpace = (int)(aSelectedBurner.CurrentMediaInfo.Size / 1024);
Magic Number,MPTagThat.Core.Burning,BurnManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\BurnManager.cs,GetAvailableDrives,The following statement contains a magic number: if (AvailableDrives.Count < 1)        {          // maybe the system was not ready yet - try again...          Thread.Sleep(1000);          AvailableDrives.Clear();          AvailableDrives = DeviceHelper.QueryBurners();        }
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,ProcessErrorHandler,The following statement contains a magic number: switch (aAppName)        {          case "cdrecord.exe":            if (!aArguments.Contains(@"-minfo"))              log.Warn("Devicehelper: {0} did not exit properly with arguments: {1}' exitcode: {2}"' aAppName'                          aArguments' aExitcode);            break;          case "mkisofs.exe":            if (aExitcode == 253)              log.Error("Devicehelper: ISO creation failed. Possible error: The source files did change.");            else              log.Warn("Devicehelper: {0} did not exit properly with arguments: {1}' exitcode: {2}"' aAppName'                          aArguments' aExitcode);            break;        }
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,StdErrDataReceived,The following statement contains a magic number: if (!string.IsNullOrEmpty(errLine.Data))        {          if (errLine.Data.Contains(@"estimate finish"))          {            string percentage;            double convert = 0;            try            {              percentage = errLine.Data.Remove(6); //  10.81% done' estimate finish Tue Nov  6 03:23:12 2007              convert = Convert.ToDouble(percentage' CultureInfo.InvariantCulture);            }            catch (Exception) {}            fDeviceHelper.ReportProgress(BurnStatus.Converting' (int)convert);          }          else if (errLine.Data.Contains(@"extents written"))          {            int pos = errLine.Data.IndexOf('(') + 1;            if (pos > 0)            {              string isoSize = errLine.Data.Substring(pos);              pos = isoSize.IndexOf("MB");              if (pos > 0)              {                isoSize = isoSize.Remove(pos).Trim();                fIsoSizeMB = Convert.ToInt16(isoSize);                log.Info("Devicehelper: Created ISO has a size of {0} MB"' isoSize);              }            }          }          else if (errLine.Data.Contains(@"times empty"))          {            int pos = errLine.Data.IndexOf("fifo");            if (pos >= 0)            {              string bufferMsg = errLine.Data.Substring(pos);              log.Info("Devicehelper: Buffer status: {0}"' bufferMsg);            }          }          // else // <-- activate for all debug output          //  log.Debug("Devicehelper: StdErr received unclassified message: {0}"' errLine.Data);        }
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,StdOutDataReceived,The following statement contains a magic number: if (!string.IsNullOrEmpty(e.Data))        {          StdOutList.Add(e.Data);            if (e.Data.Contains("written"))          {            // "Track 02:    1 of  451 MB written (fifo  94%) [buf  60%]   0.1x."            // "Writing  time:  123.891s"            // "Average write speed   2.3x."            // "Min drive buffer fill was 96%"            int pos = e.Data.IndexOf(':');            if (pos > 0)            {              int track = Convert.ToInt16(e.Data.Substring(pos - 2' 2));              string progress = e.Data.Substring(pos + 1);              int MyIsoSize = fIsoSizeMB;                pos = progress.IndexOf("of");              if (pos > 0)              {                if (MyIsoSize < 1)                {                  // property not set during iso creation - use cdrecord's output                  MyIsoSize = Convert.ToInt32(progress.Substring(pos + 2' 5).Trim());                  fIsoSizeMB = MyIsoSize;                }                  if (MyIsoSize > 0)                {                  progress = progress.Remove(pos).Trim();                  int percentage = ((Convert.ToInt16(progress) * 100) / MyIsoSize);                  fDeviceHelper.ReportProgress(BurnStatus.Burning' track' percentage);                }              }            }          }          else if (e.Data.Contains("Average write speed"))            log.Info("DeviceHelper: {0}"' e.Data);          else if (e.Data.Contains("Fixating.."))            fDeviceHelper.ReportProgress(BurnStatus.LeadOut' 0);          else            // Fixating time:    2.015s            if (e.Data.Contains("Fixating time"))              fDeviceHelper.ReportProgress(BurnStatus.Finished' 0);          //else          //log.Debug("Devicehelper: StdOut received unclassified message: {0}"' e.Data);        }
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,StdOutDataReceived,The following statement contains a magic number: if (!string.IsNullOrEmpty(e.Data))        {          StdOutList.Add(e.Data);            if (e.Data.Contains("written"))          {            // "Track 02:    1 of  451 MB written (fifo  94%) [buf  60%]   0.1x."            // "Writing  time:  123.891s"            // "Average write speed   2.3x."            // "Min drive buffer fill was 96%"            int pos = e.Data.IndexOf(':');            if (pos > 0)            {              int track = Convert.ToInt16(e.Data.Substring(pos - 2' 2));              string progress = e.Data.Substring(pos + 1);              int MyIsoSize = fIsoSizeMB;                pos = progress.IndexOf("of");              if (pos > 0)              {                if (MyIsoSize < 1)                {                  // property not set during iso creation - use cdrecord's output                  MyIsoSize = Convert.ToInt32(progress.Substring(pos + 2' 5).Trim());                  fIsoSizeMB = MyIsoSize;                }                  if (MyIsoSize > 0)                {                  progress = progress.Remove(pos).Trim();                  int percentage = ((Convert.ToInt16(progress) * 100) / MyIsoSize);                  fDeviceHelper.ReportProgress(BurnStatus.Burning' track' percentage);                }              }            }          }          else if (e.Data.Contains("Average write speed"))            log.Info("DeviceHelper: {0}"' e.Data);          else if (e.Data.Contains("Fixating.."))            fDeviceHelper.ReportProgress(BurnStatus.LeadOut' 0);          else            // Fixating time:    2.015s            if (e.Data.Contains("Fixating time"))              fDeviceHelper.ReportProgress(BurnStatus.Finished' 0);          //else          //log.Debug("Devicehelper: StdOut received unclassified message: {0}"' e.Data);        }
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,StdOutDataReceived,The following statement contains a magic number: if (!string.IsNullOrEmpty(e.Data))        {          StdOutList.Add(e.Data);            if (e.Data.Contains("written"))          {            // "Track 02:    1 of  451 MB written (fifo  94%) [buf  60%]   0.1x."            // "Writing  time:  123.891s"            // "Average write speed   2.3x."            // "Min drive buffer fill was 96%"            int pos = e.Data.IndexOf(':');            if (pos > 0)            {              int track = Convert.ToInt16(e.Data.Substring(pos - 2' 2));              string progress = e.Data.Substring(pos + 1);              int MyIsoSize = fIsoSizeMB;                pos = progress.IndexOf("of");              if (pos > 0)              {                if (MyIsoSize < 1)                {                  // property not set during iso creation - use cdrecord's output                  MyIsoSize = Convert.ToInt32(progress.Substring(pos + 2' 5).Trim());                  fIsoSizeMB = MyIsoSize;                }                  if (MyIsoSize > 0)                {                  progress = progress.Remove(pos).Trim();                  int percentage = ((Convert.ToInt16(progress) * 100) / MyIsoSize);                  fDeviceHelper.ReportProgress(BurnStatus.Burning' track' percentage);                }              }            }          }          else if (e.Data.Contains("Average write speed"))            log.Info("DeviceHelper: {0}"' e.Data);          else if (e.Data.Contains("Fixating.."))            fDeviceHelper.ReportProgress(BurnStatus.LeadOut' 0);          else            // Fixating time:    2.015s            if (e.Data.Contains("Fixating time"))              fDeviceHelper.ReportProgress(BurnStatus.Finished' 0);          //else          //log.Debug("Devicehelper: StdOut received unclassified message: {0}"' e.Data);        }
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,StdOutDataReceived,The following statement contains a magic number: if (!string.IsNullOrEmpty(e.Data))        {          StdOutList.Add(e.Data);            if (e.Data.Contains("written"))          {            // "Track 02:    1 of  451 MB written (fifo  94%) [buf  60%]   0.1x."            // "Writing  time:  123.891s"            // "Average write speed   2.3x."            // "Min drive buffer fill was 96%"            int pos = e.Data.IndexOf(':');            if (pos > 0)            {              int track = Convert.ToInt16(e.Data.Substring(pos - 2' 2));              string progress = e.Data.Substring(pos + 1);              int MyIsoSize = fIsoSizeMB;                pos = progress.IndexOf("of");              if (pos > 0)              {                if (MyIsoSize < 1)                {                  // property not set during iso creation - use cdrecord's output                  MyIsoSize = Convert.ToInt32(progress.Substring(pos + 2' 5).Trim());                  fIsoSizeMB = MyIsoSize;                }                  if (MyIsoSize > 0)                {                  progress = progress.Remove(pos).Trim();                  int percentage = ((Convert.ToInt16(progress) * 100) / MyIsoSize);                  fDeviceHelper.ReportProgress(BurnStatus.Burning' track' percentage);                }              }            }          }          else if (e.Data.Contains("Average write speed"))            log.Info("DeviceHelper: {0}"' e.Data);          else if (e.Data.Contains("Fixating.."))            fDeviceHelper.ReportProgress(BurnStatus.LeadOut' 0);          else            // Fixating time:    2.015s            if (e.Data.Contains("Fixating time"))              fDeviceHelper.ReportProgress(BurnStatus.Finished' 0);          //else          //log.Debug("Devicehelper: StdOut received unclassified message: {0}"' e.Data);        }
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,StdOutDataReceived,The following statement contains a magic number: if (!string.IsNullOrEmpty(e.Data))        {          StdOutList.Add(e.Data);            if (e.Data.Contains("written"))          {            // "Track 02:    1 of  451 MB written (fifo  94%) [buf  60%]   0.1x."            // "Writing  time:  123.891s"            // "Average write speed   2.3x."            // "Min drive buffer fill was 96%"            int pos = e.Data.IndexOf(':');            if (pos > 0)            {              int track = Convert.ToInt16(e.Data.Substring(pos - 2' 2));              string progress = e.Data.Substring(pos + 1);              int MyIsoSize = fIsoSizeMB;                pos = progress.IndexOf("of");              if (pos > 0)              {                if (MyIsoSize < 1)                {                  // property not set during iso creation - use cdrecord's output                  MyIsoSize = Convert.ToInt32(progress.Substring(pos + 2' 5).Trim());                  fIsoSizeMB = MyIsoSize;                }                  if (MyIsoSize > 0)                {                  progress = progress.Remove(pos).Trim();                  int percentage = ((Convert.ToInt16(progress) * 100) / MyIsoSize);                  fDeviceHelper.ReportProgress(BurnStatus.Burning' track' percentage);                }              }            }          }          else if (e.Data.Contains("Average write speed"))            log.Info("DeviceHelper: {0}"' e.Data);          else if (e.Data.Contains("Fixating.."))            fDeviceHelper.ReportProgress(BurnStatus.LeadOut' 0);          else            // Fixating time:    2.015s            if (e.Data.Contains("Fixating time"))              fDeviceHelper.ReportProgress(BurnStatus.Finished' 0);          //else          //log.Debug("Devicehelper: StdOut received unclassified message: {0}"' e.Data);        }
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,DeviceHelper,The following statement contains a magic number: StdOutList = new List<string>(80);
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,QueryForBurners,The following statement contains a magic number: try        {          List<string> DeviceInfo = new List<string>(74);          List<string> FoundDeviceIDs = new List<string>(2);          List<Burner> FoundDrives = new List<Burner>(1);          DeviceInfo = ExecuteProcReturnStdOut("cdrecord.exe"' "-scanbus"' 45000);            // fetch all optical drives          FoundDeviceIDs = ParsePossibleDevices(DeviceInfo);            foreach (string devstr in FoundDeviceIDs)          {            FoundDrives.Add(new Burner(devstr));            // let pending job finish            Application.DoEvents();          }            return FoundDrives;        }        catch (Exception)        {          log.Error("BurnManager: Error scanning SCSI bus for devices");          return null;        }
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,QueryForBurners,The following statement contains a magic number: try        {          List<string> DeviceInfo = new List<string>(74);          List<string> FoundDeviceIDs = new List<string>(2);          List<Burner> FoundDrives = new List<Burner>(1);          DeviceInfo = ExecuteProcReturnStdOut("cdrecord.exe"' "-scanbus"' 45000);            // fetch all optical drives          FoundDeviceIDs = ParsePossibleDevices(DeviceInfo);            foreach (string devstr in FoundDeviceIDs)          {            FoundDrives.Add(new Burner(devstr));            // let pending job finish            Application.DoEvents();          }            return FoundDrives;        }        catch (Exception)        {          log.Error("BurnManager: Error scanning SCSI bus for devices");          return null;        }
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,QueryForBurners,The following statement contains a magic number: try        {          List<string> DeviceInfo = new List<string>(74);          List<string> FoundDeviceIDs = new List<string>(2);          List<Burner> FoundDrives = new List<Burner>(1);          DeviceInfo = ExecuteProcReturnStdOut("cdrecord.exe"' "-scanbus"' 45000);            // fetch all optical drives          FoundDeviceIDs = ParsePossibleDevices(DeviceInfo);            foreach (string devstr in FoundDeviceIDs)          {            FoundDrives.Add(new Burner(devstr));            // let pending job finish            Application.DoEvents();          }            return FoundDrives;        }        catch (Exception)        {          log.Error("BurnManager: Error scanning SCSI bus for devices");          return null;        }
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,ParsePossibleDevices,The following statement contains a magic number: List<string> devLines = new List<string>(5);
Magic Number,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,ParsePossibleDevices,The following statement contains a magic number: foreach (string scanLine in aOutPutData)        {          if (scanLine.EndsWith(@"Removable CD-ROM"))            devLines.Add(scanLine.Substring(1' 5));        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMediaSizeMbByType,The following statement contains a magic number: switch (aMediaType)        {          case MediaType.None:            return 0;          case MediaType.ReadOnly:            return 0;          case MediaType.CDR:            return 700;          case MediaType.CDRW:            return 650;          case MediaType.DVDplusR:            return 4482;          case MediaType.DVDminusR:            return 4482;          case MediaType.DVDplusRW:            return 4482;          case MediaType.DVDminusRW:            return 4482;          case MediaType.DlDVDplusR:            return 8964;          case MediaType.DlDVDminusR:            return 8964;          case MediaType.DlDVDplusRW:            return 8964;          case MediaType.DlDVDminusRW:            return 8964;          case MediaType.DVDRam: // Type 2            return 4482;          case MediaType.DlDVDRam:            return 8964;          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Burning,MediaTypeSupport,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\MediaTypeSupport.cs,GetMaxMediaSizeMbByProjectType,The following statement contains a magic number: switch (aProjectType)        {          case ProjectType.DataCD:            return 700;          case ProjectType.AudioCD:            return 700;          case ProjectType.PhotoCD:            return 700;          case ProjectType.IsoCD:            return 700;          case ProjectType.DataDVD:            return 4482;          case ProjectType.VideoDVD:            return 4482;          case ProjectType.IsoDVD:            return 4482;          case ProjectType.LargeDataDVD:            return 8964;          case ProjectType.LargeIsoDVD:            return 8964;          case ProjectType.Autoselect:            if (aCurrentDrive == null)              return 0;            else            {              if (aCurrentDrive.MediaFeatures.WriteDlDVDplusR || aCurrentDrive.MediaFeatures.WriteDlDVDminusR ||                  aCurrentDrive.MediaFeatures.WriteDlDVDRam)                return 8964;              if (aCurrentDrive.MediaFeatures.WriteDVDplusR || aCurrentDrive.MediaFeatures.WriteDVDminusR)                return 4482;              else                return 700;            }          default:            return 0;        }
Magic Number,MPTagThat.Core.Common,Comment,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Comment.cs,Comment,The following statement contains a magic number: if (lang.Length > 3)          Language = lang.Substring(0' 3);        else          Language = lang;
Magic Number,MPTagThat.Core.Common,Comment,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Comment.cs,Comment,The following statement contains a magic number: if (lang.Length > 3)          Language = lang.Substring(0' 3);        else          Language = lang;
Magic Number,MPTagThat.Core.Common,Lyric,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Lyric.cs,Lyric,The following statement contains a magic number: Language = lang.Length == 3 ? lang.Substring(0' 3) : "";
Magic Number,MPTagThat.Core.Common,Lyric,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Lyric.cs,Lyric,The following statement contains a magic number: Language = lang.Length == 3 ? lang.Substring(0' 3) : "";
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following statement contains a magic number: if (Dock == DockStyle.Left || Dock == DockStyle.Right)        {          // create a new rectangle in the vertical center of the splitter for our collapse control button          rr = new Rectangle(r.X' r.Y + ((r.Height - 115) / 2)' 8' 115);          // force the width to 8px so that everything always draws correctly          Width = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X + 1' rr.Y' 6' 115));          }            // draw the top & bottom lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y' rr.X + rr.Width - 2' rr.Y);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + 1' rr.Y + rr.Height' rr.X + rr.Width - 2'                     rr.Y + rr.Height);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + 3));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 2' rr.Y + rr.Height - 9));          }            // draw the dots for our control image using a loop          int x = rr.X + 3;          int y = rr.Y + 14;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Left);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Right);          }        }            #endregion            // Horizontal Splitter support added in v1.2            #region Horizontal Splitter          else if (Dock == DockStyle.Top || Dock == DockStyle.Bottom)        {          // create a new rectangle in the horizontal center of the splitter for our collapse control button          rr = new Rectangle(r.X + ((r.Width - 115) / 2)' r.Y' 115' 8);          // force the height to 8px          Height = 8;            // draw the background color for our control image          if (hot)          {            g.FillRectangle(new SolidBrush(hotColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }          else          {            g.FillRectangle(new SolidBrush(BackColor)' new Rectangle(rr.X' rr.Y + 1' 115' 6));          }            // draw the left & right lines for our control image          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X' rr.Y + 1' rr.X' rr.Y + rr.Height - 2);          g.DrawLine(new Pen(SystemColors.ControlDark' 1)' rr.X + rr.Width' rr.Y + 1' rr.X + rr.Width'                     rr.Y + rr.Height - 2);            if (Enabled)          {            // draw the arrows for our control image            // the ArrowPointArray is a point array that defines an arrow shaped polygon            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + 3' rr.Y + 2));            g.FillPolygon(new SolidBrush(SystemColors.ControlDarkDark)' ArrowPointArray(rr.X + rr.Width - 9' rr.Y + 2));          }            // draw the dots for our control image using a loop          int x = rr.X + 14;          int y = rr.Y + 3;            // Visual Styles added in version 1.1          switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }            // Added in version 1.3          if (borderStyle != Border3DStyle.Flat)          {            // Paint the control border            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Top);            ControlPaint.DrawBorder3D(e.Graphics' ClientRectangle' borderStyle' Border3DSide.Bottom);          }        }            #endregion          else        {          throw new Exception("The Collapsible Splitter control cannot have the Filled or None Dockstyle property");        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: Point[] point = new Point[3];
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,ArrowPointArray,The following statement contains a magic number: if (controlToHide != null)        {          // decide which direction the arrow will point          if (            (Dock == DockStyle.Right && controlToHide.Visible)            || (Dock == DockStyle.Left && !controlToHide.Visible)            )          {            // right arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 3' y + 3);            point[2] = new Point(x' y + 6);          }          else if (            (Dock == DockStyle.Right && !controlToHide.Visible)            || (Dock == DockStyle.Left && controlToHide.Visible)            )          {            // left arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x' y + 3);            point[2] = new Point(x + 3' y + 6);          }              // Up/Down arrows added in v1.2            else if (            (Dock == DockStyle.Top && controlToHide.Visible)            || (Dock == DockStyle.Bottom && !controlToHide.Visible)            )          {            // up arrow            point[0] = new Point(x + 3' y);            point[1] = new Point(x + 6' y + 4);            point[2] = new Point(x' y + 4);          }          else if (            (Dock == DockStyle.Top && !controlToHide.Visible)            || (Dock == DockStyle.Bottom && controlToHide.Visible)            )          {            // down arrow            point[0] = new Point(x' y);            point[1] = new Point(x + 6' y);            point[2] = new Point(x + 3' y + 3);          }        }
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: Color frontColor = Color.FromArgb(255' front);
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: Color backColor = Color.FromArgb(255' back);
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: float fRed = frontRed * alpha / 255 + backRed * ((float)(255 - alpha) / 255);
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: float fRed = frontRed * alpha / 255 + backRed * ((float)(255 - alpha) / 255);
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: float fRed = frontRed * alpha / 255 + backRed * ((float)(255 - alpha) / 255);
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: float fGreen = frontGreen * alpha / 255 + backGreen * ((float)(255 - alpha) / 255);
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: float fGreen = frontGreen * alpha / 255 + backGreen * ((float)(255 - alpha) / 255);
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: float fGreen = frontGreen * alpha / 255 + backGreen * ((float)(255 - alpha) / 255);
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: float fBlue = frontBlue * alpha / 255 + backBlue * ((float)(255 - alpha) / 255);
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: float fBlue = frontBlue * alpha / 255 + backBlue * ((float)(255 - alpha) / 255);
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: float fBlue = frontBlue * alpha / 255 + backBlue * ((float)(255 - alpha) / 255);
Magic Number,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,CalculateColor,The following statement contains a magic number: return Color.FromArgb(255' newRed' newGreen' newBlue);
Magic Number,Stepi.UI,ExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\ExtendedPanel.cs,OnResize,The following statement contains a magic number: if (captionSize == 0)        {          captionSize = (Height * 20 / 100);          CheckDocking(0);        }
Magic Number,Stepi.UI,ExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\ExtendedPanel.cs,OnResize,The following statement contains a magic number: if (captionSize == 0)        {          captionSize = (Height * 20 / 100);          CheckDocking(0);        }
Magic Number,Stepi.UI,CaptionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CaptionCtrl.cs,OnPaint,The following statement contains a magic number: if (captionIcon != null)        {          if (Width >= Height)          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6); //' cornerSquare' cornerSquare);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6 + captionIcon.Width' yAxis + cornerSquare / 6)'                                  stringFormat);          }          else          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6 + +captionIcon.Height)'                                  stringFormat);          }        }        else        {          //draw the text          e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6)' stringFormat);        }
Magic Number,Stepi.UI,CaptionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CaptionCtrl.cs,OnPaint,The following statement contains a magic number: if (captionIcon != null)        {          if (Width >= Height)          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6); //' cornerSquare' cornerSquare);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6 + captionIcon.Width' yAxis + cornerSquare / 6)'                                  stringFormat);          }          else          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6 + +captionIcon.Height)'                                  stringFormat);          }        }        else        {          //draw the text          e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6)' stringFormat);        }
Magic Number,Stepi.UI,CaptionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CaptionCtrl.cs,OnPaint,The following statement contains a magic number: if (captionIcon != null)        {          if (Width >= Height)          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6); //' cornerSquare' cornerSquare);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6 + captionIcon.Width' yAxis + cornerSquare / 6)'                                  stringFormat);          }          else          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6 + +captionIcon.Height)'                                  stringFormat);          }        }        else        {          //draw the text          e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6)' stringFormat);        }
Magic Number,Stepi.UI,CaptionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CaptionCtrl.cs,OnPaint,The following statement contains a magic number: if (captionIcon != null)        {          if (Width >= Height)          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6); //' cornerSquare' cornerSquare);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6 + captionIcon.Width' yAxis + cornerSquare / 6)'                                  stringFormat);          }          else          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6 + +captionIcon.Height)'                                  stringFormat);          }        }        else        {          //draw the text          e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6)' stringFormat);        }
Magic Number,Stepi.UI,CaptionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CaptionCtrl.cs,OnPaint,The following statement contains a magic number: if (captionIcon != null)        {          if (Width >= Height)          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6); //' cornerSquare' cornerSquare);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6 + captionIcon.Width' yAxis + cornerSquare / 6)'                                  stringFormat);          }          else          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6 + +captionIcon.Height)'                                  stringFormat);          }        }        else        {          //draw the text          e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6)' stringFormat);        }
Magic Number,Stepi.UI,CaptionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CaptionCtrl.cs,OnPaint,The following statement contains a magic number: if (captionIcon != null)        {          if (Width >= Height)          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6); //' cornerSquare' cornerSquare);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6 + captionIcon.Width' yAxis + cornerSquare / 6)'                                  stringFormat);          }          else          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6 + +captionIcon.Height)'                                  stringFormat);          }        }        else        {          //draw the text          e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6)' stringFormat);        }
Magic Number,Stepi.UI,CaptionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CaptionCtrl.cs,OnPaint,The following statement contains a magic number: if (captionIcon != null)        {          if (Width >= Height)          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6); //' cornerSquare' cornerSquare);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6 + captionIcon.Width' yAxis + cornerSquare / 6)'                                  stringFormat);          }          else          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6 + +captionIcon.Height)'                                  stringFormat);          }        }        else        {          //draw the text          e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6)' stringFormat);        }
Magic Number,Stepi.UI,CaptionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CaptionCtrl.cs,OnPaint,The following statement contains a magic number: if (captionIcon != null)        {          if (Width >= Height)          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6); //' cornerSquare' cornerSquare);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6 + captionIcon.Width' yAxis + cornerSquare / 6)'                                  stringFormat);          }          else          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6 + +captionIcon.Height)'                                  stringFormat);          }        }        else        {          //draw the text          e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6)' stringFormat);        }
Magic Number,Stepi.UI,CaptionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CaptionCtrl.cs,OnPaint,The following statement contains a magic number: if (captionIcon != null)        {          if (Width >= Height)          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6); //' cornerSquare' cornerSquare);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6 + captionIcon.Width' yAxis + cornerSquare / 6)'                                  stringFormat);          }          else          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6 + +captionIcon.Height)'                                  stringFormat);          }        }        else        {          //draw the text          e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6)' stringFormat);        }
Magic Number,Stepi.UI,CaptionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CaptionCtrl.cs,OnPaint,The following statement contains a magic number: if (captionIcon != null)        {          if (Width >= Height)          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6); //' cornerSquare' cornerSquare);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6 + captionIcon.Width' yAxis + cornerSquare / 6)'                                  stringFormat);          }          else          {            e.Graphics.DrawIcon(captionIcon' cornerSquare / 6' cornerSquare / 6);            //draw the text            e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                  new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6 + +captionIcon.Height)'                                  stringFormat);          }        }        else        {          //draw the text          e.Graphics.DrawString(text' Font' new SolidBrush(textColor)'                                new PointF(xAxis + cornerSquare / 6' yAxis + cornerSquare / 6)' stringFormat);        }
Magic Number,Stepi.UI,CollapseAnimation,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CollapseAnimation.cs,Animate,The following statement contains a magic number: if (null != NotifyAnimation)        {          if (step > 0)          {            while (maximum > minimum)            {              maximum -= step;              if (maximum < minimum)              {                maximum = minimum;              }              NotifyAnimation(this' maximum);              Thread.Sleep(20);            }            if (NotifyAnimationFinished != null)            {              NotifyAnimationFinished(this);            }          }          else          {            while (maximum > minimum)            {              minimum -= step;              if (maximum < minimum)              {                minimum = maximum;              }              NotifyAnimation(this' minimum);              Thread.Sleep(20);            }            if (NotifyAnimationFinished != null)            {              NotifyAnimationFinished(this);            }          }        }
Magic Number,Stepi.UI,CollapseAnimation,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CollapseAnimation.cs,Animate,The following statement contains a magic number: if (null != NotifyAnimation)        {          if (step > 0)          {            while (maximum > minimum)            {              maximum -= step;              if (maximum < minimum)              {                maximum = minimum;              }              NotifyAnimation(this' maximum);              Thread.Sleep(20);            }            if (NotifyAnimationFinished != null)            {              NotifyAnimationFinished(this);            }          }          else          {            while (maximum > minimum)            {              minimum -= step;              if (maximum < minimum)              {                minimum = maximum;              }              NotifyAnimation(this' minimum);              Thread.Sleep(20);            }            if (NotifyAnimationFinished != null)            {              NotifyAnimationFinished(this);            }          }        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,CornerCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\CornerCtrl.cs,InitializeGraphicPath,The following statement contains a magic number: switch (cornerStyle)        {          case CornerStyle.Rounded:              graphicPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            regionPath.AddArc(0' 0' cornerSquare' cornerSquare' 180' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2 - 1' 0);            regionPath.AddLine(cornerSquare - cornerSquare / 2' 0' Width - cornerSquare + cornerSquare / 2' 0);            graphicPath.AddArc(Width - cornerSquare - 1' 0' cornerSquare' cornerSquare' -90' 90);            regionPath.AddArc(Width - cornerSquare' 0' cornerSquare' cornerSquare' -90' 90);              graphicPath.AddLine(Width - 1' cornerSquare - cornerSquare / 2' Width - 1'                                Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(Width' cornerSquare - cornerSquare / 2' Width' Height - cornerSquare + cornerSquare / 2);            graphicPath.AddArc(Width - cornerSquare - 1' Height - 1 - cornerSquare' cornerSquare' cornerSquare' 0' 90);            regionPath.AddArc(Width - cornerSquare' Height - cornerSquare' cornerSquare' cornerSquare' 0' 90);            graphicPath.AddLine(cornerSquare - cornerSquare / 2' Height - 1' Width - cornerSquare + cornerSquare / 2'                                Height - 1);            regionPath.AddLine(cornerSquare - cornerSquare / 2' Height' Width - cornerSquare + cornerSquare / 2' Height);              graphicPath.AddArc(0' Height - cornerSquare - 1' cornerSquare' cornerSquare' 90' 90);            regionPath.AddArc(0' Height - cornerSquare' cornerSquare' cornerSquare' 90' 90);              graphicPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            regionPath.AddLine(0' cornerSquare - cornerSquare / 2' 0' Height - cornerSquare + cornerSquare / 2);            //this.Region = new Region(graphicPath);              //this.Region = new Region(graphicPath);            break;            case CornerStyle.Normal:              graphicPath.AddLine(0' 0' Width - 1' 0);            regionPath.AddLine(0' 0' Width' 0);            graphicPath.AddLine(Width - 1' 0' Width - 1' Height - 1);            regionPath.AddLine(Width' 0' Width' Height);            graphicPath.AddLine(Width - 1' Height - 1' 0' Height - 1);            regionPath.AddLine(Width' Height' 0' Height);            graphicPath.AddLine(0' Height - 1' 0' 0);            regionPath.AddLine(0' Height' 0' 0);            break;            default:            throw new ApplicationException("Unrecognized style for rendering the corners");            break;        }
Magic Number,Stepi.UI,DirectionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\DirectionCtrl.cs,CreateImage,The following statement contains a magic number: if (flag)        {          font = new Font("Arial"' 12' FontStyle.Bold);        }        else        {          font = new Font("Arial"' 15' FontStyle.Bold);        }
Magic Number,Stepi.UI,DirectionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\DirectionCtrl.cs,CreateImage,The following statement contains a magic number: if (flag)        {          font = new Font("Arial"' 12' FontStyle.Bold);        }        else        {          font = new Font("Arial"' 15' FontStyle.Bold);        }
Magic Number,Raccoom.Windows.Forms,TreeViewFolderBrowser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewBrowser.cs,OnDoubleClick,The following statement contains a magic number: if ((node.Nodes.Count > 0) || (node.Path.Length > 3)) return;
Magic Number,Raccoom.Windows.Forms,TreeViewFolderBrowserDataProviderMusicDb,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewFolderBrowserDataProviderMusicDb.cs,RequestSubDirs,The following statement contains a magic number: if (_rootFolder == RootFolder.Artist)        {          result = ServiceScope.Get<IMusicDatabase>().GetArtistAlbums(parent.Path);          createDummyNode = false;        }        else if (_rootFolder == RootFolder.AlbumArtist)        {          result = ServiceScope.Get<IMusicDatabase>().GetAlbumArtistAlbums(parent.Path);          createDummyNode = false;        }        else if (_rootFolder == RootFolder.Genre)        {          string[] searchString = (parent.Tag as string).Split('\\');          if (searchString.GetLength(0) == 2)          {            result = ServiceScope.Get<IMusicDatabase>().GetGenreArtists(parent.Path);          }          else          {            isGenreArtistLevel = false;            result = ServiceScope.Get<IMusicDatabase>().GetGenreArtistAlbums(searchString[1]' searchString[2]);            createDummyNode = false;          }        }
Magic Number,Raccoom.Windows.Forms,TreeViewFolderBrowserDataProviderMusicDb,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewFolderBrowserDataProviderMusicDb.cs,RequestSubDirs,The following statement contains a magic number: if (_rootFolder == RootFolder.Artist)        {          result = ServiceScope.Get<IMusicDatabase>().GetArtistAlbums(parent.Path);          createDummyNode = false;        }        else if (_rootFolder == RootFolder.AlbumArtist)        {          result = ServiceScope.Get<IMusicDatabase>().GetAlbumArtistAlbums(parent.Path);          createDummyNode = false;        }        else if (_rootFolder == RootFolder.Genre)        {          string[] searchString = (parent.Tag as string).Split('\\');          if (searchString.GetLength(0) == 2)          {            result = ServiceScope.Get<IMusicDatabase>().GetGenreArtists(parent.Path);          }          else          {            isGenreArtistLevel = false;            result = ServiceScope.Get<IMusicDatabase>().GetGenreArtistAlbums(searchString[1]' searchString[2]);            createDummyNode = false;          }        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: if ((dmtf.Length != 25))        {          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: try        {          tempString = dmtf.Substring(0' 4);          if (("****" != tempString))          {            year = Int32.Parse(tempString);          }          tempString = dmtf.Substring(4' 2);          if (("**" != tempString))          {            month = Int32.Parse(tempString);          }          tempString = dmtf.Substring(6' 2);          if (("**" != tempString))          {            day = Int32.Parse(tempString);          }          tempString = dmtf.Substring(8' 2);          if (("**" != tempString))          {            hour = Int32.Parse(tempString);          }          tempString = dmtf.Substring(10' 2);          if (("**" != tempString))          {            minute = Int32.Parse(tempString);          }          tempString = dmtf.Substring(12' 2);          if (("**" != tempString))          {            second = Int32.Parse(tempString);          }          tempString = dmtf.Substring(15' 6);          if (("******" != tempString))          {            ticks = (Int64.Parse(tempString)                     * (TimeSpan.TicksPerMillisecond / 1000));          }          if (((((((((year < 0)                     || (month < 0))                    || (day < 0))                   || (hour < 0))                  || (minute < 0))                 || (minute < 0))                || (second < 0))               || (ticks < 0)))          {            throw new ArgumentOutOfRangeException();          }        }        catch (Exception e)        {          e = e;          throw new ArgumentOutOfRangeException();        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: tempString = dmtf.Substring(22' 3);
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: tempString = dmtf.Substring(22' 3);
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: if ((tempString != "***"))        {          tempString = dmtf.Substring(21' 4);          try          {            UTCOffset = Int32.Parse(tempString);          }          catch (Exception e)          {            throw new ArgumentOutOfRangeException();          }          OffsetToBeAdjusted = (OffsetMins - UTCOffset);          datetime = datetime.AddMinutes(OffsetToBeAdjusted);        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDateTime,The following statement contains a magic number: if ((tempString != "***"))        {          tempString = dmtf.Substring(21' 4);          try          {            UTCOffset = Int32.Parse(tempString);          }          catch (Exception e)          {            throw new ArgumentOutOfRangeException();          }          OffsetToBeAdjusted = (OffsetMins - UTCOffset);          datetime = datetime.AddMinutes(OffsetToBeAdjusted);        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: if ((Math.Abs(OffsetMins) > 999))        {          date = date.ToUniversalTime();          utcString = "+000";        }        else        {          if ((tickOffset.Ticks >= 0))          {            utcString = ("+" + ((tickOffset.Ticks / TimeSpan.TicksPerMinute)).ToString().PadLeft(3' '0'));          }          else          {            string strTemp = OffsetMins.ToString();            utcString = ("-" + strTemp.Substring(1' (strTemp.Length - 1)).PadLeft(3' '0'));          }        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: if ((Math.Abs(OffsetMins) > 999))        {          date = date.ToUniversalTime();          utcString = "+000";        }        else        {          if ((tickOffset.Ticks >= 0))          {            utcString = ("+" + ((tickOffset.Ticks / TimeSpan.TicksPerMinute)).ToString().PadLeft(3' '0'));          }          else          {            string strTemp = OffsetMins.ToString();            utcString = ("-" + strTemp.Substring(1' (strTemp.Length - 1)).PadLeft(3' '0'));          }        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: if ((Math.Abs(OffsetMins) > 999))        {          date = date.ToUniversalTime();          utcString = "+000";        }        else        {          if ((tickOffset.Ticks >= 0))          {            utcString = ("+" + ((tickOffset.Ticks / TimeSpan.TicksPerMinute)).ToString().PadLeft(3' '0'));          }          else          {            string strTemp = OffsetMins.ToString();            utcString = ("-" + strTemp.Substring(1' (strTemp.Length - 1)).PadLeft(3' '0'));          }        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: string dmtfDateTime = date.Year.ToString().PadLeft(4' '0');
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: dmtfDateTime = (dmtfDateTime + date.Month.ToString().PadLeft(2' '0'));
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: dmtfDateTime = (dmtfDateTime + date.Day.ToString().PadLeft(2' '0'));
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: dmtfDateTime = (dmtfDateTime + date.Hour.ToString().PadLeft(2' '0'));
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: dmtfDateTime = (dmtfDateTime + date.Minute.ToString().PadLeft(2' '0'));
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: dmtfDateTime = (dmtfDateTime + date.Second.ToString().PadLeft(2' '0'));
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: long microsec = (((date.Ticks - dtTemp.Ticks)                          * 1000)                         / TimeSpan.TicksPerMillisecond);
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: if ((strMicrosec.Length > 6))        {          strMicrosec = strMicrosec.Substring(0' 6);        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: if ((strMicrosec.Length > 6))        {          strMicrosec = strMicrosec.Substring(0' 6);        }
Magic Number,ROOT.CIMV2.Win32,Logicaldisk,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\Logicaldisk.cs,ToDmtfDateTime,The following statement contains a magic number: dmtfDateTime = (dmtfDateTime + strMicrosec.PadLeft(6' '0'));
Magic Number,Raccoom.Win32,SystemImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,isXpOrAbove,The following statement contains a magic number: if (Environment.OSVersion.Version.Major > 5)        {          ret = true;        }        else if ((Environment.OSVersion.Version.Major == 5) &&                 (Environment.OSVersion.Version.Minor >= 1))        {          ret = true;        }
Magic Number,Raccoom.Win32,SystemImageList,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\Win32\SystemImageList.cs,isXpOrAbove,The following statement contains a magic number: if (Environment.OSVersion.Version.Major > 5)        {          ret = true;        }        else if ((Environment.OSVersion.Version.Major == 5) &&                 (Environment.OSVersion.Version.Minor >= 1))        {          ret = true;        }
Magic Number,MPTagThat.Core.Freedb,CDInfo,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\CDInfo.cs,ToString,The following statement contains a magic number: StringBuilder buff = new StringBuilder(100);
Magic Number,MPTagThat.Core.Freedb,CDTrackDetail,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\CDTrackDetail.cs,CDTrackDetail,The following statement contains a magic number: m_durationString = string.Format("{0}:{1}"' (m_duration / 60).ToString().PadLeft(2' '0')'                                         (m_duration % 60).ToString().PadLeft(2' '0'));
Magic Number,MPTagThat.Core.Freedb,CDTrackDetail,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\CDTrackDetail.cs,CDTrackDetail,The following statement contains a magic number: m_durationString = string.Format("{0}:{1}"' (m_duration / 60).ToString().PadLeft(2' '0')'                                         (m_duration % 60).ToString().PadLeft(2' '0'));
Magic Number,MPTagThat.Core.Freedb,CDTrackDetail,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\CDTrackDetail.cs,CDTrackDetail,The following statement contains a magic number: m_durationString = string.Format("{0}:{1}"' (m_duration / 60).ToString().PadLeft(2' '0')'                                         (m_duration % 60).ToString().PadLeft(2' '0'));
Magic Number,MPTagThat.Core.Freedb,CDTrackDetail,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\CDTrackDetail.cs,CDTrackDetail,The following statement contains a magic number: m_durationString = string.Format("{0}:{1}"' (m_duration / 60).ToString().PadLeft(2' '0')'                                         (m_duration % 60).ToString().PadLeft(2' '0'));
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,FreeDBQuery,The following statement contains a magic number: StringBuilder buff = new StringBuilder(512);
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,Connect,The following statement contains a magic number: m_server = new FreeDBSite("freedb.freedb.org"' FreeDBSite.FreeDBProtocol.HTTP' 80' "/~cddb/cddb.cgi"'                                  "N000.00"' "W000.00"' "Random freedb server");
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetFeedbSites,The following statement contains a magic number: m_message = m_message.Substring(4);
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetFeedbSites,The following statement contains a magic number: switch (code)        {          case 210: // OK' Site Information Follows.            // Read in all sites.            string[] sites = ParseMultiLine(urlRdr);            retval = new FreeDBSite[sites.Length];            int index = 0;            // Loop through server list and extract different parts.            foreach (string site in sites)            {              string loc = "";              string[] siteInfo = site.Split(sep);              retval[index] = new FreeDBSite();              retval[index].Host = siteInfo[0];              retval[index].Protocol =                (FreeDBSite.FreeDBProtocol)Enum.Parse(typeof (FreeDBSite.FreeDBProtocol)' siteInfo[1]' true);              retval[index].Port = Convert.ToInt32(siteInfo[2]);              retval[index].URI = siteInfo[3];              retval[index].Latitude = siteInfo[4];              retval[index].Longitude = siteInfo[5];                for (int i = 6; i < siteInfo.Length; i++)                loc += retval[i] + " ";              retval[index].Location = loc;              index++;            }            break;          case 401: // No Site Information Available.            break;            ;          default:            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetFeedbSites,The following statement contains a magic number: switch (code)        {          case 210: // OK' Site Information Follows.            // Read in all sites.            string[] sites = ParseMultiLine(urlRdr);            retval = new FreeDBSite[sites.Length];            int index = 0;            // Loop through server list and extract different parts.            foreach (string site in sites)            {              string loc = "";              string[] siteInfo = site.Split(sep);              retval[index] = new FreeDBSite();              retval[index].Host = siteInfo[0];              retval[index].Protocol =                (FreeDBSite.FreeDBProtocol)Enum.Parse(typeof (FreeDBSite.FreeDBProtocol)' siteInfo[1]' true);              retval[index].Port = Convert.ToInt32(siteInfo[2]);              retval[index].URI = siteInfo[3];              retval[index].Latitude = siteInfo[4];              retval[index].Longitude = siteInfo[5];                for (int i = 6; i < siteInfo.Length; i++)                loc += retval[i] + " ";              retval[index].Location = loc;              index++;            }            break;          case 401: // No Site Information Available.            break;            ;          default:            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetFeedbSites,The following statement contains a magic number: switch (code)        {          case 210: // OK' Site Information Follows.            // Read in all sites.            string[] sites = ParseMultiLine(urlRdr);            retval = new FreeDBSite[sites.Length];            int index = 0;            // Loop through server list and extract different parts.            foreach (string site in sites)            {              string loc = "";              string[] siteInfo = site.Split(sep);              retval[index] = new FreeDBSite();              retval[index].Host = siteInfo[0];              retval[index].Protocol =                (FreeDBSite.FreeDBProtocol)Enum.Parse(typeof (FreeDBSite.FreeDBProtocol)' siteInfo[1]' true);              retval[index].Port = Convert.ToInt32(siteInfo[2]);              retval[index].URI = siteInfo[3];              retval[index].Latitude = siteInfo[4];              retval[index].Longitude = siteInfo[5];                for (int i = 6; i < siteInfo.Length; i++)                loc += retval[i] + " ";              retval[index].Location = loc;              index++;            }            break;          case 401: // No Site Information Available.            break;            ;          default:            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetFeedbSites,The following statement contains a magic number: switch (code)        {          case 210: // OK' Site Information Follows.            // Read in all sites.            string[] sites = ParseMultiLine(urlRdr);            retval = new FreeDBSite[sites.Length];            int index = 0;            // Loop through server list and extract different parts.            foreach (string site in sites)            {              string loc = "";              string[] siteInfo = site.Split(sep);              retval[index] = new FreeDBSite();              retval[index].Host = siteInfo[0];              retval[index].Protocol =                (FreeDBSite.FreeDBProtocol)Enum.Parse(typeof (FreeDBSite.FreeDBProtocol)' siteInfo[1]' true);              retval[index].Port = Convert.ToInt32(siteInfo[2]);              retval[index].URI = siteInfo[3];              retval[index].Latitude = siteInfo[4];              retval[index].Longitude = siteInfo[5];                for (int i = 6; i < siteInfo.Length; i++)                loc += retval[i] + " ";              retval[index].Location = loc;              index++;            }            break;          case 401: // No Site Information Available.            break;            ;          default:            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetFeedbSites,The following statement contains a magic number: switch (code)        {          case 210: // OK' Site Information Follows.            // Read in all sites.            string[] sites = ParseMultiLine(urlRdr);            retval = new FreeDBSite[sites.Length];            int index = 0;            // Loop through server list and extract different parts.            foreach (string site in sites)            {              string loc = "";              string[] siteInfo = site.Split(sep);              retval[index] = new FreeDBSite();              retval[index].Host = siteInfo[0];              retval[index].Protocol =                (FreeDBSite.FreeDBProtocol)Enum.Parse(typeof (FreeDBSite.FreeDBProtocol)' siteInfo[1]' true);              retval[index].Port = Convert.ToInt32(siteInfo[2]);              retval[index].URI = siteInfo[3];              retval[index].Latitude = siteInfo[4];              retval[index].Longitude = siteInfo[5];                for (int i = 6; i < siteInfo.Length; i++)                loc += retval[i] + " ";              retval[index].Location = loc;              index++;            }            break;          case 401: // No Site Information Available.            break;            ;          default:            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetFeedbSites,The following statement contains a magic number: switch (code)        {          case 210: // OK' Site Information Follows.            // Read in all sites.            string[] sites = ParseMultiLine(urlRdr);            retval = new FreeDBSite[sites.Length];            int index = 0;            // Loop through server list and extract different parts.            foreach (string site in sites)            {              string loc = "";              string[] siteInfo = site.Split(sep);              retval[index] = new FreeDBSite();              retval[index].Host = siteInfo[0];              retval[index].Protocol =                (FreeDBSite.FreeDBProtocol)Enum.Parse(typeof (FreeDBSite.FreeDBProtocol)' siteInfo[1]' true);              retval[index].Port = Convert.ToInt32(siteInfo[2]);              retval[index].URI = siteInfo[3];              retval[index].Latitude = siteInfo[4];              retval[index].Longitude = siteInfo[5];                for (int i = 6; i < siteInfo.Length; i++)                loc += retval[i] + " ";              retval[index].Location = loc;              index++;            }            break;          case 401: // No Site Information Available.            break;            ;          default:            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetFeedbSites,The following statement contains a magic number: switch (code)        {          case 210: // OK' Site Information Follows.            // Read in all sites.            string[] sites = ParseMultiLine(urlRdr);            retval = new FreeDBSite[sites.Length];            int index = 0;            // Loop through server list and extract different parts.            foreach (string site in sites)            {              string loc = "";              string[] siteInfo = site.Split(sep);              retval[index] = new FreeDBSite();              retval[index].Host = siteInfo[0];              retval[index].Protocol =                (FreeDBSite.FreeDBProtocol)Enum.Parse(typeof (FreeDBSite.FreeDBProtocol)' siteInfo[1]' true);              retval[index].Port = Convert.ToInt32(siteInfo[2]);              retval[index].URI = siteInfo[3];              retval[index].Latitude = siteInfo[4];              retval[index].Longitude = siteInfo[5];                for (int i = 6; i < siteInfo.Length; i++)                loc += retval[i] + " ";              retval[index].Location = loc;              index++;            }            break;          case 401: // No Site Information Available.            break;            ;          default:            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfo,The following statement contains a magic number: m_message = m_message.Substring(4);
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfo,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfo,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfo,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfo,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfo,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfo,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfo,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfo,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfoByID,The following statement contains a magic number: m_message = m_message.Substring(4);
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfoByID,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfoByID,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfoByID,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfoByID,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfoByID,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfoByID,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfoByID,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetDiscInfoByID,The following statement contains a magic number: switch (code)        {          case 200: // Exact Match...            match = m_message.Split(sep);            retval = new CDInfo[1];              retval[0] = new CDInfo();            retval[0].Category = match[0];            retval[0].DiscId = match[1];            for (int i = 2; i < match.Length; i++)              title += match[i] + " ";            retval[0].Title = title.Trim();            break;          case 202: // no match found            break;          case 211: // Found Inexact Matches. List Follows.          case 210: // Found Exact Matches. List Follows.            matches = ParseMultiLine(urlRdr);            retval = new CDInfo[matches.Length];            foreach (string line in matches)            {              match = line.Split(sep);                retval[index] = new CDInfo();              retval[index].Category = match[0];              retval[index].DiscId = match[1];              for (int i = 2; i < match.Length; i++)                title += match[i] + " ";              retval[index].Title = title.Trim();              index++;            }            break;          case 403: // Database Entry is Corrupt.            retval = null;            break;          case 409: // No handshake... Should not happen!            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetInfo,The following statement contains a magic number: m_message = m_message.Substring(4);
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetInfo,The following statement contains a magic number: switch (code / 100)        {          case 2: // no problem            retval = ParseMultiLine(urlRdr);            break;          case 4: // no permission            retval = null;            break;          case 5: // problem            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetInfo,The following statement contains a magic number: switch (code / 100)        {          case 2: // no problem            retval = ParseMultiLine(urlRdr);            break;          case 4: // no permission            retval = null;            break;          case 5: // problem            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetInfo,The following statement contains a magic number: switch (code / 100)        {          case 2: // no problem            retval = ParseMultiLine(urlRdr);            break;          case 4: // no permission            retval = null;            break;          case 5: // problem            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetInfo,The following statement contains a magic number: switch (code / 100)        {          case 2: // no problem            retval = ParseMultiLine(urlRdr);            break;          case 4: // no permission            retval = null;            break;          case 5: // problem            retval = null;            break;          default:            retval = null;            break;        }
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetStreamFromSite,The following statement contains a magic number: req.Timeout = 50000;
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetCode,The following statement contains a magic number: m_code = Convert.ToInt32(content.Substring(0' 3));
Magic Number,MPTagThat.Core.Freedb,FreeDBQuery,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\FreeDBQuery.cs,GetCDDBDiscID,The following statement contains a magic number: if (drive > -1)        {          string id = BassCd.BASS_CD_GetID(drive' BASSCDId.BASS_CDID_CDDB);          retval = id.Substring(0' 8);          BassCd.BASS_CD_Release(drive);        }
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,parse,The following statement contains a magic number: StringBuilder buff = new StringBuilder(1024);
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,Parse2,The following statement contains a magic number: for (int i = 0; i < content.Length; i++)        {          string curLine = content[i].Trim();          if (curLine.StartsWith("#") && curLine.Trim().Length > 1)          {            //string[] curcomment = curLine.Substring(1).Split(commentSep);            string[] curcomment = null;            int index = curLine.IndexOf(":");            if (index > 0)            {              curcomment = new string[2];              curcomment[0] = curLine.Substring(1' index - 1).Trim();              if (index < curLine.Length)                curcomment[1] = curLine.Substring(index + 1).Trim();              else                curcomment[1] = "";            }            else            {              curcomment = new string[1];              curcomment[0] = curLine.Substring(1).Trim();            }              if (curcomment.Length == 2 && curcomment[0].Length > 0 && curcomment[1].Length > 0)            {              // for comments that are split over two lines.              if (comments.ContainsKey(curcomment[0]))              {                comments[curcomment[0]] += curcomment[1];              }              else              {                comments.Add(curcomment[0]' curcomment[1]);              }            }            else if (curcomment.Length == 1 && curcomment[0].Length > 0)            {              try              {                int lastOne = 0;                int thisOne = Convert.ToInt32(curcomment[0]);                if (offsets.Count > 0)                  lastOne = Convert.ToInt32(offsets[offsets.Count - 1]);                if (thisOne > lastOne) // just to avoid adding unexpected commented numbers as offsets                  offsets.Add(Convert.ToInt32(curcomment[0]));              }              catch              {                ;              }            }          }          else          {            //string[] curfield = curLine.Split(fieldSep);            string[] curfield = null;            int index = curLine.IndexOf("=");            if (index > 0)            {              curfield = new string[2];              curfield[0] = curLine.Substring(0' index).Trim();              if (index < curLine.Length)                curfield[1] = curLine.Substring(index + 1).Trim();              else                curfield[1] = "";            }            else            {              curfield = new string[1];              curfield[0] = curLine.Substring(1).Trim();            }              if (curfield.Length == 2 && curfield[0].Length > 0)            {              // for fields that are split over two lines.              if (fields.ContainsKey(curfield[0]))              {                fields[curfield[0]] += curfield[1];              }              else              {                fields.Add(curfield[0]' curfield[1]);              }            }          }        }
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,Parse2,The following statement contains a magic number: for (int i = 0; i < content.Length; i++)        {          string curLine = content[i].Trim();          if (curLine.StartsWith("#") && curLine.Trim().Length > 1)          {            //string[] curcomment = curLine.Substring(1).Split(commentSep);            string[] curcomment = null;            int index = curLine.IndexOf(":");            if (index > 0)            {              curcomment = new string[2];              curcomment[0] = curLine.Substring(1' index - 1).Trim();              if (index < curLine.Length)                curcomment[1] = curLine.Substring(index + 1).Trim();              else                curcomment[1] = "";            }            else            {              curcomment = new string[1];              curcomment[0] = curLine.Substring(1).Trim();            }              if (curcomment.Length == 2 && curcomment[0].Length > 0 && curcomment[1].Length > 0)            {              // for comments that are split over two lines.              if (comments.ContainsKey(curcomment[0]))              {                comments[curcomment[0]] += curcomment[1];              }              else              {                comments.Add(curcomment[0]' curcomment[1]);              }            }            else if (curcomment.Length == 1 && curcomment[0].Length > 0)            {              try              {                int lastOne = 0;                int thisOne = Convert.ToInt32(curcomment[0]);                if (offsets.Count > 0)                  lastOne = Convert.ToInt32(offsets[offsets.Count - 1]);                if (thisOne > lastOne) // just to avoid adding unexpected commented numbers as offsets                  offsets.Add(Convert.ToInt32(curcomment[0]));              }              catch              {                ;              }            }          }          else          {            //string[] curfield = curLine.Split(fieldSep);            string[] curfield = null;            int index = curLine.IndexOf("=");            if (index > 0)            {              curfield = new string[2];              curfield[0] = curLine.Substring(0' index).Trim();              if (index < curLine.Length)                curfield[1] = curLine.Substring(index + 1).Trim();              else                curfield[1] = "";            }            else            {              curfield = new string[1];              curfield[0] = curLine.Substring(1).Trim();            }              if (curfield.Length == 2 && curfield[0].Length > 0)            {              // for fields that are split over two lines.              if (fields.ContainsKey(curfield[0]))              {                fields[curfield[0]] += curfield[1];              }              else              {                fields.Add(curfield[0]' curfield[1]);              }            }          }        }
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,Parse2,The following statement contains a magic number: for (int i = 0; i < content.Length; i++)        {          string curLine = content[i].Trim();          if (curLine.StartsWith("#") && curLine.Trim().Length > 1)          {            //string[] curcomment = curLine.Substring(1).Split(commentSep);            string[] curcomment = null;            int index = curLine.IndexOf(":");            if (index > 0)            {              curcomment = new string[2];              curcomment[0] = curLine.Substring(1' index - 1).Trim();              if (index < curLine.Length)                curcomment[1] = curLine.Substring(index + 1).Trim();              else                curcomment[1] = "";            }            else            {              curcomment = new string[1];              curcomment[0] = curLine.Substring(1).Trim();            }              if (curcomment.Length == 2 && curcomment[0].Length > 0 && curcomment[1].Length > 0)            {              // for comments that are split over two lines.              if (comments.ContainsKey(curcomment[0]))              {                comments[curcomment[0]] += curcomment[1];              }              else              {                comments.Add(curcomment[0]' curcomment[1]);              }            }            else if (curcomment.Length == 1 && curcomment[0].Length > 0)            {              try              {                int lastOne = 0;                int thisOne = Convert.ToInt32(curcomment[0]);                if (offsets.Count > 0)                  lastOne = Convert.ToInt32(offsets[offsets.Count - 1]);                if (thisOne > lastOne) // just to avoid adding unexpected commented numbers as offsets                  offsets.Add(Convert.ToInt32(curcomment[0]));              }              catch              {                ;              }            }          }          else          {            //string[] curfield = curLine.Split(fieldSep);            string[] curfield = null;            int index = curLine.IndexOf("=");            if (index > 0)            {              curfield = new string[2];              curfield[0] = curLine.Substring(0' index).Trim();              if (index < curLine.Length)                curfield[1] = curLine.Substring(index + 1).Trim();              else                curfield[1] = "";            }            else            {              curfield = new string[1];              curfield[0] = curLine.Substring(1).Trim();            }              if (curfield.Length == 2 && curfield[0].Length > 0)            {              // for fields that are split over two lines.              if (fields.ContainsKey(curfield[0]))              {                fields[curfield[0]] += curfield[1];              }              else              {                fields.Add(curfield[0]' curfield[1]);              }            }          }        }
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,Parse2,The following statement contains a magic number: for (int i = 0; i < content.Length; i++)        {          string curLine = content[i].Trim();          if (curLine.StartsWith("#") && curLine.Trim().Length > 1)          {            //string[] curcomment = curLine.Substring(1).Split(commentSep);            string[] curcomment = null;            int index = curLine.IndexOf(":");            if (index > 0)            {              curcomment = new string[2];              curcomment[0] = curLine.Substring(1' index - 1).Trim();              if (index < curLine.Length)                curcomment[1] = curLine.Substring(index + 1).Trim();              else                curcomment[1] = "";            }            else            {              curcomment = new string[1];              curcomment[0] = curLine.Substring(1).Trim();            }              if (curcomment.Length == 2 && curcomment[0].Length > 0 && curcomment[1].Length > 0)            {              // for comments that are split over two lines.              if (comments.ContainsKey(curcomment[0]))              {                comments[curcomment[0]] += curcomment[1];              }              else              {                comments.Add(curcomment[0]' curcomment[1]);              }            }            else if (curcomment.Length == 1 && curcomment[0].Length > 0)            {              try              {                int lastOne = 0;                int thisOne = Convert.ToInt32(curcomment[0]);                if (offsets.Count > 0)                  lastOne = Convert.ToInt32(offsets[offsets.Count - 1]);                if (thisOne > lastOne) // just to avoid adding unexpected commented numbers as offsets                  offsets.Add(Convert.ToInt32(curcomment[0]));              }              catch              {                ;              }            }          }          else          {            //string[] curfield = curLine.Split(fieldSep);            string[] curfield = null;            int index = curLine.IndexOf("=");            if (index > 0)            {              curfield = new string[2];              curfield[0] = curLine.Substring(0' index).Trim();              if (index < curLine.Length)                curfield[1] = curLine.Substring(index + 1).Trim();              else                curfield[1] = "";            }            else            {              curfield = new string[1];              curfield[0] = curLine.Substring(1).Trim();            }              if (curfield.Length == 2 && curfield[0].Length > 0)            {              // for fields that are split over two lines.              if (fields.ContainsKey(curfield[0]))              {                fields[curfield[0]] += curfield[1];              }              else              {                fields.Add(curfield[0]' curfield[1]);              }            }          }        }
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,InitVariables,The following statement contains a magic number: if (slash < 0)          m_artist = null;        else        {          m_artist = m_title.Substring(0' slash);          m_title = m_title.Substring(slash + 3);        }
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,calculateDurations,The following statement contains a magic number: for (i = 1; i < offsets.Length; i++)          durations[i - 1] = (offsets[i] - offsets[i - 1]) / 75;
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,calculateDurations,The following statement contains a magic number: durations[i - 1] = totalDuration - (offsets[i - 1] / 75);
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,parseCDTitle,The following statement contains a magic number: if (i < 0)          return title;        else          return title.Substring(i + 3);
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,extendedParseTrackTitle,The following statement contains a magic number: if (j > 0)        {          return title.Substring(j + 3);        }          //If we're sure that the CD is a real compilation then we can use this workaround:          //A lot of annotators don't use the standard " / " to split the Artist name from the Title name' instead they rely on the unconventional " - " delimiter        else if (isALegitimateCompilation)        {          j = title.IndexOf(" - ");          if (j > 0)            return title.Substring(j + 3);        }
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,extendedParseTrackTitle,The following statement contains a magic number: if (j > 0)        {          return title.Substring(j + 3);        }          //If we're sure that the CD is a real compilation then we can use this workaround:          //A lot of annotators don't use the standard " / " to split the Artist name from the Title name' instead they rely on the unconventional " - " delimiter        else if (isALegitimateCompilation)        {          j = title.IndexOf(" - ");          if (j > 0)            return title.Substring(j + 3);        }
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,parseTrackTitle,The following statement contains a magic number: if (j > 0)          return title.Substring(j + 3);        else          return title;
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,getTagText,The following statement contains a magic number: for (; i > -1; i = m_content.IndexOf(search' i + key.Length + 2))          s2 += " " + m_content.Substring(i + key.Length + 2' m_content.IndexOf("\n"' i + key.Length + 2)).Trim();
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,getTagText,The following statement contains a magic number: for (; i > -1; i = m_content.IndexOf(search' i + key.Length + 2))          s2 += " " + m_content.Substring(i + key.Length + 2' m_content.IndexOf("\n"' i + key.Length + 2)).Trim();
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,getTagText,The following statement contains a magic number: for (; i > -1; i = m_content.IndexOf(search' i + key.Length + 2))          s2 += " " + m_content.Substring(i + key.Length + 2' m_content.IndexOf("\n"' i + key.Length + 2)).Trim();
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,createXMCD,The following statement contains a magic number: StringBuilder content = new StringBuilder(400);
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,createXMCD,The following statement contains a magic number: StringBuilder tracks = new StringBuilder(100);
Magic Number,MPTagThat.Core.Freedb,XMCDParser,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\FreeDB\XMCDParser.cs,createXMCD,The following statement contains a magic number: StringBuilder extt = new StringBuilder(100);
Magic Number,MPTagThat.Core.MediaChangeMonitor,DeviceVolumeMonitor,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MediaChangeMonitor\DeviceVolumeMonitor.cs,MaskToLogicalPaths,The following statement contains a magic number: StringBuilder lReturn = new StringBuilder(128);
Magic Number,MPTagThat.Core.MediaChangeMonitor,DeviceVolumeMonitor,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MediaChangeMonitor\DeviceVolumeMonitor.cs,MaskToLogicalPaths,The following statement contains a magic number: try        {          lReturn = new StringBuilder(128);          if (aMask > 0)          {            for (; lMask != 0; lMask >>= 1)            {              if ((lMask & 1) != 0)              {                lReturn.Append((char)(65 + lValue));                lReturn.Append(":'");              }              lValue++;            }            lReturn.Remove(lReturn.Length - 1' 1);          }          return lReturn.ToString();        }        finally        {          lReturn = null;        }
Magic Number,MPTagThat.Core.MediaChangeMonitor,DeviceVolumeMonitor,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MediaChangeMonitor\DeviceVolumeMonitor.cs,MaskToLogicalPaths,The following statement contains a magic number: try        {          lReturn = new StringBuilder(128);          if (aMask > 0)          {            for (; lMask != 0; lMask >>= 1)            {              if ((lMask & 1) != 0)              {                lReturn.Append((char)(65 + lValue));                lReturn.Append(":'");              }              lValue++;            }            lReturn.Remove(lReturn.Length - 1' 1);          }          return lReturn.ToString();        }        finally        {          lReturn = null;        }
Magic Number,MPTagThat.Core.MediaChangeMonitor,DeviceVolumeMonitor,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MediaChangeMonitor\DeviceVolumeMonitor.cs,MaskToDevicePaths,The following statement contains a magic number: try        {          lBuffer = new StringBuilder(256);          lReturn = new StringBuilder(256);          foreach (string lPath in lLogical)          {            if (QueryDosDevice(lPath' lBuffer' lBuffer.Capacity) > 0)            {              lReturn.Append(lBuffer.ToString());              lReturn.Append("'");            }          }          lReturn.Remove(lReturn.Length - 1' 1);          return lReturn.ToString();        }        finally        {          lBuffer = null;          lReturn = null;        }
Magic Number,MPTagThat.Core.MediaChangeMonitor,DeviceVolumeMonitor,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MediaChangeMonitor\DeviceVolumeMonitor.cs,MaskToDevicePaths,The following statement contains a magic number: try        {          lBuffer = new StringBuilder(256);          lReturn = new StringBuilder(256);          foreach (string lPath in lLogical)          {            if (QueryDosDevice(lPath' lBuffer' lBuffer.Capacity) > 0)            {              lReturn.Append(lBuffer.ToString());              lReturn.Append("'");            }          }          lReturn.Remove(lReturn.Length - 1' 1);          return lReturn.ToString();        }        finally        {          lBuffer = null;          lReturn = null;        }
Magic Number,MPTagThat.Core.Services.MusicDatabase,MusicDatabase,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MusicDatabase\MusicDatabase.cs,ExecuteQuery,The following statement contains a magic number: if (query.Contains(":"))        {          // Set Artist as default order' if nothing is specified          if (order[0] == "")          {            Array.Resize(ref order' 3);            order[0] = "Artist";            order[1] = "Album";            order[2] = "Track";          }            result = _session.Advanced.DocumentQuery<TrackData>()            .Where(query)            .OrderBy(order)            .Take(int.MaxValue)            .ToList();        }        else        {          var searchText = new List<object>();          searchText.AddRange(query.Split(new char[] { ' ' }));          var resultSet = _session.Advanced.DocumentQuery<TrackData' DefaultSearchIndex>()            .ContainsAll("Query"' searchText)            .Take(int.MaxValue)            .ToList();            // need to do our own ordering          result = resultSet.OrderBy(x => x.Artist).ThenBy(x => x.Album).ThenBy(x => x.Track).ToList();        }
Magic Number,MPTagThat.Core.Services.MusicDatabase,MusicDatabase,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MusicDatabase\MusicDatabase.cs,ExecuteQuery,The following statement contains a magic number: if (query.Contains(":"))        {          // Set Artist as default order' if nothing is specified          if (order[0] == "")          {            Array.Resize(ref order' 3);            order[0] = "Artist";            order[1] = "Album";            order[2] = "Track";          }            result = _session.Advanced.DocumentQuery<TrackData>()            .Where(query)            .OrderBy(order)            .Take(int.MaxValue)            .ToList();        }        else        {          var searchText = new List<object>();          searchText.AddRange(query.Split(new char[] { ' ' }));          var resultSet = _session.Advanced.DocumentQuery<TrackData' DefaultSearchIndex>()            .ContainsAll("Query"' searchText)            .Take(int.MaxValue)            .ToList();            // need to do our own ordering          result = resultSet.OrderBy(x => x.Artist).ThenBy(x => x.Album).ThenBy(x => x.Track).ToList();        }
Magic Number,MPTagThat.Core.Services.MusicDatabase,MusicDatabase,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MusicDatabase\MusicDatabase.cs,ScanShare_DoWork,The following statement contains a magic number: try        {          BulkInsertOptions bulkInsertOptions = new BulkInsertOptions          {            BatchSize = 1000'            OverwriteExisting = true          };                     using (BulkInsertOperation bulkInsert = _store.BulkInsert(null' bulkInsertOptions))          {            foreach (FileInfo fi in GetFiles(di' true))            {              if (_bgwScanShare.CancellationPending)              {                e.Cancel = true;                break;              }                try              {                if (!Util.IsAudio(fi.FullName))                {                  continue;                }                Util.SendProgress($"Reading file {fi.FullName}");                var track = Track.Create(fi.FullName);                if (track != null)                {                  track = StoreCoverArt(track);                  bulkInsert.Store(track);                  _audioFiles++;                  if (_audioFiles%1000 == 0)                  {                    log.Info($"Number of processed files: {_audioFiles}");                  }                }              }              catch (PathTooLongException)              {                continue;              }              catch (System.UnauthorizedAccessException)              {                continue;              }              catch (Exception ex)              {                log.Error("Error during Database BulkInsert {0}"' ex.Message);              }            }          }        }        catch (System.InvalidOperationException ex)        {          log.Error("Error during Database BulkInsert {0}"' ex.Message);        }
Magic Number,MPTagThat.Core.Services.MusicDatabase,MusicDatabase,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MusicDatabase\MusicDatabase.cs,ScanShare_DoWork,The following statement contains a magic number: try        {          BulkInsertOptions bulkInsertOptions = new BulkInsertOptions          {            BatchSize = 1000'            OverwriteExisting = true          };                     using (BulkInsertOperation bulkInsert = _store.BulkInsert(null' bulkInsertOptions))          {            foreach (FileInfo fi in GetFiles(di' true))            {              if (_bgwScanShare.CancellationPending)              {                e.Cancel = true;                break;              }                try              {                if (!Util.IsAudio(fi.FullName))                {                  continue;                }                Util.SendProgress($"Reading file {fi.FullName}");                var track = Track.Create(fi.FullName);                if (track != null)                {                  track = StoreCoverArt(track);                  bulkInsert.Store(track);                  _audioFiles++;                  if (_audioFiles%1000 == 0)                  {                    log.Info($"Number of processed files: {_audioFiles}");                  }                }              }              catch (PathTooLongException)              {                continue;              }              catch (System.UnauthorizedAccessException)              {                continue;              }              catch (Exception ex)              {                log.Error("Error during Database BulkInsert {0}"' ex.Message);              }            }          }        }        catch (System.InvalidOperationException ex)        {          log.Error("Error during Database BulkInsert {0}"' ex.Message);        }
Magic Number,MPTagThat.Core.Services.MusicDatabase,MusicDatabase,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MusicDatabase\MusicDatabase.cs,CreateDocumentStore,The following statement contains a magic number: return new Lazy<IDocumentStore>(() =>        {                 var docStore = new EmbeddableDocumentStore()          {            UseEmbeddedHttpServer = databaseName == "MusicDatabase" && Options.StartupSettings.RavenStudio'            DataDirectory = $"{Options.StartupSettings.DatabaseFolder}{databaseName}"'            RunInMemory = false'            Configuration =            {              Port = Options.StartupSettings.RavenStudioPort'              MaxPageSize = 300000'            }'          };          if (Options.StartupSettings.RavenStudio)          {            Raven.Database.Server.NonAdminHttp.EnsureCanListenToWhenInNonAdminContext(Options.StartupSettings.RavenStudioPort);          }          docStore.Initialize();            docStore.Conventions.MaxNumberOfRequestsPerSession = 1000000;          docStore.Conventions.AllowMultipuleAsyncOperations = true;            return docStore;        });
Magic Number,MPTagThat.Core.Services.MusicDatabase,MusicDatabase,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\MusicDatabase\MusicDatabase.cs,CreateDocumentStore,The following statement contains a magic number: return new Lazy<IDocumentStore>(() =>        {                 var docStore = new EmbeddableDocumentStore()          {            UseEmbeddedHttpServer = databaseName == "MusicDatabase" && Options.StartupSettings.RavenStudio'            DataDirectory = $"{Options.StartupSettings.DatabaseFolder}{databaseName}"'            RunInMemory = false'            Configuration =            {              Port = Options.StartupSettings.RavenStudioPort'              MaxPageSize = 300000'            }'          };          if (Options.StartupSettings.RavenStudio)          {            Raven.Database.Server.NonAdminHttp.EnsureCanListenToWhenInNonAdminContext(Options.StartupSettings.RavenStudioPort);          }          docStore.Initialize();            docStore.Conventions.MaxNumberOfRequestsPerSession = 1000000;          docStore.Conventions.AllowMultipuleAsyncOperations = true;            return docStore;        });
Magic Number,MPTagThat.Core.ShellLib,ShellBrowseForFolderDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ShellBrowseForFolderDialog.cs,ShowDialog,The following statement contains a magic number: bi.pszDisplayName = new String(' '' 256);
Magic Number,MPTagThat.Core.ShellLib,ShellExecute,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ShellExecute.cs,Execute,The following statement contains a magic number: return (iRetVal > 32) ? true : false;
Magic Number,MPTagThat.Core.ShellLib,ShellOpenFileDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ShellOpenFileDialog.cs,ShellOpenFileDialog,The following statement contains a magic number: _ofn.file = new String(new char[256]);
Magic Number,MPTagThat.Core.ShellLib,ShellOpenFileDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ShellOpenFileDialog.cs,ShellOpenFileDialog,The following statement contains a magic number: _ofn.fileTitle = new String(new char[64]);
Missing Default,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,SaveFile,The following switch statement is missing a default case: switch (dlgResult)          {            case DialogResult.Yes:              Options.ReadOnlyFileHandling = 0; // Yes               break;              case DialogResult.OK:              Options.ReadOnlyFileHandling = 1; // Yes to All               break;              case DialogResult.No:              Options.ReadOnlyFileHandling = 2; // No               break;              case DialogResult.Cancel:              Options.ReadOnlyFileHandling = 3; // No to All               break;          }
Missing Default,MPTagThat.Core,Track,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Common\Track.cs,SaveFile,The following switch statement is missing a default case: switch (Options.MainSettings.CharacterEncoding)              {                case 0:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.Latin1;                  break;                  case 1:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16;                  break;                  case 2:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16BE;                  break;                  case 3:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF8;                  break;                  case 4:                  TagLib.Id3v2.Tag.DefaultEncoding = StringType.UTF16LE;                  break;              }
Missing Default,MPTagThat.Core,ColorSlider,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\Colorslider\ColorSlider.cs,OnKeyUp,The following switch statement is missing a default case: switch (e.KeyCode)        {          case Keys.Down:          case Keys.Left:            SetProperValue(Value - (int)smallChange);            if (Scroll != null) Scroll(this' new ScrollEventArgs(ScrollEventType.SmallDecrement' Value));            break;          case Keys.Up:          case Keys.Right:            SetProperValue(Value + (int)smallChange);            if (Scroll != null) Scroll(this' new ScrollEventArgs(ScrollEventType.SmallIncrement' Value));            break;          case Keys.Home:            Value = barMinimum;            break;          case Keys.End:            Value = barMaximum;            break;          case Keys.PageDown:            SetProperValue(Value - (int)largeChange);            if (Scroll != null) Scroll(this' new ScrollEventArgs(ScrollEventType.LargeDecrement' Value));            break;          case Keys.PageUp:            SetProperValue(Value + (int)largeChange);            if (Scroll != null) Scroll(this' new ScrollEventArgs(ScrollEventType.LargeIncrement' Value));            break;        }
Missing Default,MPTagThat.Core,ThemeManager,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\ThemeManager\ThemeManager.cs,LoadTheme,The following switch statement is missing a default case: switch (attr.Name)              {                case "Label":                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.LabelForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                        Convert.ToInt16(colorArray[2]));                  theme.LabelFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                             (float)                                             Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                               CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "PanelHeading":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.PanelHeadingBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("directionctrlcolor").Value.Split(''');                  theme.PanelHeadingDirectionCtrlColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                        Convert.ToInt16(colorArray[1])'                                                                        Convert.ToInt16(colorArray[2]));                  theme.PanelHeadingFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                    (float)                                                    Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                      CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "FormHeader":                  colorArray = attr.Attributes.GetNamedItem("forecolor").Value.Split(''');                  theme.FormHeaderForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                             Convert.ToInt16(colorArray[1])'                                                             Convert.ToInt16(colorArray[2]));                  theme.FormHeaderFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                                  (float)                                                  Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                    CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;                  case "GridView":                  colorArray = attr.Attributes.GetNamedItem("defaultbackcolor").Value.Split(''');                  theme.DefaultBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("selectionbackcolor").Value.Split(''');                  theme.SelectionBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                            Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowbackcolor").Value.Split(''');                  theme.AlternatingRowBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("alternatingrowforecolor").Value.Split(''');                  theme.AlternatingRowForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                 Convert.ToInt16(colorArray[1])'                                                                 Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedbackcolor").Value.Split(''');                  theme.ChangedBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("changedforecolor").Value.Split(''');                  theme.ChangedForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                          Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorbackcolor").Value.Split(''');                  theme.FixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("fixableerrorforecolor").Value.Split(''');                  theme.FixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                               Convert.ToInt16(colorArray[1])'                                                               Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorbackcolor").Value.Split(''');                  theme.NonFixableErrorBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("nonfixableerrorforecolor").Value.Split(''');                  theme.NonFixableErrorForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                                  Convert.ToInt16(colorArray[1])'                                                                  Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplacebackcolor").Value.Split(''');                  theme.FindReplaceBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("findreplaceforecolor").Value.Split(''');                  theme.FindReplaceForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])'                                                              Convert.ToInt16(colorArray[1])'                                                              Convert.ToInt16(colorArray[2]));                  break;                  case "Button":                  colorArray = attr.Attributes.GetNamedItem("backcolor").Value.Split(''');                  theme.ButtonBackColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  colorArray = attr.Attributes.GetNamedItem("color").Value.Split(''');                  theme.ButtonForeColor = Color.FromArgb(Convert.ToInt16(colorArray[0])' Convert.ToInt16(colorArray[1])'                                                         Convert.ToInt16(colorArray[2]));                  theme.ButtonFont = new Font(attr.Attributes.GetNamedItem("font").Value'                                              (float)                                              Convert.ToDecimal(attr.Attributes.GetNamedItem("size").Value'                                                                CultureInfo.InvariantCulture)' FontStyle.Regular);                  break;              }
Missing Default,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,IsAudio,The following switch statement is missing a default case: switch (ext)        {          case ".aif":          case ".aiff":          case ".ape":          case ".asf":          case ".dsf":          case ".flac":          case ".mp3":          case ".ogg":          case ".opus":          case ".wv":          case ".wma":          case ".mp4":          case ".m4a":          case ".m4b":          case ".m4p":          case ".mpc":          case ".mp+":          case ".mpp":          case ".wav":            return true;        }
Missing Default,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,IsPicture,The following switch statement is missing a default case: switch (ext)        {          case ".bmp":          case ".gif":          case ".jpg":          case ".png":            return true;        }
Missing Default,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,IsReplayGain,The following switch statement is missing a default case: switch (description.ToLowerInvariant())        {          case "replaygain_track_gain":          case "replaygain_track_peak":          case "replaygain_album_gain":          case "replaygain_album_peak":            return true;        }
Missing Default,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,LabelToParameter,The following switch statement is missing a default case: switch (label)        {          case "lblParmArtist":            parameter = "<A>";            break;            case "lblParmTitle":            parameter = "<T>";            break;            case "lblParmAlbum":            parameter = "<B>";            break;            case "lblParmYear":            parameter = "<Y>";            break;            case "lblParmTrack":            parameter = "<K>";            break;            case "lblParmTrackTotal":            parameter = "<k>";            break;            case "lblParmDisc":            parameter = "<D>";            break;            case "lblParmDiscTotal":            parameter = "<d>";            break;            case "lblParmGenre":            parameter = "<G>";            break;            case "lblAlbumArtist":            parameter = "<O>";            break;            case "lblParmComment":            parameter = "<C>";            break;            case "lblConductor":            parameter = "<N>";            break;            case "lblComposer":            parameter = "<R>";            break;            case "lblModifiedBy":            parameter = "<M>";            break;            case "lblBPM":            parameter = "<E>";            break;            case "lblSubTitle":            parameter = "<S>";            break;            case "lblContentGroup":            parameter = "<U>";            break;            case "lblParmFileName":            parameter = "<F>";            break;            case "lblParmEnumerate":            parameter = "<#>";            break;            case "lblParmBitRate":            parameter = "<I>";            break;            case "lblParmFirstArtist":            parameter = "<A:n>";            break;            case "lblParmFirstAlbumArtist":            parameter = "<O:n>";            break;            case "lblParmUnused":            parameter = "<X>";            break;            case "lblParmFolder":            parameter = @"\";            break;        }
Missing Default,MPTagThat.Core,Util,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Utils\Util.cs,FormatGridColumn,The following switch statement is missing a default case: switch (setting.Type.ToLower())        {          case "text":          case "process":            column.ValueType = typeof (string);            break;          case "number":          case "check":          case "rating":            column.ValueType = typeof (int);            break;        }
Missing Default,MPTagThat.Core.AudioEncoder,AudioEncoder,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\AudioEncoder\AudioEncoder.cs,SetOutFileExtension,The following switch statement is missing a default case: switch (_encoder)        {          case "mp3":            outFileName += ".mp3";            break;            case "ogg":            outFileName += ".ogg";            break;            case "flac":            outFileName += ".flac";            break;            case "m4a":            outFileName += ".m4a";            break;            case "wav":            outFileName += ".wav";            break;            case "wma":            outFileName += ".wma";            break;            case "mpc":            outFileName += ".mpc";            break;            case "wv":            outFileName += ".wv";            break;        }
Missing Default,MPTagThat.Core.AudioEncoder,AudioEncoder,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\AudioEncoder\AudioEncoder.cs,SetEncoderSettings,The following switch statement is missing a default case: switch (_encoder)        {          case "mp3":            EncoderLAME encLame = new EncoderLAME(stream);            if (Options.MainSettings.RipLameExpert.Length > 0)            {              encLame.LAME_CustomOptions = Options.MainSettings.RipLameExpert;              encLame.LAME_UseCustomOptionsOnly = true;            }            else            {              if (Options.MainSettings.RipLamePreset == (int)Options.LamePreset.ABR)                encLame.LAME_PresetName = Options.MainSettings.RipLameABRBitRate.ToString();              else                encLame.LAME_PresetName =                  Enum.GetName(typeof (Options.LamePreset)' Options.MainSettings.RipLamePreset).ToLower();            }            encoder = encLame;            break;            case "ogg":            EncoderOGG encOgg = new EncoderOGG(stream);            if (Options.MainSettings.RipOggExpert.Length > 0)            {              encOgg.OGG_CustomOptions = Options.MainSettings.RipOggExpert;              encOgg.OGG_UseCustomOptionsOnly = true;            }            else            {              encOgg.OGG_Quality = Convert.ToInt32(Options.MainSettings.RipOggQuality);            }            encoder = encOgg;            break;            case "flac":            EncoderFLAC encFlac = new EncoderFLAC(stream);            if (Options.MainSettings.RipFlacExpert.Length > 0)            {              encFlac.FLAC_CustomOptions = Options.MainSettings.RipFlacExpert;              encFlac.FLAC_UseCustomOptionsOnly = true;            }            else            {              encFlac.FLAC_CompressionLevel = Options.MainSettings.RipFlacQuality;            }            // put a 1k padding block for Tagging in front            encFlac.FLAC_Padding = 1024;            encoder = encFlac;            break;            case "m4a":            EncoderFAAC encAAC = new EncoderFAAC(stream);              int bitrate =              Convert.ToInt32(Options.MainSettings.RipEncoderAACBitRate.Substring(0'                                                                                  Options.MainSettings.                                                                                    RipEncoderAACBitRate.IndexOf(' ')));            encAAC.FAAC_Bitrate = bitrate;            encAAC.FAAC_Quality = 100;            encAAC.FAAC_UseQualityMode = true;            encAAC.FAAC_WrapMP4 = true;              encoder = encAAC;            break;            case "wav":            EncoderWAV encWav = new EncoderWAV(stream);            encoder = encWav;            break;            case "wma":            EncoderWMA encWma = new EncoderWMA(stream);            string[] sampleFormat = Options.MainSettings.RipEncoderWMASample.Split(''');            string encoderFormat = Options.MainSettings.RipEncoderWMA;            if (encoderFormat == "wmapro" || encoderFormat == "wmalossless")              encWma.WMA_UsePro = true;            else              encWma.WMA_ForceStandard = true;              if (Options.MainSettings.RipEncoderWMACbrVbr == "Vbr")            {              encWma.WMA_UseVBR = true;              encWma.WMA_VBRQuality = Convert.ToInt32(Options.MainSettings.RipEncoderWMABitRate);            }            else              encWma.WMA_Bitrate = Convert.ToInt32(Options.MainSettings.RipEncoderWMABitRate) / 1000;                if (sampleFormat[0] == "24")              encWma.WMA_Use24Bit = true;              encoder = encWma;            break;            case "mpc":            EncoderMPC encMpc = new EncoderMPC(stream);            if (Options.MainSettings.RipEncoderMPCExpert.Length > 0)            {              encMpc.MPC_CustomOptions = Options.MainSettings.RipEncoderMPCExpert;              encMpc.MPC_UseCustomOptionsOnly = true;            }            else            {              encMpc.MPC_Preset =                (EncoderMPC.MPCPreset)Enum.Parse(typeof (EncoderMPC.MPCPreset)' Options.MainSettings.RipEncoderMPCPreset);            }            encoder = encMpc;            break;            case "wv":            EncoderWavPack encWv = new EncoderWavPack(stream);            if (Options.MainSettings.RipEncoderWVExpert.Length > 0)            {              encWv.WV_CustomOptions = Options.MainSettings.RipEncoderWVExpert;              encWv.WV_UseCustomOptionsOnly = true;            }            else            {              if (Options.MainSettings.RipEncoderWVPreset == "-f")                encWv.WV_FastMode = true;              else                encWv.WV_HighQuality = true;            }            encoder = encWv;            break;        }
Missing Default,MPTagThat.Core.Burning,DeviceHelper,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Services\Burner\DeviceHelper.cs,ProcessErrorHandler,The following switch statement is missing a default case: switch (aAppName)        {          case "cdrecord.exe":            if (!aArguments.Contains(@"-minfo"))              log.Warn("Devicehelper: {0} did not exit properly with arguments: {1}' exitcode: {2}"' aAppName'                          aArguments' aExitcode);            break;          case "mkisofs.exe":            if (aExitcode == 253)              log.Error("Devicehelper: ISO creation failed. Possible error: The source files did change.");            else              log.Warn("Devicehelper: {0} did not exit properly with arguments: {1}' exitcode: {2}"' aAppName'                          aArguments' aExitcode);            break;        }
Missing Default,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,animationTimerTick,The following switch statement is missing a default case: switch (currentState)        {          case SplitterState.Collapsing:              if (Dock == DockStyle.Left || Dock == DockStyle.Right)            {              // vertical splitter              if (controlToHide.Width > animationStep)              {                if (expandParentForm && parentForm.WindowState != FormWindowState.Maximized                    && parentForm != null)                {                  parentForm.Width -= animationStep;                }                controlToHide.Width -= animationStep;              }              else              {                if (expandParentForm && parentForm.WindowState != FormWindowState.Maximized                    && parentForm != null)                {                  parentForm.Width = parentFormWidth;                }                controlToHide.Visible = false;                animationTimer.Enabled = false;                controlToHide.Width = controlWidth;                currentState = SplitterState.Collapsed;                Invalidate();              }            }            else            {              // horizontal splitter              if (controlToHide.Height > animationStep)              {                if (expandParentForm && parentForm.WindowState != FormWindowState.Maximized                    && parentForm != null)                {                  parentForm.Height -= animationStep;                }                controlToHide.Height -= animationStep;              }              else              {                if (expandParentForm && parentForm.WindowState != FormWindowState.Maximized                    && parentForm != null)                {                  parentForm.Height = parentFormHeight;                }                controlToHide.Visible = false;                animationTimer.Enabled = false;                controlToHide.Height = controlHeight;                currentState = SplitterState.Collapsed;                Invalidate();              }            }            break;            case SplitterState.Expanding:              if (Dock == DockStyle.Left || Dock == DockStyle.Right)            {              // vertical splitter              if (controlToHide.Width < (controlWidth - animationStep))              {                if (expandParentForm && parentForm.WindowState != FormWindowState.Maximized                    && parentForm != null)                {                  parentForm.Width += animationStep;                }                controlToHide.Width += animationStep;              }              else              {                if (expandParentForm && parentForm.WindowState != FormWindowState.Maximized                    && parentForm != null)                {                  parentForm.Width = parentFormWidth;                }                controlToHide.Width = controlWidth;                controlToHide.Visible = true;                animationTimer.Enabled = false;                currentState = SplitterState.Expanded;                Invalidate();              }            }            else            {              // horizontal splitter              if (controlToHide.Height < (controlHeight - animationStep))              {                if (expandParentForm && parentForm.WindowState != FormWindowState.Maximized                    && parentForm != null)                {                  parentForm.Height += animationStep;                }                controlToHide.Height += animationStep;              }              else              {                if (expandParentForm && parentForm.WindowState != FormWindowState.Maximized                    && parentForm != null)                {                  parentForm.Height = parentFormHeight;                }                controlToHide.Height = controlHeight;                controlToHide.Visible = true;                animationTimer.Enabled = false;                currentState = SplitterState.Expanded;                Invalidate();              }            }            break;        }
Missing Default,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following switch statement is missing a default case: switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y + (i * 3)' x + 1' y + 1 + (i * 3));                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 2' y + 1 + (i * 3)' x + 2' y + 2 + (i * 3));                }              }              break;              case VisualStyles.DoubleDots:              for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x - 1' y + (i * 3)' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 2' y + 1 + (i * 3)' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + 1' y + (i * 3)' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 2' y);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 2' y' x + 2' y + 90);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 90' x + 2' y + 90);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x' y + (i * 5)' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1' y + 1 + (i * 5)' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x' y + (i * 5)' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x' y + (i * 5) + 1);                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 5)' x + 1' y + (i * 5));              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + (i * 2)' x + 2' y + (i * 2));              }                break;          }
Missing Default,NJFLib.Controls,CollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\CollapsibleSplitter\CollapsibleSplitter.cs,OnPaint,The following switch statement is missing a default case: switch (visualStyle)          {            case VisualStyles.Mozilla:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x + (i * 3)' y' x + 1 + (i * 3)' y + 1);                // dark dot                g.DrawLine(new Pen(SystemColors.ControlDarkDark)' x + 1 + (i * 3)' y + 1' x + 2 + (i * 3)' y + 2);                // overdraw the background color as we actually drew 2px diagonal lines' not just dots                if (hot)                {                  g.DrawLine(new Pen(hotColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }                else                {                  g.DrawLine(new Pen(BackColor)' x + 1 + (i * 3)' y + 2' x + 2 + (i * 3)' y + 2);                }              }              break;              case VisualStyles.DoubleDots:                for (int i = 0; i < 30; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y - 1' 1' 1);                i++;                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 3)' y + 2' 1' 1);                // dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDark)' x + (i * 3)' y + 1' 1' 1);              }              break;              case VisualStyles.Win9x:                g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x' y + 2);              g.DrawLine(new Pen(SystemColors.ControlLightLight)' x' y' x + 88' y);              g.DrawLine(new Pen(SystemColors.ControlDark)' x' y + 2' x + 88' y + 2);              g.DrawLine(new Pen(SystemColors.ControlDark)' x + 88' y' x + 88' y + 2);              break;              case VisualStyles.XP:                for (int i = 0; i < 18; i++)              {                // light dot                g.DrawRectangle(new Pen(SystemColors.ControlLight)' x + (i * 5)' y' 2' 2);                // light light dot                g.DrawRectangle(new Pen(SystemColors.ControlLightLight)' x + 1 + (i * 5)' y + 1' 1' 1);                // dark dark dot                g.DrawRectangle(new Pen(SystemColors.ControlDarkDark)' x + (i * 5)' y' 1' 1);                // dark fill                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5) + 1' y);                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 5)' y' x + (i * 5)' y + 1);              }              break;              case VisualStyles.Lines:                for (int i = 0; i < 44; i++)              {                g.DrawLine(new Pen(SystemColors.ControlDark)' x + (i * 2)' y' x + (i * 2)' y + 2);              }                break;          }
Missing Default,Stepi.UI,ExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\ExtendedPanel.cs,Collapse,The following switch statement is missing a default case: switch (captionAlign)        {          case DirectionStyle.Up: //set above            break;            case DirectionStyle.Left:            oldStyle = DirectionStyle.Left;            newStyle = DirectionStyle.Right;            break;            case DirectionStyle.Right:            oldStyle = DirectionStyle.Right;            newStyle = DirectionStyle.Left;            break;            case DirectionStyle.Down:            oldStyle = DirectionStyle.Down;            newStyle = DirectionStyle.Up;            break;        }
Missing Default,Stepi.UI,ExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\ExtendedPanel.cs,Expand,The following switch statement is missing a default case: switch (captionAlign)        {          case DirectionStyle.Up: //set above            break;            case DirectionStyle.Left:            oldStyle = DirectionStyle.Right;            newStyle = DirectionStyle.Left;            break;            case DirectionStyle.Right:            oldStyle = DirectionStyle.Left;            newStyle = DirectionStyle.Right;            break;            case DirectionStyle.Down:            oldStyle = DirectionStyle.Up;            newStyle = DirectionStyle.Down;            break;        }
Missing Default,Stepi.UI,ExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\ExtendedPanel.cs,CheckDocking,The following switch statement is missing a default case: switch (captionAlign)          {            case DirectionStyle.Up:              SuspendLayout();              foreach (Control control in Controls)              {                if (control != captionCtrl)                {                  control.Top += offset;                }              }              ResumeLayout(false);              break;              case DirectionStyle.Down:              SuspendLayout();              foreach (Control control in Controls)              {                if (control != captionCtrl)                {                  control.Top -= offset;                }              }              ResumeLayout(false);                break;              case DirectionStyle.Left:              SuspendLayout();              foreach (Control control in Controls)              {                if (control != captionCtrl)                {                  control.Left += offset;                }              }              ResumeLayout(false);              break;              case DirectionStyle.Right:              SuspendLayout();              foreach (Control control in Controls)              {                if (control != captionCtrl)                {                  control.Left -= offset;                }              }              ResumeLayout(false);              break;          }
Missing Default,Stepi.UI,ExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\ExtendedPanel.cs,SetSizeCallback,The following switch statement is missing a default case: switch (captionAlign)        {          case DirectionStyle.Down:            int tempY = Height - size;            //set the new location of the panel            Win32Wrapper.SetWindowPos(Handle' IntPtr.Zero' Location.X' Location.Y + tempY' Width' size'                                      Win32Wrapper.FlagsSetWindowPos.SWP_NOZORDER |                                      Win32Wrapper.FlagsSetWindowPos.SWP_SHOWWINDOW);            break;            case DirectionStyle.Up:            Height = size;            break;            case DirectionStyle.Right:            int tempX = Width - size;            Win32Wrapper.SetWindowPos(Handle' IntPtr.Zero' Location.X + tempX' Location.Y' size' Height'                                      Win32Wrapper.FlagsSetWindowPos.SWP_NOZORDER |                                      Win32Wrapper.FlagsSetWindowPos.SWP_SHOWWINDOW);            break;            case DirectionStyle.Left:            Width = size;            if (Width < captionCtrl.Width)            {              Width = captionCtrl.Width;            }            break;        }
Missing Default,Stepi.UI,ExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\ExtendedPanel.cs,SetCaptionControl,The following switch statement is missing a default case: switch (captionAlign)        {          case DirectionStyle.Up:            if (flag)            {              captionCtrl.Height = captionSize; //(int)(this.Height * captionSize / 100);              captionCtrl.Location = new Point(0' 0);            }            if (Width != captionCtrl.Width)            {              captionCtrl.Width = Width;            }            break;            case DirectionStyle.Down:            if (flag)            {              captionCtrl.Height = captionSize; //(int)(this.Height * captionSize / 100);              captionCtrl.Location = new Point(0' Height - captionCtrl.Height);            }            if (Width != captionCtrl.Width)            {              captionCtrl.Width = Width;            }              break;            case DirectionStyle.Left:            if (flag)            {              captionCtrl.Width = captionSize; // (int)(this.Width * captionSize / 100);              captionCtrl.Location = new Point(0' 0);            }            if (captionCtrl.Height != Height)            {              captionCtrl.Height = Height;            }            break;            case DirectionStyle.Right:            if (flag)            {              captionCtrl.Width = captionSize; // (int)(this.Width * captionSize / 100);              captionCtrl.Location = new Point(Width - captionCtrl.Width' 0);            }            if (captionCtrl.Height != Height)            {              captionCtrl.Height = Height;            }              break;        }
Missing Default,Stepi.UI,ExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\ExtendedPanel.cs,WndProc,The following switch statement is missing a default case: switch (captionAlign)          {            case DirectionStyle.Down:              //set the new location of the panel              Win32Wrapper.SetWindowPos(Handle' IntPtr.Zero' Location.X' Location.Y + captionCtrl.Location.Y' Width'                                        captionCtrl.Height' Win32Wrapper.FlagsSetWindowPos.SWP_NOZORDER);              captionCtrl.SetDirectionStyle(DirectionStyle.Up);              break;              case DirectionStyle.Up:              Height = captionCtrl.Height;              captionCtrl.SetDirectionStyle(DirectionStyle.Down);              break;              case DirectionStyle.Right:              //int tempX = this.Width - size;              Win32Wrapper.SetWindowPos(Handle' IntPtr.Zero' Location.X + Width - captionCtrl.Location.X' Location.Y'                                        captionCtrl.Width' Height' Win32Wrapper.FlagsSetWindowPos.SWP_NOZORDER);              captionCtrl.SetDirectionStyle(DirectionStyle.Left);              break;              case DirectionStyle.Left:              Width = captionCtrl.Width;              captionCtrl.SetDirectionStyle(DirectionStyle.Right);              break;          }
Missing Default,Stepi.UI,ExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\ExtendedPanel.cs,CollapsingHandler,The following switch statement is missing a default case: switch (captionAlign)        {          case DirectionStyle.Up:            if (e.Old == DirectionStyle.Up)            {              backupHeight = Height;              backupWidth = Width;                collapseAnimation.Maximum = Height;              collapseAnimation.Minimum = captionCtrl.Height;              if (animation == Animation.Yes)              {                collapseAnimation.Step = step;              }              else              {                collapseAnimation.Step = Height - captionCtrl.Height;              }            }            else            {              collapseAnimation.Maximum = backupHeight;              collapseAnimation.Minimum = captionCtrl.Height;              if (animation == Animation.Yes)              {                collapseAnimation.Step = -step;              }              else              {                collapseAnimation.Step = -(backupHeight - captionCtrl.Height);              }            }            break;            case DirectionStyle.Down:            if (e.Old == DirectionStyle.Down)            {              //have to extract caption ctrl because of the flickering involved              ChangeCaptionParent();                //save the size as will need them for expanding the control back              backupHeight = Height;              backupWidth = Width;                collapseAnimation.Maximum = Height;              collapseAnimation.Minimum = captionCtrl.Height;              if (animation == Animation.Yes)              {                collapseAnimation.Step = step;              }              else              {                collapseAnimation.Step = Height - captionCtrl.Height;              }            }            else            {              //have to extract caption ctrl because of the flickering involved              ChangeCaptionParent();                collapseAnimation.Maximum = backupHeight;              collapseAnimation.Minimum = captionCtrl.Height;              if (animation == Animation.Yes)              {                collapseAnimation.Step = -step;              }              else              {                collapseAnimation.Step = -(backupHeight - captionCtrl.Height);              }            }            break;              case DirectionStyle.Left:            if (e.Old == DirectionStyle.Left)            {              //save the size as will need them for expanding the control back              backupHeight = Height;              backupWidth = Width;                collapseAnimation.Maximum = Width;              collapseAnimation.Minimum = captionCtrl.Width;              if (animation == Animation.Yes)              {                collapseAnimation.Step = step;              }              else              {                collapseAnimation.Step = Width - captionCtrl.Width;              }            }            else            {              collapseAnimation.Maximum = backupWidth;              collapseAnimation.Minimum = captionCtrl.Width;              if (animation == Animation.Yes)              {                collapseAnimation.Step = -step;              }              else              {                collapseAnimation.Step = -(backupWidth - captionCtrl.Width);              }            }            break;            case DirectionStyle.Right:            if (e.Old == DirectionStyle.Right)            {              //have to extract caption ctrl because of the flickering involved              ChangeCaptionParent();                backupHeight = Height;              backupWidth = Width;                collapseAnimation.Maximum = Width;              collapseAnimation.Minimum = captionCtrl.Width;              if (animation == Animation.Yes)              {                collapseAnimation.Step = step;              }              else              {                collapseAnimation.Step = Width - captionCtrl.Width;              }            }            else            {              //have to extract caption ctrl because of the flickering involved              ChangeCaptionParent();                collapseAnimation.Maximum = backupWidth;              collapseAnimation.Minimum = captionCtrl.Width;              if (animation == Animation.Yes)              {                collapseAnimation.Step = -step;              }              else              {                collapseAnimation.Step = -(backupWidth - captionCtrl.Width);              }            }            break;        }
Missing Default,Stepi.UI,DirectionCtrl,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\ExtendedPanel\Helpers\DirectionCtrl.cs,OnMouseClickEvent,The following switch statement is missing a default case: switch (directionStyle)        {          case DirectionStyle.Up:            directionStyle = DirectionStyle.Down;            break;            case DirectionStyle.Down:            directionStyle = DirectionStyle.Up;            break;            case DirectionStyle.Left:            directionStyle = DirectionStyle.Right;            break;            case DirectionStyle.Right:            directionStyle = DirectionStyle.Left;            break;        }
Missing Default,Raccoom.Windows.Forms,TreeViewFolderBrowserDataProviderMusicDb,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\TreeviewBrowser\TreeViewFolderBrowserDataProviderMusicDb.cs,RequestSubDirs,The following switch statement is missing a default case: switch ((string)parent.Tag)          {            case "artist":              _rootFolder = RootFolder.Artist;              result = ServiceScope.Get<IMusicDatabase>().GetArtists();              break;              case "albumartist":              _rootFolder = RootFolder.AlbumArtist;              result = ServiceScope.Get<IMusicDatabase>().GetAlbumArtists();              break;              case "genre":              _rootFolder = RootFolder.Genre;              result = ServiceScope.Get<IMusicDatabase>().GetGenres();              break;          }
Missing Default,MPTagThat.Core.WinControls,MPTCollapsibleSplitter,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\WinControls\MPTCollapsibleSplitter.cs,OnMessageReceive,The following switch statement is missing a default case: switch (action.ToLower())        {            // Message sent' when a Theme is changing          case "themechanged":            {              BackColor = themeManager.CurrentTheme.BackColor;              break;            }        }
Missing Default,MPTagThat.Core.WinControls,TTExtendedPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\WinControls\MPTExtendedPanel.cs,OnMessageReceive,The following switch statement is missing a default case: switch (action.ToLower())        {            // Message sent' when a Theme is changing          case "themechanged":            {              BackColor = themeManager.CurrentTheme.BackColor;              CaptionColorOne = themeManager.CurrentTheme.PanelHeadingBackColor;              CaptionFont = themeManager.CurrentTheme.PanelHeadingFont;              CaptionTextColor = themeManager.CurrentTheme.LabelForeColor;              DirectionCtrlColor = themeManager.CurrentTheme.PanelHeadingDirectionCtrlColor;              break;            }            case "languagechanged":            Refresh();            break;        }
Missing Default,MPTagThat.Core.WinControls,MPTRadioButton,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\WinControls\MPTRadioButton.cs,OnMessageReceive,The following switch statement is missing a default case: switch (action.ToLower())        {          case "themechanged":            {              Font = themeManager.CurrentTheme.LabelFont;              break;            }            case "languagechanged":            Text = MPTWinControlsCommon.Localise(_localisationContext' _localisation);            Refresh();            break;        }
Missing Default,MPTagThat.Core.WinControls,MPTPanel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\WinControls\MPTPanel.cs,OnMessageReceive,The following switch statement is missing a default case: switch (action.ToLower())        {            // Message sent' when a Theme is changing          case "themechanged":            {              BackColor = themeManager.CurrentTheme.BackColor;              break;            }        }
Missing Default,MPTagThat.Core.WinControls,MPTTabPage,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\WinControls\MPTTabPage.cs,OnMessageReceive,The following switch statement is missing a default case: switch (action.ToLower())        {          case "themechanged":            {              Font = themeManager.CurrentTheme.LabelFont;              if (TabControl != null)              {                TabControl.Font = themeManager.CurrentTheme.LabelFont;              }              break;            }             case "languagechanged":            Text = MPTWinControlsCommon.Localise(_localisationContext' _localisation);            Refresh();            break;        }
Missing Default,MPTagThat.Core.WinControls,MPTCheckBox,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\WinControls\MPTCheckBox.cs,OnMessageReceive,The following switch statement is missing a default case: switch (action.ToLower())        {            // Message sent' when a Theme is changing          case "themechanged":            {              Font = themeManager.CurrentTheme.LabelFont;              break;            }            case "languagechanged":            Text = MPTWinControlsCommon.Localise(_localisationContext' _localisation);            Refresh();            break;        }
Missing Default,MPTagThat.Core.WinControls,MPTButton,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\WinControls\MPTButton.cs,OnMessageReceive,The following switch statement is missing a default case: switch (action.ToLower())        {          case "themechanged":            {              Font = themeManager.CurrentTheme.LabelFont;              break;            }            case "languagechanged":            Text = MPTWinControlsCommon.Localise(_localisationContext' _localisation);            Refresh();            break;        }
Missing Default,MPTagThat.Core.WinControls,MPTGroupBox,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\WinControls\MPTGroupBox.cs,OnMessageReceive,The following switch statement is missing a default case: switch (action.ToLower())        {          case "themechanged":            {              Font = themeManager.CurrentTheme.LabelFont;              break;            }            case "languagechanged":            Text = MPTWinControlsCommon.Localise(_localisationContext' _localisation);            Refresh();            break;        }
Missing Default,MPTagThat.Core.WinControls,MPTLabel,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\Controls\WinControls\MPTLabel.cs,OnMessageReceive,The following switch statement is missing a default case: switch (action.ToLower())        {          // Message sent' when a Theme is changing          case "themechanged":            {              Font = themeManager.CurrentTheme.LabelFont;              break;            }            case "languagechanged":            Text = MPTWinControlsCommon.Localise(_localisationContext' _localisation);            Refresh();            break;        }
Missing Default,MPTagThat.Core.ShellLib,ApplicationDesktopToolbar,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ApplicationDesktopToolbar.cs,SizeAppBar,The following switch statement is missing a default case: switch (m_Edge)        {          case AppBarEdges.Left:            rt.right = rt.left + m_PrevSize.Width;            break;          case AppBarEdges.Right:            rt.left = rt.right - m_PrevSize.Width;            break;          case AppBarEdges.Top:            rt.bottom = rt.top + m_PrevSize.Height;            break;          case AppBarEdges.Bottom:            rt.top = rt.bottom - m_PrevSize.Height;            break;        }
Missing Default,MPTagThat.Core.ShellLib,ApplicationDesktopToolbar,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ApplicationDesktopToolbar.cs,OnAppbarNotification,The following switch statement is missing a default case: switch (msgType)        {          case AppBarNotifications.PosChanged:            SizeAppBar();            break;            case AppBarNotifications.StateChange:            state = AppbarGetTaskbarState();            if ((state & AppBarStates.AlwaysOnTop) != 0)            {              TopMost = true;              BringToFront();            }            else            {              TopMost = false;              SendToBack();            }            break;            case AppBarNotifications.FullScreenApp:            if ((int)msg.LParam != 0)            {              TopMost = false;              SendToBack();            }            else            {              state = AppbarGetTaskbarState();              if ((state & AppBarStates.AlwaysOnTop) != 0)              {                TopMost = true;                BringToFront();              }              else              {                TopMost = false;                SendToBack();              }            }              break;            case AppBarNotifications.WindowArrange:            if ((int)msg.LParam != 0) // before              Visible = false;            else // after              Visible = true;              break;        }
Missing Default,MPTagThat.Core.ShellLib,ShellBrowseForFolderDialog,C:\repos\MediaPortal_MPTagThat\MPTagThat.Core\ShellLib\ShellBrowseForFolderDialog.cs,myBrowseCallbackProc,The following switch statement is missing a default case: switch ((BrowseForFolderMessages)uMsg)        {          case BrowseForFolderMessages.BFFM_INITIALIZED:            Debug.WriteLine("BFFM_INITIALIZED");              if (OnInitialized != null)            {              InitializedEventArgs args = new InitializedEventArgs(hwnd);              OnInitialized(this' args);            }              break;            case BrowseForFolderMessages.BFFM_IUNKNOWN:            Debug.WriteLine("BFFM_IUNKNOWN");              if (OnIUnknown != null)            {              IUnknownEventArgs args = new IUnknownEventArgs(hwnd' (IntPtr)lParam);              OnIUnknown(this' args);            }              break;            case BrowseForFolderMessages.BFFM_SELCHANGED:            Debug.WriteLine("BFFM_SELCHANGED");              if (OnSelChanged != null)            {              SelChangedEventArgs args = new SelChangedEventArgs(hwnd' (IntPtr)lParam);              OnSelChanged(this' args);            }              break;            case BrowseForFolderMessages.BFFM_VALIDATEFAILEDA:            Debug.WriteLine("BFFM_VALIDATEFAILEDA");              if (OnValidateFailed != null)            {              string failedSel = Marshal.PtrToStringAnsi((IntPtr)lParam);              ValidateFailedEventArgs args = new ValidateFailedEventArgs(hwnd' failedSel);              return OnValidateFailed(this' args);            }            break;            case BrowseForFolderMessages.BFFM_VALIDATEFAILEDW:            Debug.WriteLine("BFFM_VALIDATEFAILEDW");              if (OnValidateFailed != null)            {              string failedSel = Marshal.PtrToStringUni((IntPtr)lParam);              ValidateFailedEventArgs args = new ValidateFailedEventArgs(hwnd' failedSel);              return OnValidateFailed(this' args);            }              break;        }
