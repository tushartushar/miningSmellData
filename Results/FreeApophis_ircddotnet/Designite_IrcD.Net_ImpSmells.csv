Implementation smell,Namespace,Class,File,Method,Description
Long Method,IrcD.Modes,ChannelModeList,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModeList.cs,Update,The method has 140 lines of code.
Complex Method,IrcD.Commands,Capabilities,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\Capabilities.cs,PrivateHandle,Cyclomatic complexity of the method is 17
Complex Method,IrcD.Commands,CommandList,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\CommandList.cs,Handle,Cyclomatic complexity of the method is 8
Complex Method,IrcD.Commands,Notice,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\Notice.cs,PrivateHandle,Cyclomatic complexity of the method is 9
Complex Method,IrcD.Commands,PrivateMessage,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\PrivateMessage.cs,PrivateHandle,Cyclomatic complexity of the method is 9
Complex Method,IrcD.Commands,Stats,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\Stats.cs,PrivateHandle,Cyclomatic complexity of the method is 8
Complex Method,IrcD.Commands,Who,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\Who.cs,PrivateHandle,Cyclomatic complexity of the method is 8
Complex Method,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,Cyclomatic complexity of the method is 14
Complex Method,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,Parser,Cyclomatic complexity of the method is 14
Complex Method,IrcD.Modes,ChannelModeList,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModeList.cs,Update,Cyclomatic complexity of the method is 35
Complex Method,IrcD.Modes,UserModeList,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\UserModeList.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,IrcD.ServerReplies,ServerReplies,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\ServerReplies\ServerReplies.cs,SendSplitted,Cyclomatic complexity of the method is 10
Long Parameter List,IrcD.Commands,CommandList,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\CommandList.cs,Handle,The method has 5 parameters.
Long Parameter List,IrcD.Commands,CommandList,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\CommandList.cs,Handle,The method has 5 parameters.
Long Parameter List,IrcD.Commands.Arguments,KickArgument,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\Arguments\KickArgument.cs,KickArgument,The method has 5 parameters.
Long Parameter List,IrcD.Core,UserInfo,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\UserInfo.cs,UserInfo,The method has 5 parameters.
Long Statement,IrcD.Commands,CommandList,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\CommandList.cs,Handle,The length of the statement  "		var checkRegistered = Attribute.GetCustomAttribute (handleMethodInfo' typeof(CheckRegisteredAttribute)) as CheckRegisteredAttribute; " is 132.
Long Statement,IrcD.Commands,CommandList,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\CommandList.cs,Handle,The length of the statement  "		var checkParamCount = Attribute.GetCustomAttribute (handleMethodInfo' typeof(CheckParamCountAttribute)) as CheckParamCountAttribute; " is 132.
Long Statement,IrcD.Commands,Join,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\Join.cs,PrivateHandle,The length of the statement  "		// ToDo: this probably should get delegated to the Channel Type specific "NormalChannel" class' because it depends on the channel type. " is 135.
Long Statement,IrcD.Commands,Knock,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\Knock.cs,PrivateHandle,The length of the statement  "		Send (new NoticeArgument (chan' chan.Name' "[KNOCK] by " + info.Usermask + "(" + ((args.Count > 1) ? args [1] : "no reason specified") + ")")); " is 143.
Long Statement,IrcD.Commands,Stats,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\Stats.cs,PrivateHandle,The length of the statement  "		foreach (var op in IrcDaemon.Nicks.Select (u => u.Value).Where (n => n.Modes.Exist<ModeOperator> () || n.Modes.Exist<ModeLocalOperator> ()).OrderBy (o => o.Nick)) { " is 164.
Long Statement,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The length of the statement  "						Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass))); " is 151.
Long Statement,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,ValidNick,The length of the statement  "		if (nick.Any (c => c == ' ' || c == ''' || c == '\x7' || c == '!' || c == '@' || c == '*' || c == '?' || c == '+' || c == '%' || c == '#')) " is 139.
Long Statement,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,ValidNick,The length of the statement  "		if (!nick.All (c => (c >= '\x5B' && c <= '\x60') || (c >= '\x7B' && c <= '\x7D') || (c >= 'a' && c < 'z') || (c >= 'A' && c < 'Z') || (c >= '0' && c < '9') || c == '[' || c == ']' || c == '\\' || c == '`' || c == '_' || c == '^' || c == '{' || c == '|' || c == '}')) " is 266.
Long Statement,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,ValidChannel,The length of the statement  "	return SupportedChannelTypes.Any (t => t.Value.Prefix == channel [0]) && (!channel.Any (c => c == ' ' || c == ''' || c == '\x7' || c == ':')); " is 142.
Long Statement,IrcD.Modes.ChannelModes,ModeBan,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeBan.cs,HandleEvent,The length of the statement  "		if (_banList.Select (ban => new WildCard (ban' WildcardMatch.Exact)).Any (usermask => usermask.IsMatch (user.Usermask))) { " is 122.
Long Statement,IrcD.Modes.ChannelModes,ModeBan,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeBan.cs,HandleEvent,The length of the statement  "		if (_banList.Select (ban => new WildCard (ban' WildcardMatch.Exact)).Any (usermask => usermask.IsMatch (user.Usermask))) { " is 122.
Long Statement,IrcD.Modes.ChannelModes,ModeColorless,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeColorless.cs,HandleEvent,The length of the statement  "		if (args [1].Any (c => c == IrcConstants.IrcBold || c == IrcConstants.IrcNormal || c == IrcConstants.IrcUnderline || c == IrcConstants.IrcReverse)) { " is 149.
Long Statement,IrcD.Modes.ChannelModes,ModeColorless,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeColorless.cs,HandleEvent,The length of the statement  "			channel.IrcDaemon.Replies.SendCannotSendToChannel (user' channel.Name' "Control codes (bold/underline/reverse) are not permitted in this channel"); " is 147.
Long Statement,IrcD.Modes.ChannelModes,ModeTranslate,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeTranslate.cs,HandleEvent,The length of the statement  "		user.IrcDaemon.Commands.Send (new NoticeArgument (user' user' channel.Name' "This channel automatically translates your messages' use the LANGUAGE command to set your preferred language")); " is 189.
Long Statement,IrcD.ServerReplies,ServerReplies,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\ServerReplies\ServerReplies.cs,SendISupport,The length of the statement  "	features.Add ("CHANTYPES=" + daemon.SupportedChannelTypes.Select (type => type.Value.Prefix).Concatenate (string.Empty)); " is 121.
Long Statement,IrcD.ServerReplies,ServerReplies,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\ServerReplies\ServerReplies.cs,SendISupport,The length of the statement  "	features.Add ("CHANLIMIT=" + daemon.SupportedChannelTypes.Select (c => c.Value.Prefix + ":" + c.Value.MaxJoinedAllowed).Concatenate ("'")); " is 139.
Long Statement,IrcD.ServerReplies,ServerReplies,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\ServerReplies\ServerReplies.cs,SendWhoIsChannels,The length of the statement  "	SendSplitted (_response.ToString ()' info' who.UserPerChannelInfos.Select (ucpi => ucpi.Modes.NickPrefix + ucpi.ChannelInfo.Name)' null); " is 137.
Long Statement,IrcD.ServerReplies,ServerReplies,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\ServerReplies\ServerReplies.cs,SendInviting,The length of the statement  "	// The RFC Tells the order should be <channel> <nick> however xchat and the servers I tested say it is: <nick> <channel> " is 120.
Long Statement,IrcD.ServerReplies,ServerReplies,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\ServerReplies\ServerReplies.cs,SendWhoReply,The length of the statement  "	_response.Append (who.UserInfo.Modes.Exist<ModeOperator> () || who.UserInfo.Modes.Exist<ModeLocalOperator> () ? "*" : string.Empty); " is 132.
Long Statement,IrcD.ServerReplies,ServerReplies,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\ServerReplies\ServerReplies.cs,SendNamesReply,The length of the statement  "	SendSplitted (_response.ToString ()' info' chan.UserPerChannelInfos.Values.Select (upci => upci.Modes.NickPrefix + upci.UserInfo.Nick)' null); " is 142.
Complex Conditional,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,ValidNick,The conditional expression  "nick.Any (c => c == ' ' || c == ''' || c == '\x7' || c == '!' || c == '@' || c == '*' || c == '?' || c == '+' || c == '%' || c == '#')"  is complex.
Complex Conditional,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,ValidNick,The conditional expression  "!nick.All (c => (c >= '\x5B' && c <= '\x60') || (c >= '\x7B' && c <= '\x7D') || (c >= 'a' && c < 'z') || (c >= 'A' && c < 'Z') || (c >= '0' && c < '9') || c == '[' || c == ']' || c == '\\' || c == '`' || c == '_' || c == '^' || c == '{' || c == '|' || c == '}')"  is complex.
Complex Conditional,IrcD.Modes.ChannelModes,ModeColorless,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeColorless.cs,HandleEvent,The conditional expression  "args [1].Any (c => c == IrcConstants.IrcBold || c == IrcConstants.IrcNormal || c == IrcConstants.IrcUnderline || c == IrcConstants.IrcReverse)"  is complex.
Magic Number,IrcD.Commands,Notice,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\Notice.cs,PrivateHandle,The following statement contains a magic number: if (args.Count < 2) {  	IrcDaemon.Replies.SendNoTextToSend (info);  	return;  }  
Magic Number,IrcD.Commands,PrivateMessage,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\PrivateMessage.cs,PrivateHandle,The following statement contains a magic number: if (args.Count < 2) {  	IrcDaemon.Replies.SendNoTextToSend (info);  	return;  }  
Magic Number,IrcD.Commands,User,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\User.cs,PrivateHandle,The following statement contains a magic number: if ((flags & 8) > 0) {  	info.Modes.Add (new ModeInvisible ());  }  
Magic Number,IrcD.Commands,User,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\User.cs,PrivateHandle,The following statement contains a magic number: if ((flags & 4) > 0) {  	info.Modes.Add (new ModeWallops ());  }  
Magic Number,IrcD.Commands,User,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Commands\User.cs,PrivateHandle,The following statement contains a magic number: info.InitUser (args [0]' args [3]);  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: foreach (var port in Options.ServerPorts) {  	_localEndPoint = new IPEndPoint (IPAddress.Any' port);  	var connectSocket = new Socket (_localEndPoint.AddressFamily' SocketType.Stream' ProtocolType.Tcp);  	connectSocket.Bind (_localEndPoint);  	connectSocket.Listen (20);  	Sockets.Add (connectSocket' new UserInfo (this' connectSocket' Options.ServerName' true' true));  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: connectSocket.Listen (20);  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: while (_connected) {  	try {  		var activeSockets = new List<Socket> (Sockets.Keys);  		Socket.Select (activeSockets' null' null' 2000000);  		foreach (Socket s in activeSockets) {  			try {  				if (Sockets [s].IsAcceptSocket) {  					Socket temp = s.Accept ();  					Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  					Logger.Log ("New Client connected!"' 4' "MainLoop");  				} else {  					try {  						_buffer.Initialize ();  						int numBytes = s.ReceiveFrom (_buffer' ref _ep);  						foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  							'\r''  							'\n'  						}' StringSplitOptions.RemoveEmptyEntries)) {  							Parser (line' Sockets [s]);  						}  					} catch (SocketException e) {  						Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  						Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  					}  				}  			} catch (Exception e) {  				Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  				Logger.Log ("Trace: " + e.StackTrace);  			}  		}  		foreach (var user in from user in Sockets.Where (s => s.Value.Registered)  		let interval = DateTime.Now.AddMinutes (-1)  		where user.Value.LastAction < interval && user.Value.LastAlive < interval  		select user.Value) {  			if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  				user.Remove ("Ping Timeout");  			} else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  				user.LastPing = DateTime.Now;  				Commands.Send (new PingArgument (user));  			}  		}  	} catch (Exception e) {  		Logger.Log ("Unknown ERROR: " + e.Message);  		Logger.Log ("Trace: " + e.StackTrace);  	}  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: while (_connected) {  	try {  		var activeSockets = new List<Socket> (Sockets.Keys);  		Socket.Select (activeSockets' null' null' 2000000);  		foreach (Socket s in activeSockets) {  			try {  				if (Sockets [s].IsAcceptSocket) {  					Socket temp = s.Accept ();  					Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  					Logger.Log ("New Client connected!"' 4' "MainLoop");  				} else {  					try {  						_buffer.Initialize ();  						int numBytes = s.ReceiveFrom (_buffer' ref _ep);  						foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  							'\r''  							'\n'  						}' StringSplitOptions.RemoveEmptyEntries)) {  							Parser (line' Sockets [s]);  						}  					} catch (SocketException e) {  						Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  						Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  					}  				}  			} catch (Exception e) {  				Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  				Logger.Log ("Trace: " + e.StackTrace);  			}  		}  		foreach (var user in from user in Sockets.Where (s => s.Value.Registered)  		let interval = DateTime.Now.AddMinutes (-1)  		where user.Value.LastAction < interval && user.Value.LastAlive < interval  		select user.Value) {  			if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  				user.Remove ("Ping Timeout");  			} else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  				user.LastPing = DateTime.Now;  				Commands.Send (new PingArgument (user));  			}  		}  	} catch (Exception e) {  		Logger.Log ("Unknown ERROR: " + e.Message);  		Logger.Log ("Trace: " + e.StackTrace);  	}  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: while (_connected) {  	try {  		var activeSockets = new List<Socket> (Sockets.Keys);  		Socket.Select (activeSockets' null' null' 2000000);  		foreach (Socket s in activeSockets) {  			try {  				if (Sockets [s].IsAcceptSocket) {  					Socket temp = s.Accept ();  					Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  					Logger.Log ("New Client connected!"' 4' "MainLoop");  				} else {  					try {  						_buffer.Initialize ();  						int numBytes = s.ReceiveFrom (_buffer' ref _ep);  						foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  							'\r''  							'\n'  						}' StringSplitOptions.RemoveEmptyEntries)) {  							Parser (line' Sockets [s]);  						}  					} catch (SocketException e) {  						Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  						Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  					}  				}  			} catch (Exception e) {  				Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  				Logger.Log ("Trace: " + e.StackTrace);  			}  		}  		foreach (var user in from user in Sockets.Where (s => s.Value.Registered)  		let interval = DateTime.Now.AddMinutes (-1)  		where user.Value.LastAction < interval && user.Value.LastAlive < interval  		select user.Value) {  			if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  				user.Remove ("Ping Timeout");  			} else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  				user.LastPing = DateTime.Now;  				Commands.Send (new PingArgument (user));  			}  		}  	} catch (Exception e) {  		Logger.Log ("Unknown ERROR: " + e.Message);  		Logger.Log ("Trace: " + e.StackTrace);  	}  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: while (_connected) {  	try {  		var activeSockets = new List<Socket> (Sockets.Keys);  		Socket.Select (activeSockets' null' null' 2000000);  		foreach (Socket s in activeSockets) {  			try {  				if (Sockets [s].IsAcceptSocket) {  					Socket temp = s.Accept ();  					Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  					Logger.Log ("New Client connected!"' 4' "MainLoop");  				} else {  					try {  						_buffer.Initialize ();  						int numBytes = s.ReceiveFrom (_buffer' ref _ep);  						foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  							'\r''  							'\n'  						}' StringSplitOptions.RemoveEmptyEntries)) {  							Parser (line' Sockets [s]);  						}  					} catch (SocketException e) {  						Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  						Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  					}  				}  			} catch (Exception e) {  				Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  				Logger.Log ("Trace: " + e.StackTrace);  			}  		}  		foreach (var user in from user in Sockets.Where (s => s.Value.Registered)  		let interval = DateTime.Now.AddMinutes (-1)  		where user.Value.LastAction < interval && user.Value.LastAlive < interval  		select user.Value) {  			if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  				user.Remove ("Ping Timeout");  			} else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  				user.LastPing = DateTime.Now;  				Commands.Send (new PingArgument (user));  			}  		}  	} catch (Exception e) {  		Logger.Log ("Unknown ERROR: " + e.Message);  		Logger.Log ("Trace: " + e.StackTrace);  	}  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: while (_connected) {  	try {  		var activeSockets = new List<Socket> (Sockets.Keys);  		Socket.Select (activeSockets' null' null' 2000000);  		foreach (Socket s in activeSockets) {  			try {  				if (Sockets [s].IsAcceptSocket) {  					Socket temp = s.Accept ();  					Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  					Logger.Log ("New Client connected!"' 4' "MainLoop");  				} else {  					try {  						_buffer.Initialize ();  						int numBytes = s.ReceiveFrom (_buffer' ref _ep);  						foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  							'\r''  							'\n'  						}' StringSplitOptions.RemoveEmptyEntries)) {  							Parser (line' Sockets [s]);  						}  					} catch (SocketException e) {  						Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  						Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  					}  				}  			} catch (Exception e) {  				Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  				Logger.Log ("Trace: " + e.StackTrace);  			}  		}  		foreach (var user in from user in Sockets.Where (s => s.Value.Registered)  		let interval = DateTime.Now.AddMinutes (-1)  		where user.Value.LastAction < interval && user.Value.LastAlive < interval  		select user.Value) {  			if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  				user.Remove ("Ping Timeout");  			} else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  				user.LastPing = DateTime.Now;  				Commands.Send (new PingArgument (user));  			}  		}  	} catch (Exception e) {  		Logger.Log ("Unknown ERROR: " + e.Message);  		Logger.Log ("Trace: " + e.StackTrace);  	}  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: try {  	var activeSockets = new List<Socket> (Sockets.Keys);  	Socket.Select (activeSockets' null' null' 2000000);  	foreach (Socket s in activeSockets) {  		try {  			if (Sockets [s].IsAcceptSocket) {  				Socket temp = s.Accept ();  				Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  				Logger.Log ("New Client connected!"' 4' "MainLoop");  			} else {  				try {  					_buffer.Initialize ();  					int numBytes = s.ReceiveFrom (_buffer' ref _ep);  					foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  						'\r''  						'\n'  					}' StringSplitOptions.RemoveEmptyEntries)) {  						Parser (line' Sockets [s]);  					}  				} catch (SocketException e) {  					Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  					Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  				}  			}  		} catch (Exception e) {  			Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  			Logger.Log ("Trace: " + e.StackTrace);  		}  	}  	foreach (var user in from user in Sockets.Where (s => s.Value.Registered)  	let interval = DateTime.Now.AddMinutes (-1)  	where user.Value.LastAction < interval && user.Value.LastAlive < interval  	select user.Value) {  		if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  			user.Remove ("Ping Timeout");  		} else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  			user.LastPing = DateTime.Now;  			Commands.Send (new PingArgument (user));  		}  	}  } catch (Exception e) {  	Logger.Log ("Unknown ERROR: " + e.Message);  	Logger.Log ("Trace: " + e.StackTrace);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: try {  	var activeSockets = new List<Socket> (Sockets.Keys);  	Socket.Select (activeSockets' null' null' 2000000);  	foreach (Socket s in activeSockets) {  		try {  			if (Sockets [s].IsAcceptSocket) {  				Socket temp = s.Accept ();  				Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  				Logger.Log ("New Client connected!"' 4' "MainLoop");  			} else {  				try {  					_buffer.Initialize ();  					int numBytes = s.ReceiveFrom (_buffer' ref _ep);  					foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  						'\r''  						'\n'  					}' StringSplitOptions.RemoveEmptyEntries)) {  						Parser (line' Sockets [s]);  					}  				} catch (SocketException e) {  					Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  					Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  				}  			}  		} catch (Exception e) {  			Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  			Logger.Log ("Trace: " + e.StackTrace);  		}  	}  	foreach (var user in from user in Sockets.Where (s => s.Value.Registered)  	let interval = DateTime.Now.AddMinutes (-1)  	where user.Value.LastAction < interval && user.Value.LastAlive < interval  	select user.Value) {  		if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  			user.Remove ("Ping Timeout");  		} else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  			user.LastPing = DateTime.Now;  			Commands.Send (new PingArgument (user));  		}  	}  } catch (Exception e) {  	Logger.Log ("Unknown ERROR: " + e.Message);  	Logger.Log ("Trace: " + e.StackTrace);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: try {  	var activeSockets = new List<Socket> (Sockets.Keys);  	Socket.Select (activeSockets' null' null' 2000000);  	foreach (Socket s in activeSockets) {  		try {  			if (Sockets [s].IsAcceptSocket) {  				Socket temp = s.Accept ();  				Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  				Logger.Log ("New Client connected!"' 4' "MainLoop");  			} else {  				try {  					_buffer.Initialize ();  					int numBytes = s.ReceiveFrom (_buffer' ref _ep);  					foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  						'\r''  						'\n'  					}' StringSplitOptions.RemoveEmptyEntries)) {  						Parser (line' Sockets [s]);  					}  				} catch (SocketException e) {  					Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  					Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  				}  			}  		} catch (Exception e) {  			Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  			Logger.Log ("Trace: " + e.StackTrace);  		}  	}  	foreach (var user in from user in Sockets.Where (s => s.Value.Registered)  	let interval = DateTime.Now.AddMinutes (-1)  	where user.Value.LastAction < interval && user.Value.LastAlive < interval  	select user.Value) {  		if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  			user.Remove ("Ping Timeout");  		} else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  			user.LastPing = DateTime.Now;  			Commands.Send (new PingArgument (user));  		}  	}  } catch (Exception e) {  	Logger.Log ("Unknown ERROR: " + e.Message);  	Logger.Log ("Trace: " + e.StackTrace);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: try {  	var activeSockets = new List<Socket> (Sockets.Keys);  	Socket.Select (activeSockets' null' null' 2000000);  	foreach (Socket s in activeSockets) {  		try {  			if (Sockets [s].IsAcceptSocket) {  				Socket temp = s.Accept ();  				Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  				Logger.Log ("New Client connected!"' 4' "MainLoop");  			} else {  				try {  					_buffer.Initialize ();  					int numBytes = s.ReceiveFrom (_buffer' ref _ep);  					foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  						'\r''  						'\n'  					}' StringSplitOptions.RemoveEmptyEntries)) {  						Parser (line' Sockets [s]);  					}  				} catch (SocketException e) {  					Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  					Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  				}  			}  		} catch (Exception e) {  			Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  			Logger.Log ("Trace: " + e.StackTrace);  		}  	}  	foreach (var user in from user in Sockets.Where (s => s.Value.Registered)  	let interval = DateTime.Now.AddMinutes (-1)  	where user.Value.LastAction < interval && user.Value.LastAlive < interval  	select user.Value) {  		if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  			user.Remove ("Ping Timeout");  		} else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  			user.LastPing = DateTime.Now;  			Commands.Send (new PingArgument (user));  		}  	}  } catch (Exception e) {  	Logger.Log ("Unknown ERROR: " + e.Message);  	Logger.Log ("Trace: " + e.StackTrace);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: try {  	var activeSockets = new List<Socket> (Sockets.Keys);  	Socket.Select (activeSockets' null' null' 2000000);  	foreach (Socket s in activeSockets) {  		try {  			if (Sockets [s].IsAcceptSocket) {  				Socket temp = s.Accept ();  				Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  				Logger.Log ("New Client connected!"' 4' "MainLoop");  			} else {  				try {  					_buffer.Initialize ();  					int numBytes = s.ReceiveFrom (_buffer' ref _ep);  					foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  						'\r''  						'\n'  					}' StringSplitOptions.RemoveEmptyEntries)) {  						Parser (line' Sockets [s]);  					}  				} catch (SocketException e) {  					Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  					Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  				}  			}  		} catch (Exception e) {  			Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  			Logger.Log ("Trace: " + e.StackTrace);  		}  	}  	foreach (var user in from user in Sockets.Where (s => s.Value.Registered)  	let interval = DateTime.Now.AddMinutes (-1)  	where user.Value.LastAction < interval && user.Value.LastAlive < interval  	select user.Value) {  		if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  			user.Remove ("Ping Timeout");  		} else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  			user.LastPing = DateTime.Now;  			Commands.Send (new PingArgument (user));  		}  	}  } catch (Exception e) {  	Logger.Log ("Unknown ERROR: " + e.Message);  	Logger.Log ("Trace: " + e.StackTrace);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: Socket.Select (activeSockets' null' null' 2000000);  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: foreach (Socket s in activeSockets) {  	try {  		if (Sockets [s].IsAcceptSocket) {  			Socket temp = s.Accept ();  			Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  			Logger.Log ("New Client connected!"' 4' "MainLoop");  		} else {  			try {  				_buffer.Initialize ();  				int numBytes = s.ReceiveFrom (_buffer' ref _ep);  				foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  					'\r''  					'\n'  				}' StringSplitOptions.RemoveEmptyEntries)) {  					Parser (line' Sockets [s]);  				}  			} catch (SocketException e) {  				Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  				Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  			}  		}  	} catch (Exception e) {  		Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  		Logger.Log ("Trace: " + e.StackTrace);  	}  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: foreach (Socket s in activeSockets) {  	try {  		if (Sockets [s].IsAcceptSocket) {  			Socket temp = s.Accept ();  			Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  			Logger.Log ("New Client connected!"' 4' "MainLoop");  		} else {  			try {  				_buffer.Initialize ();  				int numBytes = s.ReceiveFrom (_buffer' ref _ep);  				foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  					'\r''  					'\n'  				}' StringSplitOptions.RemoveEmptyEntries)) {  					Parser (line' Sockets [s]);  				}  			} catch (SocketException e) {  				Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  				Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  			}  		}  	} catch (Exception e) {  		Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  		Logger.Log ("Trace: " + e.StackTrace);  	}  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: foreach (Socket s in activeSockets) {  	try {  		if (Sockets [s].IsAcceptSocket) {  			Socket temp = s.Accept ();  			Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  			Logger.Log ("New Client connected!"' 4' "MainLoop");  		} else {  			try {  				_buffer.Initialize ();  				int numBytes = s.ReceiveFrom (_buffer' ref _ep);  				foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  					'\r''  					'\n'  				}' StringSplitOptions.RemoveEmptyEntries)) {  					Parser (line' Sockets [s]);  				}  			} catch (SocketException e) {  				Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  				Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  			}  		}  	} catch (Exception e) {  		Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  		Logger.Log ("Trace: " + e.StackTrace);  	}  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: try {  	if (Sockets [s].IsAcceptSocket) {  		Socket temp = s.Accept ();  		Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  		Logger.Log ("New Client connected!"' 4' "MainLoop");  	} else {  		try {  			_buffer.Initialize ();  			int numBytes = s.ReceiveFrom (_buffer' ref _ep);  			foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  				'\r''  				'\n'  			}' StringSplitOptions.RemoveEmptyEntries)) {  				Parser (line' Sockets [s]);  			}  		} catch (SocketException e) {  			Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  			Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  		}  	}  } catch (Exception e) {  	Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  	Logger.Log ("Trace: " + e.StackTrace);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: try {  	if (Sockets [s].IsAcceptSocket) {  		Socket temp = s.Accept ();  		Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  		Logger.Log ("New Client connected!"' 4' "MainLoop");  	} else {  		try {  			_buffer.Initialize ();  			int numBytes = s.ReceiveFrom (_buffer' ref _ep);  			foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  				'\r''  				'\n'  			}' StringSplitOptions.RemoveEmptyEntries)) {  				Parser (line' Sockets [s]);  			}  		} catch (SocketException e) {  			Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  			Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  		}  	}  } catch (Exception e) {  	Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  	Logger.Log ("Trace: " + e.StackTrace);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: try {  	if (Sockets [s].IsAcceptSocket) {  		Socket temp = s.Accept ();  		Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  		Logger.Log ("New Client connected!"' 4' "MainLoop");  	} else {  		try {  			_buffer.Initialize ();  			int numBytes = s.ReceiveFrom (_buffer' ref _ep);  			foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  				'\r''  				'\n'  			}' StringSplitOptions.RemoveEmptyEntries)) {  				Parser (line' Sockets [s]);  			}  		} catch (SocketException e) {  			Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  			Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  		}  	}  } catch (Exception e) {  	Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  	Logger.Log ("Trace: " + e.StackTrace);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: if (Sockets [s].IsAcceptSocket) {  	Socket temp = s.Accept ();  	Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  	Logger.Log ("New Client connected!"' 4' "MainLoop");  } else {  	try {  		_buffer.Initialize ();  		int numBytes = s.ReceiveFrom (_buffer' ref _ep);  		foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  			'\r''  			'\n'  		}' StringSplitOptions.RemoveEmptyEntries)) {  			Parser (line' Sockets [s]);  		}  	} catch (SocketException e) {  		Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  		Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  	}  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: if (Sockets [s].IsAcceptSocket) {  	Socket temp = s.Accept ();  	Sockets.Add (temp' new UserInfo (this' temp' ((IPEndPoint)temp.RemoteEndPoint).Address.ToString ()' false' String.IsNullOrEmpty (Options.ServerPass)));  	Logger.Log ("New Client connected!"' 4' "MainLoop");  } else {  	try {  		_buffer.Initialize ();  		int numBytes = s.ReceiveFrom (_buffer' ref _ep);  		foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  			'\r''  			'\n'  		}' StringSplitOptions.RemoveEmptyEntries)) {  			Parser (line' Sockets [s]);  		}  	} catch (SocketException e) {  		Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  		Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  	}  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: Logger.Log ("New Client connected!"' 4' "MainLoop");  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: try {  	_buffer.Initialize ();  	int numBytes = s.ReceiveFrom (_buffer' ref _ep);  	foreach (string line in Encoding.UTF8.GetString (_buffer' 0' numBytes).Split (new[] {  		'\r''  		'\n'  	}' StringSplitOptions.RemoveEmptyEntries)) {  		Parser (line' Sockets [s]);  	}  } catch (SocketException e) {  	Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  	Sockets [s].Remove ("Socket reset by peer (" + e.ErrorCode + ")");  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: Logger.Log ("ERROR:  (Socket reset) " + e.Message + "(CODE:" + e.ErrorCode + ")"' 4' "E1" + Sockets [s].Nick);  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: Logger.Log ("Unknown ERROR: " + e.Message' 4' "E2" + Sockets [s].Nick);  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: foreach (var user in from user in Sockets.Where (s => s.Value.Registered)  let interval = DateTime.Now.AddMinutes (-1)  where user.Value.LastAction < interval && user.Value.LastAlive < interval  select user.Value) {  	if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  		user.Remove ("Ping Timeout");  	} else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  		user.LastPing = DateTime.Now;  		Commands.Send (new PingArgument (user));  	}  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: if (user.LastAlive < DateTime.Now.AddMinutes (-5)) {  	user.Remove ("Ping Timeout");  } else if (user.LastAlive < DateTime.Now.AddMinutes (-1) && user.LastPing < DateTime.Now.AddMinutes (-1)) {  	user.LastPing = DateTime.Now;  	Commands.Send (new PingArgument (user));  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: foreach (var serverSocket in Sockets.Values) {  	serverSocket.Socket.Close (5);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,MainLoop,The following statement contains a magic number: serverSocket.Socket.Close (5);  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,Parser,The following statement contains a magic number: try {  	int i = 0;  	if (line [0] == PrefixCharacter) {  		while (line [++i] != ' ') {  		}  		prefix = line.Substring (1' i - 1);  	} else {  		prefix = info.Usermask;  	}  	int commandStart = i;  	if (char.IsDigit (line [i + 1]) && char.IsDigit (line [i + 2]) && char.IsDigit (line [i + 3])) {  		replyCode = (ReplyCode)int.Parse (line.Substring (i + 1' 3));  		i += 4;  	} else {  		while ((i < (line.Length - 1)) && line [++i] != ' ') {  		}  		if (line.Length - 1 == i) {  			++i;  		}  		command = line.Substring (commandStart' i - commandStart);  	}  	++i;  	int paramStart = i;  	while (i < line.Length) {  		if (line [i] == ' ' && i != paramStart) {  			args.Add (line.Substring (paramStart' i - paramStart));  			paramStart = i + 1;  		}  		if (line [i] == PrefixCharacter) {  			if (paramStart != i) {  				args.Add (line.Substring (paramStart' i - paramStart));  			}  			args.Add (line.Substring (i + 1));  			break;  		}  		++i;  	}  	if (i == line.Length) {  		args.Add (line.Substring (paramStart));  	}  } catch (IndexOutOfRangeException) {  	Logger.Log ("Invalid Message: " + line);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,Parser,The following statement contains a magic number: try {  	int i = 0;  	if (line [0] == PrefixCharacter) {  		while (line [++i] != ' ') {  		}  		prefix = line.Substring (1' i - 1);  	} else {  		prefix = info.Usermask;  	}  	int commandStart = i;  	if (char.IsDigit (line [i + 1]) && char.IsDigit (line [i + 2]) && char.IsDigit (line [i + 3])) {  		replyCode = (ReplyCode)int.Parse (line.Substring (i + 1' 3));  		i += 4;  	} else {  		while ((i < (line.Length - 1)) && line [++i] != ' ') {  		}  		if (line.Length - 1 == i) {  			++i;  		}  		command = line.Substring (commandStart' i - commandStart);  	}  	++i;  	int paramStart = i;  	while (i < line.Length) {  		if (line [i] == ' ' && i != paramStart) {  			args.Add (line.Substring (paramStart' i - paramStart));  			paramStart = i + 1;  		}  		if (line [i] == PrefixCharacter) {  			if (paramStart != i) {  				args.Add (line.Substring (paramStart' i - paramStart));  			}  			args.Add (line.Substring (i + 1));  			break;  		}  		++i;  	}  	if (i == line.Length) {  		args.Add (line.Substring (paramStart));  	}  } catch (IndexOutOfRangeException) {  	Logger.Log ("Invalid Message: " + line);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,Parser,The following statement contains a magic number: try {  	int i = 0;  	if (line [0] == PrefixCharacter) {  		while (line [++i] != ' ') {  		}  		prefix = line.Substring (1' i - 1);  	} else {  		prefix = info.Usermask;  	}  	int commandStart = i;  	if (char.IsDigit (line [i + 1]) && char.IsDigit (line [i + 2]) && char.IsDigit (line [i + 3])) {  		replyCode = (ReplyCode)int.Parse (line.Substring (i + 1' 3));  		i += 4;  	} else {  		while ((i < (line.Length - 1)) && line [++i] != ' ') {  		}  		if (line.Length - 1 == i) {  			++i;  		}  		command = line.Substring (commandStart' i - commandStart);  	}  	++i;  	int paramStart = i;  	while (i < line.Length) {  		if (line [i] == ' ' && i != paramStart) {  			args.Add (line.Substring (paramStart' i - paramStart));  			paramStart = i + 1;  		}  		if (line [i] == PrefixCharacter) {  			if (paramStart != i) {  				args.Add (line.Substring (paramStart' i - paramStart));  			}  			args.Add (line.Substring (i + 1));  			break;  		}  		++i;  	}  	if (i == line.Length) {  		args.Add (line.Substring (paramStart));  	}  } catch (IndexOutOfRangeException) {  	Logger.Log ("Invalid Message: " + line);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,Parser,The following statement contains a magic number: try {  	int i = 0;  	if (line [0] == PrefixCharacter) {  		while (line [++i] != ' ') {  		}  		prefix = line.Substring (1' i - 1);  	} else {  		prefix = info.Usermask;  	}  	int commandStart = i;  	if (char.IsDigit (line [i + 1]) && char.IsDigit (line [i + 2]) && char.IsDigit (line [i + 3])) {  		replyCode = (ReplyCode)int.Parse (line.Substring (i + 1' 3));  		i += 4;  	} else {  		while ((i < (line.Length - 1)) && line [++i] != ' ') {  		}  		if (line.Length - 1 == i) {  			++i;  		}  		command = line.Substring (commandStart' i - commandStart);  	}  	++i;  	int paramStart = i;  	while (i < line.Length) {  		if (line [i] == ' ' && i != paramStart) {  			args.Add (line.Substring (paramStart' i - paramStart));  			paramStart = i + 1;  		}  		if (line [i] == PrefixCharacter) {  			if (paramStart != i) {  				args.Add (line.Substring (paramStart' i - paramStart));  			}  			args.Add (line.Substring (i + 1));  			break;  		}  		++i;  	}  	if (i == line.Length) {  		args.Add (line.Substring (paramStart));  	}  } catch (IndexOutOfRangeException) {  	Logger.Log ("Invalid Message: " + line);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,Parser,The following statement contains a magic number: if (char.IsDigit (line [i + 1]) && char.IsDigit (line [i + 2]) && char.IsDigit (line [i + 3])) {  	replyCode = (ReplyCode)int.Parse (line.Substring (i + 1' 3));  	i += 4;  } else {  	while ((i < (line.Length - 1)) && line [++i] != ' ') {  	}  	if (line.Length - 1 == i) {  		++i;  	}  	command = line.Substring (commandStart' i - commandStart);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,Parser,The following statement contains a magic number: if (char.IsDigit (line [i + 1]) && char.IsDigit (line [i + 2]) && char.IsDigit (line [i + 3])) {  	replyCode = (ReplyCode)int.Parse (line.Substring (i + 1' 3));  	i += 4;  } else {  	while ((i < (line.Length - 1)) && line [++i] != ' ') {  	}  	if (line.Length - 1 == i) {  		++i;  	}  	command = line.Substring (commandStart' i - commandStart);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,Parser,The following statement contains a magic number: if (char.IsDigit (line [i + 1]) && char.IsDigit (line [i + 2]) && char.IsDigit (line [i + 3])) {  	replyCode = (ReplyCode)int.Parse (line.Substring (i + 1' 3));  	i += 4;  } else {  	while ((i < (line.Length - 1)) && line [++i] != ' ') {  	}  	if (line.Length - 1 == i) {  		++i;  	}  	command = line.Substring (commandStart' i - commandStart);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,Parser,The following statement contains a magic number: if (char.IsDigit (line [i + 1]) && char.IsDigit (line [i + 2]) && char.IsDigit (line [i + 3])) {  	replyCode = (ReplyCode)int.Parse (line.Substring (i + 1' 3));  	i += 4;  } else {  	while ((i < (line.Length - 1)) && line [++i] != ' ') {  	}  	if (line.Length - 1 == i) {  		++i;  	}  	command = line.Substring (commandStart' i - commandStart);  }  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,Parser,The following statement contains a magic number: replyCode = (ReplyCode)int.Parse (line.Substring (i + 1' 3));  
Magic Number,IrcD.Core,IrcDaemon,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\IrcDaemon.cs,Parser,The following statement contains a magic number: i += 4;  
Magic Number,IrcD.Core.Utils,P10Numeric,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\Utils\P10Numerics.cs,CreateString,The following statement contains a magic number: NumericString (_serverNumeric' 2);  
Magic Number,IrcD.Core.Utils,P10Numeric,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\Utils\P10Numerics.cs,CreateString,The following statement contains a magic number: if (_clientNumeric.HasValue) {  	NumericString (_clientNumeric.Value' 3);  }  
Magic Number,IrcD.Core.Utils,P10Numeric,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Core\Utils\P10Numerics.cs,CreateString,The following statement contains a magic number: NumericString (_clientNumeric.Value' 3);  
Magic Number,IrcD.Modes.ChannelModes,ModeInvite,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeInvite.cs,HandleEvent,The following statement contains a magic number: if (command is Invite) {  	UserPerChannelInfo upci;  	if (channel.UserPerChannelInfos.TryGetValue (user.Nick' out upci)) {  		if (upci.Modes.Level < 30) {  			channel.IrcDaemon.Replies.SendChannelOpPrivilegesNeeded (user' channel);  			return false;  		}  	} else {  		channel.IrcDaemon.Replies.SendNotOnChannel (user' channel.Name);  		return false;  	}  }  
Magic Number,IrcD.Modes.ChannelModes,ModeInvite,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeInvite.cs,HandleEvent,The following statement contains a magic number: if (channel.UserPerChannelInfos.TryGetValue (user.Nick' out upci)) {  	if (upci.Modes.Level < 30) {  		channel.IrcDaemon.Replies.SendChannelOpPrivilegesNeeded (user' channel);  		return false;  	}  } else {  	channel.IrcDaemon.Replies.SendNotOnChannel (user' channel.Name);  	return false;  }  
Magic Number,IrcD.Modes.ChannelModes,ModeInvite,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeInvite.cs,HandleEvent,The following statement contains a magic number: if (upci.Modes.Level < 30) {  	channel.IrcDaemon.Replies.SendChannelOpPrivilegesNeeded (user' channel);  	return false;  }  
Magic Number,IrcD.Modes.ChannelModes,ModeModerated,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeModerated.cs,HandleEvent,The following statement contains a magic number: if (command is PrivateMessage || command is Notice) {  	UserPerChannelInfo upci;  	if (!channel.UserPerChannelInfos.TryGetValue (user.Nick' out upci) || upci.Modes.Level < 10) {  		user.IrcDaemon.Replies.SendCannotSendToChannel (user' channel.Name);  		return false;  	}  }  
Magic Number,IrcD.Modes.ChannelModes,ModeModerated,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeModerated.cs,HandleEvent,The following statement contains a magic number: if (!channel.UserPerChannelInfos.TryGetValue (user.Nick' out upci) || upci.Modes.Level < 10) {  	user.IrcDaemon.Replies.SendCannotSendToChannel (user' channel.Name);  	return false;  }  
Magic Number,IrcD.Modes.ChannelModes,ModeTopic,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeTopic.cs,HandleEvent,The following statement contains a magic number: if (command is Topic) {  	UserPerChannelInfo upci;  	if (!channel.UserPerChannelInfos.TryGetValue (user.Nick' out upci)) {  		user.IrcDaemon.Replies.SendNotOnChannel (user' channel.Name);  		return false;  	}  	if (upci.Modes.Level < 30) {  		user.IrcDaemon.Replies.SendChannelOpPrivilegesNeeded (user' channel);  		return false;  	}  }  
Magic Number,IrcD.Modes.ChannelModes,ModeTopic,F:\newReposMay17\FreeApophis_ircddotnet\IrcD.Net\Modes\ChannelModes\ModeTopic.cs,HandleEvent,The following statement contains a magic number: if (upci.Modes.Level < 30) {  	user.IrcDaemon.Replies.SendChannelOpPrivilegesNeeded (user' channel);  	return false;  }  
