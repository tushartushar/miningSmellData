Implementation smell,Namespace,Class,File,Method,Description
Long Method,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,ExtractLocalizableStrings,The method has 111 lines of code.
Complex Method,LocalizableStringExtractor,Window1,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Window1.xaml.cs,Window1,Cyclomatic complexity of the method is 8
Complex Method,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,ExtractLocalizableStrings,Cyclomatic complexity of the method is 16
Complex Method,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,ParseMethodCallForStringLiterals,Cyclomatic complexity of the method is 9
Complex Method,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,ReadSettings,Cyclomatic complexity of the method is 10
Long Parameter List,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,TryParseMethodParams,The method has 5 parameters. Parameters: s' iFirstChar' stopIndex' outLiteral' outAfterEnd
Long Parameter List,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,TryParseForStringLiteral,The method has 5 parameters. Parameters: s' iFirstChar' iStopChar' literal' afterEnd
Long Statement,LocalizableStringExtractor,Window1,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Window1.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/LocalizableStringExtractor;component/window1.xaml"' System.UriKind.Relative); " is 123.
Long Statement,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,ExtractLocalizableStrings,The length of the statement  "                    foreach (var projFile in MsBuildUtils.MsBuildFile.GetProjects(slnFile).Select(p => p.FileName).Where(f => notIgnored(f))) " is 121.
Long Statement,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,ExtractLocalizableStrings,The length of the statement  "                    projFiles.AddRange(Directory.GetFiles(sourceRoot' "*.csproj"' SearchOption.TopDirectoryOnly).Where(f => notIgnored(f))); " is 120.
Long Statement,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,ReadSettings,The length of the statement  "                        throw new ArgumentException("File '" + settingsPath + "' Line " + lineNum + ": At least one source file or path must be listed before specifying one (and only one) target xml"); " is 177.
Long Statement,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,ReadSettings,The length of the statement  "                        throw new ArgumentException("File '" + settingsPath + "' Line " + lineNum + ": Must specify one (and only one) target xml before ignored items are listed"); " is 156.
Magic Number,LocalizableStringExtractor,Window1,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Window1.xaml.cs,Window1,The following statement contains a magic number: if (!File.Exists(m_settingsPath))              {                  string message = "The settings file could not be found: " + m_settingsPath;                  if (m_autoMode)                      Console.WriteLine(message);                  else                      MessageBox.Show(message);                  Application.Current.Shutdown(-2);                  return;              }
Magic Number,LocalizableStringExtractor,Window1,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Window1.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.MainWindow = ((LocalizableStringExtractor.Window1)(target));              return;              case 2:              this.textBlock1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.StartBtn = ((System.Windows.Controls.Button)(target));                            #line 7 "..\..\Window1.xaml"              this.StartBtn.Click += new System.Windows.RoutedEventHandler(this.StartBtn_Click);                            #line default              #line hidden              return;              case 4:              this.CancelBtn = ((System.Windows.Controls.Button)(target));                            #line 8 "..\..\Window1.xaml"              this.CancelBtn.Click += new System.Windows.RoutedEventHandler(this.CancelBtn_Click);                            #line default              #line hidden              return;              case 5:              this.DirectoriesBtn = ((System.Windows.Controls.Button)(target));                            #line 9 "..\..\Window1.xaml"              this.DirectoriesBtn.Click += new System.Windows.RoutedEventHandler(this.DirectoriesBtn_Click);                            #line default              #line hidden              return;              case 6:              this.ExtractionProgressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              }
Magic Number,LocalizableStringExtractor,Window1,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Window1.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.MainWindow = ((LocalizableStringExtractor.Window1)(target));              return;              case 2:              this.textBlock1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.StartBtn = ((System.Windows.Controls.Button)(target));                            #line 7 "..\..\Window1.xaml"              this.StartBtn.Click += new System.Windows.RoutedEventHandler(this.StartBtn_Click);                            #line default              #line hidden              return;              case 4:              this.CancelBtn = ((System.Windows.Controls.Button)(target));                            #line 8 "..\..\Window1.xaml"              this.CancelBtn.Click += new System.Windows.RoutedEventHandler(this.CancelBtn_Click);                            #line default              #line hidden              return;              case 5:              this.DirectoriesBtn = ((System.Windows.Controls.Button)(target));                            #line 9 "..\..\Window1.xaml"              this.DirectoriesBtn.Click += new System.Windows.RoutedEventHandler(this.DirectoriesBtn_Click);                            #line default              #line hidden              return;              case 6:              this.ExtractionProgressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              }
Magic Number,LocalizableStringExtractor,Window1,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Window1.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.MainWindow = ((LocalizableStringExtractor.Window1)(target));              return;              case 2:              this.textBlock1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.StartBtn = ((System.Windows.Controls.Button)(target));                            #line 7 "..\..\Window1.xaml"              this.StartBtn.Click += new System.Windows.RoutedEventHandler(this.StartBtn_Click);                            #line default              #line hidden              return;              case 4:              this.CancelBtn = ((System.Windows.Controls.Button)(target));                            #line 8 "..\..\Window1.xaml"              this.CancelBtn.Click += new System.Windows.RoutedEventHandler(this.CancelBtn_Click);                            #line default              #line hidden              return;              case 5:              this.DirectoriesBtn = ((System.Windows.Controls.Button)(target));                            #line 9 "..\..\Window1.xaml"              this.DirectoriesBtn.Click += new System.Windows.RoutedEventHandler(this.DirectoriesBtn_Click);                            #line default              #line hidden              return;              case 6:              this.ExtractionProgressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              }
Magic Number,LocalizableStringExtractor,Window1,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Window1.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.MainWindow = ((LocalizableStringExtractor.Window1)(target));              return;              case 2:              this.textBlock1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.StartBtn = ((System.Windows.Controls.Button)(target));                            #line 7 "..\..\Window1.xaml"              this.StartBtn.Click += new System.Windows.RoutedEventHandler(this.StartBtn_Click);                            #line default              #line hidden              return;              case 4:              this.CancelBtn = ((System.Windows.Controls.Button)(target));                            #line 8 "..\..\Window1.xaml"              this.CancelBtn.Click += new System.Windows.RoutedEventHandler(this.CancelBtn_Click);                            #line default              #line hidden              return;              case 5:              this.DirectoriesBtn = ((System.Windows.Controls.Button)(target));                            #line 9 "..\..\Window1.xaml"              this.DirectoriesBtn.Click += new System.Windows.RoutedEventHandler(this.DirectoriesBtn_Click);                            #line default              #line hidden              return;              case 6:              this.ExtractionProgressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              }
Magic Number,LocalizableStringExtractor,Window1,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Window1.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.MainWindow = ((LocalizableStringExtractor.Window1)(target));              return;              case 2:              this.textBlock1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.StartBtn = ((System.Windows.Controls.Button)(target));                            #line 7 "..\..\Window1.xaml"              this.StartBtn.Click += new System.Windows.RoutedEventHandler(this.StartBtn_Click);                            #line default              #line hidden              return;              case 4:              this.CancelBtn = ((System.Windows.Controls.Button)(target));                            #line 8 "..\..\Window1.xaml"              this.CancelBtn.Click += new System.Windows.RoutedEventHandler(this.CancelBtn_Click);                            #line default              #line hidden              return;              case 5:              this.DirectoriesBtn = ((System.Windows.Controls.Button)(target));                            #line 9 "..\..\Window1.xaml"              this.DirectoriesBtn.Click += new System.Windows.RoutedEventHandler(this.DirectoriesBtn_Click);                            #line default              #line hidden              return;              case 6:              this.ExtractionProgressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              }
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,ParseMethodCallForStringLiterals,The following statement contains a magic number: if (methodNameIndex >= 3 && s[methodNameIndex - 1] == '.')              {                  if (TryParseStringLiteralFromEnd(s' methodNameIndex - 2' out literal))                      paramStrings.Add(literal);              }
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,ParseMethodCallForStringLiterals,The following statement contains a magic number: if (methodNameIndex >= 3 && s[methodNameIndex - 1] == '.')              {                  if (TryParseStringLiteralFromEnd(s' methodNameIndex - 2' out literal))                      paramStrings.Add(literal);              }
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,TryParseForStringLiteral,The following statement contains a magic number: while (match.Success)              {                  // Regex defines two capturing groups' one in the 'explicit string literal' pattern'                   // and one in the 'regular string literal' pattern.  So match result should have 3 groups.                  if (match.Groups.Count != 3)                      throw new Exception("Expecting the regex to have specified 2 groups' not " + match.Groups.Count);                    // Figure out which pattern actually matched                  bool  explicitStringLiteral;                  Group matchingGroup;                  if (match.Groups[1].Success)                  {                      matchingGroup = match.Groups[1];                      explicitStringLiteral = true;                  }                  else if (match.Groups[2].Success)                  {                      matchingGroup = match.Groups[2];                      explicitStringLiteral = false;                  }                  else // Something went really wrong if neither group matched                      throw new Exception("Did not match for an explicit string literal' nor a regular string literal");                    // If a terminating character is found before the current match' the match is not part of current string literal                  var nextTerm = GetNextTerm(s' afterEnd);                  if (nextTerm >= afterEnd && nextTerm < matchingGroup.Index)                      break;                    // Current match is the next item in the current string literal.                  // If it's a 'regular' string literal' convert doubly-escaped characters                  validMatchCount++;                  var matchStr = matchingGroup.Value;                  if (matchStr.Length > 0)                      Unescape(ref matchStr' explicitStringLiteral);                    // add to string literal parsed so far                  sb.Append(matchStr);                    // skip to end of matched string' and evaluate next found match                  afterEnd = match.Index + match.Length;                  match = match.NextMatch();              }
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,TryParseForStringLiteral,The following statement contains a magic number: while (match.Success)              {                  // Regex defines two capturing groups' one in the 'explicit string literal' pattern'                   // and one in the 'regular string literal' pattern.  So match result should have 3 groups.                  if (match.Groups.Count != 3)                      throw new Exception("Expecting the regex to have specified 2 groups' not " + match.Groups.Count);                    // Figure out which pattern actually matched                  bool  explicitStringLiteral;                  Group matchingGroup;                  if (match.Groups[1].Success)                  {                      matchingGroup = match.Groups[1];                      explicitStringLiteral = true;                  }                  else if (match.Groups[2].Success)                  {                      matchingGroup = match.Groups[2];                      explicitStringLiteral = false;                  }                  else // Something went really wrong if neither group matched                      throw new Exception("Did not match for an explicit string literal' nor a regular string literal");                    // If a terminating character is found before the current match' the match is not part of current string literal                  var nextTerm = GetNextTerm(s' afterEnd);                  if (nextTerm >= afterEnd && nextTerm < matchingGroup.Index)                      break;                    // Current match is the next item in the current string literal.                  // If it's a 'regular' string literal' convert doubly-escaped characters                  validMatchCount++;                  var matchStr = matchingGroup.Value;                  if (matchStr.Length > 0)                      Unescape(ref matchStr' explicitStringLiteral);                    // add to string literal parsed so far                  sb.Append(matchStr);                    // skip to end of matched string' and evaluate next found match                  afterEnd = match.Index + match.Length;                  match = match.NextMatch();              }
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,TryParseForStringLiteral,The following statement contains a magic number: while (match.Success)              {                  // Regex defines two capturing groups' one in the 'explicit string literal' pattern'                   // and one in the 'regular string literal' pattern.  So match result should have 3 groups.                  if (match.Groups.Count != 3)                      throw new Exception("Expecting the regex to have specified 2 groups' not " + match.Groups.Count);                    // Figure out which pattern actually matched                  bool  explicitStringLiteral;                  Group matchingGroup;                  if (match.Groups[1].Success)                  {                      matchingGroup = match.Groups[1];                      explicitStringLiteral = true;                  }                  else if (match.Groups[2].Success)                  {                      matchingGroup = match.Groups[2];                      explicitStringLiteral = false;                  }                  else // Something went really wrong if neither group matched                      throw new Exception("Did not match for an explicit string literal' nor a regular string literal");                    // If a terminating character is found before the current match' the match is not part of current string literal                  var nextTerm = GetNextTerm(s' afterEnd);                  if (nextTerm >= afterEnd && nextTerm < matchingGroup.Index)                      break;                    // Current match is the next item in the current string literal.                  // If it's a 'regular' string literal' convert doubly-escaped characters                  validMatchCount++;                  var matchStr = matchingGroup.Value;                  if (matchStr.Length > 0)                      Unescape(ref matchStr' explicitStringLiteral);                    // add to string literal parsed so far                  sb.Append(matchStr);                    // skip to end of matched string' and evaluate next found match                  afterEnd = match.Index + match.Length;                  match = match.NextMatch();              }
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,Unescape,The following statement contains a magic number: str = Regex.Replace(str' kHexPattern' m => (hexToStringChar(m.Value.Substring(2))));
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,Unescape,The following statement contains a magic number: str = Regex.Replace(str' kUni16Pattern' m => (hexToStringChar(m.Value.Substring(2))));
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,Unescape,The following statement contains a magic number: str = Regex.Replace(str' kUni32Pattern' m => (hexToStringChar(m.Value.Substring(2))));
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,ReadSettings,The following statement contains a magic number: foreach (string line in lines)              {                  lineNum++;;                  if (line.Length == 0 || line[0] == '#')                      continue;                    //break these:                  //  Framework\Atf.Perforce Framework\Atf.Perforce\Resources\Localization.xml                  //  "Samples\CircuitEditor" Samples\CircuitEditor\Resources\Localization.xml                  //into the separate source and target paths and combine with the ATF root directory.                    // "[^"]+"|[^ ]+ matches anything in quotes or anything without spaces.                  MatchCollection paths = Regex.Matches(line' "\"[^\"]+\"|[^ ]+");                  if (paths.Count < 2)                      throw new InvalidOperationException(string.Format("bad settings line:{0}"' line));                    var foundXml = false;                  var sourceList = new List<string>();                  var target = "";                  var ignoreList = new List<string>();                    for (var i = 0; i < paths.Count; i++)                  {                      var path = paths[i].ToString().Trim('\"');                      var isXml = path.EndsWith(".xml");                      var isIgnoreTag = path == "-ignore";                        // must have at least one source file specified                      if (isXml && (i==0 || foundXml))                          throw new ArgumentException("File '" + settingsPath + "' Line " + lineNum + ": At least one source file or path must be listed before specifying one (and only one) target xml");                        // must specify target xml before ignore list                      if (isIgnoreTag && !foundXml)                          throw new ArgumentException("File '" + settingsPath + "' Line " + lineNum + ": Must specify one (and only one) target xml before ignored items are listed");                        // Looking for source files' and target xml                      if (!foundXml)                      {                          if (isXml)                          {                              target = path;                              foundXml = true;                          }                          else                              sourceList.Add(path);                      }                      else // Looking for ignore files                      {                          if (!isIgnoreTag)                              ignoreList.Add(path);                      }                  }                    if (string.IsNullOrEmpty(target))                      throw new ArgumentException("File '" + settingsPath + ": no target xml was listed");                    m_directories.Add(new TargetRule(sourceList' target' ignoreList));              }
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,LocalizeMethodHandler,The following statement contains a magic number: if (paramStrings.Count == 1 && !string.IsNullOrEmpty(paramStrings[0]))                  yield return new LocalizableString(paramStrings[0]' string.Empty);              else if (paramStrings.Count == 2 && !string.IsNullOrEmpty(paramStrings[0]) && !string.IsNullOrEmpty(paramStrings[1]))                  yield return new LocalizableString(paramStrings[0]' paramStrings[1]);
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,PropertyMethodHandler,The following statement contains a magic number: if (paramStrings.Count == 4)              {                  if (!string.IsNullOrEmpty(paramStrings[1]))                      yield return new LocalizableString(paramStrings[1]' string.Empty);                  if (!string.IsNullOrEmpty(paramStrings[3]))                      yield return new LocalizableString(paramStrings[3]' string.Empty);              }
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,PropertyMethodHandler,The following statement contains a magic number: if (paramStrings.Count == 4)              {                  if (!string.IsNullOrEmpty(paramStrings[1]))                      yield return new LocalizableString(paramStrings[1]' string.Empty);                  if (!string.IsNullOrEmpty(paramStrings[3]))                      yield return new LocalizableString(paramStrings[3]' string.Empty);              }
Magic Number,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,PropertyMethodHandler,The following statement contains a magic number: if (paramStrings.Count == 4)              {                  if (!string.IsNullOrEmpty(paramStrings[1]))                      yield return new LocalizableString(paramStrings[1]' string.Empty);                  if (!string.IsNullOrEmpty(paramStrings[3]))                      yield return new LocalizableString(paramStrings[3]' string.Empty);              }
Magic Number,LocalizableStringExtractor,LocalizableString,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\LocalizableString.cs,GetHashCode,The following statement contains a magic number: unchecked // Overflow is fine' just wrap              {                  int hash = 17;                  hash = hash * 23 + Text.GetHashCode();                  hash = hash * 23 + Context.GetHashCode();                  return hash;              }
Magic Number,LocalizableStringExtractor,LocalizableString,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\LocalizableString.cs,GetHashCode,The following statement contains a magic number: unchecked // Overflow is fine' just wrap              {                  int hash = 17;                  hash = hash * 23 + Text.GetHashCode();                  hash = hash * 23 + Context.GetHashCode();                  return hash;              }
Magic Number,LocalizableStringExtractor,LocalizableString,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\LocalizableString.cs,GetHashCode,The following statement contains a magic number: unchecked // Overflow is fine' just wrap              {                  int hash = 17;                  hash = hash * 23 + Text.GetHashCode();                  hash = hash * 23 + Context.GetHashCode();                  return hash;              }
Missing Default,LocalizableStringExtractor,Window1,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Window1.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.MainWindow = ((LocalizableStringExtractor.Window1)(target));              return;              case 2:              this.textBlock1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.StartBtn = ((System.Windows.Controls.Button)(target));                            #line 7 "..\..\Window1.xaml"              this.StartBtn.Click += new System.Windows.RoutedEventHandler(this.StartBtn_Click);                            #line default              #line hidden              return;              case 4:              this.CancelBtn = ((System.Windows.Controls.Button)(target));                            #line 8 "..\..\Window1.xaml"              this.CancelBtn.Click += new System.Windows.RoutedEventHandler(this.CancelBtn_Click);                            #line default              #line hidden              return;              case 5:              this.DirectoriesBtn = ((System.Windows.Controls.Button)(target));                            #line 9 "..\..\Window1.xaml"              this.DirectoriesBtn.Click += new System.Windows.RoutedEventHandler(this.DirectoriesBtn_Click);                            #line default              #line hidden              return;              case 6:              this.ExtractionProgressBar = ((System.Windows.Controls.ProgressBar)(target));              return;              }
Missing Default,LocalizableStringExtractor,Extractor,C:\repos\SonyWWS_ATF\DevTools\Localization\LocalizableStringExtractor\Extractor.cs,TryParseMethodParams,The following switch statement is missing a default case: switch (c)                  {                      // end of method parameter - we're done here                      case ''':                      case ')':                          outAfterEnd = nextMatchChar + 1;                          terminated = true;                          break;                        // illegal terminating character - fail                      case ';':                          return false;                        // start of string literal - parse past it' append it to result' and continue                      case '@':                      case '"':                      {                          if (!TryParseForStringLiteral(s' nextMatchChar' stopIndex' out outLiteral' out outAfterEnd))                              return false;                          sb.Append(outLiteral);                          break;                      }                        // start of parenthesized expression - parse past it' and continue                      case '(':                          var start = nextMatchChar + 1;                          outAfterEnd = GetMatchingCloseParen(s' start);                          if (outAfterEnd < start)                              return false;                          outAfterEnd++;                          break;                  }
