Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sce.Atf.Applications,PropertyEditingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditingCommands.cs,DoCommand,The method has 103 lines of code.
Long Method,Sce.Atf.Applications,RenameCommandDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\RenameCommandDialog.cs,InitializeComponent,The method has 173 lines of code.
Long Method,Sce.Atf.Applications,SkinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,Init,The method has 105 lines of code.
Long Method,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,Initialize,The method has 121 lines of code.
Long Method,Sce.Atf.Applications.NetworkTargetServices,TargetEditDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TargetEditDialog.cs,InitializeComponent,The method has 102 lines of code.
Long Method,Sce.Atf.Applications.WebServices,FeedbackForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\WebServices\FeedbackForm.cs,InitializeComponent,The method has 138 lines of code.
Long Method,Sce.Atf.Controls,CustomizeKeyboardDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CustomizeKeyboardDialog.cs,InitializeComponent,The method has 185 lines of code.
Long Method,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawSubItem,The method has 121 lines of code.
Long Method,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,InitializeComponent,The method has 141 lines of code.
Long Method,Sce.Atf.Controls,FindFileDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FindFileDialog.cs,InitializeComponent,The method has 101 lines of code.
Long Method,Sce.Atf.Controls,FindFileWithSuggestionDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FindFileWithSuggestionDialog.cs,InitializeComponent,The method has 115 lines of code.
Long Method,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,ProcessDialogKey,The method has 121 lines of code.
Long Method,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The method has 167 lines of code.
Long Method,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,ListTreeViewDrawSubItem,The method has 130 lines of code.
Long Method,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,Pick,The method has 139 lines of code.
Long Method,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,DrawAnnotation,The method has 136 lines of code.
Long Method,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_PreviewKeyDown,The method has 128 lines of code.
Long Method,Sce.Atf.Controls.Adaptable,MouseLayoutManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseLayoutManipulator.cs,GetTransform,The method has 111 lines of code.
Long Method,Sce.Atf.Controls.Adaptable.Graphs,GroupingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupingCommands.cs,CreateGroup,The method has 112 lines of code.
Long Method,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Pick,The method has 305 lines of code.
Long Method,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Draw,The method has 199 lines of code.
Long Method,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickSubItem,The method has 101 lines of code.
Long Method,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetHierarchicalElementSizeInfo,The method has 110 lines of code.
Long Method,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphAdapter.cs,OnRender,The method has 149 lines of code.
Long Method,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,ConnectWires,The method has 131 lines of code.
Long Method,Sce.Atf.Controls.Adaptable.Graphs,GraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\GraphEdgeEditAdapter.cs,OnDragging,The method has 121 lines of code.
Long Method,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The method has 144 lines of code.
Long Method,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The method has 452 lines of code.
Long Method,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,Paste,The method has 145 lines of code.
Long Method,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The method has 144 lines of code.
Long Method,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PerformAction,The method has 200 lines of code.
Long Method,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,Translate,The method has 146 lines of code.
Long Method,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The method has 177 lines of code.
Long Method,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The method has 673 lines of code.
Long Method,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,InputBoxValidating,The method has 118 lines of code.
Long Method,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,DrawCurve,The method has 126 lines of code.
Long Method,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,InitializeComponent,The method has 129 lines of code.
Long Method,Sce.Atf.Controls.PropertyEditing,CollectionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EmbeddedCollectionEditor.cs,ProcessPendingChanges,The method has 168 lines of code.
Long Method,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,ProcessDialogKey,The method has 147 lines of code.
Long Method,Sce.Atf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,PropertyGrid,The method has 146 lines of code.
Long Method,Sce.Atf.Controls.Timelines.Direct2D,D2dMoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dMoveManipulator.cs,_MoveSelection,The method has 133 lines of code.
Long Method,Sce.Atf.Controls.Timelines.Direct2D,D2dMoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dMoveManipulator.cs,GetMoveGhostInfo,The method has 145 lines of code.
Long Method,Sce.Atf.Controls.Timelines.Direct2D,D2dMoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dMoveManipulator.cs,GetMoveTargets,The method has 109 lines of code.
Long Method,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,PickSubTimeline,The method has 110 lines of code.
Long Method,Sce.Atf.Controls.Timelines,MoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\MoveManipulator.cs,MoveSelection,The method has 136 lines of code.
Long Method,Sce.Atf.Controls.Timelines,MoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\MoveManipulator.cs,GetMoveGhostInfo,The method has 130 lines of code.
Long Method,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,PickSubTimeline,The method has 108 lines of code.
Complex Method,Sce.Atf.Applications,AtfScriptVariables,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\AtfScriptVariables.cs,Initialize,Cyclomatic complexity of the method is 15
Complex Method,Sce.Atf.Applications,AutoDocumentService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\AutoDocumentService.cs,mainWindow_Loaded,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Applications,CommandService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\CommandService.cs,DoCommand,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Applications,CommandService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\CommandService.cs,BuildDefaultMenusAndToolbars,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Applications,CommandService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\CommandService.cs,ProcessKey,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ControlHostService.cs,RegisterControl,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ControlHostService.cs,ShowDockContent,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ControlHostService.cs,DockHandlerSubscribe,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ControlHostService.cs,DockHandlerUnsubscribe,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Applications,ResourceLister,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\ResourceLister.cs,AddFolder,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Applications,TreeControlAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\TreeControlAdapter.cs,ExpandPath,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Applications,TreeListViewAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\TreeListViewAdapter.cs,HandleSelectionUpdates,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Applications,MainForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\MainForm.cs,SavePanelState,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Applications,ClonedPropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,ClonedPropertyEditor,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Applications,SettingsService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsService.cs,RegisterUserSettings,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Applications,SkinService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinService.cs,GetInstance,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Applications,SkinService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinService.cs,ApplySkinToNonClientArea,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Applications,SkinService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinService.cs,ApplyNewPropertyValues,Cyclomatic complexity of the method is 13
Complex Method,Sce.Atf.Applications,DefaultTypeConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinService.cs,ConvertTo,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,Initialize,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,CanDoCommand,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,DoCheckIn,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,DoRevert,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Applications,QueryStringInput,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\QueryInputTree\QueryTextInput.cs,QueryStringInput,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Applications,QueryNumericalInput,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\QueryInputTree\QueryTextInput.cs,QueryNumericalInput,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Applications.NetworkTargetServices,TargetEnumerationService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TargetEnumerationService.cs,UpdateTargetsView,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Applications.NetworkTargetServices,TargetEnumerationService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TargetEnumerationService.cs,ListViewSelectTargets,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,Intersects,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf,WinFormsUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\WinFormsUtil.cs,UpdateScrollbars,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls,AboutDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\AboutDialog.cs,AboutDialog,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,OnMouseMove,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawItem,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,Dispose,Cyclomatic complexity of the method is 15
Complex Method,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnMouseUp,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,GroupingDataItem,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,UpdateFolderListView,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls,SplitButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SplitButton.cs,OnPaint,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnKeyDown,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,Cyclomatic complexity of the method is 25
Complex Method,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,Pick,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls,TreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.Column.cs,ControlSelectedIndexChanged,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls,TreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.Column.cs,AddNode,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls,TreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.Column.cs,UpdateNode,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,ListTreeViewDrawSubItem,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawExtraneousStuff,Cyclomatic complexity of the method is 13
Complex Method,Sce.Atf.Controls,WindowLayoutManageDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\WindowLayoutManageDialog.cs,LayoutsAfterLabelEdit,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable,AnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotationAdapter.cs,control_ContextChanged,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable,AnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotationAdapter.cs,control_Paint,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,Pick,Cyclomatic complexity of the method is 17
Complex Method,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_Paint,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,DrawAnnotation,Cyclomatic complexity of the method is 15
Complex Method,Sce.Atf.Controls.Adaptable,MouseTransformManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseTransformManipulator.cs,control_MouseMove,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,Draw,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,Copy,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,Insert,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,DomNode_ChildInserted,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,DomNode_ChildRemoved,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,Connect,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,CanMove,Cyclomatic complexity of the method is 14
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,WireStyleProvider<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\WireStyleProvider.cs,GetGroupPinChainData,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,GroupingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupingCommands.cs,CreateGroup,Cyclomatic complexity of the method is 19
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,GroupingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupingCommands.cs,CanDoTogglePinVisibility,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,PositioningFloatigPin,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,LayeringContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\LayeringContext.cs,CanInsert,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,LayeringContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\LayeringContext.cs,Insert,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,LayeringContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\LayeringContext.cs,GetCheckState,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitValidator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitValidator.cs,OnEnding,Cyclomatic complexity of the method is 16
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitValidator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitValidator.cs,UpdateWires,Cyclomatic complexity of the method is 15
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitValidator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitValidator.cs,ValidateEdges,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitValidator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitValidator.cs,UpdateTemplateInfo,Cyclomatic complexity of the method is 14
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,CircuitValidator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitValidator.cs,UpdateGroupPinConnectivity,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,ViewingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\ViewingContext.cs,GetBounds,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Pick,Cyclomatic complexity of the method is 23
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Draw,Cyclomatic complexity of the method is 33
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawExpandedGroup,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetElementSizeInfo,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetHierarchicalElementSizeInfo,Cyclomatic complexity of the method is 22
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetVisibleInputPins,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetVisibleOutputPins,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphAdapter.cs,OnRender,Cyclomatic complexity of the method is 20
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphAdapter.cs,control_ContextChanged,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,ConnectWires,Cyclomatic complexity of the method is 13
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,GetFirstEdgeTo,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,GetFirstEdgeFrom,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphNodeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphNodeEditAdapter.cs,OnBeginDrag,Cyclomatic complexity of the method is 14
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphNodeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphNodeEditAdapter.cs,OnDragging,Cyclomatic complexity of the method is 17
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,Pick,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,Pick,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Pick,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,GraphAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\GraphAdapter.cs,control_ContextChanged,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,GraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\GraphEdgeEditAdapter.cs,OnDragging,Cyclomatic complexity of the method is 15
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,KeyboardIOGraphNavigator<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\KeyboardIOGraphNavigator.cs,PreviewKeyDown,Cyclomatic complexity of the method is 14
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Pick,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Pick,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseDown,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseMove,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseUp,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,Suggest,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,Cyclomatic complexity of the method is 19
Complex Method,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,ScalePoints,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,Translate,Cyclomatic complexity of the method is 13
Complex Method,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,Cyclomatic complexity of the method is 17
Complex Method,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,UpdateInputBoxes,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,PickPoints,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,Pick,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,DrawCurve,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,ComputeIndices,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.PropertyEditing,ArrayEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\ArrayEditingControl.cs,UpdateMoveButtons,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.PropertyEditing,ArrayEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\ArrayEditingControl.cs,SelectItemControl,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.PropertyEditing,CollectionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EmbeddedCollectionEditor.cs,ProcessPendingChanges,Cyclomatic complexity of the method is 18
Complex Method,Sce.Atf.Controls.PropertyEditing,CollectionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EmbeddedCollectionEditor.cs,SelectItemControl,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.PropertyEditing,FileUriEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\FileUriEditor.cs,EditValue,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,ProcessDialogKey,Cyclomatic complexity of the method is 14
Complex Method,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnPaint,Cyclomatic complexity of the method is 15
Complex Method,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,LeaveEditModeWhenGrinDoesNotContainFocus,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,Pick,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnMouseMove,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Controls.PropertyEditing,PropertyEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,Bind,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.PropertyEditing,PropertyEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,SetPropertyFromTextBox,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,PropertyGrid,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,OnMouseMove,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Controls.PropertyEditing,PropertyView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyView.cs,SortPropertiesFromPropertyNamesList,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.PropertyEditing,PropertyView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyView.cs,BuildProperty,Cyclomatic complexity of the method is 13
Complex Method,Sce.Atf.Controls.PropertyEditing,PropertyView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyView.cs,BuildCategories,Cyclomatic complexity of the method is 16
Complex Method,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,UpdateResults,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,AnalyzeListeners,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dMoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dMoveManipulator.cs,_MoveSelection,Cyclomatic complexity of the method is 30
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dMoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dMoveManipulator.cs,GetMoveGhostInfo,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dMoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dMoveManipulator.cs,GetMoveTargets,Cyclomatic complexity of the method is 18
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,Resizer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScaleManipulator.cs,CreateGhostInfo,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dSelectionManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dSelectionManipulator.cs,GetRangeOfEvents,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dSnapManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dSnapManipulator.cs,GetSnapOffset,Cyclomatic complexity of the method is 14
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,Pick,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,GetOwningTimeline,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,GetObjectsInOneDocument,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,timelineDocument_ItemInserted,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,DrawSubTimeline,Cyclomatic complexity of the method is 12
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,DrawGroupsAndTracks,Cyclomatic complexity of the method is 18
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,DrawGhosts,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,PickSubTimeline,Cyclomatic complexity of the method is 27
Complex Method,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,LayoutSubTimeline,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Controls.Timelines,MoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\MoveManipulator.cs,GetMoveGhostInfo,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.Timelines,MoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\MoveManipulator.cs,GetMoveTargets,Cyclomatic complexity of the method is 15
Complex Method,Sce.Atf.Controls.Timelines,Resizer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScaleManipulator.cs,CreateGhostInfo,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Timelines,SelectionManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\SelectionManipulator.cs,GetRangeOfEvents,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.Timelines,SnapManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\SnapManipulator.cs,GetSnapOffset,Cyclomatic complexity of the method is 14
Complex Method,Sce.Atf.Controls.Timelines,TimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineControl.cs,GetObjectsInOneDocument,Cyclomatic complexity of the method is 11
Complex Method,Sce.Atf.Controls.Timelines,TimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineControl.cs,timelineDocument_ItemInserted,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,DrawSubTimeline,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,DrawGroupsAndTracks,Cyclomatic complexity of the method is 18
Complex Method,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,DrawGhosts,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,PickSubTimeline,Cyclomatic complexity of the method is 26
Complex Method,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,LayoutSubTimeline,Cyclomatic complexity of the method is 12
Long Parameter List,Sce.Atf.Applications,WinFormsCommandServices,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\CommandService.cs,RegisterCommand,The method has 9 parameters. Parameters: commandService' commandTag' menuTag' groupTag' menuText' description' shortcut' imageName' client
Long Parameter List,Sce.Atf.Applications,WinFormsCommandServices,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\CommandService.cs,RegisterCommand,The method has 10 parameters. Parameters: commandService' commandTag' menuTag' groupTag' menuText' description' shortcut' imageName' visibility' client
Long Parameter List,Sce.Atf.Applications,ControlInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ControlInfo.cs,ControlInfo,The method has 5 parameters. Parameters: name' description' group' image' helpUrl
Long Parameter List,Sce.Atf.Applications,ControlHostServices,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\IControlHostService.cs,RegisterControl,The method has 6 parameters. Parameters: controlHostService' control' name' description' group' client
Long Parameter List,Sce.Atf.Applications,ControlHostServices,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\IControlHostService.cs,RegisterControl,The method has 8 parameters. Parameters: controlHostService' control' name' description' group' image' client' helpUrl
Long Parameter List,Sce.Atf.Applications,TreeListViewAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\TreeListViewAdapter.cs,AddChildrenToItemRecursively,The method has 7 parameters. Parameters: item' node' view' itemView' imageList' stateImageList' dictNodes
Long Parameter List,Sce.Atf.Applications,TreeListViewAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\TreeListViewAdapter.cs,CreateNodeForObject,The method has 5 parameters. Parameters: item' itemView' imageList' stateImageList' dictNodes
Long Parameter List,Sce.Atf.Applications,RenameCommand,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\RenameCommand.cs,Rename,The method has 5 parameters. Parameters: original' prefix' baseName' suffix' numericSuffix
Long Parameter List,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' x' y' cx' cy' uFlags
Long Parameter List,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,ExcludeClipRect,The method has 5 parameters. Parameters: hdc' nLeftRect' nTopRect' nRightRect' nBottomRect
Long Parameter List,Sce.Atf.Applications,SkinSetterAttributePropertyDescriptor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,SkinSetterAttributePropertyDescriptor,The method has 8 parameters. Parameters: domObj' name' attribute' category' description' isReadOnly' editor' typeConverter
Long Parameter List,Sce.Atf.Applications,FontDescriptor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,FontDescriptor,The method has 6 parameters. Parameters: domObj' name' category' description' editor' typeConverter
Long Parameter List,Sce.Atf.Applications.NetworkTargetServices,TargetDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TargetDialog.cs,TargetDialog,The method has 5 parameters. Parameters: targets' singleSelectionMode' defaultPortNumber' canEditPortNumber' protocols
Long Parameter List,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalGrid,The method has 5 parameters. Parameters: transform' graphRect' step' color' g
Long Parameter List,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalGrid,The method has 5 parameters. Parameters: transform' graphRect' step' color' g
Long Parameter List,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalGrid,The method has 5 parameters. Parameters: transform' graphRect' step' color' g
Long Parameter List,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalGrid,The method has 5 parameters. Parameters: transform' graphRect' step' color' g
Long Parameter List,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,LabelGrid,The method has 6 parameters. Parameters: transform' graphRect' step' font' textBrush' g
Long Parameter List,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalScaleGrid,The method has 5 parameters. Parameters: transform' graphRect' majorSpacing' linePen' g
Long Parameter List,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalScaleGrid,The method has 5 parameters. Parameters: transform' graphRect' majorSpacing' linePen' g
Long Parameter List,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalScale,The method has 9 parameters. Parameters: transform' graphRect' top' majorSpacing' minimumGraphStep' linePen' font' textBrush' g
Long Parameter List,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalScale,The method has 9 parameters. Parameters: transform' graphRect' left' majorSpacing' minimumGraphStep' linePen' font' textBrush' g
Long Parameter List,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawXYLabel,The method has 8 parameters. Parameters: x' y' position' backgroundBrush' linePen' font' textBrush' g
Long Parameter List,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,CreateLozengeImage,The method has 5 parameters. Parameters: color1' color2' outlinePen' shadowColor' cornerRadius
Long Parameter List,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawExpander,The method has 5 parameters. Parameters: x' y' expanded' g' p
Long Parameter List,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawExpander,The method has 7 parameters. Parameters: g' x' y' size' expanded' brush' pen
Long Parameter List,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawExpander,The method has 6 parameters. Parameters: x' y' size' pen' expanded' g
Long Parameter List,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawOfficeExpander,The method has 5 parameters. Parameters: x' y' pen' expanded' g
Long Parameter List,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawSortDirectionIndicator,The method has 7 parameters. Parameters: x' y' width' height' up' brush' g
Long Parameter List,Sce.Atf,MessageInterop,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Interop\MessageInterop.cs,MessageInterop,The method has 5 parameters. Parameters: hWnd' msg' wparam' lparam' result
Long Parameter List,Sce.Atf,MouseEventArgsInterop,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Interop\MouseEventArgsInterop.cs,MouseEventArgsInterop,The method has 5 parameters. Parameters: button' clicks' x' y' delta
Long Parameter List,Sce.Atf,MouseEventArgsInterop,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Interop\MouseEventArgsInterop.cs,MouseEventArgsInterop,The method has 5 parameters. Parameters: button' clicks' x' y' delta
Long Parameter List,Sce.Atf.Controls,AboutDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\AboutDialog.cs,AboutDialog,The method has 5 parameters. Parameters: title' url' clientControl' logo' credits
Long Parameter List,Sce.Atf.Controls,AboutDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\AboutDialog.cs,AboutDialog,The method has 6 parameters. Parameters: title' url' clientControl' logo' credits' addAtfInfo
Long Parameter List,Sce.Atf.Controls,HoverEventArgs<TObject;TPart>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\HoverEventArgs.cs,HoverEventArgs,The method has 5 parameters. Parameters: obj' part' subobj' subpart' adaptableControl
Long Parameter List,Sce.Atf.Controls,TreeItemRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,DrawImage,The method has 5 parameters. Parameters: imageList' g' x' y' index
Long Parameter List,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawExtraneousStuff,The method has 5 parameters. Parameters: e' iOffset' expanderGradient' expanderPen' hierarchyLinePen
Long Parameter List,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawExpander,The method has 5 parameters. Parameters: gfx' bounds' expanderGradient' expanderPen' hierarchyLinePen
Long Parameter List,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawCollapser,The method has 6 parameters. Parameters: gfx' bounds' expanderGradient' expanderPen' hierarchyLinePen' bItemBelow
Long Parameter List,Sce.Atf.Controls,BalloonToolTipHelper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\WindowLayoutNewDialog.cs,Show,The method has 5 parameters. Parameters: control' title' icon' format' args
Long Parameter List,Sce.Atf.Controls,BalloonToolTipHelper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\WindowLayoutNewDialog.cs,Show,The method has 6 parameters. Parameters: control' point' title' icon' format' args
Long Parameter List,Sce.Atf.Controls,BalloonToolTipHelper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\WindowLayoutNewDialog.cs,Show,The method has 6 parameters. Parameters: control' title' icon' timeoutMsec' format' args
Long Parameter List,Sce.Atf.Controls,BalloonToolTipHelper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\WindowLayoutNewDialog.cs,Show,The method has 7 parameters. Parameters: control' point' title' icon' timeoutMsec' format' args
Long Parameter List,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,DrawAnnotation,The method has 5 parameters. Parameters: annotation' style' g' drawText' graphBound
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,Draw,The method has 7 parameters. Parameters: outputElement' outputPin' inputElement' inputPin' label' endPoint' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,DrawWire,The method has 6 parameters. Parameters: outputElement' outputPin' inputElement' inputPin' g' pen
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,DrawWire,The method has 5 parameters. Parameters: element' pin' p' fromOutput' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,DrawWire,The method has 6 parameters. Parameters: g' pen' x1' y1' x2' y2
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,Connect,The method has 5 parameters. Parameters: fromNode' fromRoute' toNode' toRoute' existingEdge
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Draw,The method has 7 parameters. Parameters: outputElement' outputPin' inputElement' inputPin' label' endPoint' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawPartialEdge,The method has 8 parameters. Parameters: outputElement' outputPin' inputElement' inputPin' label' startPoint' endPoint' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Pick,The method has 5 parameters. Parameters: nodes' edges' priorityEdge' p' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickEdge,The method has 5 parameters. Parameters: edge' p' g' xOffset' yOffset
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickPin,The method has 6 parameters. Parameters: element' inputSide' pinX' elementY' info' p
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickSubItem,The method has 5 parameters. Parameters: pickedElement' p' g' pickedSubInput' pickedSubOutput
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawWire,The method has 6 parameters. Parameters: outputElement' outputPin' inputElement' inputPin' g' pen
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawWire,The method has 5 parameters. Parameters: element' pin' p' fromOutput' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawWire,The method has 8 parameters. Parameters: g' pen' x1' y1' x2' y2' strokeWidth' strokeStyle
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,Draw,The method has 7 parameters. Parameters: fromNode' fromRoute' toNode' toRoute' label' endPoint' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,DrawEdgeSpline,The method has 7 parameters. Parameters: p1' p2' p3' p4' d' brush' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,GetTransitionPoints,The method has 5 parameters. Parameters: edge' p1' p2' p3' p4
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,GetTransitionPoints,The method has 6 parameters. Parameters: p1' normal1' p4' normal2' p2' p3
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,DrawArrow,The method has 5 parameters. Parameters: g' brush' p' dx' dy
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,DrawGroupPinNodeFakeEdge,The method has 5 parameters. Parameters: grpPin' grpPinPos' inputSide' style' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Draw,The method has 7 parameters. Parameters: fromNode' fromRoute' toNode' toRoute' label' endPoint' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,GetEdgeGeometry,The method has 6 parameters. Parameters: edge' route' startPoint' endPoint' circle' moreThan180
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,GraphRenderer<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\GraphRenderer.cs,Draw,The method has 7 parameters. Parameters: fromNode' fromRoute' toNode' toRoute' label' endPoint' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Draw,The method has 7 parameters. Parameters: fromNode' fromRoute' toNode' toRoute' label' endPoint' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawEdgeSpline,The method has 7 parameters. Parameters: p1' p2' p3' p4' d' pen' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetTransitionPoints,The method has 5 parameters. Parameters: edge' p1' p2' p3' p4
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetTransitionPoints,The method has 6 parameters. Parameters: p1' normal1' p4' normal2' p2' p3
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawArrow,The method has 5 parameters. Parameters: g' pen' p' dx' dy
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Draw,The method has 7 parameters. Parameters: fromNode' fromRoute' toNode' toRoute' label' endPoint' g
Long Parameter List,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,GetEdgeGeometry,The method has 6 parameters. Parameters: edge' route' startPoint' endPoint' circle' moreThan180
Long Parameter List,Sce.Atf.Controls.CurveEditing,CurveEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditor.cs,CurveEditor,The method has 5 parameters. Parameters: commandService' controlHostService' contextRegistry' curveEditingControl' controlInfo
Long Parameter List,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,PickPoints,The method has 5 parameters. Parameters: curves' pickRect' points' regions' singlePick
Long Parameter List,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,Pick,The method has 5 parameters. Parameters: curves' pickRect' points' regions' singlePick
Long Parameter List,Sce.Atf.Controls.PropertyEditing,ItemControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\ArrayEditingControl.cs,ItemControl,The method has 6 parameters. Parameters: index' item' singletonMode' indexColumnWidth' context' parentPropertyGridView
Long Parameter List,Sce.Atf.Controls.PropertyEditing,ItemControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\ArrayEditingControl.cs,Init,The method has 5 parameters. Parameters: index' item' singletonMode' indexColumnWidth' context
Long Parameter List,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,FillRowBackground,The method has 5 parameters. Parameters: g' defaultBrush' rowRect' row' selected
Long Parameter List,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,DrawValue,The method has 6 parameters. Parameters: g' defaultBrush' p' valueRect' row' selected
Long Parameter List,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,DrawColumnHeader,The method has 8 parameters. Parameters: g' p' x' y' rowHeight' xPadding' yPadding' menuBar
Long Parameter List,Sce.Atf.Controls.PropertyEditing,NestedCollectionEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NestedCollectionEditor.cs,CreateForm,The method has 5 parameters. Parameters: context' selectionContext' value' getCollectionItemCreators' getItemInfo
Long Parameter List,Sce.Atf.Controls.PropertyEditing,NestedCollectionEditorForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NestedCollectionEditorForm.cs,NestedCollectionEditorForm,The method has 5 parameters. Parameters: context' selectionContext' value' getCollectionItemCreators' getItemInfo
Long Parameter List,Sce.Atf.Controls.PropertyEditing,PropertyEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,DrawProperty,The method has 6 parameters. Parameters: descriptor' context' bounds' font' brush' g
Long Parameter List,Sce.Atf.Controls.PropertyEditing,PropertyEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,MsgWaitForMultipleObjects,The method has 5 parameters. Parameters: nCount' pHandles' bWaitAll' dwMilliseconds' dwWakeMask
Long Parameter List,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawCategoryRow,The method has 6 parameters. Parameters: category' expanded' x' y' width' g
Long Parameter List,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawPropertyRow,The method has 6 parameters. Parameters: property' x' y' width' middle' g
Long Parameter List,Sce.Atf.Controls.PropertyEditing,CustomizeAttribute,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyView.cs,CustomizeAttribute,The method has 9 parameters. Parameters: propertyName' columnWidth' disableSort' disableDragging' disableResize' disableEditing' hideDisplayName' horizontalEditorOffset' nameHasWholeRow
Long Parameter List,Sce.Atf.Controls.Timelines.Direct2D,Resizer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScaleManipulator.cs,Resize,The method has 6 parameters. Parameters: worldDrag' worldToView' viewStart' viewEnd' worldStart' worldEnd
Long Parameter List,Sce.Atf.Controls.Timelines.Direct2D,Resizer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScaleManipulator.cs,ScalePoint,The method has 5 parameters. Parameters: x' initialMin' initialMax' finalMin' finalMax
Long Parameter List,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,Print,The method has 7 parameters. Parameters: timeline' selection' activeGroup' activeTrack' transform' clientRectangle' marginBounds
Long Parameter List,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,Draw,The method has 6 parameters. Parameters: timeline' selection' activeGroup' activeTrack' transform' clientRectangle
Long Parameter List,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,DrawSubTimeline,The method has 6 parameters. Parameters: path' selection' activeGroup' activeTrack' layout' c
Long Parameter List,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,DrawSubTimeline,The method has 9 parameters. Parameters: path' timeline' subTimeline' expandedTimeline' selection' activeGroup' activeTrack' layout' c
Long Parameter List,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,DrawMarkers,The method has 6 parameters. Parameters: path' timeline' selection' c' layout' clipBounds
Long Parameter List,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,DrawGroupsAndTracks,The method has 7 parameters. Parameters: path' timeline' expandedTimeline' selection' c' layout' clipBounds
Long Parameter List,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,PickSubTimeline,The method has 5 parameters. Parameters: path' pickRect' c' layout' result
Long Parameter List,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,PickSubTimeline,The method has 6 parameters. Parameters: root' timeline' pickRect' c' layout' result
Long Parameter List,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,LayoutSubTimeline,The method has 6 parameters. Parameters: path' timeline' documentTop' expandedTimeline' c' result
Long Parameter List,Sce.Atf.Controls.Timelines,Resizer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScaleManipulator.cs,Resize,The method has 6 parameters. Parameters: worldDrag' worldToView' viewStart' viewEnd' worldStart' worldEnd
Long Parameter List,Sce.Atf.Controls.Timelines,Resizer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScaleManipulator.cs,ScalePoint,The method has 5 parameters. Parameters: x' initialMin' initialMax' finalMin' finalMax
Long Parameter List,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,Print,The method has 8 parameters. Parameters: timeline' selection' activeGroup' activeTrack' transform' clientRectangle' marginBounds' g
Long Parameter List,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,Draw,The method has 7 parameters. Parameters: timeline' selection' activeGroup' activeTrack' transform' clientRectangle' g
Long Parameter List,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,DrawSubTimeline,The method has 6 parameters. Parameters: path' selection' activeGroup' activeTrack' layout' c
Long Parameter List,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,DrawSubTimeline,The method has 9 parameters. Parameters: path' timeline' subTimeline' expandedTimeline' selection' activeGroup' activeTrack' layout' c
Long Parameter List,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,DrawMarkers,The method has 6 parameters. Parameters: path' timeline' selection' c' layout' clipBounds
Long Parameter List,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,DrawGroupsAndTracks,The method has 7 parameters. Parameters: path' timeline' expandedTimeline' selection' c' layout' clipBounds
Long Parameter List,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,DrawGhosts,The method has 5 parameters. Parameters: ghosts' type' transform' clientRectangle' g
Long Parameter List,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,Pick,The method has 5 parameters. Parameters: timeline' pickRect' transform' clientRectangle' g
Long Parameter List,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,PickSubTimeline,The method has 5 parameters. Parameters: path' pickRect' c' layout' result
Long Parameter List,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,PickSubTimeline,The method has 6 parameters. Parameters: root' timeline' pickRect' c' layout' result
Long Parameter List,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,LayoutSubTimeline,The method has 6 parameters. Parameters: path' timeline' documentTop' expandedTimeline' c' result
Long Identifier,Sce.Atf.Applications,TreeListViewEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\TreeListViewEditor.cs,,The length of the parameter m_actualContextMenuCommandProviders is 35.
Long Identifier,Sce.Atf.Applications.NetworkTargetServices,TargetEnumerationService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TargetEnumerationService.cs,,The length of the parameter m_actualContextMenuCommandProviders is 35.
Long Identifier,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,,The length of the parameter DrawSelectionRectangleUsingGdi is 30.
Long Identifier,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,,The length of the parameter m_columnHeaderTextColorDisabled is 31.
Long Identifier,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,,The length of the parameter m_columnHeaderCheckMarkColorDisabled is 36.
Long Identifier,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,,The length of the parameter m_columnHeaderTextBrushDisabled is 31.
Long Identifier,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,,The length of the parameter m_columnHeaderCheckMarkBrushDisabled is 36.
Long Identifier,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,,The length of the parameter currencyManager_PositionChanged is 31.
Long Identifier,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,,The length of the parameter viewOptionsToolStripDropDownButton is 34.
Long Identifier,Sce.Atf.Controls,TreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.Column.cs,,The length of the parameter m_virtualListAvoidSelectionRecursion is 36.
Long Identifier,Sce.Atf.Controls,TreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.Column.cs,,The length of the parameter m_doingRecursiveCheckStateChange is 32.
Long Identifier,Sce.Atf.Controls,TreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.Column.cs,,The length of the parameter m_virtualListOldSelectedIndices is 31.
Long Identifier,Sce.Atf.Controls,TreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.Column.cs,,The length of the parameter ExceptionTextOnlyAvailableOnVirtualList is 39.
Long Identifier,Sce.Atf.Controls,TreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.Column.cs,,The length of the parameter ExceptionTextSortingNotAllowedInVirtualList is 43.
Long Identifier,Sce.Atf.Controls,TreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.Column.cs,,The length of the parameter ExceptionTextAddingNotAllowedInVirtualList is 42.
Long Identifier,Sce.Atf.Controls,TreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.Column.cs,,The length of the parameter ExceptionTextRemovingNotAllowedInVirtualList is 44.
Long Identifier,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,ListTreeViewDrawSubItem,The length of the parameter extraneousFauxNonClientGridLinesRect is 36.
Long Identifier,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,,The length of the parameter m_modifiableHighlightTextColor is 30.
Long Identifier,Sce.Atf.Controls.Adaptable,MouseTransformManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseTransformManipulator.cs,,The length of the parameter s_defaultConstrainModifierKeys is 30.
Long Identifier,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,,The length of the parameter m_maxCollapsedGroupPinNameLength is 32.
Long Identifier,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,,The length of the parameter m_truncatedPinNameSubstringLength is 33.
Long Identifier,Sce.Atf.Controls.Adaptable.Graphs,KeyboardIOGraphNavigator<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\KeyboardIOGraphNavigator.cs,PreviewKeyDown,The length of the parameter pushOldSelectionIfSelectionChanges is 34.
Long Identifier,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,,The length of the parameter s_columnHeaderMouseDownProperty is 31.
Long Identifier,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,,The length of the parameter s_columnHeaderMouseDownPropertyIndex is 36.
Long Identifier,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,,The length of the parameter m_propertyBackgroundHighlightBrush is 34.
Long Statement,Sce.Atf.Applications,CommandInfos,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\CommandInfos.cs,GetCommandControls,The length of the statement  "                throw new InvalidOperationException("CommandInfo was registered to an ICommandService' but not specifically to a WinFormsCommandService."); " is 139.
Long Statement,Sce.Atf.Applications,CommandInfos,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\CommandInfos.cs,GetCommandControls,The length of the statement  "                throw new InvalidOperationException("WinForms CommandService to which CommandInfo thinks it's registered has no record of it."); " is 128.
Long Statement,Sce.Atf.Applications,WinFormsCommandServices,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\CommandService.cs,RegisterCommand,The length of the statement  "            CommandInfo info = new CommandInfo(commandTag' menuTag' groupTag' menuText' description' KeysInterop.ToAtf(shortcut)' imageName); " is 129.
Long Statement,Sce.Atf.Applications,WinFormsCommandServices,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\CommandService.cs,RegisterCommand,The length of the statement  "            CommandInfo info = new CommandInfo(commandTag' menuTag' groupTag' menuText' description' KeysInterop.ToAtf(shortcut)' imageName' visibility); " is 141.
Long Statement,Sce.Atf.Applications,FileDialogService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FileDialogService.cs,SaveFileName,The length of the statement  "            // Remove the path portion' if any' just as in ATF 3.5 and earlier. http://tracker.ship.scea.com/jira/browse/WWSATF-1406 " is 120.
Long Statement,Sce.Atf.Applications,FileDialogService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FileDialogService.cs,ConfirmFileClose,The length of the statement  "            dialog.YesButtonText = "&Save".Localize("The '&' is optional and means that Alt+S is the keyboard shortcut on this button"); " is 124.
Long Statement,Sce.Atf.Applications,FileDialogService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FileDialogService.cs,ConfirmFileClose,The length of the statement  "            dialog.NoButtonText = "&Discard".Localize("The '&' is optional and means that Alt+D is the keyboard shortcut on this button"); " is 126.
Long Statement,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,CloseApplication,The length of the statement  "            //Not all apps have documents' so an error from the DiscardAll command is okay (consider checking this on a per app basis) " is 122.
Long Statement,Sce.Atf.Applications,FilteredTreeView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\FilteredTreeView.cs,IsFullyExpaned,The length of the statement  "            return m_exemptedSet.Contains(parent) || !m_treeView.GetChildren(parent).Any(child => !IsMatched(child) && !m_exemptedSet.Contains(child));             " is 139.
Long Statement,Sce.Atf.Applications,HistoryLister,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\HistoryLister.cs,Initialize,The length of the statement  "                        "The '<' and '>' indicate that this is not a command name' but is the state of the document before any commands have been run.")) " is 129.
Long Statement,Sce.Atf.Applications,LayerLister,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\LayerLister.cs,contextRegistry_ActiveContextChanged,The length of the statement  "                TreeControl.Text = "Copy items from the document and paste them here to create layers whose visibility can be controlled by clicking on a check box.".Localize(); " is 161.
Long Statement,Sce.Atf.Applications,PrototypeLister,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\PrototypeLister.cs,contextRegistry_ActiveContextChanged,The length of the statement  "                "Copy items from the document and paste them here to create prototypes that can be dragged and dropped onto a canvas.".Localize() " is 129.
Long Statement,Sce.Atf.Applications,MainForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\MainForm.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm)); " is 128.
Long Statement,Sce.Atf.Applications,MenuInfos,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\MenuInfos.cs,GetMenuItem,The length of the statement  "                throw new InvalidTransactionException("MenuInfo was registered to an ICommandService' but not specifically to Sce.Atf.Applications.CommandService."); " is 149.
Long Statement,Sce.Atf.Applications,MenuInfos,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\MenuInfos.cs,GetMenuItem,The length of the statement  "                throw new InvalidTransactionException("The MenuInfo specified has no ToolStripMenuItem associated with it' which should have been set up in CommandService.RegisterMenuInfo()"); " is 176.
Long Statement,Sce.Atf.Applications,MenuInfos,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\MenuInfos.cs,GetToolStrip,The length of the statement  "                throw new InvalidTransactionException("MenuInfo was registered to an ICommandService' but not specifically to Sce.Atf.Applications.CommandService."); " is 149.
Long Statement,Sce.Atf.Applications,MenuInfos,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\MenuInfos.cs,GetToolStrip,The length of the statement  "                throw new InvalidTransactionException("The MenuInfo specified has no ToolStrip associated with it' which should have been set up in (or before) CommandService.RegisterMenuInfo()"); " is 180.
Long Statement,Sce.Atf.Applications,MenuInfos,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\MenuInfos.cs,SetToolStrip,The length of the statement  "                throw new NullReferenceException("MenuInfo has already been registered to a CommandService' and it is not the one specified."); " is 127.
Long Statement,Sce.Atf.Applications,PropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,Initialize,The length of the statement  "                    "Initial docking group for duplicated property editors\r\nCenter' CenterPermanent' and Hidden are not accepted".Localize()); " is 124.
Long Statement,Sce.Atf.Applications,PropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,OnPropertyGridMouseUp,The length of the statement  "                    .Where(x => !IsStandardEditCommand(x)); // filter out standard edit commands as they are not applicable for property editing' " is 125.
Long Statement,Sce.Atf.Applications,ClonedPropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,OnPropertyGridMouseUp,The length of the statement  "                        .Where(x => !m_propertyEditor.IsStandardEditCommand(x)); // filter out standard edit commands as they are not applicable for property editing' " is 142.
Long Statement,Sce.Atf.Applications,RenameCommandDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\RenameCommandDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(RenameCommandDialog)); " is 139.
Long Statement,Sce.Atf.Applications,DomNodePropertySearchService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SearchAndReplace\DomNodePropertySearchService.cs,DoLayout,The length of the statement  "                    resultsBounds.Height = m_rootControl.Height - (m_rootControl.Margin.Top + m_rootControl.Margin.Bottom + scb.Height + 2); " is 120.
Long Statement,Sce.Atf.Applications,SettingsDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(SettingsDialog)); " is 134.
Long Statement,Sce.Atf.Applications,SettingsLoadSaveDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsLoadSaveDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(SettingsLoadSaveDialog)); " is 142.
Long Statement,Sce.Atf.Applications,SkinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,Init,The length of the statement  "            m_PropertyGrid = new PropertyGrid(PropertyGridMode.PropertySorting | PropertyGridMode.DisplayDescriptions | PropertyGridMode.HideResetAllButton); " is 145.
Long Statement,Sce.Atf.Applications,SkinService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinService.cs,GetSetterType,The length of the statement  "                    throw new TypeLoadException(string.Format("{0} doesn't exist in this application. Skin cannot load."' styleTargetTypeString)); " is 126.
Long Statement,Sce.Atf.Applications,SkinService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinService.cs,GetInstance,The length of the statement  "                    throw new InvalidOperationException("Setter '" + setter.PropertyName + "' doesn't have a valueInfo' nor listInfo' specified.  Must have one (and only one) of either."); " is 168.
Long Statement,Sce.Atf.Applications,UnhandledExceptionDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\UnhandledExceptionDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(UnhandledExceptionDialog)); " is 144.
Long Statement,Sce.Atf.Applications,CheckInForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\CheckInForm.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(CheckInForm)); " is 131.
Long Statement,Sce.Atf.Applications,ReconcileForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\ReconcileForm.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ReconcileForm)); " is 133.
Long Statement,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,CanDoCommand,The length of the statement  "            foreach (IResource anyResource in SourceControlContext.Resources) // only check when SourceControlContext has resources to take care " is 132.
Long Statement,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,UpdateCommand,The length of the statement  "                    commandState.Text = SourceControlService.Enabled ? "Disable Source Control".Localize() : "Enable Source Control".Localize(); " is 124.
Long Statement,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,UpdateCommand,The length of the statement  "                    m_sourceControlEnableCmd.GetButton().Image = SourceControlService.Enabled ? m_sourceControlEnableImage: m_sourceControlDisableImage; " is 132.
Long Statement,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,documentService_DocumentSaved,The length of the statement  "                DialogResult result = MessageBox.Show(GetDialogOwner()' message' "Add document to Version Control".Localize()' MessageBoxButtons.YesNo); " is 136.
Long Statement,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,OnDocumentDirtyChanged,The length of the statement  "            if (SourceControlService == null || document == null || !document.Dirty || CheckoutOnEditBehavior == CheckoutOnEditBehavior.Never) " is 130.
Long Statement,Sce.Atf.Applications.NetworkTargetServices,TargetDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TargetDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(TargetDialog)); " is 132.
Long Statement,Sce.Atf.Applications.NetworkTargetServices,TargetEditDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TargetEditDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(TargetEditDialog)); " is 136.
Long Statement,Sce.Atf.Applications.WebServices,FeedbackForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\WebServices\FeedbackForm.cs,ValidateData,The length of the statement  "                MessageBox.Show(this' "Assembly mapping attribute not found.\nCannot proceed"' "Error"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 132.
Long Statement,Sce.Atf.Applications.WebServices,FeedbackForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\WebServices\FeedbackForm.cs,ValidateData,The length of the statement  "                if (!Regex.IsMatch(m_txtEmail.Text.Trim()' @"^([\w-\.]+)@((\[[0-9]{1'3}\.[0-9]{1'3}\.[0-9]{1'3}\.)|(([\w-]+\.)+))([a-zA-Z]{2'4}|[0-9]{1'3})(\]?)$")) " is 148.
Long Statement,Sce.Atf.Applications.WebServices,FeedbackForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\WebServices\FeedbackForm.cs,DoSubmit,The length of the statement  "                        m_bugService.submitBug(m_mappingName' m_userTextBox.Text' m_passwordTextBox.Text' m_titleTextBox.Text' desc' m_cmbPriority.SelectedIndex); " is 138.
Long Statement,Sce.Atf.Applications.WebServices,FeedbackForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\WebServices\FeedbackForm.cs,DoSubmit,The length of the statement  "                MessageBox.Show("There were errors while submitting this bug\n" + ex.Message'  "Error"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 132.
Long Statement,Sce.Atf.Applications.WebServices,FeedbackForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\WebServices\FeedbackForm.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FeedbackForm)); " is 132.
Long Statement,Sce.Atf.Applications.WebServices,VersionUpdateService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\WebServices\VersionUpdateService.cs,Initialize,The length of the statement  "            ProjectMappingAttribute mapAttr = (ProjectMappingAttribute)Attribute.GetCustomAttribute(assembly' typeof(ProjectMappingAttribute)); " is 131.
Long Statement,Sce.Atf.Applications.WebServices,VersionUpdateService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\WebServices\VersionUpdateService.cs,RegisterSettings,The length of the statement  "                            new BoundPropertyDescriptor(this' () => CheckForUpdateAtStartup' "Check for update at startup".Localize()' null' "Check for product update at startup".Localize())' " is 163.
Long Statement,Sce.Atf.Applications.WebServices,VersionUpdateService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\WebServices\VersionUpdateService.cs,updateCheck_CheckComplete,The length of the statement  "                    MessageBox.Show(m_dialogOwner' "This software is up to date.".Localize()' "Updater".Localize()' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 146.
Long Statement,Sce.Atf,FormatEnumerator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\DragDrop\DragDropDataObject.cs,Next,The length of the statement  "                    throw new ArgumentException("The number of elements in the return array is less than the number of elements requested"); " is 120.
Long Statement,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawLozenge,The length of the statement  "                new Rectangle(bounds.Right - cornerRadius' bounds.Bottom - cornerRadius' cornerRadius + ShadowSize' cornerRadius + ShadowSize)' " is 127.
Long Statement,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawLozenge,The length of the statement  "                new Rectangle(bounds.Right - cornerRadius' bounds.Top + cornerRadius' cornerRadius + ShadowSize' bounds.Height - 2 * cornerRadius)' " is 131.
Long Statement,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawLozenge,The length of the statement  "                new Rectangle(bounds.Left + cornerRadius' bounds.Bottom - cornerRadius' bounds.Width - 2 * cornerRadius' cornerRadius + ShadowSize)' " is 132.
Long Statement,Sce.Atf,DragEventArgsInterop,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Interop\DragEventArgsInterop.cs,ToAtf,The length of the statement  "            return new AtfDragEventArgs(arg.Data' arg.KeyState' arg.X' arg.Y' (AtfDragDropEffects)arg.AllowedEffect' (AtfDragDropEffects)arg.Effect); " is 137.
Long Statement,Sce.Atf,DragEventArgsInterop,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Interop\DragEventArgsInterop.cs,ToWf,The length of the statement  "            return new WfDragEventArgs((IDataObject)arg.Data' arg.KeyState' arg.X' arg.Y' (WfDragDropEffects)arg.AllowedEffect' (WfDragDropEffects)arg.Effect); " is 147.
Long Statement,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,GetImage,The length of the statement  "                throw new ArgumentNullException("Image id is null. Call Sce.Atf.WinForms.Resources.Register() to force registration of image resources."); " is 138.
Long Statement,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,GetImage13,The length of the statement  "                throw new ArgumentNullException("Image id is null. Call Sce.Atf.WinForms.Resources.Register() to force registration of image resources."); " is 138.
Long Statement,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,GetImage16,The length of the statement  "                throw new ArgumentNullException("Image id is null. Call Sce.Atf.WinForms.Resources.Register() to force registration of image resources."); " is 138.
Long Statement,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,GetImage24,The length of the statement  "                throw new ArgumentNullException("Image id is null. Call Sce.Atf.WinForms.Resources.Register() to force registration of image resources."); " is 138.
Long Statement,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,GetImage32,The length of the statement  "                throw new ArgumentNullException("Image id is null. Call Sce.Atf.WinForms.Resources.Register() to force registration of image resources."); " is 138.
Long Statement,Sce.Atf.Controls,AboutDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\AboutDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AboutDialog)); " is 131.
Long Statement,Sce.Atf.Controls,AboutSysInfoDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\AboutSysInfoDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AboutSysInfoDialog)); " is 138.
Long Statement,Sce.Atf.Controls,BoolInputControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\BoolInputControl.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(BoolInputControl)); " is 136.
Long Statement,Sce.Atf.Controls,ConfirmationDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConfirmationDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ConfirmationDialog)); " is 138.
Long Statement,Sce.Atf.Controls,CustomizeKeyboardDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CustomizeKeyboardDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(CustomizeKeyboardDialog)); " is 143.
Long Statement,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawColumnHeader,The length of the statement  "                    e.Graphics.DrawString(m_tickSymbol' m_tickFont' Enabled ? m_columnHeaderCheckMarkBrush : m_columnHeaderCheckMarkBrushDisabled' pt); " is 131.
Long Statement,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,DataBoundListView_ColumnClick,The length of the statement  "                    m_sortDirection = m_sortDirection == ListSortDirection.Ascending ? ListSortDirection.Descending : ListSortDirection.Ascending; " is 126.
Long Statement,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,SetTextBoxFromProperty,The length of the statement  "            string propertyText = PropertyUtils.GetPropertyText(m_currencyManager.List[m_currentRow]' m_propertyDescriptors[m_currentCol]); " is 127.
Long Statement,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,SetComboBoxFromProperty,The length of the statement  "            string propertyText = PropertyUtils.GetPropertyText(m_currencyManager.List[m_currentRow]' m_propertyDescriptors[m_currentCol]); " is 127.
Long Statement,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,SetPropertyFromComboBox,The length of the statement  "                PropertyUtils.SetProperty(m_currencyManager.List[m_currentRow]' m_propertyDescriptors[m_currentCol]' m_comboBox.SelectedItem); " is 126.
Long Statement,Sce.Atf.Controls,ErrorDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ErrorDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ErrorDialog)); " is 131.
Long Statement,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FilteredFileDialogBase)); " is 142.
Long Statement,Sce.Atf.Controls,FindFileDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FindFileDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FindFileDialog)); " is 134.
Long Statement,Sce.Atf.Controls,FindFileWithSuggestionDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FindFileWithSuggestionDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FindFileWithSuggestionDialog)); " is 148.
Long Statement,Sce.Atf.Controls,HoverLabel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\HoverLabel.cs,SetBounds,The length of the statement  "                Size = new Size((int)Math.Ceiling(labelSize.Width) + 2 * TextMargin' (int)Math.Ceiling(labelSize.Height) + 2 * TextMargin); " is 123.
Long Statement,Sce.Atf.Controls,ProgressDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ProgressDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ProgressDialog)); " is 134.
Long Statement,Sce.Atf.Controls,TabbedControlSelectorDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TabbedControlSelectorDialog.cs,TabbedControlSelectorDialog_KeyDown,The length of the statement  "                    SetActiveListBox((m_activeListBox == focusedPaneListBox) ? eListBoxType.UnfocusedPaneListBox : eListBoxType.FocusedPaneListBox); " is 128.
Long Statement,Sce.Atf.Controls,TabbedControlSelectorDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TabbedControlSelectorDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(TabbedControlSelectorDialog)); " is 147.
Long Statement,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnKeyDown,The length of the statement  "            // If somebody else took care of this key press already (ie: be listening for a KeyDown event)' we don't want to do anything more " is 129.
Long Statement,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The length of the statement  "                        m_itemRenderer.DrawImage(m_stateImageList' g' info.StateImageLeft' rowCenterY - m_stateImageList.ImageSize.Height / 2' node.StateImageIndex); " is 141.
Long Statement,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The length of the statement  "                        m_itemRenderer.DrawImage(m_imageList' g' info.ImageLeft' rowCenterY - m_imageList.ImageSize.Height / 2' node.ImageIndex); " is 121.
Long Statement,Sce.Atf.Controls,WindowLayoutManageDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\WindowLayoutManageDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(WindowLayoutManageDialog)); " is 144.
Long Statement,Sce.Atf.Controls,WindowLayoutNewDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\WindowLayoutNewDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(WindowLayoutNewDialog)); " is 141.
Long Statement,Sce.Atf.Controls.Adaptable,CoordinateAxisAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\CoordinateAxisAdapter.cs,control_Paint,The length of the statement  "                    transform' canvasRect' false' m_verticalTickSpacing' 0' m_theme.OutlinePen' m_theme.Font' m_theme.TextBrush' e.Graphics); " is 121.
Long Statement,Sce.Atf.Controls.Adaptable,CoordinateAxisAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\CoordinateAxisAdapter.cs,control_Paint,The length of the statement  "                    transform' canvasRect' true' m_horizontalTickSpacing' 0' m_theme.OutlinePen' m_theme.Font' m_theme.TextBrush' e.Graphics); " is 122.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,DrawAnnotation,The length of the statement  "            //g.DrawLine(bounds.X' bounds.Y + Margin.Top-1' bounds.X + bounds.Width' bounds.Y + Margin.Top-1' ControlPaint.Dark(backColor)' borderThickness); " is 145.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,DrawAnnotation,The length of the statement  "                    var textLayout = D2dFactory.CreateTextLayout(annotation.Text' m_theme.TextFormat' contentBounds.Width' contentBounds.Height); " is 125.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,DrawAnnotation,The length of the statement  "                    var hitTestMetrics = textEditor.TextLayout.HitTestTextRange(textEditor.SelectionStart' textEditor.SelectionLength' 0' 0); " is 121.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,DrawAnnotation,The length of the statement  "                        var trackBounds = new RectangleF(contentBounds.Right - ScrollBarMargin - ScrollBarWidth' contentBounds.Y' ScrollBarWidth' contentBounds.Height); " is 144.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,DrawAnnotation,The length of the statement  "                    var thumbBounds = new RectangleF(contentBounds.Right - ScrollBarMargin - ScrollBarWidth' contentBounds.Y + vMin' ScrollBarWidth' vMax - vMin); " is 142.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,ResizeAnnotation,The length of the statement  "                    newBounds = new Rectangle(m_startBounds.X' m_startBounds.Y' m_startBounds.Width + delta.X' m_startBounds.Height + delta.Y); " is 123.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,ResizeAnnotation,The length of the statement  "                    newBounds = new Rectangle(currentPoint.X' currentPoint.Y' m_startBounds.Width - delta.X' m_startBounds.Height - delta.Y); " is 121.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,ResizeAnnotation,The length of the statement  "                    newBounds = new Rectangle(m_startBounds.X' currentPoint.Y' m_startBounds.Width + delta.X' m_startBounds.Height - delta.Y); " is 122.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,ResizeAnnotation,The length of the statement  "                    newBounds = new Rectangle(currentPoint.X' m_startBounds.Y' m_startBounds.Width - delta.X' m_startBounds.Height + delta.Y); " is 122.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_KeyPress,The length of the statement  "                    annotationEditor.SetSelection(TextEditor.SelectionMode.AbsoluteLeading' annotationEditor.CaretAbsolutePosition + 2' false' false); " is 130.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_PreviewKeyDown,The length of the statement  "                    annotationEditor.SetSelection(ctrlPressed ? TextEditor.SelectionMode.LeftWord : TextEditor.SelectionMode.Left' 1' shiftPressed' false); " is 135.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_PreviewKeyDown,The length of the statement  "                    annotationEditor.SetSelection(ctrlPressed ? TextEditor.SelectionMode.RightWord : TextEditor.SelectionMode.Right' 1' shiftPressed' false); " is 137.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_PreviewKeyDown,The length of the statement  "                    annotationEditor.SetSelection(ctrlPressed ? TextEditor.SelectionMode.First : TextEditor.SelectionMode.Home' 0' shiftPressed' false); " is 132.
Long Statement,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_PreviewKeyDown,The length of the statement  "                    annotationEditor.SetSelection(ctrlPressed ? TextEditor.SelectionMode.Last : TextEditor.SelectionMode.End' 0' shiftPressed' false); " is 130.
Long Statement,Sce.Atf.Controls.Adaptable,HoverAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\HoverAdapter.cs,hoverTimer_Tick,The length of the statement  "                var hoverArgs = new HoverEventArgs<object' object>(m_hoverItem' m_hoverPart' m_hoverSubItem' m_hoverSubPart' AdaptedControl); " is 125.
Long Statement,Sce.Atf.Controls.Adaptable,TransformAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\TransformAdapter.cs,SetTransform,The length of the statement  "                PointF translation = EnforceConstraints ? this.ConstrainTranslation(new PointF(xTranslation' yTranslation)) : new PointF(xTranslation' yTranslation); " is 149.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,CircuitControlRegistry,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitControlRegistry.cs,GetDomNode,The length of the statement  "            return (from ctrol in m_circuitNodeControls where ctrol.Value.Second.Control == control select ctrol.Key).FirstOrDefault(); " is 123.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,DomNode_AttributeChanged,The length of the statement  "                            CircuitUtil.GetDomNodeName(parent)' CircuitUtil.GetDomNodeName(e.DomNode)' e.AttributeInfo.Name' e.OldValue' e.NewValue); " is 121.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,Move,The length of the statement  "            CircuitUtil.GetSubGraph(oldContainer' movingItems' moduleSet' internalConnections' incomingConnections' outgoingConnections); " is 125.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,Resize,The length of the statement  "                // The label height is added back in by D2dCircuitRenderer.GetBounds(). http://tracker.ship.scea.com/jira/browse/WWSATF-1504 " is 124.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,IsSelfContainedOrIntersected,The length of the statement  "            containerLocalBound.Height -= GetTitleHeight(control);// no subcontent offset if element is moved out of the current container " is 126.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,WireStyleProvider<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\WireStyleProvider.cs,GetGroupPinChainData,The length of the statement  "                        Point p0 = circuitRender.GetPinPositionCenterY(firstGroupPin.InternalElement.Cast<TElement>()' firstGroupPin.InternalPinIndex' false' g); " is 137.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,WireStyleProvider<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\WireStyleProvider.cs,GetGroupPinChainData,The length of the statement  "                    Point p0 = circuitRender.GetPinPositionCenterY(connection.OutputElement.Cast<TElement>()' connection.OutputPin.Index' false' g); " is 128.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,WireStyleProvider<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\WireStyleProvider.cs,GetGroupPinChainData,The length of the statement  "                        Point pn = circuitRender.GetPinPositionCenterY(lastGroupPin.InternalElement.Cast<TElement>()' lastGroupPin.InternalPinIndex' true' g); " is 134.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,WireStyleProvider<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\WireStyleProvider.cs,GetGroupPinChainData,The length of the statement  "                    Point pn = circuitRender.GetPinPositionCenterY(connection.InputElement.Cast<TElement>()' connection.InputPin.Index' true' g); " is 125.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupingCommands.cs,CreateGroup,The length of the statement  "            CircuitUtil.GetSubGraph(graphContainer' elementsToGroup' modules' internalConnections' externalConnections' externalConnections); " is 129.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupingCommands.cs,DoCommand,The length of the statement  "                    transactionContext.DoTransaction(() => UngroupGroups(circuitEditingContext' selectionContext)' "Ungroup".Localize("a verb")); " is 125.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,OnDragging,The length of the statement  "                        m_draggingGroupPins[i].Bounds = new Rectangle(m_draggingGroupPins[i].Bounds.Location.X'  Constrain(m_originalPinY[i] + offset.Y)' " is 129.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,MeasureFakePins,The length of the statement  "                        //        fakePinNode.DesiredLocation = new Point(offset.X' topY + offset.Y + fakePinNode.GroupPin.Index * (PinNodeHeight + PinNodeMargin)); " is 140.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,MeasureFakePins,The length of the statement  "                                int delta = pin.DesiredLocation.Y - lastY - (CircuitGroupPinInfo.FloatingPinNodeHeight + CircuitGroupPinInfo.FloatingPinNodeMargin); " is 132.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,MeasureFakePins,The length of the statement  "                    //          SizeF nameSize = g.MeasureString(fakePinNode.SubGraphPin.Name' m_subGraphRenderer.GetElementFont(fakePinNode' g)); " is 126.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,AdjustLayout,The length of the statement  "                        floatingPins[j].DesiredLocation = new Point(floatingPins[j].DesiredLocation.X' Math.Max(floatingPins[j].DesiredLocation.Y + delta' minY)); " is 138.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,PositioningFloatigPin,The length of the statement  "                if (againstpin.Bounds.Location.Y + CircuitGroupPinInfo.FloatingPinNodeHeight + CircuitGroupPinInfo.FloatingPinNodeMargin < minY) " is 128.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,PositioningFloatigPin,The length of the statement  "                        if (againstPinNodes[j+1].Bounds.Location.Y - againstPinNodes[j ].Bounds.Location.Y >= 2 * (CircuitGroupPinInfo.FloatingPinNodeHeight + CircuitGroupPinInfo.FloatingPinNodeMargin)) " is 178.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,PositioningFloatigPin,The length of the statement  "                            int pinNewY = Constrain(againstPinNodes[j].Bounds.Location.Y + CircuitGroupPinInfo.FloatingPinNodeHeight + CircuitGroupPinInfo.FloatingPinNodeMargin); " is 150.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,PositioningFloatigPin,The length of the statement  "                            floatingPin.Bounds = new Rectangle(floatingPin.Bounds.Location.X' pinNewY' floatingPin.Bounds.Width' floatingPin.Bounds.Height); " is 128.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,PositioningFloatigPin,The length of the statement  "                int pinNewY = Constrain(topStaticPin.Bounds.Location.Y - (CircuitGroupPinInfo.FloatingPinNodeHeight + CircuitGroupPinInfo.FloatingPinNodeMargin)); " is 146.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,PositioningFloatigPin,The length of the statement  "                floatingPin.Bounds = new Rectangle(floatingPin.Bounds.Location.X' Constrain(floatingPin.DesiredLocation.Y)' floatingPin.Bounds.Width' floatingPin.Bounds.Height); " is 161.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,PinOverlap,The length of the statement  "            var freePinInterval = new Pair<int' int>(freePin.DesiredLocation.Y - CircuitGroupPinInfo.FloatingPinNodeMargin' freePin.DesiredLocation.Y + CircuitGroupPinInfo.FloatingPinNodeHeight + CircuitGroupPinInfo.FloatingPinNodeMargin); " is 227.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,PinOverlap,The length of the statement  "            var pinInterval = new Pair<int' int>(againstPin.Bounds.Location.Y - CircuitGroupPinInfo.FloatingPinNodeMargin' againstPin.Bounds.Location.Y + CircuitGroupPinInfo.FloatingPinNodeHeight + CircuitGroupPinInfo.FloatingPinNodeMargin); " is 229.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,CircuitValidator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitValidator.cs,AddNode,The length of the statement  "                // Disable automatically combining attribute setting operations' as operations such as grouping pin index changes better run its course    " is 135.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Draw,The length of the statement  "            if (RectangleSelectsWires && style == DiagramDrawingStyle.LastSelected) // last selected is not well defined in multi-edge selection    " is 132.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Pick,The length of the statement  "            //if (pickedElement != null) // if an element is picked' further check if its label or expander is picked. They take priority over wire picking. " is 144.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Pick,The length of the statement  "            //          new Rectangle((int)labelBounds.Left' (int)labelBounds.Top' (int)labelBounds.Width' (int)labelBounds.Height)' " is 120.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Pick,The length of the statement  "            //            var border = new RectangleF(bounds.Left - m_theme.PickTolerance' bounds.Y' 2 * m_theme.PickTolerance' bounds.Height); " is 131.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Pick,The length of the statement  "            //                    border = new RectangleF(bounds.Left' bounds.Y - m_theme.PickTolerance' bounds.Width' 2 * m_theme.PickTolerance); " is 134.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Pick,The length of the statement  "            //    // a rough check here probably should suffice most of the time: the bounds of the wire should not be enclosed by the picked node " is 134.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Draw,The length of the statement  "                    g.DrawBitmap(bitMap' new RectangleF(p.X + info.Interior.X' p.Y + info.Interior.Y' info.Interior.Width' info.Interior.Height)' 1' D2dBitmapInterpolationMode.Linear); " is 164.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickPin,The length of the statement  "                (element.Is<ICircuitGroupType<TElement' TWire' TPin>>() && element.Cast<ICircuitGroupType<TElement' TWire' TPin>>().Expanded)) " is 126.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickSubItem,The length of the statement  "                var group = current.Cast<ICircuitGroupType<TElement' TWire' TPin>>(); // the stack top must be a group if we can go down " is 120.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,GetDraggingEdge,The length of the statement  "            edge.StartPoint = edge.FromRoute == null ? Matrix3x2F.TransformPoint(invXform' m_edgeDragPoint) : m_draggingContext.FromRoutePos; " is 129.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,GetDraggingEdge,The length of the statement  "            edge.EndPoint = edge.ToRoute == null ? Matrix3x2F.TransformPoint(invXform' m_edgeDragPoint) : m_draggingContext.ToRoutePos; " is 123.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,MakeConnection,The length of the statement  "                DraggingContext.EditableGraph.Connect(dragFromNode' dragFromRoute' dragToNode' dragToRoute' m_draggingContext.ExistingEdge); " is 124.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,CanConnectTo,The length of the statement  "            m_draggingContext.DragToNodeHitPath = m_mousePick.HitPath; // update DragToNodeHitPath for DraggingContext.EditableGraph " is 120.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,CanConnectFrom,The length of the statement  "            m_draggingContext.DragFromNodeHitPath = m_mousePick.HitPath;// update DragFromNodeHitPath for DraggingContext.EditableGraph " is 123.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,DrawFloatingGroupPin,The length of the statement  "                    D2dUtil.DrawPin((int)(p.X + CircuitGroupPinInfo.FloatingPinBoxWidth)' (int)p.Y + Theme.PinSize / 2' false' true' m_pinBrush' g); " is 128.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,DrawFloatingGroupPin,The length of the statement  "                RectangleF bounds = new RectangleF(p.X' p.Y' CircuitGroupPinInfo.FloatingPinBoxWidth' CircuitGroupPinInfo.FloatingPinBoxHeight); " is 128.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,DrawFloatingGroupPin,The length of the statement  "                RectangleF bounds = new RectangleF(p.X' p.Y' CircuitGroupPinInfo.FloatingPinBoxWidth' CircuitGroupPinInfo.FloatingPinBoxHeight); " is 128.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,DrawFloatingGroupPin,The length of the statement  "                g.DrawRectangle(new RectangleF(p.X' p.Y' CircuitGroupPinInfo.FloatingPinBoxWidth' CircuitGroupPinInfo.FloatingPinBoxHeight)' m_subGraphPinNodePen); " is 147.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,DrawFloatingGroupPin,The length of the statement  "                g.DrawRectangle(new RectangleF(p.X' p.Y' CircuitGroupPinInfo.FloatingPinBoxWidth' CircuitGroupPinInfo.FloatingPinBoxHeight)' Theme.HotBrush); " is 141.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,GetBounds,The length of the statement  "            var result = new RectangleF(p.X' p.Y' CircuitGroupPinInfo.FloatingPinBoxWidth' CircuitGroupPinInfo.FloatingPinBoxHeight); " is 121.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,Pick,The length of the statement  "                RectangleF bounds = new RectangleF(grpPos.X' grpPos.Y' CircuitGroupPinInfo.FloatingPinBoxWidth' CircuitGroupPinInfo.FloatingPinBoxHeight); " is 138.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,Pick,The length of the statement  "                RectangleF labelBounds = new RectangleF(bounds.Left' bounds.Bottom + Theme.PinMargin' (int)nameSize.Width' Theme.RowSpacing); " is 125.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,Pick,The length of the statement  "                RectangleF bounds = new RectangleF(grpPos.X' grpPos.Y' CircuitGroupPinInfo.FloatingPinBoxWidth' CircuitGroupPinInfo.FloatingPinBoxHeight); " is 138.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,Pick,The length of the statement  "                 RectangleF labelBounds = new RectangleF(bounds.Right - (int)nameSize.Width' bounds.Bottom + Theme.PinMargin' (int)nameSize.Width' Theme.RowSpacing); " is 148.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,GetGroupPinLocation,The length of the statement  "                 return new PointF(VisibleWorldBounds.X + CircuitGroupPinInfo.FloatingPinBoxWidth + Theme.PinMargin' grpPin.Bounds.Location.Y); " is 126.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,GetGroupPinLocation,The length of the statement  "                 return new PointF(VisibleWorldBounds.X + VisibleWorldBounds.Width - Theme.PinMargin - 2 * CircuitGroupPinInfo.FloatingPinBoxWidth - 16' grpPin.Bounds.Location.Y); " is 162.
Long Statement,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Draw,The length of the statement  "                //                g.DrawLine(Pens.LightGray' new PointF(c.Center.X' c.Center.Y)' new PointF(startPoint.X' startPoint.Y)); " is 121.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ColorBox)); " is 128.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The length of the statement  "                        LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);  " is 185.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The length of the statement  "                        LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);  " is 186.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The length of the statement  "                        LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);  " is 186.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The length of the statement  "                        LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);  " is 189.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The length of the statement  "                        LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);  " is 191.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The length of the statement  "                        LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);  " is 191.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Hue,The length of the statement  "                LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);  " is 161.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Saturation,The length of the statement  "                LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);  " is 163.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Luminance,The length of the statement  "                LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);  " is 163.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The length of the statement  "                LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);  " is 157.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The length of the statement  "                LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);  " is 157.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The length of the statement  "                LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);  " is 159.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The length of the statement  "                    _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4)))); " is 136.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The length of the statement  "                    _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4)))); " is 136.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The length of the statement  "                    _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B)); " is 136.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_Hue.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_Sat.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_Bright.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_Red.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_Green.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 143.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_Blue.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 142.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_Cyan.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 142.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_Magenta.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 145.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_Yellow.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 144.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_K.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 139.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_Hex.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 141.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_lbl_Hue_Symbol.Font = new System.Drawing.Font("Microsoft Sans Serif"' 11.25F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 152.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_lbl_Saturation_Symbol.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9.75F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 158.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_lbl_Bright_Symbol.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9.75F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 154.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_lbl_Cyan_Symbol.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9.75F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 152.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_lbl_Magenta_Symbol.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9.75F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 155.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_lbl_Yellow_Symbol.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9.75F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 154.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_txt_A.Font = new System.Drawing.Font("Microsoft Sans Serif"' 9F' System.Drawing.FontStyle.Regular' GraphicsUnit.Point' ((byte)(0))); " is 139.
Long Statement,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The length of the statement  "            this.m_ctrl_BigBox.RGB = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(0))))' ((int)(((byte)(0))))); " is 123.
Long Statement,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(VerticalColorSlider)); " is 139.
Long Statement,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The length of the statement  "                return;                                               //    since the last time it was drawn and we don't HAVE to redraw " is 120.
Long Statement,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,RegisterSettings,The length of the statement  "                        "Lock origin".Localize("This is the name of a command. Lock is a verb. Origin is like the origin of a graph.")' null' null)); " is 125.
Long Statement,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnMouseDown,The length of the statement  "            //    && (m_visibleCurveCount == 1 || !OnlyEditSelectedCurves || m_editSet.Count == 0 || m_editSet.Contains(c))).Reverse(); " is 123.
Long Statement,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The length of the statement  "            m_editModeButtons[0].ToolTipText = "Scale selected control points   " + KeysUtil.KeysToString(CurveCanvas.ShortcutKeys.Scale' true); " is 132.
Long Statement,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The length of the statement  "            m_editModeButtons[1].ToolTipText = "Move selected control points   " + KeysUtil.KeysToString(CurveCanvas.ShortcutKeys.Move' true); " is 130.
Long Statement,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,PickPoints,The length of the statement  "                    else if (curve.CurveInterpolation != InterpolationTypes.Linear && cpt.EditorData.SelectedRegion != PointSelectionRegions.None) " is 126.
Long Statement,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,PickPoints,The length of the statement  "                        bool pickTanOut = cpt.TangentOutType != CurveTangentTypes.Stepped && cpt.TangentOutType != CurveTangentTypes.SteppedNext; " is 121.
Long Statement,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(PerformanceMonitorControl)); " is 145.
Long Statement,Sce.Atf.Controls.PropertyEditing,ArrayEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\ArrayEditingControl.cs,UpdateMoveButtons,The length of the statement  "                    m_moveDownButton.ToolTipText = string.Format("Can't move down because last element selected".Localize()' selectedCount); " is 120.
Long Statement,Sce.Atf.Controls.PropertyEditing,ArrayEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\ArrayEditingControl.cs,RebuildItemControls,The length of the statement  "                    "Failed to create item controls' probably because there were not enough Window handles available. Consider using a different editor for collections of this size and nature.\r\n\r\n" " is 181.
Long Statement,Sce.Atf.Controls.PropertyEditing,CollectionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EmbeddedCollectionEditor.cs,ProcessPendingChanges,The length of the statement  "                    //m_toolStrip.Enabled = false; //This sets the focus to the next control in the tab group' which changes the property selection " is 127.
Long Statement,Sce.Atf.Controls.PropertyEditing,CollectionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EmbeddedCollectionEditor.cs,ProcessPendingChanges,The length of the statement  "                        "Failed to create item controls' probably because there were not enough Window handles available. Consider using a different editor for collections of this size and nature.\r\n\r\n" " is 181.
Long Statement,Sce.Atf.Controls.PropertyEditing,GridControlShowHidePropertiesDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridControlShowHidePropertiesDialog.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(GridControlShowHidePropertiesDialog)); " is 155.
Long Statement,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,GetPropertySortOrder,The length of the statement  "                        result = (columnInfo.NextSortDirection == ListSortDirection.Descending) ? ListSortDirection.Ascending : ListSortDirection.Descending; " is 133.
Long Statement,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnPaint,The length of the statement  "                        ControlPaint.DrawBorder3D(g' left' 0' rowHeight' rowHeight' Border3DStyle.Etched' Border3DSide.Bottom | Border3DSide.Right); " is 124.
Long Statement,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnPaint,The length of the statement  "                    DrawColumnHeader(g' s_columnHeaderMouseDownProperty' s_mouseMove.X - draggingClickOffsetX' 0' rowHeight' xPadding' yPadding' m_columnHeaderAlphaBrush); " is 151.
Long Statement,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnMouseMove,The length of the statement  "                    // calc how far the mouse moved to make sure the mouse has moved a bit so we dont kick off a drag event on tiny movements " is 121.
Long Statement,Sce.Atf.Controls.PropertyEditing,NestedCollectionEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NestedCollectionEditor.cs,EditValue,The length of the statement  "                IWindowsFormsEditorService editorService = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService)); " is 127.
Long Statement,Sce.Atf.Controls.PropertyEditing,NestedCollectionEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NestedCollectionEditor.cs,EditValue,The length of the statement  "                    NestedCollectionEditorForm collEditorFrm = CreateForm(context' m_selectionContext' value' e.GetCollectionItemCreators' e.GetItemInfo); " is 134.
Long Statement,Sce.Atf.Controls.PropertyEditing,NestedCollectionEditorForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NestedCollectionEditorForm.cs,UpdateAvailaibleTypes,The length of the statement  "                foreach (Pair<Type' NestedCollectionEditor.CreateCollectionObject> typeCreator in GetCollectionItemCreators(objectPath)) " is 120.
Long Statement,Sce.Atf.Controls.PropertyEditing,NestedCollectionEditorForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NestedCollectionEditorForm.cs,UpdateAvailaibleTypes,The length of the statement  "                    m_availaibleTypeCreators.Add(new Pair<Type' NestedCollectionEditor.CreateCollectionObject>(typeCreator.First' typeCreator.Second)); " is 131.
Long Statement,Sce.Atf.Controls.PropertyEditing,NestedCollectionEditorForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NestedCollectionEditorForm.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(NestedCollectionEditorForm)); " is 146.
Long Statement,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,SetDescription,The length of the statement  "                    int splitter_distance = (int)Math.Max(m_propertyGrid.m_splitContainer.Height - sz.Height' 0.5f * m_propertyGrid.m_splitContainer.Height); " is 137.
Long Statement,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,SetDescription,The length of the statement  "                    splitter_distance = Math.Min(splitter_distance' m_propertyGrid.m_splitContainer.Height - m_propertyGrid.m_splitContainer.Panel2MinSize); " is 136.
Long Statement,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawPropertyRow,The length of the statement  "                GdiUtil.DrawExpander(x + expanderX' y + (RowHeight - ExpanderSize) / 2' property.ChildrenExpanded' g' PropertyExpanderPen); " is 123.
Long Statement,Sce.Atf.Controls.PropertyEditing,PropertyView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyView.cs,MultiLevelSort,The length of the statement  "                result = string.Compare(pathA[pathA.Count - depth - 1].Descriptor.Name' pathB[pathB.Count - depth - 1].Descriptor.Name); " is 120.
Long Statement,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,UpdateResults,The length of the statement  "                    throw new InvalidOperationException("The class implementing IQueryableContext' which produced the results passed in' did not create results of type DomNodeQueryMatch.  Consider use DomNodeQueryable to create your search results."); " is 231.
Long Statement,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,GetDomNodeProperties,The length of the statement  "            ICustomTypeDescriptor iCustomTypeDescriptor = node.GetAdapter(typeof(CustomTypeDescriptorNodeAdapter)) as ICustomTypeDescriptor; " is 128.
Long Statement,Sce.Atf.Dom,TemplatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\TemplatingCommands.cs,AddExternalTemplateFolder,The length of the statement  "                // well' keep simple to use absolute uri for now' so we don't need to update relative uris when the SaveAs document to a different directory " is 140.
Long Statement,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,GetCanvasSize,The length of the statement  "            int canvasWidth = (int)Math.Ceiling(bounds.Right) - offset.X + Width / 2; // give user another half window's worth of canvas " is 124.
Long Statement,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,Draw,The length of the statement  "                m_graphics.DrawLine(new PointF(TrackIndent' m_timeScaleHeight)' new PointF(TrackIndent' c.ClientRectangle.Height)' m_headerLineBrush); " is 134.
Long Statement,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,Draw,The length of the statement  "                m_graphics.DrawLine(new PointF(HeaderWidth' m_timeScaleHeight)' new PointF(HeaderWidth' c.ClientRectangle.Height)' m_headerLineBrush); " is 134.
Long Statement,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,DrawEventOverlay,The length of the statement  "            m_graphics.FillRectangle(new RectangleF(HeaderWidth' 0' c.ClientRectangle.Width' m_timeScaleHeight)' m_generalSolidColorBrush); " is 127.
Long Statement,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The length of the statement  "                        c.Graphics.DrawString(GetXPositionString(bounds.Left + m_keySize / 2' c)' c.Font' SystemBrushes.WindowText' bounds.Right + 16' bounds.Y); " is 137.
Long Statement,Sce.Atf.Controls.Timelines,TimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineControl.cs,GetCanvasSize,The length of the statement  "            int canvasWidth = (int)Math.Ceiling(bounds.Right) - offset.X + Width / 2; // give user another half window's worth of canvas " is 124.
Complex Conditional,Sce.Atf.Applications,AutomationService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\AutomationService.cs,CheckUnexpectedErrors,The conditional expression  "frm.Text == "Error" ||                      frm.Text == "Unexpected Error" ||                      frm.Text == "Microsoft .NET Framework" ||                      frm.GetType() == typeof(ThreadExceptionDialog)"  is complex.
Complex Conditional,Sce.Atf.Applications,ImageThumbnailResolver,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ImageThumbnailResolver.cs,Resolve,The conditional expression  "extension.EndsWith("jpg"' StringComparison.InvariantCultureIgnoreCase) ||                  extension.EndsWith("bmp"' StringComparison.InvariantCultureIgnoreCase) ||                  extension.EndsWith("png"' StringComparison.InvariantCultureIgnoreCase) ||                  extension.EndsWith("tif"' StringComparison.InvariantCultureIgnoreCase) ||                  extension.EndsWith("gif"' StringComparison.InvariantCultureIgnoreCase)"  is complex.
Complex Conditional,Sce.Atf.Applications,FilteredTreeControlEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\FilteredTreeControlEditor.cs,TreeControl_NodeExpandedChanging,The conditional expression  "m_updating || !m_searching || e.Node.Tag == null                   || treeView == null"  is complex.
Complex Conditional,Sce.Atf.Applications,FilteredTreeControlEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\FilteredTreeControlEditor.cs,TreeControl_NodeExpandedChanged,The conditional expression  "m_updating || !m_searching || e.Node.Tag == null                   || treeView == null"  is complex.
Complex Conditional,Sce.Atf.Applications,PropertyEditingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditingCommands.cs,CanPaste,The conditional expression  "srcDescriptor == null                  || destDescriptor == null                                 || destDescriptor.IsReadOnly                  || srcDescriptor.PropertyType != destDescriptor.PropertyType                  || (destDescriptor is ChildAttributeCollectionPropertyDescriptor)                  || (destDescriptor is ChildPropertyDescriptor)"  is complex.
Complex Conditional,Sce.Atf.Applications,DefaultTypeConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinService.cs,CanConvertTo,The conditional expression  "destinationType == typeof(Double) ||                      destinationType == typeof(Single) ||                      destinationType.IsEnum ||                      destinationType == typeof(int) ||                      destinationType == typeof(byte) ||                      destinationType == typeof(bool) ||                      destinationType == typeof(Color) ||                      destinationType == typeof(string)"  is complex.
Complex Conditional,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,OnDocumentDirtyChanged,The conditional expression  "SourceControlService == null || document == null || !document.Dirty || CheckoutOnEditBehavior == CheckoutOnEditBehavior.Never"  is complex.
Complex Conditional,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,DoCheckIn,The conditional expression  "SourceControlService == null || m_contextRegistry == null ||                  SourceControlContext == null || !SourceControlService.AllowCheckIn"  is complex.
Complex Conditional,Sce.Atf,DragDropDataObject,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\DragDrop\DragDropDataObject.cs,GetCompatibleFormat,The conditional expression  "typeof(Stream).IsAssignableFrom(type) ||                  IsFormatEqual(format' DataFormats.Html) ||                  IsFormatEqual(format' DataFormats.Text) ||                  IsFormatEqual(format' DataFormats.Rtf) ||                  IsFormatEqual(format' DataFormats.OemText) ||                  IsFormatEqual(format' DataFormats.UnicodeText) ||                  IsFormatEqual(format' "ApplicationTrust") ||                  IsFormatEqual(format' DataFormats.FileDrop) ||                  IsFormatEqual(format' "FileName") ||                  IsFormatEqual(format' "FileNameW")"  is complex.
Complex Conditional,Sce.Atf,OleConverter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\DragDrop\OleConverter.cs,ConvertHandle,The conditional expression  "format.Equals(DataFormats.Text)                          || format.Equals(DataFormats.Rtf)                          || format.Equals(DataFormats.OemText)                          || format.Equals("FileName")"  is complex.
Complex Conditional,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,OnMouseMove,The conditional expression  "m_isDragging &&                  !m_dragOverThreshold &&                  (xDelta > m_dragThreshold || yDelta > m_dragThreshold)"  is complex.
Complex Conditional,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,GetListItem,The conditional expression  "m_cache != null && i >= 0 && i < m_cache.Length && m_cache[i] != null"  is complex.
Complex Conditional,Sce.Atf.Controls,NumericMatrixControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericMatrixControl.cs,Define,The conditional expression  "numericType != typeof(Int64) &&                  numericType != typeof(UInt64) &&                  numericType != typeof(Int32) &&                  numericType != typeof(UInt32) &&                  numericType != typeof(Int16) &&                  numericType != typeof(UInt16) &&                  numericType != typeof(SByte) &&                  numericType != typeof(Byte) &&                  numericType != typeof(Single) &&                  numericType != typeof(Double)"  is complex.
Complex Conditional,Sce.Atf.Controls,NumericTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTextBox.cs,NumericTextBox,The conditional expression  "numericType != typeof(Int64) &&                  numericType != typeof(UInt64) &&                  numericType != typeof(Int32) &&                  numericType != typeof(UInt32) &&                  numericType != typeof(Int16) &&                  numericType != typeof(UInt16) &&                  numericType != typeof(SByte) &&                  numericType != typeof(Byte) &&                  numericType != typeof(Single) &&                  numericType != typeof(Double)"  is complex.
Complex Conditional,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,Define,The conditional expression  "numericType != typeof(Int64) &&                  numericType != typeof(UInt64) &&                  numericType != typeof(Int32) &&                  numericType != typeof(UInt32) &&                  numericType != typeof(Int16) &&                  numericType != typeof(UInt16) &&                  numericType != typeof(SByte) &&                  numericType != typeof(Byte) &&                  numericType != typeof(Single) &&                  numericType != typeof(Double)"  is complex.
Complex Conditional,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnMouseUp,The conditional expression  "LabelEditModeContains(LabelEditModes.EditOnClick) &&                          m_lastMouseDownWasDoubleClick == false &&                          e.Button == MouseButtons.Left &&                          hitRecord.Node == m_leftClickedSelectedNode &&                          hitRecord.Type == HitType.Label &&                          hitRecord.Node.AllowLabelEdit"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,OnBeginDrag,The conditional expression  "m_layoutContext != null && e.Button == MouseButtons.Left &&                     ((Control.ModifierKeys & Keys.Alt) == 0) && !AdaptedControl.Capture"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_KeyPress,The conditional expression  "(char.IsLowSurrogate(charBackOne) && char.IsHighSurrogate(charBackTwo)) ||                                          (charBackOne == '\n' && charBackTwo == '\r')"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable,HoverAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\HoverAdapter.cs,control_MouseMove,The conditional expression  "hitRecord != null &&                      (hitRecord.Item != m_hoverItem || hitRecord.Part != m_hoverPart ||                      hitRecord.SubItem != m_hoverSubItem || hitRecord.SubPart != m_hoverSubPart)"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,CanConnect,The conditional expression  "fromNode == null ||                  outputPin == null ||                  toNode == null ||                  inputPin == null ||                  outputPin.TypeName != inputPin.TypeName"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphAdapter.cs,OnRender,The conditional expression  "drawStyle == DiagramDrawingStyle.Selected ||                                  drawStyle == DiagramDrawingStyle.LastSelected ||                                  (drawStyle == DiagramDrawingStyle.Hot && m_selectionContext != null &&                                      m_selectionContext.SelectionContains(node))"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,MakeConnection,The conditional expression  "dragToNode != null && dragToRoute != null &&                  dragFromNode != null && dragFromRoute != null"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,DoMouseClick,The conditional expression  "m_draggingContext.DragToNode != null && m_draggingContext.DragToRoute != null &&                          m_draggingContext.DragFromNode != null && m_draggingContext.DragFromRoute != null"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphEdgeEditAdapter.cs,DoMouseClick,The conditional expression  "m_draggingContext.ExistingEdge == null || // this is a new edge                              m_draggingContext.ExistingEdge.ToNode != m_draggingContext.DragToNode ||                              m_draggingContext.ExistingEdge.ToRoute != m_draggingContext.DragToRoute ||                              m_draggingContext.ExistingEdge.FromNode != m_draggingContext.DragFromNode ||                              m_draggingContext.ExistingEdge.FromRoute != m_draggingContext.DragFromRoute"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphNodeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphNodeEditAdapter.cs,AllowDragging,The conditional expression  "c1 && c2 && c3 && c4"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphNodeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphNodeEditAdapter.cs,OnBeginDrag,The conditional expression  "m_layoutContext != null && e.Button == MouseButtons.Left &&                     ((Control.ModifierKeys & Keys.Alt) == 0) &&                     !AdaptedControl.Capture"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable.Graphs,GraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\GraphEdgeEditAdapter.cs,OnMouseUp,The conditional expression  "m_existingEdge == null || // this is a new edge                          m_existingEdge.ToNode != m_dragToNode ||                          m_existingEdge.ToRoute != m_dragToRoute ||                          m_existingEdge.FromNode != m_dragFromNode ||                          m_existingEdge.FromRoute != m_dragFromRoute"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable.Graphs,GraphEdgeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\GraphEdgeEditAdapter.cs,OnMouseUp,The conditional expression  "m_dragToNode != null &&                                  m_dragToRoute != null &&                                  m_dragFromNode != null &&                                  m_dragFromRoute != null"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable.Graphs,GraphNodeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\GraphNodeEditAdapter.cs,OnMouseMove,The conditional expression  "m_mousePick.Node != null &&                          m_mousePick.Edge == null &&                          m_mousePick.FromRoute == null &&                          m_mousePick.ToRoute == null"  is complex.
Complex Conditional,Sce.Atf.Controls.Adaptable.Graphs,KeyboardGraphNavigator<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\KeyboardGraphNavigator.cs,control_PreviewKeyDown,The conditional expression  "keyData == Keys.Up ||                  keyData == Keys.Right ||                  keyData == Keys.Down ||                  keyData == Keys.Left"  is complex.
Complex Conditional,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,IsCompoundStatement,The conditional expression  "statement.StartsWith("if ") ||                  statement.StartsWith("while ") ||                  statement.StartsWith("for ") ||                  statement.StartsWith("try ") ||                  statement.StartsWith("with ") ||                  statement.StartsWith("def ") ||                  statement.StartsWith("class ")"  is complex.
Complex Conditional,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,OnMouseMove,The conditional expression  "m_startDrag && !m_dragOverThreshold                  && (Math.Abs(dx) > m_dragThreshold || Math.Abs(dy) > m_dragThreshold)"  is complex.
Complex Conditional,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,AdvancedOnMouseDown,The conditional expression  "(e.Button == MouseButtons.Middle && Control.ModifierKeys == Keys.None)                     || (e.Button == MouseButtons.Right && Control.ModifierKeys == Keys.Control)"  is complex.
Complex Conditional,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,AdvancedOnMouseDown,The conditional expression  "(e.Button == MouseButtons.Middle && Control.ModifierKeys == Keys.Shift)                     || (e.Button == MouseButtons.Right && Control.ModifierKeys == (Keys.Control | Keys.Shift))"  is complex.
Complex Conditional,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,AdvancedOnMouseDown,The conditional expression  "(e.Button == MouseButtons.Middle && Control.ModifierKeys == Keys.Alt)                   || (e.Button == MouseButtons.Right && Control.ModifierKeys == (Keys.Control | Keys.Alt))"  is complex.
Complex Conditional,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,AdvancedOnMouseUp,The conditional expression  "(e.Button == MouseButtons.Middle && Control.ModifierKeys == Keys.None)                  || (e.Button == MouseButtons.Right && Control.ModifierKeys == Keys.Control)"  is complex.
Complex Conditional,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,AdvancedOnMouseUp,The conditional expression  "(m_editSet.Count > 0 || m_selection.Count > 0 || m_visibleCurveCount == 1) && EditMode == EditModes.InsertPoint"  is complex.
Complex Conditional,Sce.Atf.Controls.CurveEditing,NumberTextBox<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,NumberTextBox,The conditional expression  "ttype == typeof(sbyte) || ttype == typeof(short)                          || ttype == typeof(int) || ttype == typeof(long)"  is complex.
Complex Conditional,Sce.Atf.Controls.CurveEditing,NumberTextBox<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,NumberTextBox,The conditional expression  "ttype == typeof(byte) || ttype == typeof(ushort)                          || ttype == typeof(uint) || ttype == typeof(ulong)"  is complex.
Complex Conditional,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,HitTest,The conditional expression  "(start < fpx && end < fpx) || (start > lpx && end > lpx)"  is complex.
Complex Conditional,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,DrawCurve,The conditional expression  "(fpt.X > x0 || lpt.X > x0) && (fpt.X < x1 || lpt.X < x1)"  is complex.
Complex Conditional,Sce.Atf.Controls.PropertyEditing,ArrayEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\ArrayEditingControl.cs,DomNode_AttributeChanged,The conditional expression  "adapter != null &&                   e.DomNode == adapter.DomNode &&                   m_context.Descriptor.Is<AttributePropertyDescriptor>() &&                  e.AttributeInfo == m_context.Descriptor.As<AttributePropertyDescriptor>().AttributeInfo"  is complex.
Complex Conditional,Sce.Atf.Controls.PropertyEditing,BoundedFloatEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\BoundedFloatEditor.cs,Initialize,The conditional expression  "parameters.Length < 2 ||                  !Single.TryParse(parameters[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out min) ||                  !Single.TryParse(parameters[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out max) ||                  min >= max"  is complex.
Complex Conditional,Sce.Atf.Controls.PropertyEditing,BoundedIntEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\BoundedIntEditor.cs,Initialize,The conditional expression  "parameters.Length < 2 ||                  !Int32.TryParse(parameters[0]' NumberStyles.Integer' CultureInfo.InvariantCulture' out min) ||                  !Int32.TryParse(parameters[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out max) ||                  min >= max"  is complex.
Complex Conditional,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnPaint,The conditional expression  "(!m_editingRowVisible) && p.Equals(SelectedProperty) && (m_selectedRows.LastSelected == j) && (SelectedCount != 0)"  is complex.
Complex Conditional,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnPaint,The conditional expression  "selected && m_editingRowVisible && (m_selectedRows.LastSelected == j) && (!p.DisableEditing)"  is complex.
Complex Conditional,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnMouseUp,The conditional expression  "hit.Property == SelectedProperty &&                      SelectedProperty != null &&                      m_selectedRows.Contains(hit.Row) &&                      (!SelectedProperty.DisableEditing) &&                      m_clickedOnSelectedRow"  is complex.
Complex Conditional,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,Pick,The conditional expression  "property.Control != null &&                              clientPnt.X > middleX &&                              (!property.NameHasWholeRow || clientPnt.Y >= top - propertyRowHeight + RowHeight)"  is complex.
Complex Conditional,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,GetPreferredHeight,The conditional expression  "(property.Category == null || property.Category.Expanded)                      && (property.Parent == null || property.Parent.ChildrenExpanded)"  is complex.
Complex Conditional,Sce.Atf.Controls.Timelines.Direct2D,D2dMoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dMoveManipulator.cs,MouseMove,The conditional expression  "m_isDragging &&                  !m_dragOverThreshold &&                  (xDelta > m_dragThreshold || yDelta > m_dragThreshold)"  is complex.
Complex Conditional,Sce.Atf.Controls.Timelines.Direct2D,D2dSelectionManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dSelectionManipulator.cs,UpdateSelection,The conditional expression  "(modifiers & Keys.Shift) == 0 ||                      Anchor == null ||                      (Anchor.Last is IGroup && hitObject.Last is ITrack) ||                      (Anchor.Last is ITrack && hitObject.Last is IGroup) ||                      (Anchor.Last is IEvent && hitObject.Last is IEvent)"  is complex.
Complex Conditional,Sce.Atf.Controls.Timelines.Direct2D,D2dSplitManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dSplitManipulator.cs,owner_MouseMovePicked,The conditional expression  "e.HitRecord.Type == HitType.Interval &&                      e.MouseEvent.Button == MouseButtons.None &&                      !m_owner.IsUsingMouse &&                      m_owner.IsEditable(e.HitRecord.HitPath)"  is complex.
Complex Conditional,Sce.Atf.Controls.Timelines.Direct2D,D2dSplitManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dSplitManipulator.cs,owner_MouseDownPicked,The conditional expression  "m_active &&                  e.MouseEvent.Button == MouseButtons.Left &&                  !m_owner.IsUsingMouse &&                  m_owner.IsEditable(hitPath)"  is complex.
Complex Conditional,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,Pick,The conditional expression  "!(                  pickRect.Left > HeaderWidth &&                  pickRect.Right < clientRectangle.Width &&                  pickRect.Bottom > 0 &&                  pickRect.Bottom < TimeScaleHeight)"  is complex.
Complex Conditional,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,PickSubTimeline,The conditional expression  "pickRect.Left > HeaderWidth &&                  pickRect.Right < clientRectangle.Width &&                  pickRect.Bottom > 0 &&                  pickRect.Bottom < TimeScaleHeight"  is complex.
Complex Conditional,Sce.Atf.Controls.Timelines,SelectionManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\SelectionManipulator.cs,UpdateSelection,The conditional expression  "(modifiers & Keys.Shift) == 0 ||                      Anchor == null ||                      (Anchor.Last is IGroup && hitObject.Last is ITrack) ||                      (Anchor.Last is ITrack && hitObject.Last is IGroup) ||                      (Anchor.Last is IEvent && hitObject.Last is IEvent)"  is complex.
Complex Conditional,Sce.Atf.Controls.Timelines,SplitManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\SplitManipulator.cs,owner_MouseMovePicked,The conditional expression  "e.HitRecord.Type == HitType.Interval &&                      e.MouseEvent.Button == MouseButtons.None &&                      !m_owner.IsUsingMouse &&                      m_owner.IsEditable(e.HitRecord.HitPath)"  is complex.
Complex Conditional,Sce.Atf.Controls.Timelines,SplitManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\SplitManipulator.cs,owner_MouseDownPicked,The conditional expression  "m_active &&                  e.MouseEvent.Button == MouseButtons.Left &&                  !m_owner.IsUsingMouse &&                  m_owner.IsEditable(hitPath)"  is complex.
Complex Conditional,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,Pick,The conditional expression  "!(                  pickRect.Left > HeaderWidth &&                  pickRect.Right < clientRectangle.Width &&                  pickRect.Bottom > 0 &&                  pickRect.Bottom < TimeScaleHeight)"  is complex.
Complex Conditional,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,PickSubTimeline,The conditional expression  "pickRect.Left > HeaderWidth &&                  pickRect.Right < clientRectangle.Width &&                  pickRect.Bottom > 0 &&                  pickRect.Bottom < TimeScaleHeight"  is complex.
Virtual Method Call from Constructor,Sce.Atf.Applications,GridPropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\GridPropertyEditor.cs,GridPropertyEditor,The constructor "GridPropertyEditor" calls a virtual method "Configure".
Virtual Method Call from Constructor,Sce.Atf.Applications,LayerLister,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\LayerLister.cs,LayerLister,The constructor "LayerLister" calls a virtual method "Configure".
Virtual Method Call from Constructor,Sce.Atf.Applications,ListViewEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\ListViewEditor.cs,ListViewEditor,The constructor "ListViewEditor" calls a virtual method "Configure".
Virtual Method Call from Constructor,Sce.Atf.Applications,PrototypeLister,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\PrototypeLister.cs,PrototypeLister,The constructor "PrototypeLister" calls a virtual method "Configure".
Virtual Method Call from Constructor,Sce.Atf.Applications,TreeControlEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\TreeControlEditor.cs,TreeControlEditor,The constructor "TreeControlEditor" calls a virtual method "Configure".
Virtual Method Call from Constructor,Sce.Atf.Applications,ClonedPropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,ClonedPropertyEditor,The constructor "ClonedPropertyEditor" calls a virtual method "Configure".
Virtual Method Call from Constructor,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,PropertyGridView,The constructor "PropertyGridView" calls a virtual method "ResetValue".
Virtual Method Call from Constructor,Sce.Atf.Dom,DomNodeReplaceToolStrip,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeReplaceToolStrip.cs,DomNodeReplaceToolStrip,The constructor "DomNodeReplaceToolStrip" calls a virtual method "GetToolStripItems".
Virtual Method Call from Constructor,Sce.Atf.Dom,DomNodeSearchToolStrip,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchToolStrip.cs,DomNodeSearchToolStrip,The constructor "DomNodeSearchToolStrip" calls a virtual method "GetToolStripItems".
Virtual Method Call from Constructor,Sce.Atf.Dom,TemplateLister,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\TemplateLister.cs,TemplateLister,The constructor "TemplateLister" calls a virtual method "Configure".
Virtual Method Call from Constructor,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,D2dTimelineControl,The constructor "D2dTimelineControl" calls a virtual method "Init".
Empty Catch Block,Sce.Atf.Applications,AutoDocumentService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\AutoDocumentService.cs,mainWindow_Loaded,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,AutomationService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\AutomationService.cs,Initialize,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,AutomationService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\AutomationService.cs,StartService,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,AutomationService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\AutomationService.cs,Dispose,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,DefaultTabCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\DefaultTabCommands.cs,Initialize,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,TestCleanup,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,TestCleanup,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,ExecuteStatementSafe,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,ExecuteScriptSafe,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,ScriptConsole,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ScriptConsole.cs,Suggestions,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,SettingsService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsService.cs,SaveSettings,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,SingleInstanceService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SingleInstanceService.cs,SingleInstanceService,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,FontDescriptor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,GetValue,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Applications,SkinService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinService.cs,SaveOriginalPropertyValues,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Controls,AboutSysInfoDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\AboutSysInfoDialog.cs,AboutSysInfoDialog,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,listView_SelectedIndexChanged,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,UpdateFolderListView,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,GetCompatibleData,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawEdgeSpline,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Controls.FolderSelection,Reflector,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FolderSelectDialog.cs,New,The method has an empty catch block.
Magic Number,Sce.Atf.Applications,AutomationService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\AutomationService.cs,GetUniquePortNumber,The following statement contains a magic number: const int basePortNumber = 4000;
Magic Number,Sce.Atf.Applications,AutomationService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\AutomationService.cs,GetUniquePortNumber,The following statement contains a magic number: const int rangeSize = 2000;
Magic Number,Sce.Atf.Applications,CommandService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\CommandService.cs,BuildSubMenus,The following statement contains a magic number: if (menuText[0] == '@')                  segments = new[] { menuText.Substring(1' menuText.Length - 1) };              else                  segments = menuText.Split(s_pathDelimiters' 8);
Magic Number,Sce.Atf.Applications,CommandService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\CommandService.cs,ProcessKey,The following statement contains a magic number: if (key == Keys.F1 && m_lastHoveringToolStrip != null)              {                  foreach (var item in m_lastHoveringToolStrip.Items)                  {                      var button = item as ToolStripButton;                      if (button != null)                      {                          if (button.Selected)                          {                              foreach (KeyValuePair<CommandInfo' CommandControls> commandAndControl in m_commandControls)                              {                                  if (commandAndControl.Value.Button == button &&                                      !string.IsNullOrEmpty(commandAndControl.Key.HelpUrl))                                  {                                      // There doesn't seem to be a way to prevent the WM_HELP message that gets generated                                      //  during the call to Process.Start(). We can't add a filter to every Control's                                      //  WndProc. So' let's use a static way of stopping WebHelp for a little bit.                                      WebHelp.SupressHelpRequests = true;                                      Process.Start(commandAndControl.Key.HelpUrl);                                        if (m_webHelpTimer == null)                                      {                                          m_webHelpTimer = new DispatcherTimer { Interval = TimeSpan.FromMilliseconds(1000) };                                          m_webHelpTimer.Tick +=                                              (o' e) =>                                              {                                                  WebHelp.SupressHelpRequests = false;                                                  m_webHelpTimer.Stop();                                              };                                      }                                      m_webHelpTimer.Start();                                                                            return true;                                  }                              }                          }                      }                  }              }
Magic Number,Sce.Atf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ControlHostService.cs,ControlHostService,The following statement contains a magic number: MouseOverTabSwitchDelay = 250;
Magic Number,Sce.Atf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ControlHostService.cs,UpdateDockContent,The following statement contains a magic number: dockContent.Icon =                  info.Image == null                      ? null                      : GdiUtil.CreateIcon(info.Image' 16' true);
Magic Number,Sce.Atf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ControlHostService.cs,GetPersistenceId,The following statement contains a magic number: bool usedefault                  = string.IsNullOrEmpty(name)                  || name.Length > 64                  || name.IndexOfAny(s_pathDelimiters) > 0                  || name.Contains(".");
Magic Number,Sce.Atf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ControlHostService.cs,SetDockPanelState,The following statement contains a magic number: using (MemoryStream stream = new MemoryStream())              {                  using (StreamWriter writer = new StreamWriter(stream))                  {                      // prepend an xml header' if it has been stripped off                      // Note: It would be better if this was done in the SettingsService as 'value' should be valid XML.                      int length = Math.Min(value.Length' 20);                      string xmlheader = StringUtil.RemoveAllWhiteSpace(value.Substring(0' length));                      if (!xmlheader.StartsWith("<?xmlversion="' StringComparison.OrdinalIgnoreCase))                          writer.Write(@"<?xml version=""1.0"" encoding=""utf-8"" standalone=""yes""?>");                        writer.Write(value);                      writer.Flush();                      stream.Seek(0' SeekOrigin.Begin);                        m_dockPanel.SuspendLayout(true);                      try                      {                          // The dock panel must be cleared of all contents before deserializing.                          var contents = new IDockContent[m_dockPanel.Contents.Count];                          m_dockPanel.Contents.CopyTo(contents' 0);                          for (int i = 0; i < contents.Length; i++)                          {                              var dockContent = (DockContent)contents[i];                              // Setting DockState causes a crash when hiding unregistered DockContents below.                              // DockPanelSuite's DockSample simply sets DockPanel to null' but inside the                              //  SuspendLayout and ResumeLayout pair.                              //dockContent.DockState = DockState.Unknown;                              dockContent.DockPanel = null;                          }                            DeserializeDockContent deserializer = StringToDockContent;                          m_dockPanel.LoadFromXml(stream' deserializer' true);                            // Put back any docking content that had no persisted state.                          // We iterate through m_dockContent rather than m_controls because m_controls can get                          //  modified inside the loop' when calling ShowDockContent.                          foreach (var pair in m_dockContent)                          {                              DockContent dockContent = pair.Value;                              if (dockContent.DockPanel == null)                              {                                  ControlInfo info = pair.Key;                                  UpdateDockContent(dockContent' info);                                  ShowDockContent(dockContent' info);                              }                          }                            // Hide these unregistered DockContents until client code calls RegisterControl().                          foreach (DockContent unregisteredContent in m_unregisteredContents)                          {                              unregisteredContent.Hide();                          }                      }                      finally                      {                          m_dockPanel.ResumeLayout(true' true);                      }                  }              }
Magic Number,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,Connect,The following statement contains a magic number: while (!connected && cnt++ < 100)              {                  try                  {                      //RemotingConfiguration.CustomErrorsMode = CustomErrorsModes.Off;                      string uri = string.Format("tcp://localhost:{0}/{1}"'                                                  port' AutomationService.TcpName);                        //Getting the object works' even if the service hasn't started yet                      m_automationService = (AutomationService)Activator.GetObject(typeof(AutomationService)' uri);                      //... but calling a method will fail if the service isn't ready                      connected = m_automationService.Connect();                  }                  catch                  {                      Console.WriteLine("Automation service exception on try#{0}"' cnt);                  }                  if (!connected)                  {                      if (m_process.HasExited)                      {                          Console.WriteLine("Not connected and process has exited' quitting early (app might have crashed)");                          break;                      }                      Console.WriteLine("Automation service not ready on try#{0}"' cnt);                      Thread.Sleep(200);                  }              }
Magic Number,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,Connect,The following statement contains a magic number: while (!connected && cnt++ < 100)              {                  try                  {                      //RemotingConfiguration.CustomErrorsMode = CustomErrorsModes.Off;                      string uri = string.Format("tcp://localhost:{0}/{1}"'                                                  port' AutomationService.TcpName);                        //Getting the object works' even if the service hasn't started yet                      m_automationService = (AutomationService)Activator.GetObject(typeof(AutomationService)' uri);                      //... but calling a method will fail if the service isn't ready                      connected = m_automationService.Connect();                  }                  catch                  {                      Console.WriteLine("Automation service exception on try#{0}"' cnt);                  }                  if (!connected)                  {                      if (m_process.HasExited)                      {                          Console.WriteLine("Not connected and process has exited' quitting early (app might have crashed)");                          break;                      }                      Console.WriteLine("Automation service not ready on try#{0}"' cnt);                      Thread.Sleep(200);                  }              }
Magic Number,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,ExecuteStatementSafe,The following statement contains a magic number: if (!t.Join(1000 * timeoutInSec))              {                  throw new TimeoutException(string.Format("Executing statement timedout: {0}"' statement));              }
Magic Number,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,ExecuteScriptSafe,The following statement contains a magic number: if (!t.Join(1000 * timeoutInSecs))              {                  Console.WriteLine("Script timed out: {0}"' scriptPath);                  throw new TimeoutException(string.Format("Executing script timed out: {0}"' scriptPath));              }
Magic Number,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,CloseApplication,The following statement contains a magic number: ExecuteStatementSafe("atfFile.DiscardAll()"' 20);
Magic Number,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,CloseApplication,The following statement contains a magic number: try              {                  //This is the close application command for ATF3                  string result = ExecuteStatementSafe("atfFileExit.DoCommand(StandardCommand.FileExit)"' 15);                  Check(string.IsNullOrEmpty(result)' "Verify no error when closing application: " + result);              }              catch (SocketException e)              {                  Console.WriteLine("Socket exception when closing the application: {0}"' e.Message);                  //Might need to kill the process here?              }
Magic Number,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,VerifyApplicationClosed,The following statement contains a magic number: while (!m_process.HasExited && cnt++ < 100)              {                  Thread.Sleep(100);              }
Magic Number,Sce.Atf.Applications,FunctionalTestBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\FunctionalTestBase.cs,VerifyApplicationClosed,The following statement contains a magic number: while (!m_process.HasExited && cnt++ < 100)              {                  Thread.Sleep(100);              }
Magic Number,Sce.Atf.Applications,LayoutContexts,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ILayoutContext.cs,Center,The following statement contains a magic number: Point topLeft = new Point(                  center.X - bounds.Width / 2'                  center.Y - bounds.Height / 2);
Magic Number,Sce.Atf.Applications,LayoutContexts,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ILayoutContext.cs,Center,The following statement contains a magic number: Point topLeft = new Point(                  center.X - bounds.Width / 2'                  center.Y - bounds.Height / 2);
Magic Number,Sce.Atf.Applications,LayoutContexts,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ILayoutContext.cs,Center,The following statement contains a magic number: Point offset = new Point(                  center.X - (bounds.Left + bounds.Width / 2)'                  center.Y - (bounds.Top + bounds.Height / 2));
Magic Number,Sce.Atf.Applications,LayoutContexts,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ILayoutContext.cs,Center,The following statement contains a magic number: Point offset = new Point(                  center.X - (bounds.Left + bounds.Width / 2)'                  center.Y - (bounds.Top + bounds.Height / 2));
Magic Number,Sce.Atf.Applications,CommandList,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\HistoryLister.cs,GetItemHeight,The following statement contains a magic number: return (int)Font.GetHeight() + 2;
Magic Number,Sce.Atf.Applications,ResourceLister,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\ResourceLister.cs,Initialize,The following statement contains a magic number: m_splitContainer.SplitterDistance = 10;
Magic Number,Sce.Atf.Applications,OutputService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\OutputService.cs,OutputMessage,The following statement contains a magic number: if (m_textBox.TextLength > 1048576)                  m_textBox.Text = string.Empty;
Magic Number,Sce.Atf.Applications,PropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,Initialize,The following statement contains a magic number: if (s_cloneImage == null)              {                  s_cloneImage = new Bitmap(16' 16' System.Drawing.Imaging.PixelFormat.Format32bppArgb);                  using (Graphics g = Graphics.FromImage(s_cloneImage))                  {                      g.Clear(Color.Transparent);                      var rect = new Rectangle(1' 1' 8' 10);                                              g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                      rect.Location = new Point(6' 5);                      g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                  }              }
Magic Number,Sce.Atf.Applications,PropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,Initialize,The following statement contains a magic number: if (s_cloneImage == null)              {                  s_cloneImage = new Bitmap(16' 16' System.Drawing.Imaging.PixelFormat.Format32bppArgb);                  using (Graphics g = Graphics.FromImage(s_cloneImage))                  {                      g.Clear(Color.Transparent);                      var rect = new Rectangle(1' 1' 8' 10);                                              g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                      rect.Location = new Point(6' 5);                      g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                  }              }
Magic Number,Sce.Atf.Applications,PropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,Initialize,The following statement contains a magic number: if (s_cloneImage == null)              {                  s_cloneImage = new Bitmap(16' 16' System.Drawing.Imaging.PixelFormat.Format32bppArgb);                  using (Graphics g = Graphics.FromImage(s_cloneImage))                  {                      g.Clear(Color.Transparent);                      var rect = new Rectangle(1' 1' 8' 10);                                              g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                      rect.Location = new Point(6' 5);                      g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                  }              }
Magic Number,Sce.Atf.Applications,PropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,Initialize,The following statement contains a magic number: if (s_cloneImage == null)              {                  s_cloneImage = new Bitmap(16' 16' System.Drawing.Imaging.PixelFormat.Format32bppArgb);                  using (Graphics g = Graphics.FromImage(s_cloneImage))                  {                      g.Clear(Color.Transparent);                      var rect = new Rectangle(1' 1' 8' 10);                                              g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                      rect.Location = new Point(6' 5);                      g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                  }              }
Magic Number,Sce.Atf.Applications,PropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,Initialize,The following statement contains a magic number: if (s_cloneImage == null)              {                  s_cloneImage = new Bitmap(16' 16' System.Drawing.Imaging.PixelFormat.Format32bppArgb);                  using (Graphics g = Graphics.FromImage(s_cloneImage))                  {                      g.Clear(Color.Transparent);                      var rect = new Rectangle(1' 1' 8' 10);                                              g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                      rect.Location = new Point(6' 5);                      g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                  }              }
Magic Number,Sce.Atf.Applications,PropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,Initialize,The following statement contains a magic number: if (s_cloneImage == null)              {                  s_cloneImage = new Bitmap(16' 16' System.Drawing.Imaging.PixelFormat.Format32bppArgb);                  using (Graphics g = Graphics.FromImage(s_cloneImage))                  {                      g.Clear(Color.Transparent);                      var rect = new Rectangle(1' 1' 8' 10);                                              g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                      rect.Location = new Point(6' 5);                      g.FillRectangle(Brushes.White' rect);                      g.DrawRectangle(Pens.Black' rect);                  }              }
Magic Number,Sce.Atf.Applications,PropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,Initialize,The following statement contains a magic number: cloneButton.Size = new Size(29' 22);
Magic Number,Sce.Atf.Applications,PropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,Initialize,The following statement contains a magic number: cloneButton.Size = new Size(29' 22);
Magic Number,Sce.Atf.Applications,ClonedPropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,ClonedPropertyEditor,The following statement contains a magic number: m_selectionButton.Size = new Size(29' 22);
Magic Number,Sce.Atf.Applications,ClonedPropertyEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditor.cs,ClonedPropertyEditor,The following statement contains a magic number: m_selectionButton.Size = new Size(29' 22);
Magic Number,Sce.Atf.Applications,RenameCommandDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\RenameCommandDialog.cs,UpdatePreview,The following statement contains a magic number: const int maxNumToPreview = 20;
Magic Number,Sce.Atf.Applications,RenameCommandDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\RenameCommandDialog.cs,InitializeComponent,The following statement contains a magic number: this.firstNumericUpDown.Maximum = new decimal(new int[] {              -1'              2147483647'              0'              0});
Magic Number,Sce.Atf.Applications,DomNodePropertySearchService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SearchAndReplace\DomNodePropertySearchService.cs,DoLayout,The following statement contains a magic number: if (SearchUI != null)              {                  SearchUI.Control.Anchor = AnchorStyles.Top | AnchorStyles.Left;                    Rectangle scb = SearchUI.Control.Bounds;                  if (ResultsUI != null)                  {                      Rectangle resultsBounds = scb;                      resultsBounds.Y += scb.Height;                      resultsBounds.Width = m_rootControl.Width - (m_rootControl.Margin.Left + m_rootControl.Margin.Right);                      resultsBounds.Height = m_rootControl.Height - (m_rootControl.Margin.Top + m_rootControl.Margin.Bottom + scb.Height + 2);                      ResultsUI.Control.Bounds = resultsBounds;                      ResultsUI.Control.Anchor = AnchorStyles.None;                  }                    if (ReplaceUI != null)                  {                      Rectangle replaceBounds = scb;                      replaceBounds.X += scb.Width;                      ReplaceUI.Control.Bounds = replaceBounds;                      ReplaceUI.Control.Anchor = AnchorStyles.None;                  }              }
Magic Number,Sce.Atf.Applications,SettingsService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsService.cs,RegisterUserSettings,The following statement contains a magic number: string[] path = pathName.Split(s_delimiters' 16);
Magic Number,Sce.Atf.Applications,SettingsService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsService.cs,GetSettingsPath,The following statement contains a magic number: string[] pathSegments = pathName.Split(s_delimiters' 16);
Magic Number,Sce.Atf.Applications,SettingsService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsService.cs,StringToXmlDoc,The following statement contains a magic number: try              {                  int len = (strXml.Length > 20) ? 20 : strXml.Length;                  string test = StringUtil.RemoveAllWhiteSpace(strXml.Substring(0' len)).ToLower();                  if (test.Contains("<?xmlversion="))                  {                      xmlDoc = new XmlDocument();                      xmlDoc.LoadXml(strXml);                  }              }              catch              {                  xmlDoc = null;              }
Magic Number,Sce.Atf.Applications,SettingsService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsService.cs,StringToXmlDoc,The following statement contains a magic number: try              {                  int len = (strXml.Length > 20) ? 20 : strXml.Length;                  string test = StringUtil.RemoveAllWhiteSpace(strXml.Substring(0' len)).ToLower();                  if (test.Contains("<?xmlversion="))                  {                      xmlDoc = new XmlDocument();                      xmlDoc.LoadXml(strXml);                  }              }              catch              {                  xmlDoc = null;              }
Magic Number,Sce.Atf.Applications,SettingsService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsService.cs,GetMutexName,The following statement contains a magic number: if (safeName.Length > 250)                  safeName = safeName.Substring(safeName.Length - 250);
Magic Number,Sce.Atf.Applications,SettingsService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsService.cs,GetMutexName,The following statement contains a magic number: if (safeName.Length > 250)                  safeName = safeName.Substring(safeName.Length - 250);
Magic Number,Sce.Atf.Applications,SingleInstanceService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SingleInstanceService.cs,SingleInstanceService,The following statement contains a magic number: if (applicationId.Length > 250)                  applicationId = applicationId.Substring(0' 250);
Magic Number,Sce.Atf.Applications,SingleInstanceService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SingleInstanceService.cs,SingleInstanceService,The following statement contains a magic number: if (applicationId.Length > 250)                  applicationId = applicationId.Substring(0' 250);
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,UpdateCaptionButtons,The following statement contains a magic number: int top = Math.Min(4' m_titleAndBorderSize - (capSize + 1));
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,UpdateCaptionButtons,The following statement contains a magic number: int iconSize = m_titleAndBorderSize - 2;
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,UpdateCaptionButtons,The following statement contains a magic number: int iconTop = 2;
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,UpdateCaptionButtons,The following statement contains a magic number: int iconLeft = 2;
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,UpdateCaptionButtons,The following statement contains a magic number: Rectangle btnBound = new Rectangle(m_winRect.Width - (capSize + 3)' top' capSize' capSize);
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,PaintTitleBar,The following statement contains a magic number: borderRect.Width -= 2;
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,PaintTitleBar,The following statement contains a magic number: borderRect.Height -= 2;
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,PaintTitleBar,The following statement contains a magic number: if (!string.IsNullOrWhiteSpace(captionStr))              {                  int w = m_iconRect.Width > 0 ? -(m_iconRect.Width + 1) : -6;                  if (m_captionButtons.Count > 0)                      w += m_captionButtons[m_captionButtons.Count - 1].Bound.X;                  else                      w += m_winRect.Width;                    int x = m_iconRect.Right > 0 ? m_iconRect.Right : 6;                  int top = 0;                  int height = m_titleAndBorderSize;                  if (m_form.WindowState == FormWindowState.Maximized)                  {                      top = m_borderSize;                      height = m_titleSize;                  }                      s_genBrush.Color = active ? m_skin.ActiveTitleBarForeColor                 : m_skin.TitleBarForeColor;                    Rectangle strRect = new Rectangle(x' top' w' height);                  g.DrawString(captionStr'                      SystemFonts.CaptionFont'                      s_genBrush'                      strRect'                      s_captionFormat);              }
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,PaintTitleBar,The following statement contains a magic number: if (!string.IsNullOrWhiteSpace(captionStr))              {                  int w = m_iconRect.Width > 0 ? -(m_iconRect.Width + 1) : -6;                  if (m_captionButtons.Count > 0)                      w += m_captionButtons[m_captionButtons.Count - 1].Bound.X;                  else                      w += m_winRect.Width;                    int x = m_iconRect.Right > 0 ? m_iconRect.Right : 6;                  int top = 0;                  int height = m_titleAndBorderSize;                  if (m_form.WindowState == FormWindowState.Maximized)                  {                      top = m_borderSize;                      height = m_titleSize;                  }                      s_genBrush.Color = active ? m_skin.ActiveTitleBarForeColor                 : m_skin.TitleBarForeColor;                    Rectangle strRect = new Rectangle(x' top' w' height);                  g.DrawString(captionStr'                      SystemFonts.CaptionFont'                      s_genBrush'                      strRect'                      s_captionFormat);              }
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,UpdateBounds,The following statement contains a magic number: m_borderSize = (w - cw) / 2;
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,UpdateBounds,The following statement contains a magic number: m_titleSize = (h - ch) - 2 * m_borderSize;
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,HiWord,The following statement contains a magic number: return (val >> 16) & 0xFFFF;
Magic Number,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,GetWindowLong,The following statement contains a magic number: if (IntPtr.Size == 4)              {                  return GetWindowLong32(hWnd' nIndex);              }
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: ActiveBorderColor = Color.FromArgb(0' 121' 203);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: ActiveBorderColor = Color.FromArgb(0' 121' 203);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: InactiveBorderColor = Color.FromArgb(70' 70' 75);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: InactiveBorderColor = Color.FromArgb(70' 70' 75);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: InactiveBorderColor = Color.FromArgb(70' 70' 75);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: TitleBarBackColor = Color.FromArgb(45' 45' 48);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: TitleBarBackColor = Color.FromArgb(45' 45' 48);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: TitleBarBackColor = Color.FromArgb(45' 45' 48);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: TitleBarForeColor = Color.FromArgb(160' 160' 160);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: TitleBarForeColor = Color.FromArgb(160' 160' 160);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: TitleBarForeColor = Color.FromArgb(160' 160' 160);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: ActiveTitleBarForeColor = Color.FromArgb(250' 250' 250);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: ActiveTitleBarForeColor = Color.FromArgb(250' 250' 250);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: ActiveTitleBarForeColor = Color.FromArgb(250' 250' 250);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: CaptionButtonHoverColor = Color.FromArgb(70' 70' 75);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: CaptionButtonHoverColor = Color.FromArgb(70' 70' 75);
Magic Number,Sce.Atf.Applications,SkinInfo,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,SkinInfo,The following statement contains a magic number: CaptionButtonHoverColor = Color.FromArgb(70' 70' 75);
Magic Number,Sce.Atf.Applications,CustomCaptionButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,Draw,The following statement contains a magic number: if (Id == HitTest.HTCLOSE)                  {                      var smoothMode = g.SmoothingMode;                      g.SmoothingMode = SmoothingMode.AntiAlias;                      s_genPen.Width = 2.0f;                      g.DrawLine(s_genPen' rect.X' rect.Y' rect.Right' rect.Bottom);                      g.DrawLine(s_genPen' rect.Right' rect.Y' rect.X' rect.Bottom);                      g.SmoothingMode = smoothMode;                  }                  else if (Id == HitTest.HTMAXBUTTON)                  {                      s_genPen.Width = 1.0f;                      if (form.WindowState == FormWindowState.Normal)                      {                          g.DrawRectangle(s_genPen' rect);                          g.DrawLine(s_genPen' rect.X' rect.Y + 1' rect.Right' rect.Y + 1);                      }                      else                      {                          Rectangle rect2 = rect;                            rect2.X += margin / 2;                          rect2.Y -= margin / 2;                            g.DrawRectangle(s_genPen' rect2);                          g.DrawLine(s_genPen' rect2.X' rect2.Y + 1' rect2.Right' rect2.Y + 1);                            rect2.X -= margin / 2;                          rect2.Y += margin / 2;                            g.FillRectangle(s_genBrush' rect2);                          g.DrawRectangle(s_genPen' rect2);                          g.DrawLine(s_genPen' rect2.X' rect2.Y + 1' rect2.Right' rect2.Y + 1);                      }                    }                  else if (Id == HitTest.HTMINBUTTON)                  {                      s_genPen.Width = 2;                      g.DrawLine(s_genPen' rect.X' rect.Bottom' rect.Right' rect.Bottom);                  }
Magic Number,Sce.Atf.Applications,CustomCaptionButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,Draw,The following statement contains a magic number: if (Id == HitTest.HTCLOSE)                  {                      var smoothMode = g.SmoothingMode;                      g.SmoothingMode = SmoothingMode.AntiAlias;                      s_genPen.Width = 2.0f;                      g.DrawLine(s_genPen' rect.X' rect.Y' rect.Right' rect.Bottom);                      g.DrawLine(s_genPen' rect.Right' rect.Y' rect.X' rect.Bottom);                      g.SmoothingMode = smoothMode;                  }                  else if (Id == HitTest.HTMAXBUTTON)                  {                      s_genPen.Width = 1.0f;                      if (form.WindowState == FormWindowState.Normal)                      {                          g.DrawRectangle(s_genPen' rect);                          g.DrawLine(s_genPen' rect.X' rect.Y + 1' rect.Right' rect.Y + 1);                      }                      else                      {                          Rectangle rect2 = rect;                            rect2.X += margin / 2;                          rect2.Y -= margin / 2;                            g.DrawRectangle(s_genPen' rect2);                          g.DrawLine(s_genPen' rect2.X' rect2.Y + 1' rect2.Right' rect2.Y + 1);                            rect2.X -= margin / 2;                          rect2.Y += margin / 2;                            g.FillRectangle(s_genBrush' rect2);                          g.DrawRectangle(s_genPen' rect2);                          g.DrawLine(s_genPen' rect2.X' rect2.Y + 1' rect2.Right' rect2.Y + 1);                      }                    }                  else if (Id == HitTest.HTMINBUTTON)                  {                      s_genPen.Width = 2;                      g.DrawLine(s_genPen' rect.X' rect.Bottom' rect.Right' rect.Bottom);                  }
Magic Number,Sce.Atf.Applications,CustomCaptionButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,Draw,The following statement contains a magic number: if (Id == HitTest.HTCLOSE)                  {                      var smoothMode = g.SmoothingMode;                      g.SmoothingMode = SmoothingMode.AntiAlias;                      s_genPen.Width = 2.0f;                      g.DrawLine(s_genPen' rect.X' rect.Y' rect.Right' rect.Bottom);                      g.DrawLine(s_genPen' rect.Right' rect.Y' rect.X' rect.Bottom);                      g.SmoothingMode = smoothMode;                  }                  else if (Id == HitTest.HTMAXBUTTON)                  {                      s_genPen.Width = 1.0f;                      if (form.WindowState == FormWindowState.Normal)                      {                          g.DrawRectangle(s_genPen' rect);                          g.DrawLine(s_genPen' rect.X' rect.Y + 1' rect.Right' rect.Y + 1);                      }                      else                      {                          Rectangle rect2 = rect;                            rect2.X += margin / 2;                          rect2.Y -= margin / 2;                            g.DrawRectangle(s_genPen' rect2);                          g.DrawLine(s_genPen' rect2.X' rect2.Y + 1' rect2.Right' rect2.Y + 1);                            rect2.X -= margin / 2;                          rect2.Y += margin / 2;                            g.FillRectangle(s_genBrush' rect2);                          g.DrawRectangle(s_genPen' rect2);                          g.DrawLine(s_genPen' rect2.X' rect2.Y + 1' rect2.Right' rect2.Y + 1);                      }                    }                  else if (Id == HitTest.HTMINBUTTON)                  {                      s_genPen.Width = 2;                      g.DrawLine(s_genPen' rect.X' rect.Bottom' rect.Right' rect.Bottom);                  }
Magic Number,Sce.Atf.Applications,CustomCaptionButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,Draw,The following statement contains a magic number: if (Id == HitTest.HTCLOSE)                  {                      var smoothMode = g.SmoothingMode;                      g.SmoothingMode = SmoothingMode.AntiAlias;                      s_genPen.Width = 2.0f;                      g.DrawLine(s_genPen' rect.X' rect.Y' rect.Right' rect.Bottom);                      g.DrawLine(s_genPen' rect.Right' rect.Y' rect.X' rect.Bottom);                      g.SmoothingMode = smoothMode;                  }                  else if (Id == HitTest.HTMAXBUTTON)                  {                      s_genPen.Width = 1.0f;                      if (form.WindowState == FormWindowState.Normal)                      {                          g.DrawRectangle(s_genPen' rect);                          g.DrawLine(s_genPen' rect.X' rect.Y + 1' rect.Right' rect.Y + 1);                      }                      else                      {                          Rectangle rect2 = rect;                            rect2.X += margin / 2;                          rect2.Y -= margin / 2;                            g.DrawRectangle(s_genPen' rect2);                          g.DrawLine(s_genPen' rect2.X' rect2.Y + 1' rect2.Right' rect2.Y + 1);                            rect2.X -= margin / 2;                          rect2.Y += margin / 2;                            g.FillRectangle(s_genBrush' rect2);                          g.DrawRectangle(s_genPen' rect2);                          g.DrawLine(s_genPen' rect2.X' rect2.Y + 1' rect2.Right' rect2.Y + 1);                      }                    }                  else if (Id == HitTest.HTMINBUTTON)                  {                      s_genPen.Width = 2;                      g.DrawLine(s_genPen' rect.X' rect.Bottom' rect.Right' rect.Bottom);                  }
Magic Number,Sce.Atf.Applications,CustomCaptionButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,Draw,The following statement contains a magic number: if (Id == HitTest.HTCLOSE)                  {                      var smoothMode = g.SmoothingMode;                      g.SmoothingMode = SmoothingMode.AntiAlias;                      s_genPen.Width = 2.0f;                      g.DrawLine(s_genPen' rect.X' rect.Y' rect.Right' rect.Bottom);                      g.DrawLine(s_genPen' rect.Right' rect.Y' rect.X' rect.Bottom);                      g.SmoothingMode = smoothMode;                  }                  else if (Id == HitTest.HTMAXBUTTON)                  {                      s_genPen.Width = 1.0f;                      if (form.WindowState == FormWindowState.Normal)                      {                          g.DrawRectangle(s_genPen' rect);                          g.DrawLine(s_genPen' rect.X' rect.Y + 1' rect.Right' rect.Y + 1);                      }                      else                      {                          Rectangle rect2 = rect;                            rect2.X += margin / 2;                          rect2.Y -= margin / 2;                            g.DrawRectangle(s_genPen' rect2);                          g.DrawLine(s_genPen' rect2.X' rect2.Y + 1' rect2.Right' rect2.Y + 1);                            rect2.X -= margin / 2;                          rect2.Y += margin / 2;                            g.FillRectangle(s_genBrush' rect2);                          g.DrawRectangle(s_genPen' rect2);                          g.DrawLine(s_genPen' rect2.X' rect2.Y + 1' rect2.Right' rect2.Y + 1);                      }                    }                  else if (Id == HitTest.HTMINBUTTON)                  {                      s_genPen.Width = 2;                      g.DrawLine(s_genPen' rect.X' rect.Bottom' rect.Right' rect.Bottom);                  }
Magic Number,Sce.Atf.Applications,SkinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,Init,The following statement contains a magic number: fileMenu.Size = new System.Drawing.Size(37' 20);
Magic Number,Sce.Atf.Applications,SkinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,Init,The following statement contains a magic number: fileMenu.Size = new System.Drawing.Size(37' 20);
Magic Number,Sce.Atf.Applications,SkinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,Init,The following statement contains a magic number: m_treeControl.Width = 150;
Magic Number,Sce.Atf.Applications,SkinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,Init,The following statement contains a magic number: m_PropertyGrid.TabIndex = 3;
Magic Number,Sce.Atf.Applications,SkinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,Init,The following statement contains a magic number: splitter.SplitterDistance = 100;
Magic Number,Sce.Atf.Applications,SkinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,Init,The following statement contains a magic number: ClientSize = new System.Drawing.Size(600' 400);
Magic Number,Sce.Atf.Applications,SkinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,Init,The following statement contains a magic number: ClientSize = new System.Drawing.Size(600' 400);
Magic Number,Sce.Atf.Applications,SkinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinEditor.cs,Init,The following statement contains a magic number: splitter.SplitterDistance = 170;
Magic Number,Sce.Atf.Applications,StandardLayoutCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StandardLayoutCommands.cs,AlignCenters,The following statement contains a magic number: int boundsCenter = (bounds.Left + bounds.Right) / 2;
Magic Number,Sce.Atf.Applications,StandardLayoutCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StandardLayoutCommands.cs,AlignCenters,The following statement contains a magic number: foreach (object item in items)              {                  Rectangle itemBounds;                  layoutContext.GetBounds(item' out itemBounds);                  itemBounds.X = boundsCenter - itemBounds.Width / 2;                  layoutContext.SetBounds(item' itemBounds' BoundsSpecified.X);              }
Magic Number,Sce.Atf.Applications,StandardLayoutCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StandardLayoutCommands.cs,AlignMiddles,The following statement contains a magic number: int boundsMiddle = (bounds.Top + bounds.Bottom) / 2;
Magic Number,Sce.Atf.Applications,StandardLayoutCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StandardLayoutCommands.cs,AlignMiddles,The following statement contains a magic number: foreach (object item in items)              {                  Rectangle itemBounds;                  layoutContext.GetBounds(item' out itemBounds);                  itemBounds.Y = boundsMiddle - itemBounds.Height / 2;                  layoutContext.SetBounds(item' itemBounds' BoundsSpecified.Y);              }
Magic Number,Sce.Atf.Applications,StatusService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StatusService.cs,StatusService,The following statement contains a magic number: m_mainPanel.Width = 256;
Magic Number,Sce.Atf.Applications,StatusService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StatusService.cs,progressCallback,The following statement contains a magic number: lock (this)              {                  if (m_progress < 1.0)                  {                      if (!m_progressDialog.IsDialogVisible)                          m_progressDialog.Show();                      int percent = (int)(100 * m_progress);                      if (percent < 0)                          percent = 0;                      else if (percent > 100)                          percent = 100;                        m_progressDialog.Percent = percent;                      m_progress += m_autoIncrement;                  }                  else                  {                      EndProgress();                  }              }
Magic Number,Sce.Atf.Applications,StatusService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StatusService.cs,progressCallback,The following statement contains a magic number: lock (this)              {                  if (m_progress < 1.0)                  {                      if (!m_progressDialog.IsDialogVisible)                          m_progressDialog.Show();                      int percent = (int)(100 * m_progress);                      if (percent < 0)                          percent = 0;                      else if (percent > 100)                          percent = 100;                        m_progressDialog.Percent = percent;                      m_progress += m_autoIncrement;                  }                  else                  {                      EndProgress();                  }              }
Magic Number,Sce.Atf.Applications,StatusService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StatusService.cs,progressCallback,The following statement contains a magic number: lock (this)              {                  if (m_progress < 1.0)                  {                      if (!m_progressDialog.IsDialogVisible)                          m_progressDialog.Show();                      int percent = (int)(100 * m_progress);                      if (percent < 0)                          percent = 0;                      else if (percent > 100)                          percent = 100;                        m_progressDialog.Percent = percent;                      m_progress += m_autoIncrement;                  }                  else                  {                      EndProgress();                  }              }
Magic Number,Sce.Atf.Applications,StringSearchInputUI,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\StringSearchInputUI.cs,StringSearchInputUI,The following statement contains a magic number: dropDownButton.Size = new System.Drawing.Size(29' 22);
Magic Number,Sce.Atf.Applications,StringSearchInputUI,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\StringSearchInputUI.cs,StringSearchInputUI,The following statement contains a magic number: dropDownButton.Size = new System.Drawing.Size(29' 22);
Magic Number,Sce.Atf.Applications,StringSearchInputUI,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\StringSearchInputUI.cs,StringSearchInputUI,The following statement contains a magic number: clearSearchButton.Size = new System.Drawing.Size(29' 22);
Magic Number,Sce.Atf.Applications,StringSearchInputUI,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\StringSearchInputUI.cs,StringSearchInputUI,The following statement contains a magic number: clearSearchButton.Size = new System.Drawing.Size(29' 22);
Magic Number,Sce.Atf.Applications,StringSearchInputUI,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\StringSearchInputUI.cs,StringSearchInputUI,The following statement contains a magic number: m_patternTextBox.MaximumWidth = 1080;
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TargetEnumerationService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TargetEnumerationService.cs,SetUpTargetsView,The following statement contains a magic number: m_userControl = new UserControl { Margin = new Padding(3) };
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TargetEnumerationService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TargetEnumerationService.cs,UpdateTargetsView,The following statement contains a magic number: if (itemsToAdd.Count > 3)                  m_targets.AddRange(itemsToAdd);              else              {                  foreach (var item in itemsToAdd)                      m_targets.Add(item);              }
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TargetTcpSocket,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TargetTcpSocket.cs,Connect,The following statement contains a magic number: try              {                  lock (m_syncSocket)                  {                      IPAddress ipaddr = target.IPAddress;                      m_theSocket = new Socket(ipaddr.AddressFamily' SocketType.Stream' ProtocolType.Tcp);                      m_theSocket.Blocking = true;                      m_theSocket.SendTimeout = 5000;                        //m_theSocket.ExclusiveAddressUse = true;                      m_theSocket.BeginConnect(ipaddr'target.Port' m_connectClb'target);                      m_ConnectionInProgress = true;                  }                                }              catch (Exception ex)              {                  lock (m_syncSocket)                  {                      if (m_theSocket != null)                      {                          m_theSocket.Close();                          m_theSocket = null;                          m_curTarget = null;                      }                  }                  OnUnHandledException(ex);              }
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DataReadyHandler,The following statement contains a magic number: for (int i=0; i<buf.Length; i++)              {                  // Separate opcode' payload size' and payload                  if (m_numBytesReceivedThisCommand < 4)                  {                      m_opcodeBytes[m_numBytesReceivedThisCommand] = buf[i];                  }                  else if (m_numBytesReceivedThisCommand < 8)                  {                      m_payloadSizeBytes[m_numBytesReceivedThisCommand - 4] = buf[i];                  }                  else                  {                      m_payloadBytes[m_numBytesReceivedThisCommand - 8] = buf[i];                      m_payloadSizeThisCommand++;                  }                    m_numBytesReceivedThisCommand++;                    // Create the tcp command header if we have enough data                  if (m_numBytesReceivedThisCommand == 8)                  {                      DecodeInt(m_opcodeBytes'0'out m_tcpCommand.m_opcode);                      DecodeInt(m_payloadSizeBytes'0'out m_tcpCommand.m_payloadSize);                  }                    // If we have a fully formed command' dispatch it                  if (m_numBytesReceivedThisCommand == m_tcpCommand.m_payloadSize + 8)                  {                      CommandReadyHandler chr = CommandReady;                      if (chr != null)                      {                          m_tcpCommand.m_payload = m_payloadBytes;                          chr(this'm_tcpCommand);                      }                      m_numBytesReceivedThisCommand = 0;                      m_payloadSizeThisCommand = 0;                  }              }
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DataReadyHandler,The following statement contains a magic number: for (int i=0; i<buf.Length; i++)              {                  // Separate opcode' payload size' and payload                  if (m_numBytesReceivedThisCommand < 4)                  {                      m_opcodeBytes[m_numBytesReceivedThisCommand] = buf[i];                  }                  else if (m_numBytesReceivedThisCommand < 8)                  {                      m_payloadSizeBytes[m_numBytesReceivedThisCommand - 4] = buf[i];                  }                  else                  {                      m_payloadBytes[m_numBytesReceivedThisCommand - 8] = buf[i];                      m_payloadSizeThisCommand++;                  }                    m_numBytesReceivedThisCommand++;                    // Create the tcp command header if we have enough data                  if (m_numBytesReceivedThisCommand == 8)                  {                      DecodeInt(m_opcodeBytes'0'out m_tcpCommand.m_opcode);                      DecodeInt(m_payloadSizeBytes'0'out m_tcpCommand.m_payloadSize);                  }                    // If we have a fully formed command' dispatch it                  if (m_numBytesReceivedThisCommand == m_tcpCommand.m_payloadSize + 8)                  {                      CommandReadyHandler chr = CommandReady;                      if (chr != null)                      {                          m_tcpCommand.m_payload = m_payloadBytes;                          chr(this'm_tcpCommand);                      }                      m_numBytesReceivedThisCommand = 0;                      m_payloadSizeThisCommand = 0;                  }              }
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DataReadyHandler,The following statement contains a magic number: for (int i=0; i<buf.Length; i++)              {                  // Separate opcode' payload size' and payload                  if (m_numBytesReceivedThisCommand < 4)                  {                      m_opcodeBytes[m_numBytesReceivedThisCommand] = buf[i];                  }                  else if (m_numBytesReceivedThisCommand < 8)                  {                      m_payloadSizeBytes[m_numBytesReceivedThisCommand - 4] = buf[i];                  }                  else                  {                      m_payloadBytes[m_numBytesReceivedThisCommand - 8] = buf[i];                      m_payloadSizeThisCommand++;                  }                    m_numBytesReceivedThisCommand++;                    // Create the tcp command header if we have enough data                  if (m_numBytesReceivedThisCommand == 8)                  {                      DecodeInt(m_opcodeBytes'0'out m_tcpCommand.m_opcode);                      DecodeInt(m_payloadSizeBytes'0'out m_tcpCommand.m_payloadSize);                  }                    // If we have a fully formed command' dispatch it                  if (m_numBytesReceivedThisCommand == m_tcpCommand.m_payloadSize + 8)                  {                      CommandReadyHandler chr = CommandReady;                      if (chr != null)                      {                          m_tcpCommand.m_payload = m_payloadBytes;                          chr(this'm_tcpCommand);                      }                      m_numBytesReceivedThisCommand = 0;                      m_payloadSizeThisCommand = 0;                  }              }
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DataReadyHandler,The following statement contains a magic number: for (int i=0; i<buf.Length; i++)              {                  // Separate opcode' payload size' and payload                  if (m_numBytesReceivedThisCommand < 4)                  {                      m_opcodeBytes[m_numBytesReceivedThisCommand] = buf[i];                  }                  else if (m_numBytesReceivedThisCommand < 8)                  {                      m_payloadSizeBytes[m_numBytesReceivedThisCommand - 4] = buf[i];                  }                  else                  {                      m_payloadBytes[m_numBytesReceivedThisCommand - 8] = buf[i];                      m_payloadSizeThisCommand++;                  }                    m_numBytesReceivedThisCommand++;                    // Create the tcp command header if we have enough data                  if (m_numBytesReceivedThisCommand == 8)                  {                      DecodeInt(m_opcodeBytes'0'out m_tcpCommand.m_opcode);                      DecodeInt(m_payloadSizeBytes'0'out m_tcpCommand.m_payloadSize);                  }                    // If we have a fully formed command' dispatch it                  if (m_numBytesReceivedThisCommand == m_tcpCommand.m_payloadSize + 8)                  {                      CommandReadyHandler chr = CommandReady;                      if (chr != null)                      {                          m_tcpCommand.m_payload = m_payloadBytes;                          chr(this'm_tcpCommand);                      }                      m_numBytesReceivedThisCommand = 0;                      m_payloadSizeThisCommand = 0;                  }              }
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DataReadyHandler,The following statement contains a magic number: for (int i=0; i<buf.Length; i++)              {                  // Separate opcode' payload size' and payload                  if (m_numBytesReceivedThisCommand < 4)                  {                      m_opcodeBytes[m_numBytesReceivedThisCommand] = buf[i];                  }                  else if (m_numBytesReceivedThisCommand < 8)                  {                      m_payloadSizeBytes[m_numBytesReceivedThisCommand - 4] = buf[i];                  }                  else                  {                      m_payloadBytes[m_numBytesReceivedThisCommand - 8] = buf[i];                      m_payloadSizeThisCommand++;                  }                    m_numBytesReceivedThisCommand++;                    // Create the tcp command header if we have enough data                  if (m_numBytesReceivedThisCommand == 8)                  {                      DecodeInt(m_opcodeBytes'0'out m_tcpCommand.m_opcode);                      DecodeInt(m_payloadSizeBytes'0'out m_tcpCommand.m_payloadSize);                  }                    // If we have a fully formed command' dispatch it                  if (m_numBytesReceivedThisCommand == m_tcpCommand.m_payloadSize + 8)                  {                      CommandReadyHandler chr = CommandReady;                      if (chr != null)                      {                          m_tcpCommand.m_payload = m_payloadBytes;                          chr(this'm_tcpCommand);                      }                      m_numBytesReceivedThisCommand = 0;                      m_payloadSizeThisCommand = 0;                  }              }
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DataReadyHandler,The following statement contains a magic number: for (int i=0; i<buf.Length; i++)              {                  // Separate opcode' payload size' and payload                  if (m_numBytesReceivedThisCommand < 4)                  {                      m_opcodeBytes[m_numBytesReceivedThisCommand] = buf[i];                  }                  else if (m_numBytesReceivedThisCommand < 8)                  {                      m_payloadSizeBytes[m_numBytesReceivedThisCommand - 4] = buf[i];                  }                  else                  {                      m_payloadBytes[m_numBytesReceivedThisCommand - 8] = buf[i];                      m_payloadSizeThisCommand++;                  }                    m_numBytesReceivedThisCommand++;                    // Create the tcp command header if we have enough data                  if (m_numBytesReceivedThisCommand == 8)                  {                      DecodeInt(m_opcodeBytes'0'out m_tcpCommand.m_opcode);                      DecodeInt(m_payloadSizeBytes'0'out m_tcpCommand.m_payloadSize);                  }                    // If we have a fully formed command' dispatch it                  if (m_numBytesReceivedThisCommand == m_tcpCommand.m_payloadSize + 8)                  {                      CommandReadyHandler chr = CommandReady;                      if (chr != null)                      {                          m_tcpCommand.m_payload = m_payloadBytes;                          chr(this'm_tcpCommand);                      }                      m_numBytesReceivedThisCommand = 0;                      m_payloadSizeThisCommand = 0;                  }              }
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeInt,The following statement contains a magic number: byte[] temp = new byte[4];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeInt,The following statement contains a magic number: temp[0] = data[startIndex + 3];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeInt,The following statement contains a magic number: temp[1] = data[startIndex + 2];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeInt,The following statement contains a magic number: temp[2] = data[startIndex + 1];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeInt,The following statement contains a magic number: temp[3] = data[startIndex + 0];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeInt,The following statement contains a magic number: return 4;
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: byte[] temp = new byte[8];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[0] = data[startIndex + 7];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[1] = data[startIndex + 6];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[2] = data[startIndex + 5];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[2] = data[startIndex + 5];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[3] = data[startIndex + 4];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[3] = data[startIndex + 4];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[4] = data[startIndex + 3];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[4] = data[startIndex + 3];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[5] = data[startIndex + 2];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[5] = data[startIndex + 2];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[6] = data[startIndex + 1];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: temp[7] = data[startIndex + 0];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeUInt64,The following statement contains a magic number: return 8;
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeFloat,The following statement contains a magic number: byte[] temp = new byte[4];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeFloat,The following statement contains a magic number: temp[0] = data[startIndex + 3];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeFloat,The following statement contains a magic number: temp[1] = data[startIndex + 2];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeFloat,The following statement contains a magic number: temp[2] = data[startIndex + 1];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeFloat,The following statement contains a magic number: temp[3] = data[startIndex + 0];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeFloat,The following statement contains a magic number: return 4;
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,DecodeString,The following statement contains a magic number: return (strLen + 4);
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,EncodeInt,The following statement contains a magic number: byte[] retval = new byte[4];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,EncodeInt,The following statement contains a magic number: retval[0] = temp[3];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,EncodeInt,The following statement contains a magic number: retval[1] = temp[2];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,EncodeInt,The following statement contains a magic number: retval[2] = temp[1];
Magic Number,Sce.Atf.Applications.NetworkTargetServices,TcpCommandClient,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\NetworkTargetServices\TcpCommandClient.cs,EncodeInt,The following statement contains a magic number: retval[3] = temp[0];
Magic Number,Sce.Atf.Applications.WebServices,FeedbackForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\WebServices\FeedbackForm.cs,FeedbackForm,The following statement contains a magic number: m_cmbPriority.SelectedIndex = 2;
Magic Number,Sce.Atf.Applications.WebServices,VersionCheck,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\WebServices\VersionCheck.cs,DoCheck,The following statement contains a magic number: try              {                  if (s_checkInProgress)                      return;                  s_checkInProgress = true;                  com.scea.ship.versionCheck.VersionCheckerService checker = new com.scea.ship.versionCheck.VersionCheckerService();                  object[] versionInfo = checker.getLatestVersionInfo(m_appMappingName);                  string strServerVersion = ((string)versionInfo[0]).Trim();                  string[] arrStr = strServerVersion.Split(' ');                  m_serverVersion = new Version(arrStr[arrStr.Length - 1]);                    string url = null;                    if (m_serverVersion > m_appVersion)                  {                      url = ((string)versionInfo[2]).Trim();                  }                    NotifyClients(url' false);                }              catch (Exception e)              {                  NotifyClients("Version check failed.\nError: " + e.Message' true);              }              finally              {                  s_checkInProgress = false;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalGrid,The following statement contains a magic number: double yScale = transform.Elements[3];
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalGrid,The following statement contains a magic number: double yScale = transform.Elements[3];
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,LabelGrid,The following statement contains a magic number: double yScale = transform.Elements[3];
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,LabelGrid,The following statement contains a magic number: const int MIN_LABEL_SPACING = 96;
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,LabelGrid,The following statement contains a magic number: while (screenStep < MIN_LABEL_SPACING)              {                  screenStep *= 2;                  step *= 2;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,LabelGrid,The following statement contains a magic number: while (screenStep < MIN_LABEL_SPACING)              {                  screenStep *= 2;                  step *= 2;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalScaleGrid,The following statement contains a magic number: double yScale = transform.Elements[3];
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalScale,The following statement contains a magic number: if (top)              {                  tickEnd = clientRect.Top + 1;                  majorTickStart = tickEnd + 12;                  minorTickStart = tickEnd + 6;                  textStart = tickEnd + 8;              }              else              {                  tickEnd = clientRect.Bottom - 1;                  majorTickStart = tickEnd - 12;                  minorTickStart = tickEnd - 6;                  textStart = tickEnd - 19;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalScale,The following statement contains a magic number: if (top)              {                  tickEnd = clientRect.Top + 1;                  majorTickStart = tickEnd + 12;                  minorTickStart = tickEnd + 6;                  textStart = tickEnd + 8;              }              else              {                  tickEnd = clientRect.Bottom - 1;                  majorTickStart = tickEnd - 12;                  minorTickStart = tickEnd - 6;                  textStart = tickEnd - 19;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalScale,The following statement contains a magic number: if (top)              {                  tickEnd = clientRect.Top + 1;                  majorTickStart = tickEnd + 12;                  minorTickStart = tickEnd + 6;                  textStart = tickEnd + 8;              }              else              {                  tickEnd = clientRect.Bottom - 1;                  majorTickStart = tickEnd - 12;                  minorTickStart = tickEnd - 6;                  textStart = tickEnd - 19;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalScale,The following statement contains a magic number: if (top)              {                  tickEnd = clientRect.Top + 1;                  majorTickStart = tickEnd + 12;                  minorTickStart = tickEnd + 6;                  textStart = tickEnd + 8;              }              else              {                  tickEnd = clientRect.Bottom - 1;                  majorTickStart = tickEnd - 12;                  minorTickStart = tickEnd - 6;                  textStart = tickEnd - 19;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalScale,The following statement contains a magic number: if (top)              {                  tickEnd = clientRect.Top + 1;                  majorTickStart = tickEnd + 12;                  minorTickStart = tickEnd + 6;                  textStart = tickEnd + 8;              }              else              {                  tickEnd = clientRect.Bottom - 1;                  majorTickStart = tickEnd - 12;                  minorTickStart = tickEnd - 6;                  textStart = tickEnd - 19;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalScale,The following statement contains a magic number: if (top)              {                  tickEnd = clientRect.Top + 1;                  majorTickStart = tickEnd + 12;                  minorTickStart = tickEnd + 6;                  textStart = tickEnd + 8;              }              else              {                  tickEnd = clientRect.Bottom - 1;                  majorTickStart = tickEnd - 12;                  minorTickStart = tickEnd - 6;                  textStart = tickEnd - 19;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalScale,The following statement contains a magic number: int numMinorTicks = D2dUtil.CalculateNumMinorTicks(majorGraphStep' minimumGraphStep' 5);
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawHorizontalScale,The following statement contains a magic number: if (majorGraphStep > 0)              {                  double offset = tickAnchor - min;                  offset = offset - MathUtil.Remainder(offset' majorGraphStep);                    // draw leading minor ticks                  double cmx;                  cmx = ((tickAnchor - (offset + majorGraphStep)) - min) * xScale + clientRect.Left + cMinorStep;                  for (int i = 0; i < numMinorTicks - 1 && cmx < clientRect.Right; i++)                  {                      // cull minor ticks outside of the view                      if (cmx > clientRect.Left)                      {                          g.DrawLine(linePen' (float)cmx' (float)minorTickStart' (float)cmx' (float)tickEnd);                      }                      cmx += cMinorStep;                  }                                    for (double x = tickAnchor - offset; x < max; x += majorGraphStep)                  {                      double cx = (x - min) * xScale + clientRect.Left;                      g.DrawLine(linePen' (float)cx' (float)majorTickStart' (float)cx' (float)tickEnd);                      string xString = String.Format("{0:G8}"' Math.Round(x' 6));                      g.DrawString(xString' font' textBrush' (float)cx+1' (float)textStart);                        // draw minor ticks                      cmx = cx + cMinorStep;                      for (int i = 0; i < numMinorTicks - 1 && cmx < clientRect.Right; i++)                      {                          g.DrawLine(linePen' (float)cmx' (float)minorTickStart' (float)cmx' (float)tickEnd);                          cmx += cMinorStep;                      }                  }              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalScale,The following statement contains a magic number: double yScale = transform.Elements[3];
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalScale,The following statement contains a magic number: vertical.Rotate(90);
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalScale,The following statement contains a magic number: if (left)              {                  tickEnd = clientRect.Right - clientRect.X;                  minorTickStart = tickEnd - 6;                  textStart = tickEnd - 19;              }              else              {                  tickEnd = clientRect.Left + 1;                  minorTickStart = tickEnd + 6;                  textStart = tickEnd + 8;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalScale,The following statement contains a magic number: if (left)              {                  tickEnd = clientRect.Right - clientRect.X;                  minorTickStart = tickEnd - 6;                  textStart = tickEnd - 19;              }              else              {                  tickEnd = clientRect.Left + 1;                  minorTickStart = tickEnd + 6;                  textStart = tickEnd + 8;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalScale,The following statement contains a magic number: if (left)              {                  tickEnd = clientRect.Right - clientRect.X;                  minorTickStart = tickEnd - 6;                  textStart = tickEnd - 19;              }              else              {                  tickEnd = clientRect.Left + 1;                  minorTickStart = tickEnd + 6;                  textStart = tickEnd + 8;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalScale,The following statement contains a magic number: if (left)              {                  tickEnd = clientRect.Right - clientRect.X;                  minorTickStart = tickEnd - 6;                  textStart = tickEnd - 19;              }              else              {                  tickEnd = clientRect.Left + 1;                  minorTickStart = tickEnd + 6;                  textStart = tickEnd + 8;              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalScale,The following statement contains a magic number: int numMinorTicks = D2dUtil.CalculateNumMinorTicks(majorGraphStep' minimumGraphStep' 5);
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalScale,The following statement contains a magic number: if (majorGraphStep > 0)              {                  double offset = tickAnchor - min;                  offset = offset - MathUtil.Remainder(offset' majorGraphStep) + majorGraphStep;                  for (double x = tickAnchor - offset; x <= max; x += majorGraphStep)                  {                      double cx = (x - min) * yScale + clientRect.Left;                      //g.DrawLine(linePen' (float)cx' (float)majorTickStart' (float)cx' (float)tickEnd);                      // draw minor ticks                      double cmx = cx;                      for (int i = 0; i < numMinorTicks; i++)                      {                          cmx += cMinorStep;                          g.DrawLine(linePen' (float)cmx' (float)minorTickStart' (float)cmx' (float)tickEnd);                      }                      string xString = String.Format("{0:G8}"' Math.Round(x' 6));                      g.DrawString(xString' font' textBrush' (float)cx + 2' (float)textStart);                  }              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawVerticalScale,The following statement contains a magic number: if (majorGraphStep > 0)              {                  double offset = tickAnchor - min;                  offset = offset - MathUtil.Remainder(offset' majorGraphStep) + majorGraphStep;                  for (double x = tickAnchor - offset; x <= max; x += majorGraphStep)                  {                      double cx = (x - min) * yScale + clientRect.Left;                      //g.DrawLine(linePen' (float)cx' (float)majorTickStart' (float)cx' (float)tickEnd);                      // draw minor ticks                      double cmx = cx;                      for (int i = 0; i < numMinorTicks; i++)                      {                          cmx += cMinorStep;                          g.DrawLine(linePen' (float)cmx' (float)minorTickStart' (float)cmx' (float)tickEnd);                      }                      string xString = String.Format("{0:G8}"' Math.Round(x' 6));                      g.DrawString(xString' font' textBrush' (float)cx + 2' (float)textStart);                  }              }
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawXYLabel,The following statement contains a magic number: Rectangle box = new Rectangle(position.X + 8' position.Y + 8' (int)size.Width + 2' (int)size.Height + 2);
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawXYLabel,The following statement contains a magic number: Rectangle box = new Rectangle(position.X + 8' position.Y + 8' (int)size.Width + 2' (int)size.Height + 2);
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawXYLabel,The following statement contains a magic number: Rectangle box = new Rectangle(position.X + 8' position.Y + 8' (int)size.Width + 2' (int)size.Height + 2);
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,DrawXYLabel,The following statement contains a magic number: Rectangle box = new Rectangle(position.X + 8' position.Y + 8' (int)size.Width + 2' (int)size.Height + 2);
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,CreateFadedPen,The following statement contains a magic number: const int FADE_START = 64;
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,CreateFadedPen,The following statement contains a magic number: const int FADE_END = 4;
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,CreateFadedPen,The following statement contains a magic number: int alpha = (int)(255 * (screenStep - FADE_END) / (FADE_START - FADE_END));
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,ComputeOpacity,The following statement contains a magic number: const int FADE_START = 64;
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,ComputeOpacity,The following statement contains a magic number: const int FADE_END = 4;
Magic Number,Sce.Atf,ChartUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ChartUtil.cs,ComputeOpacity,The following statement contains a magic number: return (int )( 255 * (screenStep - FADE_END) / (FADE_START - FADE_END));
Magic Number,Sce.Atf,DropDescriptionHelper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\DragDrop\DropDescriptionHelper.cs,SetDropDescription,The following statement contains a magic number: if (format != null && format.Length > 259)                  throw new ArgumentException("Format string exceeds the maximum allowed length of 259."' "format");
Magic Number,Sce.Atf,DropDescriptionHelper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\DragDrop\DropDescriptionHelper.cs,SetDropDescription,The following statement contains a magic number: if (insert != null && insert.Length > 259)                  throw new ArgumentException("Insert string exceeds the maximum allowed length of 259."' "insert");
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,CreateIcon,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(square))              {                  int x' y' w' h; // dimensions for new image                    if (!keepAspectRatio || image.Height == image.Width)                  {                      // just fill the square                      x = y = 0; // set x and y to 0                      w = h = size; // set width and height to size                  }                  else                  {                      // work out the aspect ratio                      float r = (float)image.Width / (float)image.Height;                        // set dimensions accordingly to fit inside size^2 square                      if (r > 1)                      { // w is bigger' so divide h by r                          w = size;                          h = (int)((float)size / r);                          x = 0; y = (size - h) / 2; // center the image                      }                      else                      { // h is bigger' so multiply w by r                          w = (int)((float)size * r);                          h = size;                          y = 0; x = (size - w) / 2; // center the image                      }                  }                    // make the image shrink nicely by using HighQualityBicubic mode                  g.InterpolationMode = InterpolationMode.HighQualityBicubic;                  g.DrawImage(image' x' y' w' h); // draw image with specified dimensions              }
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,CreateIcon,The following statement contains a magic number: using (Graphics g = Graphics.FromImage(square))              {                  int x' y' w' h; // dimensions for new image                    if (!keepAspectRatio || image.Height == image.Width)                  {                      // just fill the square                      x = y = 0; // set x and y to 0                      w = h = size; // set width and height to size                  }                  else                  {                      // work out the aspect ratio                      float r = (float)image.Width / (float)image.Height;                        // set dimensions accordingly to fit inside size^2 square                      if (r > 1)                      { // w is bigger' so divide h by r                          w = size;                          h = (int)((float)size / r);                          x = 0; y = (size - h) / 2; // center the image                      }                      else                      { // h is bigger' so multiply w by r                          w = (int)((float)size * r);                          h = size;                          y = 0; x = (size - w) / 2; // center the image                      }                  }                    // make the image shrink nicely by using HighQualityBicubic mode                  g.InterpolationMode = InterpolationMode.HighQualityBicubic;                  g.DrawImage(image' x' y' w' h); // draw image with specified dimensions              }
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,MeasureDisplayString,The following statement contains a magic number: const int width = 32;
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,MeasureDisplayString,The following statement contains a magic number: using (var bitmap = new Bitmap(width' 1' graphics))              {                  SizeF size = graphics.MeasureString(text' font);                  using (Graphics anagra = Graphics.FromImage(bitmap))                  {                      int measured_width = (int)size.Width;                        anagra.Clear(Color.White);                      anagra.DrawString(text + "|"' font' Brushes.Black' width - measured_width' -font.Height / 2);                        for (int i = width - 1; i >= 0; i--)                      {                          measured_width--;                          if (bitmap.GetPixel(i' 0).R == 0)                          {                              break;                          }                      }                      return new SizeF(measured_width' size.Height);                  }              }
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,CreateLozengeImage,The following statement contains a magic number: int diameter = 2 * cornerRadius;
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawLozenge,The following statement contains a magic number: int cornerRadius = (lozengeImage.Width - ShadowSize) / 2;
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawLozenge,The following statement contains a magic number: g.DrawImage(lozengeImage'                  new Rectangle(bounds.Left + cornerRadius' bounds.Top' bounds.Width - 2 * cornerRadius' cornerRadius)'                  new Rectangle(cornerRadius' 0' 1' cornerRadius)' GraphicsUnit.Pixel);
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawLozenge,The following statement contains a magic number: g.DrawImage(lozengeImage'                  new Rectangle(bounds.Right - cornerRadius' bounds.Top + cornerRadius' cornerRadius + ShadowSize' bounds.Height - 2 * cornerRadius)'                  new Rectangle(cornerRadius' cornerRadius' cornerRadius + ShadowSize' 1)' GraphicsUnit.Pixel);
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawLozenge,The following statement contains a magic number: g.DrawImage(lozengeImage'                  new Rectangle(bounds.Left + cornerRadius' bounds.Bottom - cornerRadius' bounds.Width - 2 * cornerRadius' cornerRadius + ShadowSize)'                  new Rectangle(cornerRadius' cornerRadius' 1' cornerRadius + ShadowSize)' GraphicsUnit.Pixel);
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawLozenge,The following statement contains a magic number: g.DrawImage(lozengeImage'                  new Rectangle(bounds.Left' bounds.Top + cornerRadius' cornerRadius' bounds.Height - 2 * cornerRadius)'                  new Rectangle(0' cornerRadius' cornerRadius' 1)' GraphicsUnit.Pixel);
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawLozenge,The following statement contains a magic number: g.DrawImage(lozengeImage'                  new Rectangle(                      bounds.Left + cornerRadius - 1'                      bounds.Top + cornerRadius - 1'                      bounds.Width - 2 * cornerRadius + 1'                      bounds.Height - 2 * cornerRadius + 1)'                  new Rectangle(cornerRadius' cornerRadius' 1' 1)'                  GraphicsUnit.Pixel);
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawLozenge,The following statement contains a magic number: g.DrawImage(lozengeImage'                  new Rectangle(                      bounds.Left + cornerRadius - 1'                      bounds.Top + cornerRadius - 1'                      bounds.Width - 2 * cornerRadius + 1'                      bounds.Height - 2 * cornerRadius + 1)'                  new Rectangle(cornerRadius' cornerRadius' 1' 1)'                  GraphicsUnit.Pixel);
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawExpander,The following statement contains a magic number: if (expanded)              {                                  s_expanderPoints[1] = new Point(x + size' y + size);                  s_expanderPoints[2] = new Point(x + size' y);                              }              else              {                  s_expanderPoints[1] = new Point(x + size' y + size / 2);                  s_expanderPoints[2] = new Point(x' y);                          }
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawExpander,The following statement contains a magic number: if (expanded)              {                                  s_expanderPoints[1] = new Point(x + size' y + size);                  s_expanderPoints[2] = new Point(x + size' y);                              }              else              {                  s_expanderPoints[1] = new Point(x + size' y + size / 2);                  s_expanderPoints[2] = new Point(x' y);                          }
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawExpander,The following statement contains a magic number: if (expanded)              {                                  s_expanderPoints[1] = new Point(x + size' y + size);                  s_expanderPoints[2] = new Point(x + size' y);                              }              else              {                  s_expanderPoints[1] = new Point(x + size' y + size / 2);                  s_expanderPoints[2] = new Point(x' y);                          }
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawExpander,The following statement contains a magic number: if (expanded)              {                  s_expanderBrush.Color = pen.Color;                  s_expanderPoints[1] = new Point(x + size' y + size);                  s_expanderPoints[2] = new Point(x + size' y);                  g.FillPolygon(s_expanderBrush' s_expanderPoints);              }              else              {                  s_expanderPoints[1] = new Point(x + size' y + size / 2);                  s_expanderPoints[2] = new Point(x' y);                  g.DrawPolygon(pen' s_expanderPoints);              }
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawExpander,The following statement contains a magic number: if (expanded)              {                  s_expanderBrush.Color = pen.Color;                  s_expanderPoints[1] = new Point(x + size' y + size);                  s_expanderPoints[2] = new Point(x + size' y);                  g.FillPolygon(s_expanderBrush' s_expanderPoints);              }              else              {                  s_expanderPoints[1] = new Point(x + size' y + size / 2);                  s_expanderPoints[2] = new Point(x' y);                  g.DrawPolygon(pen' s_expanderPoints);              }
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawExpander,The following statement contains a magic number: if (expanded)              {                  s_expanderBrush.Color = pen.Color;                  s_expanderPoints[1] = new Point(x + size' y + size);                  s_expanderPoints[2] = new Point(x + size' y);                  g.FillPolygon(s_expanderBrush' s_expanderPoints);              }              else              {                  s_expanderPoints[1] = new Point(x + size' y + size / 2);                  s_expanderPoints[2] = new Point(x' y);                  g.DrawPolygon(pen' s_expanderPoints);              }
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawOfficeExpander,The following statement contains a magic number: int xMid = x + OfficeExpanderSize / 2;
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawOfficeExpander,The following statement contains a magic number: int yMid = y + OfficeExpanderSize / 2;
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawSortDirectionIndicator,The following statement contains a magic number: s_directionIndicatorPoints[2] = new Point(x + width / 2' y + height);
Magic Number,Sce.Atf,GdiUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\GdiUtil.cs,DrawSortDirectionIndicator,The following statement contains a magic number: s_directionIndicatorPoints[2] = new Point(x + width / 2' y + height);
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,RegisterImage,The following statement contains a magic number: if (image.Width == 13 && image.Height == 13)              {                  int keyIndex = s_images13.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images13.Images.Add(id' image);                  else                      s_images13.Images[keyIndex] = image;              }              else if (image.Width == 16 && image.Height == 16)              {                  int keyIndex = s_images16.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images16.Images.Add(id' image);                  else                      s_images16.Images[keyIndex] = image;              }              else if (image.Width == 24 && image.Height == 24)              {                  int keyIndex = s_images24.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images24.Images.Add(id' image);                  else                      s_images24.Images[keyIndex] = image;              }              else if (image.Width == 32 && image.Height == 32)              {                  int keyIndex = s_images32.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images32.Images.Add(id' image);                  else                      s_images32.Images[keyIndex] = image;              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,RegisterImage,The following statement contains a magic number: if (image.Width == 13 && image.Height == 13)              {                  int keyIndex = s_images13.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images13.Images.Add(id' image);                  else                      s_images13.Images[keyIndex] = image;              }              else if (image.Width == 16 && image.Height == 16)              {                  int keyIndex = s_images16.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images16.Images.Add(id' image);                  else                      s_images16.Images[keyIndex] = image;              }              else if (image.Width == 24 && image.Height == 24)              {                  int keyIndex = s_images24.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images24.Images.Add(id' image);                  else                      s_images24.Images[keyIndex] = image;              }              else if (image.Width == 32 && image.Height == 32)              {                  int keyIndex = s_images32.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images32.Images.Add(id' image);                  else                      s_images32.Images[keyIndex] = image;              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,RegisterImage,The following statement contains a magic number: if (image.Width == 13 && image.Height == 13)              {                  int keyIndex = s_images13.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images13.Images.Add(id' image);                  else                      s_images13.Images[keyIndex] = image;              }              else if (image.Width == 16 && image.Height == 16)              {                  int keyIndex = s_images16.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images16.Images.Add(id' image);                  else                      s_images16.Images[keyIndex] = image;              }              else if (image.Width == 24 && image.Height == 24)              {                  int keyIndex = s_images24.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images24.Images.Add(id' image);                  else                      s_images24.Images[keyIndex] = image;              }              else if (image.Width == 32 && image.Height == 32)              {                  int keyIndex = s_images32.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images32.Images.Add(id' image);                  else                      s_images32.Images[keyIndex] = image;              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,RegisterImage,The following statement contains a magic number: if (image.Width == 13 && image.Height == 13)              {                  int keyIndex = s_images13.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images13.Images.Add(id' image);                  else                      s_images13.Images[keyIndex] = image;              }              else if (image.Width == 16 && image.Height == 16)              {                  int keyIndex = s_images16.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images16.Images.Add(id' image);                  else                      s_images16.Images[keyIndex] = image;              }              else if (image.Width == 24 && image.Height == 24)              {                  int keyIndex = s_images24.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images24.Images.Add(id' image);                  else                      s_images24.Images[keyIndex] = image;              }              else if (image.Width == 32 && image.Height == 32)              {                  int keyIndex = s_images32.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images32.Images.Add(id' image);                  else                      s_images32.Images[keyIndex] = image;              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,RegisterImage,The following statement contains a magic number: if (image.Width == 13 && image.Height == 13)              {                  int keyIndex = s_images13.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images13.Images.Add(id' image);                  else                      s_images13.Images[keyIndex] = image;              }              else if (image.Width == 16 && image.Height == 16)              {                  int keyIndex = s_images16.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images16.Images.Add(id' image);                  else                      s_images16.Images[keyIndex] = image;              }              else if (image.Width == 24 && image.Height == 24)              {                  int keyIndex = s_images24.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images24.Images.Add(id' image);                  else                      s_images24.Images[keyIndex] = image;              }              else if (image.Width == 32 && image.Height == 32)              {                  int keyIndex = s_images32.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images32.Images.Add(id' image);                  else                      s_images32.Images[keyIndex] = image;              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,RegisterImage,The following statement contains a magic number: if (image.Width == 13 && image.Height == 13)              {                  int keyIndex = s_images13.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images13.Images.Add(id' image);                  else                      s_images13.Images[keyIndex] = image;              }              else if (image.Width == 16 && image.Height == 16)              {                  int keyIndex = s_images16.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images16.Images.Add(id' image);                  else                      s_images16.Images[keyIndex] = image;              }              else if (image.Width == 24 && image.Height == 24)              {                  int keyIndex = s_images24.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images24.Images.Add(id' image);                  else                      s_images24.Images[keyIndex] = image;              }              else if (image.Width == 32 && image.Height == 32)              {                  int keyIndex = s_images32.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images32.Images.Add(id' image);                  else                      s_images32.Images[keyIndex] = image;              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,RegisterImage,The following statement contains a magic number: if (image.Width == 13 && image.Height == 13)              {                  int keyIndex = s_images13.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images13.Images.Add(id' image);                  else                      s_images13.Images[keyIndex] = image;              }              else if (image.Width == 16 && image.Height == 16)              {                  int keyIndex = s_images16.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images16.Images.Add(id' image);                  else                      s_images16.Images[keyIndex] = image;              }              else if (image.Width == 24 && image.Height == 24)              {                  int keyIndex = s_images24.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images24.Images.Add(id' image);                  else                      s_images24.Images[keyIndex] = image;              }              else if (image.Width == 32 && image.Height == 32)              {                  int keyIndex = s_images32.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images32.Images.Add(id' image);                  else                      s_images32.Images[keyIndex] = image;              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,RegisterImage,The following statement contains a magic number: if (image.Width == 13 && image.Height == 13)              {                  int keyIndex = s_images13.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images13.Images.Add(id' image);                  else                      s_images13.Images[keyIndex] = image;              }              else if (image.Width == 16 && image.Height == 16)              {                  int keyIndex = s_images16.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images16.Images.Add(id' image);                  else                      s_images16.Images[keyIndex] = image;              }              else if (image.Width == 24 && image.Height == 24)              {                  int keyIndex = s_images24.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images24.Images.Add(id' image);                  else                      s_images24.Images[keyIndex] = image;              }              else if (image.Width == 32 && image.Height == 32)              {                  int keyIndex = s_images32.Images.IndexOfKey(id);                  if (keyIndex == -1)                      s_images32.Images.Add(id' image);                  else                      s_images32.Images[keyIndex] = image;              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,RegisterImage,The following statement contains a magic number: if (image16 != null)              {                  image16 = GdiUtil.ResizeImage(image16' 16);                  s_images16.Images.Add(id' image16);                  bestImage = image16;              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,RegisterImage,The following statement contains a magic number: if (image24 != null)              {                  image24 = GdiUtil.ResizeImage(image24' 24);                  s_images24.Images.Add(id' image24);                  bestImage = image24;              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,RegisterImage,The following statement contains a magic number: if (image32 != null)              {                  image32 = GdiUtil.ResizeImage(image32' 32);                  s_images32.Images.Add(id' image32);                  bestImage = image32;              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,GetImage13,The following statement contains a magic number: if (image == null)              {                  image = GetImage(id);                  if (image != null)                      image = GdiUtil.ResizeImage(image' 13);              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,GetImage16,The following statement contains a magic number: if (image == null)              {                  image = GetImage(id);                  if (image != null)                      image = GdiUtil.ResizeImage(image' 16);              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,GetImage24,The following statement contains a magic number: if (image == null)              {                  image = GetImage(id);                  if (image != null)                      image = GdiUtil.ResizeImage(image' 24);              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,GetImage32,The following statement contains a magic number: if (image == null)              {                  image = GetImage(id);                  if (image != null)                      image = GdiUtil.ResizeImage(image' 32);              }
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,ResourceUtil,The following statement contains a magic number: s_images13.ImageSize = new Size(13' 13);
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,ResourceUtil,The following statement contains a magic number: s_images13.ImageSize = new Size(13' 13);
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,ResourceUtil,The following statement contains a magic number: s_images16.ImageSize = new Size(16' 16);
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,ResourceUtil,The following statement contains a magic number: s_images16.ImageSize = new Size(16' 16);
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,ResourceUtil,The following statement contains a magic number: s_images24.ImageSize = new Size(24' 24);
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,ResourceUtil,The following statement contains a magic number: s_images24.ImageSize = new Size(24' 24);
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,ResourceUtil,The following statement contains a magic number: s_images32.ImageSize = new Size(32' 32);
Magic Number,Sce.Atf,ResourceUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\ResourceUtil.cs,ResourceUtil,The following statement contains a magic number: s_images32.ImageSize = new Size(32' 32);
Magic Number,Sce.Atf,WinFormsUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\WinFormsUtil.cs,UpdateScrollbars,The following statement contains a magic number: if (vScrollBar != null)              {                  if (numPixelsOffScreenY > 0)                  {                      visibleArea.Width -= vScrollBar.Width;                      canvas = Rectangle.Union(visibleArea' contentArea);                      numPixelsOffScreenX = Math.Max(0' canvas.Width - visibleArea.Width);                        vScrollBar.Visible = true;                        vScrollBar.LargeChange = Math.Max(visibleArea.Height' 1);                      vScrollBar.SmallChange = Math.Max(1' vScrollBar.LargeChange / 10);                      vScrollBar.Minimum = canvas.Top;                      vScrollBar.Maximum = canvas.Bottom;                  }                  else                  {                      vScrollBar.Visible = false;                  }              }
Magic Number,Sce.Atf,WinFormsUtil,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\WinFormsUtil.cs,UpdateScrollbars,The following statement contains a magic number: if (hScrollBar != null)              {                  if (numPixelsOffScreenX > 0)                  {                      hScrollBar.Visible = true;                        hScrollBar.LargeChange = Math.Max(visibleArea.Width' 1);                      hScrollBar.SmallChange = Math.Max(1' hScrollBar.LargeChange / 10);                      hScrollBar.Minimum = canvas.Left;                      hScrollBar.Maximum = canvas.Right;                  }                  else                  {                      hScrollBar.Visible = false;                  }              }
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,CanvasControl,The following statement contains a magic number: m_autoScrollTimer.Interval = 10;
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,Frame,The following statement contains a magic number: Point clientCenter = new Point(                  (int)(clientRect.Left + clientRect.Width / 2)'                  (int)(clientRect.Top + clientRect.Height / 2));
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,Frame,The following statement contains a magic number: Point clientCenter = new Point(                  (int)(clientRect.Left + clientRect.Width / 2)'                  (int)(clientRect.Top + clientRect.Height / 2));
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,Frame,The following statement contains a magic number: Point canvasCenter = new Point(                  (int)(targetCanvasRect.Left + targetCanvasRect.Width / 2)'                  (int)(targetCanvasRect.Top + targetCanvasRect.Height / 2));
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,Frame,The following statement contains a magic number: Point canvasCenter = new Point(                  (int)(targetCanvasRect.Left + targetCanvasRect.Width / 2)'                  (int)(targetCanvasRect.Top + targetCanvasRect.Height / 2));
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,OnMouseMove,The following statement contains a magic number: if (m_dragOverThreshold)              {                  Point delta = DragDelta;                    // auto scroll if mouse is outside control                  if (m_autoScroll && !VisibleClientRectangle.Contains(m_currentPoint) && !m_autoScrollTimer.Enabled)                      m_autoScrollTimer.Start();                    if (m_isMultiSelecting && DrawSelectionRectangleUsingGdi)                  {                      Rectangle rect = MakeSelectionRect(LastMouseDragPoint' FirstMouseDragPoint);                      ControlPaint.DrawReversibleFrame(rect' BackColor' FrameStyle.Dashed);                        rect = MakeSelectionRect(CurrentMouseDragPoint' FirstMouseDragPoint);                      ControlPaint.DrawReversibleFrame(rect' BackColor' FrameStyle.Dashed);                  }                  else if (m_isScrolling)                  {                      ScrollPosition = new Point(                          m_autoScrollPositionStart.X + delta.X'                          m_autoScrollPositionStart.Y + delta.Y);                  }                  else if (m_isZooming)                  {                        float xScale = 1 + 2 * delta.X / (float)Width;                      float yScale = 1 + 2 * delta.Y / (float)Height;                        if (m_constrain || UniformZoom)                          xScale = yScale = Math.Max(xScale' yScale);                        SetZoom(m_xZoomStart * xScale' m_yZoomStart * yScale);                        ScrollPosition = new Point((int)(m_firstPoint.X - m_zoomCenterStart.X * m_xZoom)'                          (int)(m_firstPoint.Y - m_zoomCenterStart.Y * m_yZoom));                  }              }
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,OnMouseMove,The following statement contains a magic number: if (m_dragOverThreshold)              {                  Point delta = DragDelta;                    // auto scroll if mouse is outside control                  if (m_autoScroll && !VisibleClientRectangle.Contains(m_currentPoint) && !m_autoScrollTimer.Enabled)                      m_autoScrollTimer.Start();                    if (m_isMultiSelecting && DrawSelectionRectangleUsingGdi)                  {                      Rectangle rect = MakeSelectionRect(LastMouseDragPoint' FirstMouseDragPoint);                      ControlPaint.DrawReversibleFrame(rect' BackColor' FrameStyle.Dashed);                        rect = MakeSelectionRect(CurrentMouseDragPoint' FirstMouseDragPoint);                      ControlPaint.DrawReversibleFrame(rect' BackColor' FrameStyle.Dashed);                  }                  else if (m_isScrolling)                  {                      ScrollPosition = new Point(                          m_autoScrollPositionStart.X + delta.X'                          m_autoScrollPositionStart.Y + delta.Y);                  }                  else if (m_isZooming)                  {                        float xScale = 1 + 2 * delta.X / (float)Width;                      float yScale = 1 + 2 * delta.Y / (float)Height;                        if (m_constrain || UniformZoom)                          xScale = yScale = Math.Max(xScale' yScale);                        SetZoom(m_xZoomStart * xScale' m_yZoomStart * yScale);                        ScrollPosition = new Point((int)(m_firstPoint.X - m_zoomCenterStart.X * m_xZoom)'                          (int)(m_firstPoint.Y - m_zoomCenterStart.Y * m_yZoom));                  }              }
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,autoScrollTimer_Tick,The following statement contains a magic number: if (!VisibleClientRectangle.Contains(m_currentPoint))              {                  if (m_isMultiSelecting && DrawSelectionRectangleUsingGdi)                  {                      Rectangle selectionRect = MakeSelectionRect(m_currentPoint' m_firstPoint);                      ControlPaint.DrawReversibleFrame(selectionRect' BackColor' FrameStyle.Dashed);                  }                    const int autoScrollSpeed = 10;                  Rectangle visibleRect = VisibleClientRectangle;                  Point scroll = m_scroll;                  if (m_currentPoint.X < 0)                      scroll.X += autoScrollSpeed;                  else if (m_currentPoint.X > visibleRect.Width)                      scroll.X -= autoScrollSpeed;                  if (m_currentPoint.Y < 0)                      scroll.Y += autoScrollSpeed;                  else if (m_currentPoint.Y > visibleRect.Height)                      scroll.Y -= autoScrollSpeed;                  Point diff = m_scroll;                    ScrollPosition = new Point(scroll.X' scroll.Y);                    diff.X = m_scroll.X - diff.X;                  diff.Y = m_scroll.Y - diff.Y;                    // adjust mouse positions                  m_firstPoint.X += diff.X;                  m_firstPoint.Y += diff.Y;                  m_last = m_currentPoint;                    OnAutoScroll();                  base.Update(); // without this' the selection rect doesn't draw correctly                    if (m_isMultiSelecting && DrawSelectionRectangleUsingGdi)                  {                      Rectangle rect = MakeSelectionRect(m_currentPoint' m_firstPoint);                      ControlPaint.DrawReversibleFrame(rect' BackColor' FrameStyle.Dashed);                  }                  m_autoScrollTimer.Start();              }
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,ZoomAboutCenter,The following statement contains a magic number: PointF zoomCenter = new PointF(                  (float)(m_scroll.X - Width / 2) / (float)m_canvasSize.Width'                  (float)(m_scroll.Y - Height / 2) / (float)m_canvasSize.Height);
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,ZoomAboutCenter,The following statement contains a magic number: PointF zoomCenter = new PointF(                  (float)(m_scroll.X - Width / 2) / (float)m_canvasSize.Width'                  (float)(m_scroll.Y - Height / 2) / (float)m_canvasSize.Height);
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,ZoomAboutCenter,The following statement contains a magic number: ScrollPosition = new Point(                  (int)(-zoomCenter.X * m_canvasSize.Width - Width / 2)'                  (int)(-zoomCenter.Y * m_canvasSize.Height - Height / 2));
Magic Number,Sce.Atf.Controls,CanvasControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CanvasControl.cs,ZoomAboutCenter,The following statement contains a magic number: ScrollPosition = new Point(                  (int)(-zoomCenter.X * m_canvasSize.Width - Width / 2)'                  (int)(-zoomCenter.Y * m_canvasSize.Height - Height / 2));
Magic Number,Sce.Atf.Controls,CustomizeKeyboardDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CustomizeKeyboardDialog.cs,btnAllDefault_Click,The following statement contains a magic number: if (numCommandsToReset > 0)              {                  if (numCommandsToReset < 10)                  {                      message.Insert(0'                          "These commands currently do not use their default shortcuts:".Localize()                          + Environment.NewLine);                  }                  else                  {                      message.Length = 0;                      message.Append(                          string.Format("{0} commands currently do not use their default shortcuts.".Localize("{0} is a number")'                          numCommandsToReset));                  }                    if (MessageBox.Show(this' message.ToString()'                      "Reset all commands to the default shortcuts?".Localize()'                      MessageBoxButtons.OKCancel)                      == DialogResult.OK)                  {                      foreach (Shortcut shortcut in m_shortcuts)                          shortcut.Keys = shortcut.Info.DefaultShortcuts;                  }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,DataBoundListView,The following statement contains a magic number: ColumnHeaderSeparatorColor = Color.FromArgb(228' 229' 230);
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,DataBoundListView,The following statement contains a magic number: ColumnHeaderSeparatorColor = Color.FromArgb(228' 229' 230);
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,DataBoundListView,The following statement contains a magic number: ColumnHeaderSeparatorColor = Color.FromArgb(228' 229' 230);
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,listView_ColumnWidthChanged,The following statement contains a magic number: if (!m_adjustingColumnWidths)              {                  m_autoColumnWidth = false; // user manually resizes column                  if (m_lastNewWidth > 0 && Math.Abs(m_lastNewWidth - Columns[e.ColumnIndex].Width) > 100) // avoid snapping                       Columns[e.ColumnIndex].Width = m_lastNewWidth;              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,listView_ColumnWidthChanging,The following statement contains a magic number: if (!m_adjustingColumnWidths)              {                  m_lastNewWidth = e.NewWidth;                  // ensure minimum width to render header text +  sorting arrow                  using (Graphics g = CreateGraphics())                  {                      float wMin = g.MeasureString(Columns[e.ColumnIndex].Text' HeaderFont).Width +                                   s_sortAscendingImage.Width + 8 +2;                      if (e.ColumnIndex ==0 && CheckBoxes)                          wMin += CheckBoxWidth + 2;                      if (e.NewWidth < wMin)                      {                          e.Cancel = true;                          e.NewWidth = (int)wMin;                        }                  }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,listView_ColumnWidthChanging,The following statement contains a magic number: if (!m_adjustingColumnWidths)              {                  m_lastNewWidth = e.NewWidth;                  // ensure minimum width to render header text +  sorting arrow                  using (Graphics g = CreateGraphics())                  {                      float wMin = g.MeasureString(Columns[e.ColumnIndex].Text' HeaderFont).Width +                                   s_sortAscendingImage.Width + 8 +2;                      if (e.ColumnIndex ==0 && CheckBoxes)                          wMin += CheckBoxWidth + 2;                      if (e.NewWidth < wMin)                      {                          e.Cancel = true;                          e.NewWidth = (int)wMin;                        }                  }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,listView_ColumnWidthChanging,The following statement contains a magic number: if (!m_adjustingColumnWidths)              {                  m_lastNewWidth = e.NewWidth;                  // ensure minimum width to render header text +  sorting arrow                  using (Graphics g = CreateGraphics())                  {                      float wMin = g.MeasureString(Columns[e.ColumnIndex].Text' HeaderFont).Width +                                   s_sortAscendingImage.Width + 8 +2;                      if (e.ColumnIndex ==0 && CheckBoxes)                          wMin += CheckBoxWidth + 2;                      if (e.NewWidth < wMin)                      {                          e.Cancel = true;                          e.NewWidth = (int)wMin;                        }                  }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawItem,The following statement contains a magic number: if (AlternatingRowColors)// && e.ItemIndex == Items.Count - 1)              {                  var lastRowBound = new Rectangle();                  int rowIndex = 0;                  if (Items.Count > 0 )                  {                      if (Items[Items.Count - 1] == null || Items[0] == null)                          return;                      lastRowBound = Items[Items.Count - 1].Bounds;                      var lastSubItemBound = Items[0].SubItems[Items[0].SubItems.Count - 1].Bounds;                      m_rowHeight = lastRowBound.Height;                        if (lastSubItemBound.Right < ClientRectangle.Width) // fill the width(right of rows)                      {                          var rect = new Rectangle(lastSubItemBound.Right' Items[0].Bounds.Top'                                                   ClientRectangle.Width - lastSubItemBound.Right' m_rowHeight);                          while (rect.Y < lastRowBound.Bottom)                          {                              if (Enabled && SelectedIndices.Contains(rowIndex))                              {                                  e.Graphics.FillRectangle(m_highlightBackBrush' rect);                                }                              else                              {                                  if (rowIndex%2 == 0)                                      e.Graphics.FillRectangle(m_alternatingRowBrush1' rect);                                  else                                      e.Graphics.FillRectangle(m_alternatingRowBrush2' rect);                              }                                ++rowIndex;                              rect.Y += m_rowHeight;                          }                      }                      rowIndex = Items.Count;                  }                  else                      lastRowBound.Y = HeaderHeight;                    // fill the bottom                  if (lastRowBound.Top + lastRowBound.Height < ClientRectangle.Height)                  {                        var rect = new Rectangle(0' lastRowBound.Bottom' ClientRectangle.Width' m_rowHeight);                      while (rect.Y < ClientRectangle.Bottom)                      {                          if (rowIndex%2 == 0)                              e.Graphics.FillRectangle(m_alternatingRowBrush1' rect);                          else                              e.Graphics.FillRectangle(m_alternatingRowBrush2' rect);                            ++rowIndex;                          rect.Y += m_rowHeight;                      }                  }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawItem,The following statement contains a magic number: if (AlternatingRowColors)// && e.ItemIndex == Items.Count - 1)              {                  var lastRowBound = new Rectangle();                  int rowIndex = 0;                  if (Items.Count > 0 )                  {                      if (Items[Items.Count - 1] == null || Items[0] == null)                          return;                      lastRowBound = Items[Items.Count - 1].Bounds;                      var lastSubItemBound = Items[0].SubItems[Items[0].SubItems.Count - 1].Bounds;                      m_rowHeight = lastRowBound.Height;                        if (lastSubItemBound.Right < ClientRectangle.Width) // fill the width(right of rows)                      {                          var rect = new Rectangle(lastSubItemBound.Right' Items[0].Bounds.Top'                                                   ClientRectangle.Width - lastSubItemBound.Right' m_rowHeight);                          while (rect.Y < lastRowBound.Bottom)                          {                              if (Enabled && SelectedIndices.Contains(rowIndex))                              {                                  e.Graphics.FillRectangle(m_highlightBackBrush' rect);                                }                              else                              {                                  if (rowIndex%2 == 0)                                      e.Graphics.FillRectangle(m_alternatingRowBrush1' rect);                                  else                                      e.Graphics.FillRectangle(m_alternatingRowBrush2' rect);                              }                                ++rowIndex;                              rect.Y += m_rowHeight;                          }                      }                      rowIndex = Items.Count;                  }                  else                      lastRowBound.Y = HeaderHeight;                    // fill the bottom                  if (lastRowBound.Top + lastRowBound.Height < ClientRectangle.Height)                  {                        var rect = new Rectangle(0' lastRowBound.Bottom' ClientRectangle.Width' m_rowHeight);                      while (rect.Y < ClientRectangle.Bottom)                      {                          if (rowIndex%2 == 0)                              e.Graphics.FillRectangle(m_alternatingRowBrush1' rect);                          else                              e.Graphics.FillRectangle(m_alternatingRowBrush2' rect);                            ++rowIndex;                          rect.Y += m_rowHeight;                      }                  }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawSubItem,The following statement contains a magic number: if (CheckBoxes && e.ColumnIndex == 0)              {                  if (e.Item.Selected && Enabled)                  {                      e.Graphics.FillRectangle(m_highlightBackBrush' e.Bounds);                  }                  else                  {                      if (AlternatingRowColors)                      {                          if (e.ItemIndex % 2 == 0)                              e.Graphics.FillRectangle(m_alternatingRowBrush1' e.Bounds);                          else                              e.Graphics.FillRectangle(m_alternatingRowBrush2' e.Bounds);                      }                      else                           e.Graphics.FillRectangle(m_defaultBackBrush' e.Bounds);                  }                    DrawCheckBox(e);                    var rect = e.Bounds;                  rect.X += CheckBoxWidth + TextOffset;                  rect.Width -= CheckBoxWidth + TextOffset;                                    // Draw the subitem text                  var font = e.Item.Checked ? m_boldFont : Font;                                   using (StringFormat sf = new StringFormat(StringFormatFlags.LineLimit))                  {                      // Store the column text alignment' letting it default                      // to Left if it has not been set to Center or Right.                      switch (e.Header.TextAlign)                      {                          case HorizontalAlignment.Center:                              sf.Alignment = StringAlignment.Center;                              break;                          case HorizontalAlignment.Right:                              sf.Alignment = StringAlignment.Far;                              break;                      }                      if (IsCellReadOnly(e.ItemIndex' e.ColumnIndex))                      {                          var brush = e.Item.Selected ? m_highlightTextBrush : m_readOnlyBrush;                          if (!Enabled)                              brush = m_readOnlyBrush;                          e.Graphics.DrawString(e.SubItem.Text' font' brush' rect' sf);                      }                      else if (IsCellExternalEditor(e.ItemIndex' e.ColumnIndex))                      {                          var brush = e.Item.Selected ? m_highlightTextBrush : m_externalEditorBrush;                          if (!Enabled)                              brush = m_readOnlyBrush;                          e.Graphics.DrawString(e.SubItem.Text' font' brush' rect' sf);                      }                      else                      {                          var brush = e.Item.Selected ? m_highlightTextBrush : m_normalTextBrush;                          if (!Enabled)                              brush = m_readOnlyBrush;                          e.Graphics.DrawString(e.SubItem.Text' font' brush' rect' sf);                                               }                  }                  return;                }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawSubItem,The following statement contains a magic number: using (StringFormat sf = new StringFormat(StringFormatFlags.LineLimit))              {                  // Store the column text alignment' letting it default                  // to Left if it has not been set to Center or Right.                  switch (e.Header.TextAlign)                  {                      case HorizontalAlignment.Center:                          sf.Alignment = StringAlignment.Center;                          break;                      case HorizontalAlignment.Right:                          sf.Alignment = StringAlignment.Far;                          break;                  }                      // Draw normal text for a subitem                   if (e.Item.Selected && Enabled)                  {                      e.Graphics.FillRectangle(SystemBrushes.Highlight' e.Bounds);                  }                  else                  {                      if (e.ItemIndex % 2 == 0)                          e.Graphics.FillRectangle(m_alternatingRowBrush1' e.Bounds);                      else                          e.Graphics.FillRectangle(m_alternatingRowBrush2' e.Bounds);                  }                    // Draw the subitem text                  var font = e.Item.Checked ? m_boldFont : Font;                  if (IsCellReadOnly(e.ItemIndex' e.ColumnIndex))                  {                       var brush = e.Item.Selected ? m_highlightTextBrush : m_readOnlyBrush;                       if (!Enabled)                           brush = m_readOnlyBrush;                       e.Graphics.DrawString(e.SubItem.Text' font' brush' bound' sf);                  }                  else if (IsCellExternalEditor(e.ItemIndex' e.ColumnIndex))                  {                      var brush = e.Item.Selected ? m_highlightTextBrush : m_externalEditorBrush;                      if (!Enabled)                          brush = m_readOnlyBrush;                      e.Graphics.DrawString(e.SubItem.Text' font' brush' bound' sf);                  }                  else                  {                      var brush = e.Item.Selected ? m_highlightTextBrush : m_normalTextBrush;                      if (!Enabled)                          brush = m_readOnlyBrush;                      e.Graphics.DrawString(e.SubItem.Text' font' brush' bound' sf);                                      }                }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawColumnHeader,The following statement contains a magic number: using (StringFormat sf = new StringFormat())              {                  // Store the column text alignment' letting it default                  // to Left if it has not been set to Center or Right.                  switch (e.Header.TextAlign)                  {                      case HorizontalAlignment.Center:                          sf.Alignment = StringAlignment.Center;                          break;                      case HorizontalAlignment.Right:                          sf.Alignment = StringAlignment.Far;                          break;                  }                      // Draw the standard header background.                  e.DrawBackground();                                                    // Draw the header text.                  var bound = e.Bounds;                  bound.Y += 3;                  bound.X += 8;                  if (e.ColumnIndex == 0)                      bound.X += CheckBoxWidth;                    var brush = Enabled ? m_columnHeaderTextBrush : m_columnHeaderTextBrushDisabled;                  e.Graphics.DrawString(e.Header.Text' HeaderFont' brush' bound' sf);                      if (e.ColumnIndex == m_sortColumn) // Draw sort arrow                  {                      float w = e.Graphics.MeasureString(e.Header.Text' HeaderFont).Width;                      if (m_sortColumn == 0)                          w += CheckBoxWidth + 2;                       if (e.Bounds.Width > w + s_sortAscendingImage.Width + 8) // get enough room left for the arrow icon                      {                          Point pt = new Point(e.Bounds.Location.X + e.Bounds.Width - s_sortAscendingImage.Width - 4'                          e.Bounds.Top + (e.Bounds.Height - s_sortAscendingImage.Height) / 2);                          if (m_sortDirection == ListSortDirection.Ascending)                              e.Graphics.DrawImage(s_sortAscendingImage' pt);                          else                              e.Graphics.DrawImage(s_sortDescendingImage' pt);                      }                  }                    if (CheckBoxes && e.ColumnIndex ==0)                  {                      // draw check mark                      Point pt = new Point(e.Bounds.Location.X' e.Bounds.Top + 3);                      e.Graphics.DrawString(m_tickSymbol' m_tickFont' Enabled ? m_columnHeaderCheckMarkBrush : m_columnHeaderCheckMarkBrushDisabled' pt);                                           // draw a vertical line to make check mark appear in its own column                                       e.Graphics.DrawLine(m_columnHeaderSeparatorPen' CheckBoxWidth' e.Bounds.Top'                          CheckBoxWidth' e.Bounds.Bottom - 2);                                       }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawColumnHeader,The following statement contains a magic number: using (StringFormat sf = new StringFormat())              {                  // Store the column text alignment' letting it default                  // to Left if it has not been set to Center or Right.                  switch (e.Header.TextAlign)                  {                      case HorizontalAlignment.Center:                          sf.Alignment = StringAlignment.Center;                          break;                      case HorizontalAlignment.Right:                          sf.Alignment = StringAlignment.Far;                          break;                  }                      // Draw the standard header background.                  e.DrawBackground();                                                    // Draw the header text.                  var bound = e.Bounds;                  bound.Y += 3;                  bound.X += 8;                  if (e.ColumnIndex == 0)                      bound.X += CheckBoxWidth;                    var brush = Enabled ? m_columnHeaderTextBrush : m_columnHeaderTextBrushDisabled;                  e.Graphics.DrawString(e.Header.Text' HeaderFont' brush' bound' sf);                      if (e.ColumnIndex == m_sortColumn) // Draw sort arrow                  {                      float w = e.Graphics.MeasureString(e.Header.Text' HeaderFont).Width;                      if (m_sortColumn == 0)                          w += CheckBoxWidth + 2;                       if (e.Bounds.Width > w + s_sortAscendingImage.Width + 8) // get enough room left for the arrow icon                      {                          Point pt = new Point(e.Bounds.Location.X + e.Bounds.Width - s_sortAscendingImage.Width - 4'                          e.Bounds.Top + (e.Bounds.Height - s_sortAscendingImage.Height) / 2);                          if (m_sortDirection == ListSortDirection.Ascending)                              e.Graphics.DrawImage(s_sortAscendingImage' pt);                          else                              e.Graphics.DrawImage(s_sortDescendingImage' pt);                      }                  }                    if (CheckBoxes && e.ColumnIndex ==0)                  {                      // draw check mark                      Point pt = new Point(e.Bounds.Location.X' e.Bounds.Top + 3);                      e.Graphics.DrawString(m_tickSymbol' m_tickFont' Enabled ? m_columnHeaderCheckMarkBrush : m_columnHeaderCheckMarkBrushDisabled' pt);                                           // draw a vertical line to make check mark appear in its own column                                       e.Graphics.DrawLine(m_columnHeaderSeparatorPen' CheckBoxWidth' e.Bounds.Top'                          CheckBoxWidth' e.Bounds.Bottom - 2);                                       }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawColumnHeader,The following statement contains a magic number: using (StringFormat sf = new StringFormat())              {                  // Store the column text alignment' letting it default                  // to Left if it has not been set to Center or Right.                  switch (e.Header.TextAlign)                  {                      case HorizontalAlignment.Center:                          sf.Alignment = StringAlignment.Center;                          break;                      case HorizontalAlignment.Right:                          sf.Alignment = StringAlignment.Far;                          break;                  }                      // Draw the standard header background.                  e.DrawBackground();                                                    // Draw the header text.                  var bound = e.Bounds;                  bound.Y += 3;                  bound.X += 8;                  if (e.ColumnIndex == 0)                      bound.X += CheckBoxWidth;                    var brush = Enabled ? m_columnHeaderTextBrush : m_columnHeaderTextBrushDisabled;                  e.Graphics.DrawString(e.Header.Text' HeaderFont' brush' bound' sf);                      if (e.ColumnIndex == m_sortColumn) // Draw sort arrow                  {                      float w = e.Graphics.MeasureString(e.Header.Text' HeaderFont).Width;                      if (m_sortColumn == 0)                          w += CheckBoxWidth + 2;                       if (e.Bounds.Width > w + s_sortAscendingImage.Width + 8) // get enough room left for the arrow icon                      {                          Point pt = new Point(e.Bounds.Location.X + e.Bounds.Width - s_sortAscendingImage.Width - 4'                          e.Bounds.Top + (e.Bounds.Height - s_sortAscendingImage.Height) / 2);                          if (m_sortDirection == ListSortDirection.Ascending)                              e.Graphics.DrawImage(s_sortAscendingImage' pt);                          else                              e.Graphics.DrawImage(s_sortDescendingImage' pt);                      }                  }                    if (CheckBoxes && e.ColumnIndex ==0)                  {                      // draw check mark                      Point pt = new Point(e.Bounds.Location.X' e.Bounds.Top + 3);                      e.Graphics.DrawString(m_tickSymbol' m_tickFont' Enabled ? m_columnHeaderCheckMarkBrush : m_columnHeaderCheckMarkBrushDisabled' pt);                                           // draw a vertical line to make check mark appear in its own column                                       e.Graphics.DrawLine(m_columnHeaderSeparatorPen' CheckBoxWidth' e.Bounds.Top'                          CheckBoxWidth' e.Bounds.Bottom - 2);                                       }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawColumnHeader,The following statement contains a magic number: using (StringFormat sf = new StringFormat())              {                  // Store the column text alignment' letting it default                  // to Left if it has not been set to Center or Right.                  switch (e.Header.TextAlign)                  {                      case HorizontalAlignment.Center:                          sf.Alignment = StringAlignment.Center;                          break;                      case HorizontalAlignment.Right:                          sf.Alignment = StringAlignment.Far;                          break;                  }                      // Draw the standard header background.                  e.DrawBackground();                                                    // Draw the header text.                  var bound = e.Bounds;                  bound.Y += 3;                  bound.X += 8;                  if (e.ColumnIndex == 0)                      bound.X += CheckBoxWidth;                    var brush = Enabled ? m_columnHeaderTextBrush : m_columnHeaderTextBrushDisabled;                  e.Graphics.DrawString(e.Header.Text' HeaderFont' brush' bound' sf);                      if (e.ColumnIndex == m_sortColumn) // Draw sort arrow                  {                      float w = e.Graphics.MeasureString(e.Header.Text' HeaderFont).Width;                      if (m_sortColumn == 0)                          w += CheckBoxWidth + 2;                       if (e.Bounds.Width > w + s_sortAscendingImage.Width + 8) // get enough room left for the arrow icon                      {                          Point pt = new Point(e.Bounds.Location.X + e.Bounds.Width - s_sortAscendingImage.Width - 4'                          e.Bounds.Top + (e.Bounds.Height - s_sortAscendingImage.Height) / 2);                          if (m_sortDirection == ListSortDirection.Ascending)                              e.Graphics.DrawImage(s_sortAscendingImage' pt);                          else                              e.Graphics.DrawImage(s_sortDescendingImage' pt);                      }                  }                    if (CheckBoxes && e.ColumnIndex ==0)                  {                      // draw check mark                      Point pt = new Point(e.Bounds.Location.X' e.Bounds.Top + 3);                      e.Graphics.DrawString(m_tickSymbol' m_tickFont' Enabled ? m_columnHeaderCheckMarkBrush : m_columnHeaderCheckMarkBrushDisabled' pt);                                           // draw a vertical line to make check mark appear in its own column                                       e.Graphics.DrawLine(m_columnHeaderSeparatorPen' CheckBoxWidth' e.Bounds.Top'                          CheckBoxWidth' e.Bounds.Bottom - 2);                                       }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawColumnHeader,The following statement contains a magic number: using (StringFormat sf = new StringFormat())              {                  // Store the column text alignment' letting it default                  // to Left if it has not been set to Center or Right.                  switch (e.Header.TextAlign)                  {                      case HorizontalAlignment.Center:                          sf.Alignment = StringAlignment.Center;                          break;                      case HorizontalAlignment.Right:                          sf.Alignment = StringAlignment.Far;                          break;                  }                      // Draw the standard header background.                  e.DrawBackground();                                                    // Draw the header text.                  var bound = e.Bounds;                  bound.Y += 3;                  bound.X += 8;                  if (e.ColumnIndex == 0)                      bound.X += CheckBoxWidth;                    var brush = Enabled ? m_columnHeaderTextBrush : m_columnHeaderTextBrushDisabled;                  e.Graphics.DrawString(e.Header.Text' HeaderFont' brush' bound' sf);                      if (e.ColumnIndex == m_sortColumn) // Draw sort arrow                  {                      float w = e.Graphics.MeasureString(e.Header.Text' HeaderFont).Width;                      if (m_sortColumn == 0)                          w += CheckBoxWidth + 2;                       if (e.Bounds.Width > w + s_sortAscendingImage.Width + 8) // get enough room left for the arrow icon                      {                          Point pt = new Point(e.Bounds.Location.X + e.Bounds.Width - s_sortAscendingImage.Width - 4'                          e.Bounds.Top + (e.Bounds.Height - s_sortAscendingImage.Height) / 2);                          if (m_sortDirection == ListSortDirection.Ascending)                              e.Graphics.DrawImage(s_sortAscendingImage' pt);                          else                              e.Graphics.DrawImage(s_sortDescendingImage' pt);                      }                  }                    if (CheckBoxes && e.ColumnIndex ==0)                  {                      // draw check mark                      Point pt = new Point(e.Bounds.Location.X' e.Bounds.Top + 3);                      e.Graphics.DrawString(m_tickSymbol' m_tickFont' Enabled ? m_columnHeaderCheckMarkBrush : m_columnHeaderCheckMarkBrushDisabled' pt);                                           // draw a vertical line to make check mark appear in its own column                                       e.Graphics.DrawLine(m_columnHeaderSeparatorPen' CheckBoxWidth' e.Bounds.Top'                          CheckBoxWidth' e.Bounds.Bottom - 2);                                       }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawColumnHeader,The following statement contains a magic number: using (StringFormat sf = new StringFormat())              {                  // Store the column text alignment' letting it default                  // to Left if it has not been set to Center or Right.                  switch (e.Header.TextAlign)                  {                      case HorizontalAlignment.Center:                          sf.Alignment = StringAlignment.Center;                          break;                      case HorizontalAlignment.Right:                          sf.Alignment = StringAlignment.Far;                          break;                  }                      // Draw the standard header background.                  e.DrawBackground();                                                    // Draw the header text.                  var bound = e.Bounds;                  bound.Y += 3;                  bound.X += 8;                  if (e.ColumnIndex == 0)                      bound.X += CheckBoxWidth;                    var brush = Enabled ? m_columnHeaderTextBrush : m_columnHeaderTextBrushDisabled;                  e.Graphics.DrawString(e.Header.Text' HeaderFont' brush' bound' sf);                      if (e.ColumnIndex == m_sortColumn) // Draw sort arrow                  {                      float w = e.Graphics.MeasureString(e.Header.Text' HeaderFont).Width;                      if (m_sortColumn == 0)                          w += CheckBoxWidth + 2;                       if (e.Bounds.Width > w + s_sortAscendingImage.Width + 8) // get enough room left for the arrow icon                      {                          Point pt = new Point(e.Bounds.Location.X + e.Bounds.Width - s_sortAscendingImage.Width - 4'                          e.Bounds.Top + (e.Bounds.Height - s_sortAscendingImage.Height) / 2);                          if (m_sortDirection == ListSortDirection.Ascending)                              e.Graphics.DrawImage(s_sortAscendingImage' pt);                          else                              e.Graphics.DrawImage(s_sortDescendingImage' pt);                      }                  }                    if (CheckBoxes && e.ColumnIndex ==0)                  {                      // draw check mark                      Point pt = new Point(e.Bounds.Location.X' e.Bounds.Top + 3);                      e.Graphics.DrawString(m_tickSymbol' m_tickFont' Enabled ? m_columnHeaderCheckMarkBrush : m_columnHeaderCheckMarkBrushDisabled' pt);                                           // draw a vertical line to make check mark appear in its own column                                       e.Graphics.DrawLine(m_columnHeaderSeparatorPen' CheckBoxWidth' e.Bounds.Top'                          CheckBoxWidth' e.Bounds.Bottom - 2);                                       }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawColumnHeader,The following statement contains a magic number: using (StringFormat sf = new StringFormat())              {                  // Store the column text alignment' letting it default                  // to Left if it has not been set to Center or Right.                  switch (e.Header.TextAlign)                  {                      case HorizontalAlignment.Center:                          sf.Alignment = StringAlignment.Center;                          break;                      case HorizontalAlignment.Right:                          sf.Alignment = StringAlignment.Far;                          break;                  }                      // Draw the standard header background.                  e.DrawBackground();                                                    // Draw the header text.                  var bound = e.Bounds;                  bound.Y += 3;                  bound.X += 8;                  if (e.ColumnIndex == 0)                      bound.X += CheckBoxWidth;                    var brush = Enabled ? m_columnHeaderTextBrush : m_columnHeaderTextBrushDisabled;                  e.Graphics.DrawString(e.Header.Text' HeaderFont' brush' bound' sf);                      if (e.ColumnIndex == m_sortColumn) // Draw sort arrow                  {                      float w = e.Graphics.MeasureString(e.Header.Text' HeaderFont).Width;                      if (m_sortColumn == 0)                          w += CheckBoxWidth + 2;                       if (e.Bounds.Width > w + s_sortAscendingImage.Width + 8) // get enough room left for the arrow icon                      {                          Point pt = new Point(e.Bounds.Location.X + e.Bounds.Width - s_sortAscendingImage.Width - 4'                          e.Bounds.Top + (e.Bounds.Height - s_sortAscendingImage.Height) / 2);                          if (m_sortDirection == ListSortDirection.Ascending)                              e.Graphics.DrawImage(s_sortAscendingImage' pt);                          else                              e.Graphics.DrawImage(s_sortDescendingImage' pt);                      }                  }                    if (CheckBoxes && e.ColumnIndex ==0)                  {                      // draw check mark                      Point pt = new Point(e.Bounds.Location.X' e.Bounds.Top + 3);                      e.Graphics.DrawString(m_tickSymbol' m_tickFont' Enabled ? m_columnHeaderCheckMarkBrush : m_columnHeaderCheckMarkBrushDisabled' pt);                                           // draw a vertical line to make check mark appear in its own column                                       e.Graphics.DrawLine(m_columnHeaderSeparatorPen' CheckBoxWidth' e.Bounds.Top'                          CheckBoxWidth' e.Bounds.Bottom - 2);                                       }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawColumnHeader,The following statement contains a magic number: using (StringFormat sf = new StringFormat())              {                  // Store the column text alignment' letting it default                  // to Left if it has not been set to Center or Right.                  switch (e.Header.TextAlign)                  {                      case HorizontalAlignment.Center:                          sf.Alignment = StringAlignment.Center;                          break;                      case HorizontalAlignment.Right:                          sf.Alignment = StringAlignment.Far;                          break;                  }                      // Draw the standard header background.                  e.DrawBackground();                                                    // Draw the header text.                  var bound = e.Bounds;                  bound.Y += 3;                  bound.X += 8;                  if (e.ColumnIndex == 0)                      bound.X += CheckBoxWidth;                    var brush = Enabled ? m_columnHeaderTextBrush : m_columnHeaderTextBrushDisabled;                  e.Graphics.DrawString(e.Header.Text' HeaderFont' brush' bound' sf);                      if (e.ColumnIndex == m_sortColumn) // Draw sort arrow                  {                      float w = e.Graphics.MeasureString(e.Header.Text' HeaderFont).Width;                      if (m_sortColumn == 0)                          w += CheckBoxWidth + 2;                       if (e.Bounds.Width > w + s_sortAscendingImage.Width + 8) // get enough room left for the arrow icon                      {                          Point pt = new Point(e.Bounds.Location.X + e.Bounds.Width - s_sortAscendingImage.Width - 4'                          e.Bounds.Top + (e.Bounds.Height - s_sortAscendingImage.Height) / 2);                          if (m_sortDirection == ListSortDirection.Ascending)                              e.Graphics.DrawImage(s_sortAscendingImage' pt);                          else                              e.Graphics.DrawImage(s_sortDescendingImage' pt);                      }                  }                    if (CheckBoxes && e.ColumnIndex ==0)                  {                      // draw check mark                      Point pt = new Point(e.Bounds.Location.X' e.Bounds.Top + 3);                      e.Graphics.DrawString(m_tickSymbol' m_tickFont' Enabled ? m_columnHeaderCheckMarkBrush : m_columnHeaderCheckMarkBrushDisabled' pt);                                           // draw a vertical line to make check mark appear in its own column                                       e.Graphics.DrawLine(m_columnHeaderSeparatorPen' CheckBoxWidth' e.Bounds.Top'                          CheckBoxWidth' e.Bounds.Bottom - 2);                                       }              }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,WndProc,The following statement contains a magic number: if (AlternatingRowColors && Items.Count ==0)              {                  const int WM_PAINT = 0x000F;                  if (m.Msg == WM_PAINT)                  {                      using (Graphics g = CreateGraphics())                      {                          int rowIndex = 0;                          var rowBound = new Rectangle(0' HeaderHeight'0'0);                                                    if (rowBound.Top + rowBound.Height < ClientRectangle.Height)                          {                                var rect = new Rectangle(0' rowBound.Bottom' ClientRectangle.Width' m_rowHeight);                              while (rect.Y < ClientRectangle.Bottom)                              {                                  if (rowIndex%2 == 0)                                      g.FillRectangle(m_alternatingRowBrush1' rect);                                  else                                      g.FillRectangle(m_alternatingRowBrush2' rect);                                    ++rowIndex;                                  rect.Y += m_rowHeight;                              }                          }                      }                  }                }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,AutoResizeColumns,The following statement contains a magic number: using (Graphics g = CreateGraphics())              {                  int numColumns =  Columns.Count;                  for (int columnIndex = 0; columnIndex < numColumns; ++columnIndex)                  {                                        float width = g.MeasureString(Columns[columnIndex].Text' HeaderFont).Width +                          2 * s_sortAscendingImage.Width + Margin.Left + Margin.Right +18;                       for (int itemIndex = 0; itemIndex < Items.Count; ++itemIndex)                     {                         float w = g.MeasureString(Items[itemIndex].SubItems[columnIndex].Text' Font).Width + Margin.Left + Margin.Right +18;                         if (w > width)                             width = w;                     }                                    Columns[columnIndex].Width = (int)width;                 }                               }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,AutoResizeColumns,The following statement contains a magic number: using (Graphics g = CreateGraphics())              {                  int numColumns =  Columns.Count;                  for (int columnIndex = 0; columnIndex < numColumns; ++columnIndex)                  {                                        float width = g.MeasureString(Columns[columnIndex].Text' HeaderFont).Width +                          2 * s_sortAscendingImage.Width + Margin.Left + Margin.Right +18;                       for (int itemIndex = 0; itemIndex < Items.Count; ++itemIndex)                     {                         float w = g.MeasureString(Items[itemIndex].SubItems[columnIndex].Text' Font).Width + Margin.Left + Margin.Right +18;                         if (w > width)                             width = w;                     }                                    Columns[columnIndex].Width = (int)width;                 }                               }
Magic Number,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,AutoResizeColumns,The following statement contains a magic number: using (Graphics g = CreateGraphics())              {                  int numColumns =  Columns.Count;                  for (int columnIndex = 0; columnIndex < numColumns; ++columnIndex)                  {                                        float width = g.MeasureString(Columns[columnIndex].Text' HeaderFont).Width +                          2 * s_sortAscendingImage.Width + Margin.Left + Margin.Right +18;                       for (int itemIndex = 0; itemIndex < Items.Count; ++itemIndex)                     {                         float w = g.MeasureString(Items[itemIndex].SubItems[columnIndex].Text' Font).Width + Margin.Left + Margin.Right +18;                         if (w > width)                             width = w;                     }                                    Columns[columnIndex].Width = (int)width;                 }                               }
Magic Number,Sce.Atf.Controls,DataEditorTheme,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\DataEditorTheme.cs,DataEditorTheme,The following statement contains a magic number: m_padding = new Padding(8);
Magic Number,Sce.Atf.Controls,DataEditorTheme,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\DataEditorTheme.cs,DataEditorTheme,The following statement contains a magic number: m__defaultSliderWidth = 100;
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,PaintValue,The following statement contains a magic number: if (ShowSlider)              {                  // draw track                  float slideY = area.Y + area.Height / 2;                  g.DrawLine(Theme.SliderTrackPen' left' slideY' left + SliderWidth' slideY);                    // draw thumb                  float t = (Value - Min) / (Max - Min);                  float thumbX = left + t * SliderWidth;                  var thumbRectangle = new Rectangle((int)thumbX - 8' (int)area.Top' 18' 18);                  if (TrackBarRenderer.IsSupported)                      TrackBarRenderer.DrawBottomPointingThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  else // visual styles may be disabled by the user in the operating system' roll our own                  {                      thumbRectangle = new Rectangle((int) thumbX - 4' (int) area.Top' 8' 16);                      DrawThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  }                    textOffset = SliderWidth + Theme.Padding.Left;              }
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,PaintValue,The following statement contains a magic number: if (ShowSlider)              {                  // draw track                  float slideY = area.Y + area.Height / 2;                  g.DrawLine(Theme.SliderTrackPen' left' slideY' left + SliderWidth' slideY);                    // draw thumb                  float t = (Value - Min) / (Max - Min);                  float thumbX = left + t * SliderWidth;                  var thumbRectangle = new Rectangle((int)thumbX - 8' (int)area.Top' 18' 18);                  if (TrackBarRenderer.IsSupported)                      TrackBarRenderer.DrawBottomPointingThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  else // visual styles may be disabled by the user in the operating system' roll our own                  {                      thumbRectangle = new Rectangle((int) thumbX - 4' (int) area.Top' 8' 16);                      DrawThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  }                    textOffset = SliderWidth + Theme.Padding.Left;              }
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,PaintValue,The following statement contains a magic number: if (ShowSlider)              {                  // draw track                  float slideY = area.Y + area.Height / 2;                  g.DrawLine(Theme.SliderTrackPen' left' slideY' left + SliderWidth' slideY);                    // draw thumb                  float t = (Value - Min) / (Max - Min);                  float thumbX = left + t * SliderWidth;                  var thumbRectangle = new Rectangle((int)thumbX - 8' (int)area.Top' 18' 18);                  if (TrackBarRenderer.IsSupported)                      TrackBarRenderer.DrawBottomPointingThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  else // visual styles may be disabled by the user in the operating system' roll our own                  {                      thumbRectangle = new Rectangle((int) thumbX - 4' (int) area.Top' 8' 16);                      DrawThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  }                    textOffset = SliderWidth + Theme.Padding.Left;              }
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,PaintValue,The following statement contains a magic number: if (ShowSlider)              {                  // draw track                  float slideY = area.Y + area.Height / 2;                  g.DrawLine(Theme.SliderTrackPen' left' slideY' left + SliderWidth' slideY);                    // draw thumb                  float t = (Value - Min) / (Max - Min);                  float thumbX = left + t * SliderWidth;                  var thumbRectangle = new Rectangle((int)thumbX - 8' (int)area.Top' 18' 18);                  if (TrackBarRenderer.IsSupported)                      TrackBarRenderer.DrawBottomPointingThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  else // visual styles may be disabled by the user in the operating system' roll our own                  {                      thumbRectangle = new Rectangle((int) thumbX - 4' (int) area.Top' 8' 16);                      DrawThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  }                    textOffset = SliderWidth + Theme.Padding.Left;              }
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,PaintValue,The following statement contains a magic number: if (ShowSlider)              {                  // draw track                  float slideY = area.Y + area.Height / 2;                  g.DrawLine(Theme.SliderTrackPen' left' slideY' left + SliderWidth' slideY);                    // draw thumb                  float t = (Value - Min) / (Max - Min);                  float thumbX = left + t * SliderWidth;                  var thumbRectangle = new Rectangle((int)thumbX - 8' (int)area.Top' 18' 18);                  if (TrackBarRenderer.IsSupported)                      TrackBarRenderer.DrawBottomPointingThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  else // visual styles may be disabled by the user in the operating system' roll our own                  {                      thumbRectangle = new Rectangle((int) thumbX - 4' (int) area.Top' 8' 16);                      DrawThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  }                    textOffset = SliderWidth + Theme.Padding.Left;              }
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,PaintValue,The following statement contains a magic number: if (ShowSlider)              {                  // draw track                  float slideY = area.Y + area.Height / 2;                  g.DrawLine(Theme.SliderTrackPen' left' slideY' left + SliderWidth' slideY);                    // draw thumb                  float t = (Value - Min) / (Max - Min);                  float thumbX = left + t * SliderWidth;                  var thumbRectangle = new Rectangle((int)thumbX - 8' (int)area.Top' 18' 18);                  if (TrackBarRenderer.IsSupported)                      TrackBarRenderer.DrawBottomPointingThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  else // visual styles may be disabled by the user in the operating system' roll our own                  {                      thumbRectangle = new Rectangle((int) thumbX - 4' (int) area.Top' 8' 16);                      DrawThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  }                    textOffset = SliderWidth + Theme.Padding.Left;              }
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,PaintValue,The following statement contains a magic number: if (ShowSlider)              {                  // draw track                  float slideY = area.Y + area.Height / 2;                  g.DrawLine(Theme.SliderTrackPen' left' slideY' left + SliderWidth' slideY);                    // draw thumb                  float t = (Value - Min) / (Max - Min);                  float thumbX = left + t * SliderWidth;                  var thumbRectangle = new Rectangle((int)thumbX - 8' (int)area.Top' 18' 18);                  if (TrackBarRenderer.IsSupported)                      TrackBarRenderer.DrawBottomPointingThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  else // visual styles may be disabled by the user in the operating system' roll our own                  {                      thumbRectangle = new Rectangle((int) thumbX - 4' (int) area.Top' 8' 16);                      DrawThumb(g' thumbRectangle' TrackBarThumbState.Normal);                  }                    textOffset = SliderWidth + Theme.Padding.Left;              }
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,DrawThumb,The following statement contains a magic number: s_thumbPoints[2] = new Point(bounds.Right' bounds.Top + bounds.Height * 3 / 4);
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,DrawThumb,The following statement contains a magic number: s_thumbPoints[2] = new Point(bounds.Right' bounds.Top + bounds.Height * 3 / 4);
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,DrawThumb,The following statement contains a magic number: s_thumbPoints[2] = new Point(bounds.Right' bounds.Top + bounds.Height * 3 / 4);
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,DrawThumb,The following statement contains a magic number: s_thumbPoints[3] = new Point((bounds.Left + bounds.Right) / 2' bounds.Top + bounds.Height);
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,DrawThumb,The following statement contains a magic number: s_thumbPoints[3] = new Point((bounds.Left + bounds.Right) / 2' bounds.Top + bounds.Height);
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,DrawThumb,The following statement contains a magic number: s_thumbPoints[4] = new Point(bounds.Left' bounds.Top + bounds.Height * 3 / 4);
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,DrawThumb,The following statement contains a magic number: s_thumbPoints[4] = new Point(bounds.Left' bounds.Top + bounds.Height * 3 / 4);
Magic Number,Sce.Atf.Controls,FloatDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\FloatDataEditor.cs,DrawThumb,The following statement contains a magic number: s_thumbPoints[4] = new Point(bounds.Left' bounds.Top + bounds.Height * 3 / 4);
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,FilteredFileDialogBase,The following statement contains a magic number: listView1.Columns.Add("Name"' 250' HorizontalAlignment.Left);
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,FilteredFileDialogBase,The following statement contains a magic number: listView1.Columns.Add("Date Modified"' 130' HorizontalAlignment.Left);
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,FilteredFileDialogBase,The following statement contains a magic number: listView1.Columns.Add("Size"' listView1.Width - 250 - 130 - 20' HorizontalAlignment.Right);
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,FilteredFileDialogBase,The following statement contains a magic number: listView1.Columns.Add("Size"' listView1.Width - 250 - 130 - 20' HorizontalAlignment.Right);
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,FilteredFileDialogBase,The following statement contains a magic number: listView1.Columns.Add("Size"' listView1.Width - 250 - 130 - 20' HorizontalAlignment.Right);
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,lookInComboBox_DrawItem,The following statement contains a magic number: if (e.Index == 0)                  e.Graphics.DrawImage(listView1.SmallImageList.Images[3]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));              else if (e.Index == 1)                  e.Graphics.DrawImage(listView1.SmallImageList.Images[2]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));              else                  e.Graphics.DrawImage(listView1.SmallImageList.Images[0]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,lookInComboBox_DrawItem,The following statement contains a magic number: if (e.Index == 0)                  e.Graphics.DrawImage(listView1.SmallImageList.Images[3]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));              else if (e.Index == 1)                  e.Graphics.DrawImage(listView1.SmallImageList.Images[2]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));              else                  e.Graphics.DrawImage(listView1.SmallImageList.Images[0]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,lookInComboBox_DrawItem,The following statement contains a magic number: if (e.Index == 0)                  e.Graphics.DrawImage(listView1.SmallImageList.Images[3]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));              else if (e.Index == 1)                  e.Graphics.DrawImage(listView1.SmallImageList.Images[2]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));              else                  e.Graphics.DrawImage(listView1.SmallImageList.Images[0]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,lookInComboBox_DrawItem,The following statement contains a magic number: if (e.Index == 0)                  e.Graphics.DrawImage(listView1.SmallImageList.Images[3]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));              else if (e.Index == 1)                  e.Graphics.DrawImage(listView1.SmallImageList.Images[2]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));              else                  e.Graphics.DrawImage(listView1.SmallImageList.Images[0]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,lookInComboBox_DrawItem,The following statement contains a magic number: if (e.Index == 0)                  e.Graphics.DrawImage(listView1.SmallImageList.Images[3]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));              else if (e.Index == 1)                  e.Graphics.DrawImage(listView1.SmallImageList.Images[2]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));              else                  e.Graphics.DrawImage(listView1.SmallImageList.Images[0]' new Point(e.Bounds.X + e.Index * 16' e.Bounds.Y));
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,lookInComboBox_DrawItem,The following statement contains a magic number: if (e.Index >= 0)              {                  // Get the item text.                  string text = ((ComboBox)sender).Items[e.Index].ToString();                    // Draw the item text.                  e.Graphics.DrawString(text' ((Control)sender).Font'                    brush' e.Bounds.X + (e.Index + 1) * 16' e.Bounds.Y);              }
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,fileDialogBase_Load,The following statement contains a magic number: if (!string.IsNullOrEmpty(Filter))              {                  var patterns = Filter.Split('|');                  if (patterns.Length > 1)                  {                      for (int i = 0; i < patterns.Length; i += 2)                      {                          fileTypeComboBox.Items.Add(patterns[i]);                          m_patterns.Add(patterns[i + 1]);                      }                      if (FilterIndex > 0 && FilterIndex <= fileTypeComboBox.Items.Count)                      {                          fileTypeComboBox.Text = fileTypeComboBox.Items[FilterIndex - 1].ToString();                          m_activeFileTypePattern = m_patterns[FilterIndex - 1];                      }                    }                }
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,path_SelectedIndexChanged,The following statement contains a magic number: if (!m_selecting)              {                  m_selecting = true;                  if (lookInComboBox.SelectedIndex == 0) // select "Computer"                  {                      GoToComputer();                  }                  else if (lookInComboBox.SelectedIndex == 1) // select the drive                  {                        string disk = lookInComboBox.Items[lookInComboBox.SelectedIndex] as string;                      foreach (var drive in DriveInfo.GetDrives())                      {                          if (drive.Name.StartsWith(disk' StringComparison.InvariantCultureIgnoreCase))                          {                              GotoDrive(drive);                              break;                          }                      }                  }                  else if (lookInComboBox.SelectedIndex > 1)                  {                      // assemble the path                        var sb = new StringBuilder(lookInComboBox.Items[1] + @"\");                      for (int i = 2; i <= lookInComboBox.SelectedIndex; ++i)                          sb.Append(lookInComboBox.Items[i] + @"\");                      GoToDirectory(Directory.CreateDirectory(sb.ToString()));                  }                  m_selecting = false;              }
Magic Number,Sce.Atf.Controls,FilteredFileDialogBase,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,GoToComputer,The following statement contains a magic number: foreach (var drive in DriveInfo.GetDrives())              {                  var item = new ListViewItem(drive.Name' 0);                  item.ImageIndex = 2;                  item.Tag = drive;                  var subItems = new ListViewItem.ListViewSubItem[] {                                  new ListViewItem.ListViewSubItem(item' "Drive")'                                   new ListViewItem.ListViewSubItem(item'  drive.Name)};                  item.SubItems.AddRange(subItems);                  m_cache[index++] = item;              }
Magic Number,Sce.Atf.Controls,ListViewItemComparer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FilteredFileDialogBase.cs,Compare,The following statement contains a magic number: if (listviewX.Tag is DirectoryInfo && listviewY.Tag is FileInfo)                      compareResult = -1; // directory goes before files                  else if (listviewX.Tag is FileInfo && listviewY.Tag is DirectoryInfo)                      compareResult = 1;                  else if (m_columnToSort == 0) // Case insensitive Compare for file name                      compareResult = m_objectCompare.Compare(listviewX.SubItems[m_columnToSort].Text'                                                            listviewY.SubItems[m_columnToSort].Text);                  else if (m_columnToSort == 1) //  modified datetime                  {                      if (listviewX.Tag is DirectoryInfo && listviewY.Tag is DirectoryInfo)                      {                          compareResult = DateTime.Compare(((DirectoryInfo)listviewX.Tag).LastWriteTime'                                                           ((DirectoryInfo)listviewY.Tag).LastWriteTime);                      }                      else if (listviewX.Tag is FileInfo && listviewY.Tag is FileInfo)                      {                          compareResult = DateTime.Compare(((FileInfo)listviewX.Tag).LastWriteTime'                                                           ((FileInfo)listviewY.Tag).LastWriteTime);                      }                  }                  else if (m_columnToSort == 2) //  size                  {                      if (listviewX.Tag is DirectoryInfo && listviewY.Tag is DirectoryInfo)                      {                          compareResult = m_objectCompare.Compare(listviewX.SubItems[m_columnToSort].Text'                                                          listviewY.SubItems[m_columnToSort].Text);                      }                      else if (listviewX.Tag is FileInfo && listviewY.Tag is FileInfo)                      {                          compareResult = ((FileInfo)listviewX.Tag).Length.CompareTo(((FileInfo)listviewY.Tag).Length);                      }                  }
Magic Number,Sce.Atf.Controls,FloatInputControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FloatInputControl.cs,FloatInputControl,The following statement contains a magic number: m_textBox.SizeChanged += (sender' e) => Height = m_textBox.Height + 3;
Magic Number,Sce.Atf.Controls,FloatInputControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FloatInputControl.cs,OnPaint,The following statement contains a magic number: Rectangle rec                  = new Rectangle(m_textBox.Location.X' m_textBox.Height' w' 3);
Magic Number,Sce.Atf.Controls,HoverLabel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\HoverLabel.cs,SetBounds,The following statement contains a magic number: using (Graphics g = CreateGraphics())              {                  SizeF labelSize = g.MeasureString(m_label' Font);                  Size = new Size((int)Math.Ceiling(labelSize.Width) + 2 * TextMargin' (int)Math.Ceiling(labelSize.Height) + 2 * TextMargin);              }
Magic Number,Sce.Atf.Controls,HoverLabel,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\HoverLabel.cs,SetBounds,The following statement contains a magic number: using (Graphics g = CreateGraphics())              {                  SizeF labelSize = g.MeasureString(m_label' Font);                  Size = new Size((int)Math.Ceiling(labelSize.Width) + 2 * TextMargin' (int)Math.Ceiling(labelSize.Height) + 2 * TextMargin);              }
Magic Number,Sce.Atf.Controls,IntInputControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\IntInputControl.cs,IntInputControl,The following statement contains a magic number: m_textBox.SizeChanged += (sender' e) => this.Height = m_textBox.Height + 3;
Magic Number,Sce.Atf.Controls,IntInputControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\IntInputControl.cs,OnPaint,The following statement contains a magic number: Rectangle rec                  = new Rectangle(m_textBox.Location.X' m_textBox.Height' w' 3);
Magic Number,Sce.Atf.Controls,NoFocusTrackBar,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NoFocusTrackBar.cs,MakeParam,The following statement contains a magic number: return (hiWord << 16) | (loWord & 0xffff);
Magic Number,Sce.Atf.Controls,NumericMatrixControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericMatrixControl.cs,AreEqual,The following statement contains a magic number: if (m_numericType == typeof(Single))                  return MathUtil.AreApproxEqual((Single[])array1' (Single[])array2' 0.000001);
Magic Number,Sce.Atf.Controls,NumericMatrixControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericMatrixControl.cs,AreEqual,The following statement contains a magic number: if (m_numericType == typeof(Double))                  return MathUtil.AreApproxEqual((Double[])array1' (Double[])array2' 0.000001);
Magic Number,Sce.Atf.Controls,NumericTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTextBox.cs,OnMouseDown,The following statement contains a magic number: if (e.Button == MouseButtons.Left &&                  e.Clicks == 2)              {                  SelectAll();                  return;              }
Magic Number,Sce.Atf.Controls,NumericTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTextBox.cs,Flush,The following statement contains a magic number: if (TryValidateText(text))              {                  bool equal;                  object value = Value;                    if (m_numericType == typeof(Single))                  {                      equal =                          m_lastEdit != null &&                          MathUtil.AreApproxEqual((Single)m_lastEdit' (Single)value' 0.000001);                  }                  else if (m_numericType == typeof(Double))                  {                      equal =                          m_lastEdit != null &&                          MathUtil.AreApproxEqual((Double)m_lastEdit' (Double)value' 0.000001);                  }                  else                  {                      equal =                          m_lastEdit != null &&                          m_lastEdit.Equals(value);                  }                    if (!equal)                  {                      OnValueEdited(EventArgs.Empty);                      m_lastEdit = value;                  }              }              else              {                  Cancel();              }
Magic Number,Sce.Atf.Controls,NumericTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTextBox.cs,Flush,The following statement contains a magic number: if (TryValidateText(text))              {                  bool equal;                  object value = Value;                    if (m_numericType == typeof(Single))                  {                      equal =                          m_lastEdit != null &&                          MathUtil.AreApproxEqual((Single)m_lastEdit' (Single)value' 0.000001);                  }                  else if (m_numericType == typeof(Double))                  {                      equal =                          m_lastEdit != null &&                          MathUtil.AreApproxEqual((Double)m_lastEdit' (Double)value' 0.000001);                  }                  else                  {                      equal =                          m_lastEdit != null &&                          m_lastEdit.Equals(value);                  }                    if (!equal)                  {                      OnValueEdited(EventArgs.Empty);                      m_lastEdit = value;                  }              }              else              {                  Cancel();              }
Magic Number,Sce.Atf.Controls,CompactSpinner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTextBox.cs,OnPaint,The following statement contains a magic number: int midy = this.Height / 2;
Magic Number,Sce.Atf.Controls,CompactSpinner,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTextBox.cs,OnPaint,The following statement contains a magic number: using (Pen pen = new Pen(Color.LightBlue))              {                  pen.Width = 4;                  pen.EndCap = System.Drawing.Drawing2D.LineCap.ArrowAnchor;                  pen.StartCap = System.Drawing.Drawing2D.LineCap.ArrowAnchor;                  e.Graphics.DrawLine(pen' 0' midy' Width' midy);                              }
Magic Number,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,NumericTupleControl,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,NumericTupleControl,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,NumericTupleControl,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,NumericTupleControl,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,NumericTupleControl,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,NumericTupleControl,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,NumericTupleControl,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,NumericTupleControl,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,NumericTupleControl,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,NumericTupleControl,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls,NumericTupleControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\NumericTupleControl.cs,OnResize,The following statement contains a magic number: if (HideAxisLabel)              {                  int x = 0;                  foreach (NumericTextBox control in Controls)                  {                      control.BorderStyle = BorderStyle.FixedSingle;                      control.Bounds = new Rectangle(x' 0' cellSize' control.Height);                      x += cellSize;                  }              }              else              {                  if (m_labelWidth[0] == -1)                      ComputeLabelWidth();                  const int margin = 3;                                  int x = 0' c = 0;                  foreach (Control control in Controls)                  {                      int labelWidth = m_labelWidth[c++];                      control.Bounds = new Rectangle(x + labelWidth + margin' 0' cellSize - labelWidth - margin' control.Height);                      x += cellSize;                  }              }
Magic Number,Sce.Atf.Controls,OverlayButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\OverlayButton.cs,OverlayButton,The following statement contains a magic number: m_bound = new Rectangle(0'0'16'16);
Magic Number,Sce.Atf.Controls,OverlayButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\OverlayButton.cs,OverlayButton,The following statement contains a magic number: m_bound = new Rectangle(0'0'16'16);
Magic Number,Sce.Atf.Controls,ProgressDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ProgressDialog.cs,InitializeComponent,The following statement contains a magic number: progressBar1.Step = 5;
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (m_enableX)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      x - m_splitterThickness / 2'                      -1'                      m_splitterThickness'                      Height + 2);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (m_enableX)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      x - m_splitterThickness / 2'                      -1'                      m_splitterThickness'                      Height + 2);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (m_enableY)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      -1'                      y - m_splitterThickness / 2'                      Width + 2'                      m_splitterThickness);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (m_enableY)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      -1'                      y - m_splitterThickness / 2'                      Width + 2'                      m_splitterThickness);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (MultiPanelMode)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      x - m_splitterThickness / 2'                      y - m_splitterThickness / 2'                      m_splitterThickness'                      m_splitterThickness'                      Border3DStyle.Flat'                      Border3DSide.Middle);                    Control activeControl = ActiveControl;                  if (activeControl != null)                  {                      Rectangle rect = activeControl.Bounds;                      rect.Inflate(2' 2);                      ControlPaint.DrawBorder(                          e.Graphics'                          rect'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid);                  }              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (MultiPanelMode)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      x - m_splitterThickness / 2'                      y - m_splitterThickness / 2'                      m_splitterThickness'                      m_splitterThickness'                      Border3DStyle.Flat'                      Border3DSide.Middle);                    Control activeControl = ActiveControl;                  if (activeControl != null)                  {                      Rectangle rect = activeControl.Bounds;                      rect.Inflate(2' 2);                      ControlPaint.DrawBorder(                          e.Graphics'                          rect'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid);                  }              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (MultiPanelMode)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      x - m_splitterThickness / 2'                      y - m_splitterThickness / 2'                      m_splitterThickness'                      m_splitterThickness'                      Border3DStyle.Flat'                      Border3DSide.Middle);                    Control activeControl = ActiveControl;                  if (activeControl != null)                  {                      Rectangle rect = activeControl.Bounds;                      rect.Inflate(2' 2);                      ControlPaint.DrawBorder(                          e.Graphics'                          rect'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid);                  }              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (MultiPanelMode)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      x - m_splitterThickness / 2'                      y - m_splitterThickness / 2'                      m_splitterThickness'                      m_splitterThickness'                      Border3DStyle.Flat'                      Border3DSide.Middle);                    Control activeControl = ActiveControl;                  if (activeControl != null)                  {                      Rectangle rect = activeControl.Bounds;                      rect.Inflate(2' 2);                      ControlPaint.DrawBorder(                          e.Graphics'                          rect'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid);                  }              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (MultiPanelMode)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      x - m_splitterThickness / 2'                      y - m_splitterThickness / 2'                      m_splitterThickness'                      m_splitterThickness'                      Border3DStyle.Flat'                      Border3DSide.Middle);                    Control activeControl = ActiveControl;                  if (activeControl != null)                  {                      Rectangle rect = activeControl.Bounds;                      rect.Inflate(2' 2);                      ControlPaint.DrawBorder(                          e.Graphics'                          rect'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid);                  }              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (MultiPanelMode)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      x - m_splitterThickness / 2'                      y - m_splitterThickness / 2'                      m_splitterThickness'                      m_splitterThickness'                      Border3DStyle.Flat'                      Border3DSide.Middle);                    Control activeControl = ActiveControl;                  if (activeControl != null)                  {                      Rectangle rect = activeControl.Bounds;                      rect.Inflate(2' 2);                      ControlPaint.DrawBorder(                          e.Graphics'                          rect'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid);                  }              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (MultiPanelMode)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      x - m_splitterThickness / 2'                      y - m_splitterThickness / 2'                      m_splitterThickness'                      m_splitterThickness'                      Border3DStyle.Flat'                      Border3DSide.Middle);                    Control activeControl = ActiveControl;                  if (activeControl != null)                  {                      Rectangle rect = activeControl.Bounds;                      rect.Inflate(2' 2);                      ControlPaint.DrawBorder(                          e.Graphics'                          rect'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid);                  }              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,OnPaint,The following statement contains a magic number: if (MultiPanelMode)              {                  ControlPaint.DrawBorder3D(                      e.Graphics'                      x - m_splitterThickness / 2'                      y - m_splitterThickness / 2'                      m_splitterThickness'                      m_splitterThickness'                      Border3DStyle.Flat'                      Border3DSide.Middle);                    Control activeControl = ActiveControl;                  if (activeControl != null)                  {                      Rectangle rect = activeControl.Bounds;                      rect.Inflate(2' 2);                      ControlPaint.DrawBorder(                          e.Graphics'                          rect'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid'                          Color.Blue'                          2'                          ButtonBorderStyle.Solid);                  }              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeTopLeft,The following statement contains a magic number: if (m_topLeft != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2;                  m_topLeft.Bounds = new Rectangle(1' 1' x - 2' y - 2);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeTopLeft,The following statement contains a magic number: if (m_topLeft != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2;                  m_topLeft.Bounds = new Rectangle(1' 1' x - 2' y - 2);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeTopLeft,The following statement contains a magic number: if (m_topLeft != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2;                  m_topLeft.Bounds = new Rectangle(1' 1' x - 2' y - 2);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeTopLeft,The following statement contains a magic number: if (m_topLeft != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2;                  m_topLeft.Bounds = new Rectangle(1' 1' x - 2' y - 2);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeTopRight,The following statement contains a magic number: if (m_topRight != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2 + m_splitterThickness;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2;                  m_topRight.Bounds = new Rectangle(x' 1' Width - x - 1' y - 2);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeTopRight,The following statement contains a magic number: if (m_topRight != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2 + m_splitterThickness;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2;                  m_topRight.Bounds = new Rectangle(x' 1' Width - x - 1' y - 2);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeTopRight,The following statement contains a magic number: if (m_topRight != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2 + m_splitterThickness;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2;                  m_topRight.Bounds = new Rectangle(x' 1' Width - x - 1' y - 2);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeBottomLeft,The following statement contains a magic number: if (m_bottomLeft != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2 + m_splitterThickness;                  m_bottomLeft.Bounds = new Rectangle(1' y' x - 2' Height - y - 1);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeBottomLeft,The following statement contains a magic number: if (m_bottomLeft != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2 + m_splitterThickness;                  m_bottomLeft.Bounds = new Rectangle(1' y' x - 2' Height - y - 1);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeBottomLeft,The following statement contains a magic number: if (m_bottomLeft != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2 + m_splitterThickness;                  m_bottomLeft.Bounds = new Rectangle(1' y' x - 2' Height - y - 1);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeBottomRight,The following statement contains a magic number: if (m_bottomRight != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2 + m_splitterThickness;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2 + m_splitterThickness;                  m_bottomRight.Bounds = new Rectangle(x' y' Width - x - 1' Height - y - 1);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,SizeBottomRight,The following statement contains a magic number: if (m_bottomRight != null)              {                  int x = (int)(m_splitX * Width) - m_splitterThickness / 2 + m_splitterThickness;                  int y = (int)(m_splitY * Height) - m_splitterThickness / 2 + m_splitterThickness;                  m_bottomRight.Bounds = new Rectangle(x' y' Width - x - 1' Height - y - 1);              }
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,IsOverSplitX,The following statement contains a magic number: return Math.Abs(GetSplitX() - x) < m_splitterThickness / 2 + m_tolerance;
Magic Number,Sce.Atf.Controls,QuadPanelControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\QuadPanelControl.cs,IsOverSplitY,The following statement contains a magic number: return Math.Abs(GetSplitY() - y) < m_splitterThickness / 2 + m_tolerance;
Magic Number,Sce.Atf.Controls,SplitButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SplitButton.cs,GetPreferredSize,The following statement contains a magic number: if (m_showSplit && !string.IsNullOrEmpty(Text) &&                  TextRenderer.MeasureText(Text' Font).Width + PushButtonWidth > preferredSize.Width)              {                  return preferredSize + new Size(PushButtonWidth + BorderSize*2' 0);              }
Magic Number,Sce.Atf.Controls,SplitButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SplitButton.cs,OnPaint,The following statement contains a magic number: m_dropDownRectangle = new Rectangle(bounds.Right - PushButtonWidth - 1' BorderSize' PushButtonWidth'                                                bounds.Height - BorderSize*2);
Magic Number,Sce.Atf.Controls,SplitButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SplitButton.cs,OnPaint,The following statement contains a magic number: var focusRect =                  new Rectangle(internalBorder'                                internalBorder'                                bounds.Width - m_dropDownRectangle.Width - internalBorder'                                bounds.Height - (internalBorder*2));
Magic Number,Sce.Atf.Controls,SplitButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SplitButton.cs,PaintArrow,The following statement contains a magic number: var middle = new Point(Convert.ToInt32(dropDownRect.Left + dropDownRect.Width/2)'                                     Convert.ToInt32(dropDownRect.Top + dropDownRect.Height/2));
Magic Number,Sce.Atf.Controls,SplitButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SplitButton.cs,PaintArrow,The following statement contains a magic number: var middle = new Point(Convert.ToInt32(dropDownRect.Left + dropDownRect.Width/2)'                                     Convert.ToInt32(dropDownRect.Top + dropDownRect.Height/2));
Magic Number,Sce.Atf.Controls,SplitButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SplitButton.cs,PaintArrow,The following statement contains a magic number: middle.X += (dropDownRect.Width%2);
Magic Number,Sce.Atf.Controls,SplitButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SplitButton.cs,PaintArrow,The following statement contains a magic number: var arrow = new[]                              {                                  new Point(middle.X - 2' middle.Y - 1)' new Point(middle.X + 3' middle.Y - 1)'                                  new Point(middle.X' middle.Y + 2)                              };
Magic Number,Sce.Atf.Controls,SplitButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SplitButton.cs,PaintArrow,The following statement contains a magic number: var arrow = new[]                              {                                  new Point(middle.X - 2' middle.Y - 1)' new Point(middle.X + 3' middle.Y - 1)'                                  new Point(middle.X' middle.Y + 2)                              };
Magic Number,Sce.Atf.Controls,SplitButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SplitButton.cs,PaintArrow,The following statement contains a magic number: var arrow = new[]                              {                                  new Point(middle.X - 2' middle.Y - 1)' new Point(middle.X + 3' middle.Y - 1)'                                  new Point(middle.X' middle.Y + 2)                              };
Magic Number,Sce.Atf.Controls,BackgroundThread,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThreadSafeProgressDialog.cs,ThreadUnsafeUpdateLocation,The following statement contains a magic number: if (m_dialog != null)                  {                      if (m_parent.m_ownerBounds == null)                      {                          m_dialog.TopMost = false;                          return;                      }                        // unbox rectangle                      var bounds = (Rectangle)m_parent.m_ownerBounds;                        // center on owner                      Point point = bounds.Location;                      point.Offset((bounds.Width - m_dialog.Width) / 2' (bounds.Height - m_dialog.Height) / 2);                        m_dialog.DesktopLocation = point;                      m_dialog.TopMost = true;                  }
Magic Number,Sce.Atf.Controls,BackgroundThread,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThreadSafeProgressDialog.cs,ThreadUnsafeUpdateLocation,The following statement contains a magic number: if (m_dialog != null)                  {                      if (m_parent.m_ownerBounds == null)                      {                          m_dialog.TopMost = false;                          return;                      }                        // unbox rectangle                      var bounds = (Rectangle)m_parent.m_ownerBounds;                        // center on owner                      Point point = bounds.Location;                      point.Offset((bounds.Width - m_dialog.Width) / 2' (bounds.Height - m_dialog.Height) / 2);                        m_dialog.DesktopLocation = point;                      m_dialog.TopMost = true;                  }
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,ThumbnailControl,The following statement contains a magic number: m_hoverTimer = new Timer {Interval = 500};
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,OnPaint,The following statement contains a magic number: using (StringFormat format = new StringFormat())              {                  format.Alignment = StringAlignment.Center;                    HashSet<ThumbnailControlItem> selected = new HashSet<ThumbnailControlItem>(m_selection);                    foreach (ThumbnailControlItem item in m_items)                  {                      Image image = item.Image;                      Rectangle thumbRect = GetThumbnailRect(position' image);                        e.Graphics.DrawImage(image' thumbRect);                        RectangleF captionRect = new RectangleF(                          position.X'                          position.Y + m_thumbnailSize + ThumbnailMargin'                          m_thumbnailSize'                          m_fontHeight);                        e.Graphics.DrawString(                          item.Name'                          Font'                          SystemBrushes.ControlText'                          captionRect'                          format);                        if (m_indicatorImages != null &&                          item.Indicator != null)                      {                          Image indicator = m_indicatorImages.Images[item.Indicator];                          if (indicator != null)                          {                              Rectangle indicatorRect = new Rectangle(                                  new Point(position.X - 2' position.Y - 2)'                                  m_indicatorImages.ImageSize);                                e.Graphics.DrawImage(indicator' indicatorRect);                          }                      }                        e.Graphics.DrawRectangle(                          selected.Contains(item) ? Pens.Black : Pens.LightGray'                          GetThumbnailBoundaryRect(position));                        position = NextThumbnailPosition(position);                  }              }
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,OnPaint,The following statement contains a magic number: using (StringFormat format = new StringFormat())              {                  format.Alignment = StringAlignment.Center;                    HashSet<ThumbnailControlItem> selected = new HashSet<ThumbnailControlItem>(m_selection);                    foreach (ThumbnailControlItem item in m_items)                  {                      Image image = item.Image;                      Rectangle thumbRect = GetThumbnailRect(position' image);                        e.Graphics.DrawImage(image' thumbRect);                        RectangleF captionRect = new RectangleF(                          position.X'                          position.Y + m_thumbnailSize + ThumbnailMargin'                          m_thumbnailSize'                          m_fontHeight);                        e.Graphics.DrawString(                          item.Name'                          Font'                          SystemBrushes.ControlText'                          captionRect'                          format);                        if (m_indicatorImages != null &&                          item.Indicator != null)                      {                          Image indicator = m_indicatorImages.Images[item.Indicator];                          if (indicator != null)                          {                              Rectangle indicatorRect = new Rectangle(                                  new Point(position.X - 2' position.Y - 2)'                                  m_indicatorImages.ImageSize);                                e.Graphics.DrawImage(indicator' indicatorRect);                          }                      }                        e.Graphics.DrawRectangle(                          selected.Contains(item) ? Pens.Black : Pens.LightGray'                          GetThumbnailBoundaryRect(position));                        position = NextThumbnailPosition(position);                  }              }
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,HoverTimerTick,The following statement contains a magic number: if (m_hoverLabel == null && m_hoverThumbnail != null)              {                  m_hoverLabel =                      new HoverLabel(m_hoverThumbnail.Description)                          {                              Location = new Point(MousePosition.X - 8' MousePosition.Y + 8)                          };                  m_hoverLabel.ShowWithoutFocus();              }
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,HoverTimerTick,The following statement contains a magic number: if (m_hoverLabel == null && m_hoverThumbnail != null)              {                  m_hoverLabel =                      new HoverLabel(m_hoverThumbnail.Description)                          {                              Location = new Point(MousePosition.X - 8' MousePosition.Y + 8)                          };                  m_hoverLabel.ShowWithoutFocus();              }
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,RecalculateClientSize,The following statement contains a magic number: if (m_items.Count > 0)              {                  int thumbsPerCol;                  int thumbsPerRow;                    if (m_orientation == Orientation.Horizontal)                  {                      thumbsPerCol = (ClientSize.Height - ThumbnailMargin) / (m_thumbnailSize + (2 * ThumbnailMargin) + m_fontHeight);                      if (thumbsPerCol < 1) thumbsPerCol = 1;                        thumbsPerRow = (m_items.Count / thumbsPerCol) + 1;                      if ((m_items.Count % 2) == 0)                          thumbsPerRow -= 1;                        if (thumbsPerRow < 1) thumbsPerRow = 1;                  }                  else // m_orientation == Orientation.Vertical                  {                      thumbsPerRow = (ClientSize.Width - ThumbnailMargin) / (m_thumbnailSize + ThumbnailMargin);                      if (thumbsPerRow < 1) thumbsPerRow = 1;                        thumbsPerCol = (m_items.Count / thumbsPerRow) + 1;                      if (((thumbsPerRow * thumbsPerCol) - m_items.Count) >= thumbsPerRow)                          thumbsPerCol -= 1;                        if (thumbsPerCol < 1) thumbsPerCol = 1;                  }                    size.Width = ((thumbsPerRow) * (m_thumbnailSize + ThumbnailMargin)) + ThumbnailMargin;                  size.Height = ((thumbsPerCol) * (m_thumbnailSize + (2 * ThumbnailMargin) + m_fontHeight)) + ThumbnailMargin;                  m_clientSize = size;              }
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,RecalculateClientSize,The following statement contains a magic number: if (m_items.Count > 0)              {                  int thumbsPerCol;                  int thumbsPerRow;                    if (m_orientation == Orientation.Horizontal)                  {                      thumbsPerCol = (ClientSize.Height - ThumbnailMargin) / (m_thumbnailSize + (2 * ThumbnailMargin) + m_fontHeight);                      if (thumbsPerCol < 1) thumbsPerCol = 1;                        thumbsPerRow = (m_items.Count / thumbsPerCol) + 1;                      if ((m_items.Count % 2) == 0)                          thumbsPerRow -= 1;                        if (thumbsPerRow < 1) thumbsPerRow = 1;                  }                  else // m_orientation == Orientation.Vertical                  {                      thumbsPerRow = (ClientSize.Width - ThumbnailMargin) / (m_thumbnailSize + ThumbnailMargin);                      if (thumbsPerRow < 1) thumbsPerRow = 1;                        thumbsPerCol = (m_items.Count / thumbsPerRow) + 1;                      if (((thumbsPerRow * thumbsPerCol) - m_items.Count) >= thumbsPerRow)                          thumbsPerCol -= 1;                        if (thumbsPerCol < 1) thumbsPerCol = 1;                  }                    size.Width = ((thumbsPerRow) * (m_thumbnailSize + ThumbnailMargin)) + ThumbnailMargin;                  size.Height = ((thumbsPerCol) * (m_thumbnailSize + (2 * ThumbnailMargin) + m_fontHeight)) + ThumbnailMargin;                  m_clientSize = size;              }
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,RecalculateClientSize,The following statement contains a magic number: if (m_items.Count > 0)              {                  int thumbsPerCol;                  int thumbsPerRow;                    if (m_orientation == Orientation.Horizontal)                  {                      thumbsPerCol = (ClientSize.Height - ThumbnailMargin) / (m_thumbnailSize + (2 * ThumbnailMargin) + m_fontHeight);                      if (thumbsPerCol < 1) thumbsPerCol = 1;                        thumbsPerRow = (m_items.Count / thumbsPerCol) + 1;                      if ((m_items.Count % 2) == 0)                          thumbsPerRow -= 1;                        if (thumbsPerRow < 1) thumbsPerRow = 1;                  }                  else // m_orientation == Orientation.Vertical                  {                      thumbsPerRow = (ClientSize.Width - ThumbnailMargin) / (m_thumbnailSize + ThumbnailMargin);                      if (thumbsPerRow < 1) thumbsPerRow = 1;                        thumbsPerCol = (m_items.Count / thumbsPerRow) + 1;                      if (((thumbsPerRow * thumbsPerCol) - m_items.Count) >= thumbsPerRow)                          thumbsPerCol -= 1;                        if (thumbsPerCol < 1) thumbsPerCol = 1;                  }                    size.Width = ((thumbsPerRow) * (m_thumbnailSize + ThumbnailMargin)) + ThumbnailMargin;                  size.Height = ((thumbsPerCol) * (m_thumbnailSize + (2 * ThumbnailMargin) + m_fontHeight)) + ThumbnailMargin;                  m_clientSize = size;              }
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,GetThumbnailRect,The following statement contains a magic number: int xInset = Math.Max(0' m_thumbnailSize - thumbSize.Width) / 2;
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,GetThumbnailRect,The following statement contains a magic number: int yInset = Math.Max(0' m_thumbnailSize - thumbSize.Height) / 2;
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,GetThumbnailBoundaryRect,The following statement contains a magic number: return new Rectangle(position.X - 4' position.Y - 4'                  m_thumbnailSize + 8' m_thumbnailSize + 8);
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,GetThumbnailBoundaryRect,The following statement contains a magic number: return new Rectangle(position.X - 4' position.Y - 4'                  m_thumbnailSize + 8' m_thumbnailSize + 8);
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,GetThumbnailBoundaryRect,The following statement contains a magic number: return new Rectangle(position.X - 4' position.Y - 4'                  m_thumbnailSize + 8' m_thumbnailSize + 8);
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,GetThumbnailBoundaryRect,The following statement contains a magic number: return new Rectangle(position.X - 4' position.Y - 4'                  m_thumbnailSize + 8' m_thumbnailSize + 8);
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,NextThumbnailPosition,The following statement contains a magic number: if (m_orientation == Orientation.Horizontal)              {                  position.Y += m_thumbnailSize + m_fontHeight + (2 * ThumbnailMargin);                  if (position.Y >= (m_clientSize.Height + AutoScrollPosition.Y - ThumbnailMargin))                  {                      position.X += ThumbnailMargin + m_thumbnailSize;                      position.Y = ThumbnailMargin + AutoScrollPosition.Y;                  }              }              else // m_orientation == Orientation.Vertical              {                  position.X += m_thumbnailSize + ThumbnailMargin;                  if (position.X >= (m_clientSize.Width + AutoScrollPosition.X - ThumbnailMargin))                  {                      position.X = ThumbnailMargin + AutoScrollPosition.X;                      position.Y += (m_thumbnailSize + (2 * ThumbnailMargin) + m_fontHeight);                  }              }
Magic Number,Sce.Atf.Controls,ThumbnailControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ThumbnailControl.cs,NextThumbnailPosition,The following statement contains a magic number: if (m_orientation == Orientation.Horizontal)              {                  position.Y += m_thumbnailSize + m_fontHeight + (2 * ThumbnailMargin);                  if (position.Y >= (m_clientSize.Height + AutoScrollPosition.Y - ThumbnailMargin))                  {                      position.X += ThumbnailMargin + m_thumbnailSize;                      position.Y = ThumbnailMargin + AutoScrollPosition.Y;                  }              }              else // m_orientation == Orientation.Vertical              {                  position.X += m_thumbnailSize + ThumbnailMargin;                  if (position.X >= (m_clientSize.Width + AutoScrollPosition.X - ThumbnailMargin))                  {                      position.X = ThumbnailMargin + AutoScrollPosition.X;                      position.Y += (m_thumbnailSize + (2 * ThumbnailMargin) + m_fontHeight);                  }              }
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,TreeControl,The following statement contains a magic number: m_dragHoverExpandTimer.Interval = 1000;
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,TreeControl,The following statement contains a magic number: m_autoScrollTimer.Interval = 200;
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,TreeControl,The following statement contains a magic number: m_vScrollBar.SmallChange = 8;
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnMouseDown,The following statement contains a magic number: m_lastMouseDownWasDoubleClick = (e.Clicks == 2);
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnMouseWheel,The following statement contains a magic number: int value = m_vScrollBar.Value - e.Delta / 2;
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnDragOver,The following statement contains a magic number: if (clientPoint.Y < m_averageRowHeight)              {                  m_autoScrollUp = true;                  m_autoScrollTimer.Enabled = true;              }              else if (clientPoint.Y >= m_clientSize.Height - m_averageRowHeight)              {                  m_autoScrollUp = false;                  m_autoScrollTimer.Enabled = true;              }              else              {                  m_autoScrollTimer.Enabled = false;                    Node hitNode = GetNodeAt(clientPoint);                  if (hitNode != m_dragHoverNode)                  {                      m_dragHoverExpandTimer.Stop();                      m_dragHoverExpandTimer.Enabled = (hitNode != null);                      m_dragHoverNode = hitNode;                  }                    int y = clientPoint.Y + m_vScroll;                  foreach (Node node in VisibleNodes)                  {                      int rowHeight = GetRowHeight(node);                      if (y <= rowHeight)                      {                          break;                      }                      y -= rowHeight;                  }                    m_dragBetween = y < 5;              }
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: int halfExpanderWidth = expanderSize.Width / 2;
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: int halfExpanderHeight = expanderSize.Height / 2;
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: int halfCheckBoxHeight = m_itemRenderer.CheckBoxSize.Height / 2;
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: List<int> segmentYs = new List<int>(16);
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: foreach (NodeLayoutInfo info in NodeLayout)              {                  Node node = info.Node;                  int rowHeight = GetRowHeight(node);                  int rowCenterY = info.Y + rowHeight / 2;                    if (segmentYs.Count == 0)                      segmentYs.Add(rowHeight - yPadding);                    while (info.Depth != depth)                  {                      if (info.Depth > depth)                      {                          segmentYs.Add(info.Y + rowHeight - yPadding);                          depth = info.Depth;                          break;                      }                      else                      {                          segmentYs.RemoveAt(depth); // remove last                          depth--;                      }                  }                    bool visible = (rowHeight > 0) && (info.Y + rowHeight > 0) && (info.Y < height);                    segmentYs[depth] = info.Y + rowHeight - yPadding;                    // draw expanders and hierarchy lines                  if (depth > 0)                  {                      int yMin = segmentYs[depth - 1];                      int yMax' yNext;                      if (node.IsLeaf)                      {                          yMax = rowCenterY;                          yNext = yMax + 1;                      }                      else                      {                          yMax = Math.Max(rowCenterY - halfExpanderHeight' yMin);                          yNext = rowCenterY + halfExpanderHeight + 1;                      }                      segmentYs[depth - 1] = yNext;                        if (visible)                      {                          m_itemRenderer.DrawBackground(node' g' info.X' info.Y);                      }                        if (yMax >= 0 && yMin <= height && drawHierarchyLines)                      {                          m_itemRenderer.DrawHierarchyLine(g'                              new Point(info.X - Indent + halfExpanderWidth' yMin)'                              new Point(info.X - Indent + halfExpanderWidth' yMax));                      }                        if (visible)                      {                          int stemX = info.X - Indent + halfExpanderWidth;                          if (drawExpanders)                          {                              if (!node.IsLeaf)                              {                                  m_itemRenderer.DrawExpander(node' g' info.X - Indent' rowCenterY - halfExpanderHeight);                                  stemX += halfExpanderWidth + 1;                              }                          }                          else                          {                              if (node.Parent == m_root) // category?                              {                                  Rectangle r = new Rectangle(0' info.Y' right' rowHeight);                                  m_itemRenderer.DrawCategory(node' g' r);                              }                          }                            if (drawHierarchyLines)                          {                              m_itemRenderer.DrawHierarchyLine(g'                                  new Point(stemX' rowCenterY)'                                  new Point(info.X' rowCenterY));                          }                      }                  }                    if (visible)                  {                      numVisibleNodes++;                      visibleNodesHeight += rowHeight;                        // draw optional check box                      if (node.HasCheck)                      {                          m_itemRenderer.DrawCheckBox(node' g' info.X' rowCenterY - halfCheckBoxHeight);                      }                        // draw optional indicator and image                      if (m_stateImageList != null &&                          node.StateImageIndex >= 0 &&                          node.StateImageIndex < m_stateImageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_stateImageList' g' info.StateImageLeft' rowCenterY - m_stateImageList.ImageSize.Height / 2' node.StateImageIndex);                      }                        if (m_imageList != null &&                          node.ImageIndex >= 0 &&                          node.ImageIndex < m_imageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_imageList' g' info.ImageLeft' rowCenterY - m_imageList.ImageSize.Height / 2' node.ImageIndex);                      }                        int filterOffset = 0;                      if (node.PartiallyExpanded)                      {                          filterOffset += m_filterImage.Width;                          g.DrawImage(m_filterImage' info.ImageLeft + m_filterImage.Width' rowCenterY - (m_filterImage.Height + yPadding) / 2);                      }                        // draw label if it's not being edited                      if (node != m_labelEditNode)                      {                          m_itemRenderer.DrawLabel(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      }                        m_itemRenderer.DrawData(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      if (node == dragNode)                      {                           g.DrawLine(Pens.Red'                              new Point(info.X - Indent + halfExpanderWidth' info.Y -2)'                              new Point(info.X - Indent + halfExpanderWidth + 100' info.Y - 2));                      }                  }              }
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: foreach (NodeLayoutInfo info in NodeLayout)              {                  Node node = info.Node;                  int rowHeight = GetRowHeight(node);                  int rowCenterY = info.Y + rowHeight / 2;                    if (segmentYs.Count == 0)                      segmentYs.Add(rowHeight - yPadding);                    while (info.Depth != depth)                  {                      if (info.Depth > depth)                      {                          segmentYs.Add(info.Y + rowHeight - yPadding);                          depth = info.Depth;                          break;                      }                      else                      {                          segmentYs.RemoveAt(depth); // remove last                          depth--;                      }                  }                    bool visible = (rowHeight > 0) && (info.Y + rowHeight > 0) && (info.Y < height);                    segmentYs[depth] = info.Y + rowHeight - yPadding;                    // draw expanders and hierarchy lines                  if (depth > 0)                  {                      int yMin = segmentYs[depth - 1];                      int yMax' yNext;                      if (node.IsLeaf)                      {                          yMax = rowCenterY;                          yNext = yMax + 1;                      }                      else                      {                          yMax = Math.Max(rowCenterY - halfExpanderHeight' yMin);                          yNext = rowCenterY + halfExpanderHeight + 1;                      }                      segmentYs[depth - 1] = yNext;                        if (visible)                      {                          m_itemRenderer.DrawBackground(node' g' info.X' info.Y);                      }                        if (yMax >= 0 && yMin <= height && drawHierarchyLines)                      {                          m_itemRenderer.DrawHierarchyLine(g'                              new Point(info.X - Indent + halfExpanderWidth' yMin)'                              new Point(info.X - Indent + halfExpanderWidth' yMax));                      }                        if (visible)                      {                          int stemX = info.X - Indent + halfExpanderWidth;                          if (drawExpanders)                          {                              if (!node.IsLeaf)                              {                                  m_itemRenderer.DrawExpander(node' g' info.X - Indent' rowCenterY - halfExpanderHeight);                                  stemX += halfExpanderWidth + 1;                              }                          }                          else                          {                              if (node.Parent == m_root) // category?                              {                                  Rectangle r = new Rectangle(0' info.Y' right' rowHeight);                                  m_itemRenderer.DrawCategory(node' g' r);                              }                          }                            if (drawHierarchyLines)                          {                              m_itemRenderer.DrawHierarchyLine(g'                                  new Point(stemX' rowCenterY)'                                  new Point(info.X' rowCenterY));                          }                      }                  }                    if (visible)                  {                      numVisibleNodes++;                      visibleNodesHeight += rowHeight;                        // draw optional check box                      if (node.HasCheck)                      {                          m_itemRenderer.DrawCheckBox(node' g' info.X' rowCenterY - halfCheckBoxHeight);                      }                        // draw optional indicator and image                      if (m_stateImageList != null &&                          node.StateImageIndex >= 0 &&                          node.StateImageIndex < m_stateImageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_stateImageList' g' info.StateImageLeft' rowCenterY - m_stateImageList.ImageSize.Height / 2' node.StateImageIndex);                      }                        if (m_imageList != null &&                          node.ImageIndex >= 0 &&                          node.ImageIndex < m_imageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_imageList' g' info.ImageLeft' rowCenterY - m_imageList.ImageSize.Height / 2' node.ImageIndex);                      }                        int filterOffset = 0;                      if (node.PartiallyExpanded)                      {                          filterOffset += m_filterImage.Width;                          g.DrawImage(m_filterImage' info.ImageLeft + m_filterImage.Width' rowCenterY - (m_filterImage.Height + yPadding) / 2);                      }                        // draw label if it's not being edited                      if (node != m_labelEditNode)                      {                          m_itemRenderer.DrawLabel(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      }                        m_itemRenderer.DrawData(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      if (node == dragNode)                      {                           g.DrawLine(Pens.Red'                              new Point(info.X - Indent + halfExpanderWidth' info.Y -2)'                              new Point(info.X - Indent + halfExpanderWidth + 100' info.Y - 2));                      }                  }              }
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: foreach (NodeLayoutInfo info in NodeLayout)              {                  Node node = info.Node;                  int rowHeight = GetRowHeight(node);                  int rowCenterY = info.Y + rowHeight / 2;                    if (segmentYs.Count == 0)                      segmentYs.Add(rowHeight - yPadding);                    while (info.Depth != depth)                  {                      if (info.Depth > depth)                      {                          segmentYs.Add(info.Y + rowHeight - yPadding);                          depth = info.Depth;                          break;                      }                      else                      {                          segmentYs.RemoveAt(depth); // remove last                          depth--;                      }                  }                    bool visible = (rowHeight > 0) && (info.Y + rowHeight > 0) && (info.Y < height);                    segmentYs[depth] = info.Y + rowHeight - yPadding;                    // draw expanders and hierarchy lines                  if (depth > 0)                  {                      int yMin = segmentYs[depth - 1];                      int yMax' yNext;                      if (node.IsLeaf)                      {                          yMax = rowCenterY;                          yNext = yMax + 1;                      }                      else                      {                          yMax = Math.Max(rowCenterY - halfExpanderHeight' yMin);                          yNext = rowCenterY + halfExpanderHeight + 1;                      }                      segmentYs[depth - 1] = yNext;                        if (visible)                      {                          m_itemRenderer.DrawBackground(node' g' info.X' info.Y);                      }                        if (yMax >= 0 && yMin <= height && drawHierarchyLines)                      {                          m_itemRenderer.DrawHierarchyLine(g'                              new Point(info.X - Indent + halfExpanderWidth' yMin)'                              new Point(info.X - Indent + halfExpanderWidth' yMax));                      }                        if (visible)                      {                          int stemX = info.X - Indent + halfExpanderWidth;                          if (drawExpanders)                          {                              if (!node.IsLeaf)                              {                                  m_itemRenderer.DrawExpander(node' g' info.X - Indent' rowCenterY - halfExpanderHeight);                                  stemX += halfExpanderWidth + 1;                              }                          }                          else                          {                              if (node.Parent == m_root) // category?                              {                                  Rectangle r = new Rectangle(0' info.Y' right' rowHeight);                                  m_itemRenderer.DrawCategory(node' g' r);                              }                          }                            if (drawHierarchyLines)                          {                              m_itemRenderer.DrawHierarchyLine(g'                                  new Point(stemX' rowCenterY)'                                  new Point(info.X' rowCenterY));                          }                      }                  }                    if (visible)                  {                      numVisibleNodes++;                      visibleNodesHeight += rowHeight;                        // draw optional check box                      if (node.HasCheck)                      {                          m_itemRenderer.DrawCheckBox(node' g' info.X' rowCenterY - halfCheckBoxHeight);                      }                        // draw optional indicator and image                      if (m_stateImageList != null &&                          node.StateImageIndex >= 0 &&                          node.StateImageIndex < m_stateImageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_stateImageList' g' info.StateImageLeft' rowCenterY - m_stateImageList.ImageSize.Height / 2' node.StateImageIndex);                      }                        if (m_imageList != null &&                          node.ImageIndex >= 0 &&                          node.ImageIndex < m_imageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_imageList' g' info.ImageLeft' rowCenterY - m_imageList.ImageSize.Height / 2' node.ImageIndex);                      }                        int filterOffset = 0;                      if (node.PartiallyExpanded)                      {                          filterOffset += m_filterImage.Width;                          g.DrawImage(m_filterImage' info.ImageLeft + m_filterImage.Width' rowCenterY - (m_filterImage.Height + yPadding) / 2);                      }                        // draw label if it's not being edited                      if (node != m_labelEditNode)                      {                          m_itemRenderer.DrawLabel(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      }                        m_itemRenderer.DrawData(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      if (node == dragNode)                      {                           g.DrawLine(Pens.Red'                              new Point(info.X - Indent + halfExpanderWidth' info.Y -2)'                              new Point(info.X - Indent + halfExpanderWidth + 100' info.Y - 2));                      }                  }              }
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: foreach (NodeLayoutInfo info in NodeLayout)              {                  Node node = info.Node;                  int rowHeight = GetRowHeight(node);                  int rowCenterY = info.Y + rowHeight / 2;                    if (segmentYs.Count == 0)                      segmentYs.Add(rowHeight - yPadding);                    while (info.Depth != depth)                  {                      if (info.Depth > depth)                      {                          segmentYs.Add(info.Y + rowHeight - yPadding);                          depth = info.Depth;                          break;                      }                      else                      {                          segmentYs.RemoveAt(depth); // remove last                          depth--;                      }                  }                    bool visible = (rowHeight > 0) && (info.Y + rowHeight > 0) && (info.Y < height);                    segmentYs[depth] = info.Y + rowHeight - yPadding;                    // draw expanders and hierarchy lines                  if (depth > 0)                  {                      int yMin = segmentYs[depth - 1];                      int yMax' yNext;                      if (node.IsLeaf)                      {                          yMax = rowCenterY;                          yNext = yMax + 1;                      }                      else                      {                          yMax = Math.Max(rowCenterY - halfExpanderHeight' yMin);                          yNext = rowCenterY + halfExpanderHeight + 1;                      }                      segmentYs[depth - 1] = yNext;                        if (visible)                      {                          m_itemRenderer.DrawBackground(node' g' info.X' info.Y);                      }                        if (yMax >= 0 && yMin <= height && drawHierarchyLines)                      {                          m_itemRenderer.DrawHierarchyLine(g'                              new Point(info.X - Indent + halfExpanderWidth' yMin)'                              new Point(info.X - Indent + halfExpanderWidth' yMax));                      }                        if (visible)                      {                          int stemX = info.X - Indent + halfExpanderWidth;                          if (drawExpanders)                          {                              if (!node.IsLeaf)                              {                                  m_itemRenderer.DrawExpander(node' g' info.X - Indent' rowCenterY - halfExpanderHeight);                                  stemX += halfExpanderWidth + 1;                              }                          }                          else                          {                              if (node.Parent == m_root) // category?                              {                                  Rectangle r = new Rectangle(0' info.Y' right' rowHeight);                                  m_itemRenderer.DrawCategory(node' g' r);                              }                          }                            if (drawHierarchyLines)                          {                              m_itemRenderer.DrawHierarchyLine(g'                                  new Point(stemX' rowCenterY)'                                  new Point(info.X' rowCenterY));                          }                      }                  }                    if (visible)                  {                      numVisibleNodes++;                      visibleNodesHeight += rowHeight;                        // draw optional check box                      if (node.HasCheck)                      {                          m_itemRenderer.DrawCheckBox(node' g' info.X' rowCenterY - halfCheckBoxHeight);                      }                        // draw optional indicator and image                      if (m_stateImageList != null &&                          node.StateImageIndex >= 0 &&                          node.StateImageIndex < m_stateImageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_stateImageList' g' info.StateImageLeft' rowCenterY - m_stateImageList.ImageSize.Height / 2' node.StateImageIndex);                      }                        if (m_imageList != null &&                          node.ImageIndex >= 0 &&                          node.ImageIndex < m_imageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_imageList' g' info.ImageLeft' rowCenterY - m_imageList.ImageSize.Height / 2' node.ImageIndex);                      }                        int filterOffset = 0;                      if (node.PartiallyExpanded)                      {                          filterOffset += m_filterImage.Width;                          g.DrawImage(m_filterImage' info.ImageLeft + m_filterImage.Width' rowCenterY - (m_filterImage.Height + yPadding) / 2);                      }                        // draw label if it's not being edited                      if (node != m_labelEditNode)                      {                          m_itemRenderer.DrawLabel(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      }                        m_itemRenderer.DrawData(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      if (node == dragNode)                      {                           g.DrawLine(Pens.Red'                              new Point(info.X - Indent + halfExpanderWidth' info.Y -2)'                              new Point(info.X - Indent + halfExpanderWidth + 100' info.Y - 2));                      }                  }              }
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: foreach (NodeLayoutInfo info in NodeLayout)              {                  Node node = info.Node;                  int rowHeight = GetRowHeight(node);                  int rowCenterY = info.Y + rowHeight / 2;                    if (segmentYs.Count == 0)                      segmentYs.Add(rowHeight - yPadding);                    while (info.Depth != depth)                  {                      if (info.Depth > depth)                      {                          segmentYs.Add(info.Y + rowHeight - yPadding);                          depth = info.Depth;                          break;                      }                      else                      {                          segmentYs.RemoveAt(depth); // remove last                          depth--;                      }                  }                    bool visible = (rowHeight > 0) && (info.Y + rowHeight > 0) && (info.Y < height);                    segmentYs[depth] = info.Y + rowHeight - yPadding;                    // draw expanders and hierarchy lines                  if (depth > 0)                  {                      int yMin = segmentYs[depth - 1];                      int yMax' yNext;                      if (node.IsLeaf)                      {                          yMax = rowCenterY;                          yNext = yMax + 1;                      }                      else                      {                          yMax = Math.Max(rowCenterY - halfExpanderHeight' yMin);                          yNext = rowCenterY + halfExpanderHeight + 1;                      }                      segmentYs[depth - 1] = yNext;                        if (visible)                      {                          m_itemRenderer.DrawBackground(node' g' info.X' info.Y);                      }                        if (yMax >= 0 && yMin <= height && drawHierarchyLines)                      {                          m_itemRenderer.DrawHierarchyLine(g'                              new Point(info.X - Indent + halfExpanderWidth' yMin)'                              new Point(info.X - Indent + halfExpanderWidth' yMax));                      }                        if (visible)                      {                          int stemX = info.X - Indent + halfExpanderWidth;                          if (drawExpanders)                          {                              if (!node.IsLeaf)                              {                                  m_itemRenderer.DrawExpander(node' g' info.X - Indent' rowCenterY - halfExpanderHeight);                                  stemX += halfExpanderWidth + 1;                              }                          }                          else                          {                              if (node.Parent == m_root) // category?                              {                                  Rectangle r = new Rectangle(0' info.Y' right' rowHeight);                                  m_itemRenderer.DrawCategory(node' g' r);                              }                          }                            if (drawHierarchyLines)                          {                              m_itemRenderer.DrawHierarchyLine(g'                                  new Point(stemX' rowCenterY)'                                  new Point(info.X' rowCenterY));                          }                      }                  }                    if (visible)                  {                      numVisibleNodes++;                      visibleNodesHeight += rowHeight;                        // draw optional check box                      if (node.HasCheck)                      {                          m_itemRenderer.DrawCheckBox(node' g' info.X' rowCenterY - halfCheckBoxHeight);                      }                        // draw optional indicator and image                      if (m_stateImageList != null &&                          node.StateImageIndex >= 0 &&                          node.StateImageIndex < m_stateImageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_stateImageList' g' info.StateImageLeft' rowCenterY - m_stateImageList.ImageSize.Height / 2' node.StateImageIndex);                      }                        if (m_imageList != null &&                          node.ImageIndex >= 0 &&                          node.ImageIndex < m_imageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_imageList' g' info.ImageLeft' rowCenterY - m_imageList.ImageSize.Height / 2' node.ImageIndex);                      }                        int filterOffset = 0;                      if (node.PartiallyExpanded)                      {                          filterOffset += m_filterImage.Width;                          g.DrawImage(m_filterImage' info.ImageLeft + m_filterImage.Width' rowCenterY - (m_filterImage.Height + yPadding) / 2);                      }                        // draw label if it's not being edited                      if (node != m_labelEditNode)                      {                          m_itemRenderer.DrawLabel(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      }                        m_itemRenderer.DrawData(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      if (node == dragNode)                      {                           g.DrawLine(Pens.Red'                              new Point(info.X - Indent + halfExpanderWidth' info.Y -2)'                              new Point(info.X - Indent + halfExpanderWidth + 100' info.Y - 2));                      }                  }              }
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: foreach (NodeLayoutInfo info in NodeLayout)              {                  Node node = info.Node;                  int rowHeight = GetRowHeight(node);                  int rowCenterY = info.Y + rowHeight / 2;                    if (segmentYs.Count == 0)                      segmentYs.Add(rowHeight - yPadding);                    while (info.Depth != depth)                  {                      if (info.Depth > depth)                      {                          segmentYs.Add(info.Y + rowHeight - yPadding);                          depth = info.Depth;                          break;                      }                      else                      {                          segmentYs.RemoveAt(depth); // remove last                          depth--;                      }                  }                    bool visible = (rowHeight > 0) && (info.Y + rowHeight > 0) && (info.Y < height);                    segmentYs[depth] = info.Y + rowHeight - yPadding;                    // draw expanders and hierarchy lines                  if (depth > 0)                  {                      int yMin = segmentYs[depth - 1];                      int yMax' yNext;                      if (node.IsLeaf)                      {                          yMax = rowCenterY;                          yNext = yMax + 1;                      }                      else                      {                          yMax = Math.Max(rowCenterY - halfExpanderHeight' yMin);                          yNext = rowCenterY + halfExpanderHeight + 1;                      }                      segmentYs[depth - 1] = yNext;                        if (visible)                      {                          m_itemRenderer.DrawBackground(node' g' info.X' info.Y);                      }                        if (yMax >= 0 && yMin <= height && drawHierarchyLines)                      {                          m_itemRenderer.DrawHierarchyLine(g'                              new Point(info.X - Indent + halfExpanderWidth' yMin)'                              new Point(info.X - Indent + halfExpanderWidth' yMax));                      }                        if (visible)                      {                          int stemX = info.X - Indent + halfExpanderWidth;                          if (drawExpanders)                          {                              if (!node.IsLeaf)                              {                                  m_itemRenderer.DrawExpander(node' g' info.X - Indent' rowCenterY - halfExpanderHeight);                                  stemX += halfExpanderWidth + 1;                              }                          }                          else                          {                              if (node.Parent == m_root) // category?                              {                                  Rectangle r = new Rectangle(0' info.Y' right' rowHeight);                                  m_itemRenderer.DrawCategory(node' g' r);                              }                          }                            if (drawHierarchyLines)                          {                              m_itemRenderer.DrawHierarchyLine(g'                                  new Point(stemX' rowCenterY)'                                  new Point(info.X' rowCenterY));                          }                      }                  }                    if (visible)                  {                      numVisibleNodes++;                      visibleNodesHeight += rowHeight;                        // draw optional check box                      if (node.HasCheck)                      {                          m_itemRenderer.DrawCheckBox(node' g' info.X' rowCenterY - halfCheckBoxHeight);                      }                        // draw optional indicator and image                      if (m_stateImageList != null &&                          node.StateImageIndex >= 0 &&                          node.StateImageIndex < m_stateImageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_stateImageList' g' info.StateImageLeft' rowCenterY - m_stateImageList.ImageSize.Height / 2' node.StateImageIndex);                      }                        if (m_imageList != null &&                          node.ImageIndex >= 0 &&                          node.ImageIndex < m_imageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_imageList' g' info.ImageLeft' rowCenterY - m_imageList.ImageSize.Height / 2' node.ImageIndex);                      }                        int filterOffset = 0;                      if (node.PartiallyExpanded)                      {                          filterOffset += m_filterImage.Width;                          g.DrawImage(m_filterImage' info.ImageLeft + m_filterImage.Width' rowCenterY - (m_filterImage.Height + yPadding) / 2);                      }                        // draw label if it's not being edited                      if (node != m_labelEditNode)                      {                          m_itemRenderer.DrawLabel(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      }                        m_itemRenderer.DrawData(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      if (node == dragNode)                      {                           g.DrawLine(Pens.Red'                              new Point(info.X - Indent + halfExpanderWidth' info.Y -2)'                              new Point(info.X - Indent + halfExpanderWidth + 100' info.Y - 2));                      }                  }              }
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: foreach (NodeLayoutInfo info in NodeLayout)              {                  Node node = info.Node;                  int rowHeight = GetRowHeight(node);                  int rowCenterY = info.Y + rowHeight / 2;                    if (segmentYs.Count == 0)                      segmentYs.Add(rowHeight - yPadding);                    while (info.Depth != depth)                  {                      if (info.Depth > depth)                      {                          segmentYs.Add(info.Y + rowHeight - yPadding);                          depth = info.Depth;                          break;                      }                      else                      {                          segmentYs.RemoveAt(depth); // remove last                          depth--;                      }                  }                    bool visible = (rowHeight > 0) && (info.Y + rowHeight > 0) && (info.Y < height);                    segmentYs[depth] = info.Y + rowHeight - yPadding;                    // draw expanders and hierarchy lines                  if (depth > 0)                  {                      int yMin = segmentYs[depth - 1];                      int yMax' yNext;                      if (node.IsLeaf)                      {                          yMax = rowCenterY;                          yNext = yMax + 1;                      }                      else                      {                          yMax = Math.Max(rowCenterY - halfExpanderHeight' yMin);                          yNext = rowCenterY + halfExpanderHeight + 1;                      }                      segmentYs[depth - 1] = yNext;                        if (visible)                      {                          m_itemRenderer.DrawBackground(node' g' info.X' info.Y);                      }                        if (yMax >= 0 && yMin <= height && drawHierarchyLines)                      {                          m_itemRenderer.DrawHierarchyLine(g'                              new Point(info.X - Indent + halfExpanderWidth' yMin)'                              new Point(info.X - Indent + halfExpanderWidth' yMax));                      }                        if (visible)                      {                          int stemX = info.X - Indent + halfExpanderWidth;                          if (drawExpanders)                          {                              if (!node.IsLeaf)                              {                                  m_itemRenderer.DrawExpander(node' g' info.X - Indent' rowCenterY - halfExpanderHeight);                                  stemX += halfExpanderWidth + 1;                              }                          }                          else                          {                              if (node.Parent == m_root) // category?                              {                                  Rectangle r = new Rectangle(0' info.Y' right' rowHeight);                                  m_itemRenderer.DrawCategory(node' g' r);                              }                          }                            if (drawHierarchyLines)                          {                              m_itemRenderer.DrawHierarchyLine(g'                                  new Point(stemX' rowCenterY)'                                  new Point(info.X' rowCenterY));                          }                      }                  }                    if (visible)                  {                      numVisibleNodes++;                      visibleNodesHeight += rowHeight;                        // draw optional check box                      if (node.HasCheck)                      {                          m_itemRenderer.DrawCheckBox(node' g' info.X' rowCenterY - halfCheckBoxHeight);                      }                        // draw optional indicator and image                      if (m_stateImageList != null &&                          node.StateImageIndex >= 0 &&                          node.StateImageIndex < m_stateImageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_stateImageList' g' info.StateImageLeft' rowCenterY - m_stateImageList.ImageSize.Height / 2' node.StateImageIndex);                      }                        if (m_imageList != null &&                          node.ImageIndex >= 0 &&                          node.ImageIndex < m_imageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_imageList' g' info.ImageLeft' rowCenterY - m_imageList.ImageSize.Height / 2' node.ImageIndex);                      }                        int filterOffset = 0;                      if (node.PartiallyExpanded)                      {                          filterOffset += m_filterImage.Width;                          g.DrawImage(m_filterImage' info.ImageLeft + m_filterImage.Width' rowCenterY - (m_filterImage.Height + yPadding) / 2);                      }                        // draw label if it's not being edited                      if (node != m_labelEditNode)                      {                          m_itemRenderer.DrawLabel(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      }                        m_itemRenderer.DrawData(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      if (node == dragNode)                      {                           g.DrawLine(Pens.Red'                              new Point(info.X - Indent + halfExpanderWidth' info.Y -2)'                              new Point(info.X - Indent + halfExpanderWidth + 100' info.Y - 2));                      }                  }              }
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: foreach (NodeLayoutInfo info in NodeLayout)              {                  Node node = info.Node;                  int rowHeight = GetRowHeight(node);                  int rowCenterY = info.Y + rowHeight / 2;                    if (segmentYs.Count == 0)                      segmentYs.Add(rowHeight - yPadding);                    while (info.Depth != depth)                  {                      if (info.Depth > depth)                      {                          segmentYs.Add(info.Y + rowHeight - yPadding);                          depth = info.Depth;                          break;                      }                      else                      {                          segmentYs.RemoveAt(depth); // remove last                          depth--;                      }                  }                    bool visible = (rowHeight > 0) && (info.Y + rowHeight > 0) && (info.Y < height);                    segmentYs[depth] = info.Y + rowHeight - yPadding;                    // draw expanders and hierarchy lines                  if (depth > 0)                  {                      int yMin = segmentYs[depth - 1];                      int yMax' yNext;                      if (node.IsLeaf)                      {                          yMax = rowCenterY;                          yNext = yMax + 1;                      }                      else                      {                          yMax = Math.Max(rowCenterY - halfExpanderHeight' yMin);                          yNext = rowCenterY + halfExpanderHeight + 1;                      }                      segmentYs[depth - 1] = yNext;                        if (visible)                      {                          m_itemRenderer.DrawBackground(node' g' info.X' info.Y);                      }                        if (yMax >= 0 && yMin <= height && drawHierarchyLines)                      {                          m_itemRenderer.DrawHierarchyLine(g'                              new Point(info.X - Indent + halfExpanderWidth' yMin)'                              new Point(info.X - Indent + halfExpanderWidth' yMax));                      }                        if (visible)                      {                          int stemX = info.X - Indent + halfExpanderWidth;                          if (drawExpanders)                          {                              if (!node.IsLeaf)                              {                                  m_itemRenderer.DrawExpander(node' g' info.X - Indent' rowCenterY - halfExpanderHeight);                                  stemX += halfExpanderWidth + 1;                              }                          }                          else                          {                              if (node.Parent == m_root) // category?                              {                                  Rectangle r = new Rectangle(0' info.Y' right' rowHeight);                                  m_itemRenderer.DrawCategory(node' g' r);                              }                          }                            if (drawHierarchyLines)                          {                              m_itemRenderer.DrawHierarchyLine(g'                                  new Point(stemX' rowCenterY)'                                  new Point(info.X' rowCenterY));                          }                      }                  }                    if (visible)                  {                      numVisibleNodes++;                      visibleNodesHeight += rowHeight;                        // draw optional check box                      if (node.HasCheck)                      {                          m_itemRenderer.DrawCheckBox(node' g' info.X' rowCenterY - halfCheckBoxHeight);                      }                        // draw optional indicator and image                      if (m_stateImageList != null &&                          node.StateImageIndex >= 0 &&                          node.StateImageIndex < m_stateImageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_stateImageList' g' info.StateImageLeft' rowCenterY - m_stateImageList.ImageSize.Height / 2' node.StateImageIndex);                      }                        if (m_imageList != null &&                          node.ImageIndex >= 0 &&                          node.ImageIndex < m_imageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_imageList' g' info.ImageLeft' rowCenterY - m_imageList.ImageSize.Height / 2' node.ImageIndex);                      }                        int filterOffset = 0;                      if (node.PartiallyExpanded)                      {                          filterOffset += m_filterImage.Width;                          g.DrawImage(m_filterImage' info.ImageLeft + m_filterImage.Width' rowCenterY - (m_filterImage.Height + yPadding) / 2);                      }                        // draw label if it's not being edited                      if (node != m_labelEditNode)                      {                          m_itemRenderer.DrawLabel(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      }                        m_itemRenderer.DrawData(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      if (node == dragNode)                      {                           g.DrawLine(Pens.Red'                              new Point(info.X - Indent + halfExpanderWidth' info.Y -2)'                              new Point(info.X - Indent + halfExpanderWidth + 100' info.Y - 2));                      }                  }              }
Magic Number,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnPaint,The following statement contains a magic number: foreach (NodeLayoutInfo info in NodeLayout)              {                  Node node = info.Node;                  int rowHeight = GetRowHeight(node);                  int rowCenterY = info.Y + rowHeight / 2;                    if (segmentYs.Count == 0)                      segmentYs.Add(rowHeight - yPadding);                    while (info.Depth != depth)                  {                      if (info.Depth > depth)                      {                          segmentYs.Add(info.Y + rowHeight - yPadding);                          depth = info.Depth;                          break;                      }                      else                      {                          segmentYs.RemoveAt(depth); // remove last                          depth--;                      }                  }                    bool visible = (rowHeight > 0) && (info.Y + rowHeight > 0) && (info.Y < height);                    segmentYs[depth] = info.Y + rowHeight - yPadding;                    // draw expanders and hierarchy lines                  if (depth > 0)                  {                      int yMin = segmentYs[depth - 1];                      int yMax' yNext;                      if (node.IsLeaf)                      {                          yMax = rowCenterY;                          yNext = yMax + 1;                      }                      else                      {                          yMax = Math.Max(rowCenterY - halfExpanderHeight' yMin);                          yNext = rowCenterY + halfExpanderHeight + 1;                      }                      segmentYs[depth - 1] = yNext;                        if (visible)                      {                          m_itemRenderer.DrawBackground(node' g' info.X' info.Y);                      }                        if (yMax >= 0 && yMin <= height && drawHierarchyLines)                      {                          m_itemRenderer.DrawHierarchyLine(g'                              new Point(info.X - Indent + halfExpanderWidth' yMin)'                              new Point(info.X - Indent + halfExpanderWidth' yMax));                      }                        if (visible)                      {                          int stemX = info.X - Indent + halfExpanderWidth;                          if (drawExpanders)                          {                              if (!node.IsLeaf)                              {                                  m_itemRenderer.DrawExpander(node' g' info.X - Indent' rowCenterY - halfExpanderHeight);                                  stemX += halfExpanderWidth + 1;                              }                          }                          else                          {                              if (node.Parent == m_root) // category?                              {                                  Rectangle r = new Rectangle(0' info.Y' right' rowHeight);                                  m_itemRenderer.DrawCategory(node' g' r);                              }                          }                            if (drawHierarchyLines)                          {                              m_itemRenderer.DrawHierarchyLine(g'                                  new Point(stemX' rowCenterY)'                                  new Point(info.X' rowCenterY));                          }                      }                  }                    if (visible)                  {                      numVisibleNodes++;                      visibleNodesHeight += rowHeight;                        // draw optional check box                      if (node.HasCheck)                      {                          m_itemRenderer.DrawCheckBox(node' g' info.X' rowCenterY - halfCheckBoxHeight);                      }                        // draw optional indicator and image                      if (m_stateImageList != null &&                          node.StateImageIndex >= 0 &&                          node.StateImageIndex < m_stateImageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_stateImageList' g' info.StateImageLeft' rowCenterY - m_stateImageList.ImageSize.Height / 2' node.StateImageIndex);                      }                        if (m_imageList != null &&                          node.ImageIndex >= 0 &&                          node.ImageIndex < m_imageList.Images.Count)                      {                          m_itemRenderer.DrawImage(m_imageList' g' info.ImageLeft' rowCenterY - m_imageList.ImageSize.Height / 2' node.ImageIndex);                      }                        int filterOffset = 0;                      if (node.PartiallyExpanded)                      {                          filterOffset += m_filterImage.Width;                          g.DrawImage(m_filterImage' info.ImageLeft + m_filterImage.Width' rowCenterY - (m_filterImage.Height + yPadding) / 2);                      }                        // draw label if it's not being edited                      if (node != m_labelEditNode)                      {                          m_itemRenderer.DrawLabel(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      }                        m_itemRenderer.DrawData(node' g' info.LabelLeft + filterOffset' rowCenterY - node.LabelHeight / 2);                      if (node == dragNode)                      {                           g.DrawLine(Pens.Red'                              new Point(info.X - Indent + halfExpanderWidth' info.Y -2)'                              new Point(info.X - Indent + halfExpanderWidth + 100' info.Y - 2));                      }                  }              }
Magic Number,Sce.Atf.Controls,TreeItemRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,MeasureDisplayStringWidth,The following statement contains a magic number: RectangleF rect = new RectangleF(0' 0' 1600' 1600);
Magic Number,Sce.Atf.Controls,TreeItemRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,MeasureDisplayStringWidth,The following statement contains a magic number: RectangleF rect = new RectangleF(0' 0' 1600' 1600);
Magic Number,Sce.Atf.Controls,TreeItemRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,DrawLabel,The following statement contains a magic number: if (!string.IsNullOrEmpty(FilteringPattern) && node.Label != null)              {                  int regularStart = 0;                  int matchStart;                  PointF textLoc = new PointF(textRect.X' textRect.Y);                    do                  {                      // highlight the background of matched text                       matchStart = node.Label.IndexOf(FilteringPattern' regularStart' StringComparison.CurrentCultureIgnoreCase);                      if (matchStart >= 0)                      {                          // non-matched substring                           string regularString = node.Label.Substring(regularStart' matchStart - regularStart);                          SizeF regularSize = MeasureDisplayStringWidth(g' regularString' font);                          textLoc.X += regularSize.Width;                          regularStart = matchStart + FilteringPattern.Length; // advance string offset                            // matched substring                           string matchedString = node.Label.Substring(matchStart' FilteringPattern.Length);                          SizeF matchedSize = MeasureDisplayStringWidth(g' matchedString' font);                          RectangleF matchedRect = new RectangleF(textLoc' matchedSize);                            // offset a couple of pixels to avoid obvious overlap with preceding char                          matchedRect.X += 2;                          matchedRect.Width -= 2;                          g.FillRectangle(MatchedHighlightBrush' matchedRect);                          textLoc.X += matchedSize.Width;                      }                  } while (matchStart >= 0);              }
Magic Number,Sce.Atf.Controls,TreeItemRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,DrawLabel,The following statement contains a magic number: if (!string.IsNullOrEmpty(FilteringPattern) && node.Label != null)              {                  int regularStart = 0;                  int matchStart;                  PointF textLoc = new PointF(textRect.X' textRect.Y);                    do                  {                      // highlight the background of matched text                       matchStart = node.Label.IndexOf(FilteringPattern' regularStart' StringComparison.CurrentCultureIgnoreCase);                      if (matchStart >= 0)                      {                          // non-matched substring                           string regularString = node.Label.Substring(regularStart' matchStart - regularStart);                          SizeF regularSize = MeasureDisplayStringWidth(g' regularString' font);                          textLoc.X += regularSize.Width;                          regularStart = matchStart + FilteringPattern.Length; // advance string offset                            // matched substring                           string matchedString = node.Label.Substring(matchStart' FilteringPattern.Length);                          SizeF matchedSize = MeasureDisplayStringWidth(g' matchedString' font);                          RectangleF matchedRect = new RectangleF(textLoc' matchedSize);                            // offset a couple of pixels to avoid obvious overlap with preceding char                          matchedRect.X += 2;                          matchedRect.Width -= 2;                          g.FillRectangle(MatchedHighlightBrush' matchedRect);                          textLoc.X += matchedSize.Width;                      }                  } while (matchStart >= 0);              }
Magic Number,Sce.Atf.Controls,TreeItemRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,DrawBackground,The following statement contains a magic number: if (FilteringStatus != null && !string.IsNullOrEmpty(FilteringPattern))              {                  if ((FilteringStatus(node) & NodeFilteringStatus.Visible) == 0)                  {                      Rectangle bgRect = new Rectangle(Owner.Margin.Left' Owner.Margin.Top + y'                      Owner.Width - Owner.Margin.Left - Owner.Margin.Right' node.LabelHeight + Owner.Margin.Top + Owner.Margin.Bottom);                      bgRect.Y -= 3;                      g.FillRectangle(NoMatchHighlightBrush' bgRect);                  }              }
Magic Number,Sce.Atf.Controls,TreeItemRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,DrawCheckBox,The following statement contains a magic number: if (node.CheckState == CheckState.Indeterminate)              {   // draw indeterminate state.                  Brush fillBrush = SystemBrushes.Window;                  Brush fillBrush2 = node.CheckBoxEnabled ? SystemBrushes.ControlText : SystemBrushes.GrayText;                  Pen borderPen = node.CheckBoxEnabled ? SystemPens.ControlDark : SystemPens.InactiveBorder;                  var rect = Rectangle.Inflate(bounds'-1' -1);                  g.FillRectangle(fillBrush' rect);                  var rect2 = Rectangle.Inflate(bounds'-4' -4);                  g.FillRectangle(fillBrush2' rect2);                  g.DrawRectangle(borderPen' rect.X' rect.Y' rect.Width - 1' rect.Height - 1);                                               }              else              {                  var buttonState = ButtonState.Flat;                  if (node.CheckState == CheckState.Checked)                      buttonState |= ButtonState.Checked;                  if (!node.CheckBoxEnabled)                      buttonState |= ButtonState.Inactive;                  ControlPaint.DrawCheckBox(g' bounds' buttonState);              }
Magic Number,Sce.Atf.Controls,TreeItemRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,DrawCheckBox,The following statement contains a magic number: if (node.CheckState == CheckState.Indeterminate)              {   // draw indeterminate state.                  Brush fillBrush = SystemBrushes.Window;                  Brush fillBrush2 = node.CheckBoxEnabled ? SystemBrushes.ControlText : SystemBrushes.GrayText;                  Pen borderPen = node.CheckBoxEnabled ? SystemPens.ControlDark : SystemPens.InactiveBorder;                  var rect = Rectangle.Inflate(bounds'-1' -1);                  g.FillRectangle(fillBrush' rect);                  var rect2 = Rectangle.Inflate(bounds'-4' -4);                  g.FillRectangle(fillBrush2' rect2);                  g.DrawRectangle(borderPen' rect.X' rect.Y' rect.Width - 1' rect.Height - 1);                                               }              else              {                  var buttonState = ButtonState.Flat;                  if (node.CheckState == CheckState.Checked)                      buttonState |= ButtonState.Checked;                  if (!node.CheckBoxEnabled)                      buttonState |= ButtonState.Inactive;                  ControlPaint.DrawCheckBox(g' bounds' buttonState);              }
Magic Number,Sce.Atf.Controls,ChristmasTreeRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,ChristmasTreeRenderer,The following statement contains a magic number: ExpanderSize = new Size(16' 8);
Magic Number,Sce.Atf.Controls,ChristmasTreeRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,ChristmasTreeRenderer,The following statement contains a magic number: ExpanderSize = new Size(16' 8);
Magic Number,Sce.Atf.Controls,ChristmasTreeRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,ChristmasTreeRenderer,The following statement contains a magic number: CheckBoxSize = new Size(40' 32);
Magic Number,Sce.Atf.Controls,ChristmasTreeRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,ChristmasTreeRenderer,The following statement contains a magic number: CheckBoxSize = new Size(40' 32);
Magic Number,Sce.Atf.Controls,ChristmasTreeRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,DrawExpander,The following statement contains a magic number: Size lineLength = new Size(ExpanderSize.Width - 2' ExpanderSize.Height - 2);
Magic Number,Sce.Atf.Controls,ChristmasTreeRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,DrawExpander,The following statement contains a magic number: Size lineLength = new Size(ExpanderSize.Width - 2' ExpanderSize.Height - 2);
Magic Number,Sce.Atf.Controls,ChristmasTreeRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,DrawExpander,The following statement contains a magic number: Point center = new Point(ExpanderSize.Width / 2' ExpanderSize.Height / 2);
Magic Number,Sce.Atf.Controls,ChristmasTreeRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeItemRenderer.cs,DrawExpander,The following statement contains a magic number: Point center = new Point(ExpanderSize.Width / 2' ExpanderSize.Height / 2);
Magic Number,Sce.Atf.Controls,TreeListControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListControl.cs,TreeListControl,The following statement contains a magic number: ContentVerticalOffset = FontHeight+2;
Magic Number,Sce.Atf.Controls,TreeListControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListControl.cs,OnPaint,The following statement contains a magic number: if (Columns.Count > 0)              {                  for (int i = 0; i < Columns.Count; ++i)                  {                      var column = Columns[i];                      Rectangle textRect = new Rectangle(leftOffset + 3' Margin.Top' column.ActualWidth' ContentVerticalOffset);                      if (i== Columns.Count-1)                          textRect.Width = ActualClientSize.Width - leftOffset; // extends last column                       e.Graphics.DrawString(column.Label' Font' TreeListItemRenderer.TextBrush' textRect);                        // draw vertical separator                       e.Graphics.DrawLine(m_seperatorPen' leftOffset' Margin.Top' leftOffset' ContentVerticalOffset);                      leftOffset += column.ActualWidth;                    }                  // draw horizontal separator                   e.Graphics.DrawLine(m_seperatorPen' 0' ContentVerticalOffset + 2' ActualClientSize.Width'                      ContentVerticalOffset + 2);              }
Magic Number,Sce.Atf.Controls,TreeListControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListControl.cs,OnPaint,The following statement contains a magic number: if (Columns.Count > 0)              {                  for (int i = 0; i < Columns.Count; ++i)                  {                      var column = Columns[i];                      Rectangle textRect = new Rectangle(leftOffset + 3' Margin.Top' column.ActualWidth' ContentVerticalOffset);                      if (i== Columns.Count-1)                          textRect.Width = ActualClientSize.Width - leftOffset; // extends last column                       e.Graphics.DrawString(column.Label' Font' TreeListItemRenderer.TextBrush' textRect);                        // draw vertical separator                       e.Graphics.DrawLine(m_seperatorPen' leftOffset' Margin.Top' leftOffset' ContentVerticalOffset);                      leftOffset += column.ActualWidth;                    }                  // draw horizontal separator                   e.Graphics.DrawLine(m_seperatorPen' 0' ContentVerticalOffset + 2' ActualClientSize.Width'                      ContentVerticalOffset + 2);              }
Magic Number,Sce.Atf.Controls,TreeListControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListControl.cs,OnPaint,The following statement contains a magic number: if (Columns.Count > 0)              {                  for (int i = 0; i < Columns.Count; ++i)                  {                      var column = Columns[i];                      Rectangle textRect = new Rectangle(leftOffset + 3' Margin.Top' column.ActualWidth' ContentVerticalOffset);                      if (i== Columns.Count-1)                          textRect.Width = ActualClientSize.Width - leftOffset; // extends last column                       e.Graphics.DrawString(column.Label' Font' TreeListItemRenderer.TextBrush' textRect);                        // draw vertical separator                       e.Graphics.DrawLine(m_seperatorPen' leftOffset' Margin.Top' leftOffset' ContentVerticalOffset);                      leftOffset += column.ActualWidth;                    }                  // draw horizontal separator                   e.Graphics.DrawLine(m_seperatorPen' 0' ContentVerticalOffset + 2' ActualClientSize.Width'                      ContentVerticalOffset + 2);              }
Magic Number,Sce.Atf.Controls,TreeListControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListControl.cs,HitColumnSeperator,The following statement contains a magic number: if (y < ContentVerticalOffset)              {                  if (Columns.Count > 0) // hit a column separator                   {                      int left = TreeWidth;                        for (int i = 0; i < Columns.Count; ++i)                      {                          var column = Columns[i];                          if ( x <= (left + 2) && x >= (left - 2))                              return i;                          left += column.ActualWidth;                      }                  }              }
Magic Number,Sce.Atf.Controls,TreeListControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListControl.cs,HitColumnSeperator,The following statement contains a magic number: if (y < ContentVerticalOffset)              {                  if (Columns.Count > 0) // hit a column separator                   {                      int left = TreeWidth;                        for (int i = 0; i < Columns.Count; ++i)                      {                          var column = Columns[i];                          if ( x <= (left + 2) && x >= (left - 2))                              return i;                          left += column.ActualWidth;                      }                  }              }
Magic Number,Sce.Atf.Controls,TreeListControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListControl.cs,ResizeColumn,The following statement contains a magic number: if (m_currentColumn >= 0)              {                  int delta = m_currentPoint.X - m_firstPoint.X;                  if (m_currentColumn == 0)                      m_treeWidth = m_currentPoint.X;                  else                  {                      int newWitdh = m_oldColumnWidths[m_currentColumn] - delta;                      const int minWidth = 8;                      if (newWitdh >= minWidth)                      {                            // need to adjust preceding column width                          int adjust = m_oldColumnWidths[m_currentColumn - 1] + delta;                          if (adjust < minWidth)                          {                              newWitdh += adjust;                              if (newWitdh < minWidth)                                  return;                              adjust = minWidth;                          }                          Columns[m_currentColumn - 1].ActualWidth = adjust;                          Columns[m_currentColumn].ActualWidth = newWitdh;                        }                  }                    Invalidate();               }
Magic Number,Sce.Atf.Controls,TreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.Column.cs,TreeListView,The following statement contains a magic number: if (style == Style.VirtualList)              {                  m_control.VirtualMode = true;                  m_control.RetrieveVirtualItem += ControlRetrieveVirtualItem;                  m_control.SelectedIndexChanged += ControlSelectedIndexChanged;              }              else              {                  m_control.ColumnClick += ControlColumnClick;                  m_control.ItemSelectionChanged += ControlItemSelectionChanged;                    m_sortTimer = new Timer {Interval = 200};                  m_sortTimer.Tick += SortTimerTick;                  m_sortTimer.Start();              }
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,ListTreeViewDrawSubItem,The following statement contains a magic number: if (e.ColumnIndex == 0)                  {                      {                          // Limit area                          Rectangle bounds =                              new Rectangle(                                  e.Bounds.X'                                  e.Bounds.Y'                                  ExtraneousItemWidth'                                  e.Bounds.Height);                            switch (m_style)                          {                              case Style.CheckedList:                                  Renderer.DrawCheckBox(node' e.Graphics' bounds);                                  node.CheckBoxHitRect = bounds;                                  offset += ExtraneousItemWidth;                                  break;                                case Style.CheckedTreeList:                                  DrawExtraneousStuff(e' ref offset' ExpanderGradient' ExpanderPen' HierarchyLinePen);                                  offset += 2;                                  bounds.Offset(offset' 2);                                  Renderer.DrawCheckBox(node' e.Graphics' bounds);                                  node.CheckBoxHitRect = bounds;                                  offset += ExtraneousItemWidth;                                  break;                                case Style.TreeList:                                  DrawExtraneousStuff(e' ref offset' ExpanderGradient' ExpanderPen' HierarchyLinePen);                                  break;                                default:                                  offset += ExtraneousItemWidth;                                  break;                          }                      }                        // Move over slightly and draw state image (if applicable)                      {                          if ((StateImageList != null) &&                              (node.StateImageIndex != InvalidImageIndex))                          {                              Rectangle bounds =                                  new Rectangle(                                      e.Bounds.X + offset'                                      e.Bounds.Y'                                      ExtraneousItemWidth'                                      e.Bounds.Height);                                Renderer.DrawStateImage(node' e.Graphics' bounds);                              offset += ExtraneousItemWidth;                          }                      }                        // Move over slightly and draw image                      {                          Rectangle bounds =                              new Rectangle(                                  e.Bounds.X + offset'                                  e.Bounds.Y'                                  ExtraneousItemWidth'                                  e.Bounds.Height);                            Renderer.DrawImage(node' e.Graphics' bounds);                          offset += ExtraneousItemWidth;                      }                  }
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,ListTreeViewDrawSubItem,The following statement contains a magic number: if (e.ColumnIndex == 0)                  {                      {                          // Limit area                          Rectangle bounds =                              new Rectangle(                                  e.Bounds.X'                                  e.Bounds.Y'                                  ExtraneousItemWidth'                                  e.Bounds.Height);                            switch (m_style)                          {                              case Style.CheckedList:                                  Renderer.DrawCheckBox(node' e.Graphics' bounds);                                  node.CheckBoxHitRect = bounds;                                  offset += ExtraneousItemWidth;                                  break;                                case Style.CheckedTreeList:                                  DrawExtraneousStuff(e' ref offset' ExpanderGradient' ExpanderPen' HierarchyLinePen);                                  offset += 2;                                  bounds.Offset(offset' 2);                                  Renderer.DrawCheckBox(node' e.Graphics' bounds);                                  node.CheckBoxHitRect = bounds;                                  offset += ExtraneousItemWidth;                                  break;                                case Style.TreeList:                                  DrawExtraneousStuff(e' ref offset' ExpanderGradient' ExpanderPen' HierarchyLinePen);                                  break;                                default:                                  offset += ExtraneousItemWidth;                                  break;                          }                      }                        // Move over slightly and draw state image (if applicable)                      {                          if ((StateImageList != null) &&                              (node.StateImageIndex != InvalidImageIndex))                          {                              Rectangle bounds =                                  new Rectangle(                                      e.Bounds.X + offset'                                      e.Bounds.Y'                                      ExtraneousItemWidth'                                      e.Bounds.Height);                                Renderer.DrawStateImage(node' e.Graphics' bounds);                              offset += ExtraneousItemWidth;                          }                      }                        // Move over slightly and draw image                      {                          Rectangle bounds =                              new Rectangle(                                  e.Bounds.X + offset'                                  e.Bounds.Y'                                  ExtraneousItemWidth'                                  e.Bounds.Height);                            Renderer.DrawImage(node' e.Graphics' bounds);                          offset += ExtraneousItemWidth;                      }                  }
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawExtraneousStuff,The following statement contains a magic number: for (int i = 0; i < nodeThis.Level; i++)                  {                      //                      // Set stuff up for the current iteration                      //                        Point posCur = new Point(e.Item.Bounds.X + iOffset' e.Item.Bounds.Y);                      Size sizeCur = new Size(ExtraneousItemWidth' e.Item.Bounds.Height);                      Rectangle rectBounds = new Rectangle(posCur' sizeCur);                        //                      // Try to do some drawing                      //                        // Try and find an expanded item above us (tells us                      // what type of line we need to draw - if any)                      Node nodeRelative;                      FindExpandedRelativeAboveAtLevel(nodeThis' i + 1' out nodeRelative);                        if (nodeRelative != null)                      {                          if (nodeRelative == nodeThis.Parent)                              DrawElbow(e.Graphics' rectBounds' hierarchyLinePen' bHasSibling);                      }                        // Check for drawing vertical line(s)                      {                          bool bDrawVerticalLine = false;                            // Find ancestor that's one level above the "current"                          // (ie. i + 1) level and see if they have a sibling                          Node nodeTemp;                          FindExpandedRelativeAboveAtLevel(nodeThis' i + 2' out nodeTemp);                            if (nodeTemp != null)                          {                              Node nodeTempSibling;                              FindSibling(nodeTemp' out nodeTempSibling);                                if (nodeTempSibling != null)                                  bDrawVerticalLine = true;                          }                            if (bDrawVerticalLine)                              DrawVerticalLine(e.Graphics' rectBounds' hierarchyLinePen);                      }                        // Check if need an expander/collapser                      bool bDrawExpanderCollapser =                          (i == (nodeThis.Level - 1)) &&                          (nodeThis.HasChildren || !nodeThis.IsLeaf);                        // Draw expander/collapser                      if (bDrawExpanderCollapser)                      {                          if (nodeThis.Expanded)                              DrawCollapser(e.Graphics' rectBounds' expanderGradient' expanderPen' hierarchyLinePen' bHasChild);                          else                              DrawExpander(e.Graphics' rectBounds' expanderGradient' expanderPen' hierarchyLinePen);                            // Set the are that can be clicked                          nodeThis.HitRect = rectBounds;                      }                        // Check if horizontal line needed                      bool bDrawHorizontalLine =                          (i == (nodeThis.Level - 1)) &&                          (i > 0) &&                          !bDrawExpanderCollapser;                        if (bDrawHorizontalLine)                          DrawHorizontalLine(e.Graphics' rectBounds' hierarchyLinePen);                        // Keep indenting                      iOffset += ExtraneousItemWidth;                  }
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawExpander,The following statement contains a magic number: const int iRectOffset = 5;
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawExpander,The following statement contains a magic number: const int iTwoTimesRectOffset = iRectOffset * 2;
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawExpander,The following statement contains a magic number: const int iLineOffset = 3;
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawExpander,The following statement contains a magic number: Point center =                      new Point(                          bounds.X + (bounds.Width / 2)'                          bounds.Y + (bounds.Height / 2));
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawExpander,The following statement contains a magic number: Point center =                      new Point(                          bounds.X + (bounds.Width / 2)'                          bounds.Y + (bounds.Height / 2));
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawCollapser,The following statement contains a magic number: const int iRectOffset = 5;
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawCollapser,The following statement contains a magic number: const int iTwoTimesRectOffset = iRectOffset * 2;
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawCollapser,The following statement contains a magic number: const int iLineOffset = 3;
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawCollapser,The following statement contains a magic number: Point center =                      new Point(                          bounds.X + (bounds.Width / 2)'                          bounds.Y + (bounds.Height / 2));
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawCollapser,The following statement contains a magic number: Point center =                      new Point(                          bounds.X + (bounds.Width / 2)'                          bounds.Y + (bounds.Height / 2));
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawVerticalLine,The following statement contains a magic number: Point center =                      new Point(                          bounds.X + (bounds.Width / 2)'                          bounds.Y + (bounds.Height / 2));
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawVerticalLine,The following statement contains a magic number: Point center =                      new Point(                          bounds.X + (bounds.Width / 2)'                          bounds.Y + (bounds.Height / 2));
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawElbow,The following statement contains a magic number: Point center =                      new Point(                          bounds.X + (bounds.Width / 2)'                          bounds.Y + (bounds.Height / 2));
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawElbow,The following statement contains a magic number: Point center =                      new Point(                          bounds.X + (bounds.Width / 2)'                          bounds.Y + (bounds.Height / 2));
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawHorizontalLine,The following statement contains a magic number: Point center =                      new Point(                          bounds.X + (bounds.Width / 2)'                          bounds.Y + (bounds.Height / 2));
Magic Number,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,DrawHorizontalLine,The following statement contains a magic number: Point center =                      new Point(                          bounds.X + (bounds.Width / 2)'                          bounds.Y + (bounds.Height / 2));
Magic Number,Sce.Atf.Controls,BalloonToolTipHelper,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\WindowLayoutNewDialog.cs,BalloonToolTipHelper,The following statement contains a magic number: m_toolTip =                  new ToolTip                      {                          IsBalloon = true'                          ReshowDelay = 9999'                          ShowAlways = true'                          UseFading = true                      };
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < m_colorPresets.Length; ++i)              {                  var cmdInfo = m_commandService.RegisterCommand(                                  m_colorPresets[i]'                                  StandardMenu.Edit'                                  StandardCommandGroup.EditOther'                                  m_colorPresets[i].Name'                                  m_colorPresets[i].Name'                                  Keys.None'                                  null'                                  CommandVisibility.ContextMenu'                                  this);                    var menuItem = cmdInfo.GetMenuItem();                  menuItem.Image = CreateBackColorIcon(m_colorPresets[i].Color' 24' 24);              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,Initialize,The following statement contains a magic number: for (int i = 0; i < m_colorPresets.Length; ++i)              {                  var cmdInfo = m_commandService.RegisterCommand(                                  m_colorPresets[i]'                                  StandardMenu.Edit'                                  StandardCommandGroup.EditOther'                                  m_colorPresets[i].Name'                                  m_colorPresets[i].Name'                                  Keys.None'                                  null'                                  CommandVisibility.ContextMenu'                                  this);                    var menuItem = cmdInfo.GetMenuItem();                  menuItem.Image = CreateBackColorIcon(m_colorPresets[i].Color' 24' 24);              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,InitColorPresets,The following statement contains a magic number: if (m_colorPresets == null)              {                  m_colorPresets = new ColorPreset[6];                  m_colorPresets[0] = new ColorPreset()                  {                      Name = "Yellow".Localize()'                      Color = SystemColors.Info                  };                  m_colorPresets[1] = new ColorPreset()                  {                      Name = "Blue".Localize()'                      Color = Color.LightSkyBlue                  };                  m_colorPresets[2] = new ColorPreset()                  {                      Name = "Green".Localize()'                      Color = Color.FromArgb(178' 255' 161)                  };                  m_colorPresets[3] = new ColorPreset()                  {                      Name = "Pink".Localize()'                      Color = Color.LightPink                  };                  m_colorPresets[4] = new ColorPreset()                  {                      Name = "Purple".Localize()'                      Color = Color.FromArgb(182' 202' 255)                  };                  m_colorPresets[5] = new ColorPreset()                  {                      Name = "Gray".Localize()'                      Color = Color.LightGray                  };              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,InitColorPresets,The following statement contains a magic number: if (m_colorPresets == null)              {                  m_colorPresets = new ColorPreset[6];                  m_colorPresets[0] = new ColorPreset()                  {                      Name = "Yellow".Localize()'                      Color = SystemColors.Info                  };                  m_colorPresets[1] = new ColorPreset()                  {                      Name = "Blue".Localize()'                      Color = Color.LightSkyBlue                  };                  m_colorPresets[2] = new ColorPreset()                  {                      Name = "Green".Localize()'                      Color = Color.FromArgb(178' 255' 161)                  };                  m_colorPresets[3] = new ColorPreset()                  {                      Name = "Pink".Localize()'                      Color = Color.LightPink                  };                  m_colorPresets[4] = new ColorPreset()                  {                      Name = "Purple".Localize()'                      Color = Color.FromArgb(182' 202' 255)                  };                  m_colorPresets[5] = new ColorPreset()                  {                      Name = "Gray".Localize()'                      Color = Color.LightGray                  };              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,InitColorPresets,The following statement contains a magic number: if (m_colorPresets == null)              {                  m_colorPresets = new ColorPreset[6];                  m_colorPresets[0] = new ColorPreset()                  {                      Name = "Yellow".Localize()'                      Color = SystemColors.Info                  };                  m_colorPresets[1] = new ColorPreset()                  {                      Name = "Blue".Localize()'                      Color = Color.LightSkyBlue                  };                  m_colorPresets[2] = new ColorPreset()                  {                      Name = "Green".Localize()'                      Color = Color.FromArgb(178' 255' 161)                  };                  m_colorPresets[3] = new ColorPreset()                  {                      Name = "Pink".Localize()'                      Color = Color.LightPink                  };                  m_colorPresets[4] = new ColorPreset()                  {                      Name = "Purple".Localize()'                      Color = Color.FromArgb(182' 202' 255)                  };                  m_colorPresets[5] = new ColorPreset()                  {                      Name = "Gray".Localize()'                      Color = Color.LightGray                  };              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,InitColorPresets,The following statement contains a magic number: if (m_colorPresets == null)              {                  m_colorPresets = new ColorPreset[6];                  m_colorPresets[0] = new ColorPreset()                  {                      Name = "Yellow".Localize()'                      Color = SystemColors.Info                  };                  m_colorPresets[1] = new ColorPreset()                  {                      Name = "Blue".Localize()'                      Color = Color.LightSkyBlue                  };                  m_colorPresets[2] = new ColorPreset()                  {                      Name = "Green".Localize()'                      Color = Color.FromArgb(178' 255' 161)                  };                  m_colorPresets[3] = new ColorPreset()                  {                      Name = "Pink".Localize()'                      Color = Color.LightPink                  };                  m_colorPresets[4] = new ColorPreset()                  {                      Name = "Purple".Localize()'                      Color = Color.FromArgb(182' 202' 255)                  };                  m_colorPresets[5] = new ColorPreset()                  {                      Name = "Gray".Localize()'                      Color = Color.LightGray                  };              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,InitColorPresets,The following statement contains a magic number: if (m_colorPresets == null)              {                  m_colorPresets = new ColorPreset[6];                  m_colorPresets[0] = new ColorPreset()                  {                      Name = "Yellow".Localize()'                      Color = SystemColors.Info                  };                  m_colorPresets[1] = new ColorPreset()                  {                      Name = "Blue".Localize()'                      Color = Color.LightSkyBlue                  };                  m_colorPresets[2] = new ColorPreset()                  {                      Name = "Green".Localize()'                      Color = Color.FromArgb(178' 255' 161)                  };                  m_colorPresets[3] = new ColorPreset()                  {                      Name = "Pink".Localize()'                      Color = Color.LightPink                  };                  m_colorPresets[4] = new ColorPreset()                  {                      Name = "Purple".Localize()'                      Color = Color.FromArgb(182' 202' 255)                  };                  m_colorPresets[5] = new ColorPreset()                  {                      Name = "Gray".Localize()'                      Color = Color.LightGray                  };              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,InitColorPresets,The following statement contains a magic number: if (m_colorPresets == null)              {                  m_colorPresets = new ColorPreset[6];                  m_colorPresets[0] = new ColorPreset()                  {                      Name = "Yellow".Localize()'                      Color = SystemColors.Info                  };                  m_colorPresets[1] = new ColorPreset()                  {                      Name = "Blue".Localize()'                      Color = Color.LightSkyBlue                  };                  m_colorPresets[2] = new ColorPreset()                  {                      Name = "Green".Localize()'                      Color = Color.FromArgb(178' 255' 161)                  };                  m_colorPresets[3] = new ColorPreset()                  {                      Name = "Pink".Localize()'                      Color = Color.LightPink                  };                  m_colorPresets[4] = new ColorPreset()                  {                      Name = "Purple".Localize()'                      Color = Color.FromArgb(182' 202' 255)                  };                  m_colorPresets[5] = new ColorPreset()                  {                      Name = "Gray".Localize()'                      Color = Color.LightGray                  };              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,InitColorPresets,The following statement contains a magic number: if (m_colorPresets == null)              {                  m_colorPresets = new ColorPreset[6];                  m_colorPresets[0] = new ColorPreset()                  {                      Name = "Yellow".Localize()'                      Color = SystemColors.Info                  };                  m_colorPresets[1] = new ColorPreset()                  {                      Name = "Blue".Localize()'                      Color = Color.LightSkyBlue                  };                  m_colorPresets[2] = new ColorPreset()                  {                      Name = "Green".Localize()'                      Color = Color.FromArgb(178' 255' 161)                  };                  m_colorPresets[3] = new ColorPreset()                  {                      Name = "Pink".Localize()'                      Color = Color.LightPink                  };                  m_colorPresets[4] = new ColorPreset()                  {                      Name = "Purple".Localize()'                      Color = Color.FromArgb(182' 202' 255)                  };                  m_colorPresets[5] = new ColorPreset()                  {                      Name = "Gray".Localize()'                      Color = Color.LightGray                  };              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,InitColorPresets,The following statement contains a magic number: if (m_colorPresets == null)              {                  m_colorPresets = new ColorPreset[6];                  m_colorPresets[0] = new ColorPreset()                  {                      Name = "Yellow".Localize()'                      Color = SystemColors.Info                  };                  m_colorPresets[1] = new ColorPreset()                  {                      Name = "Blue".Localize()'                      Color = Color.LightSkyBlue                  };                  m_colorPresets[2] = new ColorPreset()                  {                      Name = "Green".Localize()'                      Color = Color.FromArgb(178' 255' 161)                  };                  m_colorPresets[3] = new ColorPreset()                  {                      Name = "Pink".Localize()'                      Color = Color.LightPink                  };                  m_colorPresets[4] = new ColorPreset()                  {                      Name = "Purple".Localize()'                      Color = Color.FromArgb(182' 202' 255)                  };                  m_colorPresets[5] = new ColorPreset()                  {                      Name = "Gray".Localize()'                      Color = Color.LightGray                  };              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,InitColorPresets,The following statement contains a magic number: if (m_colorPresets == null)              {                  m_colorPresets = new ColorPreset[6];                  m_colorPresets[0] = new ColorPreset()                  {                      Name = "Yellow".Localize()'                      Color = SystemColors.Info                  };                  m_colorPresets[1] = new ColorPreset()                  {                      Name = "Blue".Localize()'                      Color = Color.LightSkyBlue                  };                  m_colorPresets[2] = new ColorPreset()                  {                      Name = "Green".Localize()'                      Color = Color.FromArgb(178' 255' 161)                  };                  m_colorPresets[3] = new ColorPreset()                  {                      Name = "Pink".Localize()'                      Color = Color.LightPink                  };                  m_colorPresets[4] = new ColorPreset()                  {                      Name = "Purple".Localize()'                      Color = Color.FromArgb(182' 202' 255)                  };                  m_colorPresets[5] = new ColorPreset()                  {                      Name = "Gray".Localize()'                      Color = Color.LightGray                  };              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,InitColorPresets,The following statement contains a magic number: if (m_colorPresets == null)              {                  m_colorPresets = new ColorPreset[6];                  m_colorPresets[0] = new ColorPreset()                  {                      Name = "Yellow".Localize()'                      Color = SystemColors.Info                  };                  m_colorPresets[1] = new ColorPreset()                  {                      Name = "Blue".Localize()'                      Color = Color.LightSkyBlue                  };                  m_colorPresets[2] = new ColorPreset()                  {                      Name = "Green".Localize()'                      Color = Color.FromArgb(178' 255' 161)                  };                  m_colorPresets[3] = new ColorPreset()                  {                      Name = "Pink".Localize()'                      Color = Color.LightPink                  };                  m_colorPresets[4] = new ColorPreset()                  {                      Name = "Purple".Localize()'                      Color = Color.FromArgb(182' 202' 255)                  };                  m_colorPresets[5] = new ColorPreset()                  {                      Name = "Gray".Localize()'                      Color = Color.LightGray                  };              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotatingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotatingCommands.cs,InitColorPresets,The following statement contains a magic number: if (m_colorPresets == null)              {                  m_colorPresets = new ColorPreset[6];                  m_colorPresets[0] = new ColorPreset()                  {                      Name = "Yellow".Localize()'                      Color = SystemColors.Info                  };                  m_colorPresets[1] = new ColorPreset()                  {                      Name = "Blue".Localize()'                      Color = Color.LightSkyBlue                  };                  m_colorPresets[2] = new ColorPreset()                  {                      Name = "Green".Localize()'                      Color = Color.FromArgb(178' 255' 161)                  };                  m_colorPresets[3] = new ColorPreset()                  {                      Name = "Pink".Localize()'                      Color = Color.LightPink                  };                  m_colorPresets[4] = new ColorPreset()                  {                      Name = "Purple".Localize()'                      Color = Color.FromArgb(182' 202' 255)                  };                  m_colorPresets[5] = new ColorPreset()                  {                      Name = "Gray".Localize()'                      Color = Color.LightGray                  };              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotationAdapter.cs,Pick,The following statement contains a magic number: if (m_annotatedDiagram != null)              {                  if (m_transformAdapter != null)                      p = GdiUtil.InverseTransform(m_transformAdapter.Transform' p);                    foreach (IAnnotation annotation in m_annotatedDiagram.Annotations)                  {                      Rectangle bounds = GetBounds(annotation);                      int tolerance = m_theme.PickTolerance;                      bounds.Inflate(tolerance' tolerance);                      if (bounds.Contains(p))                      {                          bounds.Inflate(tolerance * -2' tolerance * -2);                          DiagramLabel label = null;                          if (bounds.Contains(p))                              label = new DiagramLabel(bounds' TextFormatFlags.Default);                                                    return new AnnotationHitEventArgs(annotation' label);                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotationAdapter.cs,Pick,The following statement contains a magic number: if (m_annotatedDiagram != null)              {                  if (m_transformAdapter != null)                      p = GdiUtil.InverseTransform(m_transformAdapter.Transform' p);                    foreach (IAnnotation annotation in m_annotatedDiagram.Annotations)                  {                      Rectangle bounds = GetBounds(annotation);                      int tolerance = m_theme.PickTolerance;                      bounds.Inflate(tolerance' tolerance);                      if (bounds.Contains(p))                      {                          bounds.Inflate(tolerance * -2' tolerance * -2);                          DiagramLabel label = null;                          if (bounds.Contains(p))                              label = new DiagramLabel(bounds' TextFormatFlags.Default);                                                    return new AnnotationHitEventArgs(annotation' label);                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotationAdapter.cs,control_Paint,The following statement contains a magic number: if (m_transformAdapter != null)              {                  // modify the transform so it is only a translation and uniform scale                  oldTransform = e.Graphics.Transform;                  float[] m = m_transformAdapter.Transform.Elements;                  float scale = Math.Min(m[0]' m[3]);                  Matrix newTransform = new Matrix(scale' m[1]' m[2]' scale' m[4]' m[5]);                  g.Transform = newTransform;                    delta = GdiUtil.InverseTransformVector(newTransform' delta);              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotationAdapter.cs,control_Paint,The following statement contains a magic number: if (m_transformAdapter != null)              {                  // modify the transform so it is only a translation and uniform scale                  oldTransform = e.Graphics.Transform;                  float[] m = m_transformAdapter.Transform.Elements;                  float scale = Math.Min(m[0]' m[3]);                  Matrix newTransform = new Matrix(scale' m[1]' m[2]' scale' m[4]' m[5]);                  g.Transform = newTransform;                    delta = GdiUtil.InverseTransformVector(newTransform' delta);              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotationAdapter.cs,control_Paint,The following statement contains a magic number: if (m_transformAdapter != null)              {                  // modify the transform so it is only a translation and uniform scale                  oldTransform = e.Graphics.Transform;                  float[] m = m_transformAdapter.Transform.Elements;                  float scale = Math.Min(m[0]' m[3]);                  Matrix newTransform = new Matrix(scale' m[1]' m[2]' scale' m[4]' m[5]);                  g.Transform = newTransform;                    delta = GdiUtil.InverseTransformVector(newTransform' delta);              }
Magic Number,Sce.Atf.Controls.Adaptable,AnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AnnotationAdapter.cs,control_Paint,The following statement contains a magic number: if (m_transformAdapter != null)              {                  // modify the transform so it is only a translation and uniform scale                  oldTransform = e.Graphics.Transform;                  float[] m = m_transformAdapter.Transform.Elements;                  float scale = Math.Min(m[0]' m[3]);                  Matrix newTransform = new Matrix(scale' m[1]' m[2]' scale' m[4]' m[5]);                  g.Transform = newTransform;                    delta = GdiUtil.InverseTransformVector(newTransform' delta);              }
Magic Number,Sce.Atf.Controls.Adaptable,AutoTranslateAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AutoTranslateAdapter.cs,AutoTranslateAdapter,The following statement contains a magic number: m_timer.Interval = 10;
Magic Number,Sce.Atf.Controls.Adaptable,AutoTranslateAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\AutoTranslateAdapter.cs,timer_Tick,The following statement contains a magic number: if (!AdaptedControl.ClientRectangle.Contains(m_mousePosition))              {                  const int Speed = 10;                    int dx = 0;                  if (m_mousePosition.X < 0)                      dx = Speed;                  else if (m_mousePosition.X > AdaptedControl.Width)                      dx = -Speed;                    int dy = 0;                  if (m_mousePosition.Y < 0)                      dy = Speed;                  else if (m_mousePosition.Y > AdaptedControl.Height)                      dy = -Speed;                    PointF translation = m_transformAdapter.Translation;                  m_transformAdapter.Translation = new PointF(translation.X + dx' translation.Y + dy);                    m_timer.Start();              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,D2dAnnotationAdapter,The following statement contains a magic number: m_solidBrush = D2dFactory.CreateSolidBrush(Color.FromArgb(128' 120' 120' 120));
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,D2dAnnotationAdapter,The following statement contains a magic number: m_solidBrush = D2dFactory.CreateSolidBrush(Color.FromArgb(128' 120' 120' 120));
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,D2dAnnotationAdapter,The following statement contains a magic number: m_solidBrush = D2dFactory.CreateSolidBrush(Color.FromArgb(128' 120' 120' 120));
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,D2dAnnotationAdapter,The following statement contains a magic number: m_solidBrush = D2dFactory.CreateSolidBrush(Color.FromArgb(128' 120' 120' 120));
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,Pick,The following statement contains a magic number: if (m_annotatedDiagram != null && !PickingDisabled)              {                  if (m_transformAdapter != null)                      p = GdiUtil.InverseTransform(m_transformAdapter.Transform' p);                    foreach (IAnnotation annotation in m_annotatedDiagram.Annotations.Reverse())                  {                        TextEditor textEditor;                      m_annotationEditors.TryGetValue(annotation' out textEditor);                      Rectangle bounds = GetBounds(annotation);                      if (bounds.IsEmpty && textEditor == null)                          continue;                      var inflated = bounds;                      int tolerance = m_theme.PickTolerance;                      inflated.Inflate(tolerance' tolerance);                        if (!inflated.Contains(p)) continue;                        Rectangle contentRect = bounds;                      contentRect.X += Margin.Left;                      contentRect.Y += Margin.Right;                      contentRect.Size -= Margin.Size;                      if (contentRect.Contains(p))                      {                                                    // check scroll bar                          if (textEditor != null && textEditor.VerticalScrollBarVisibe)                          {                              var scrollbarRect = new Rectangle(bounds.Right - Margin.Right - ScrollBarWidth - 2 * ScrollBarMargin' bounds.Y'                                  ScrollBarWidth + 2 * ScrollBarMargin' bounds.Height);                              if (scrollbarRect.Contains(p))                                  return new AnnotationHitEventArgs(annotation' new DiagramScrollBar(annotation' Orientation.Vertical));                          }                            //var textBounds = new Rectangle(contentRect.X' contentRect.Y'                          //    contentRect.Width' contentRect.Height);                            var textBounds = contentRect;                          DiagramLabel label = new DiagramLabel(textBounds' TextFormatFlags.LeftAndRightPadding);                            PointF origin = textEditor != null ?                              new PointF(contentRect.X' contentRect.Y - textEditor.GetLineYOffset(textEditor.TopLine))                          : contentRect.Location;                          var result = new AnnotationHitEventArgs(annotation' label);                          result.Position = new PointF(p.X - origin.X' p.Y - origin.Y);                          return result;                      }                        //// check titlebar                      //var titlebarRect = new RectangleF(bounds.Left + 2 * tolerance' bounds.Y - tolerance'                      //    bounds.Width - 4 * tolerance' Margin.Top + tolerance);                      //if (titlebarRect.Contains(p))                      //{                      //    return new AnnotationHitEventArgs(annotation' new DiagramTitleBar(annotation));                      //}                        // margin between inflated bounds and content bound.                      int leftPad = contentRect.X - inflated.X;                      int rightPad = inflated.Right - contentRect.Right;                      int topPad = contentRect.Y - inflated.Y;                      int bottomPad = inflated.Bottom - contentRect.Bottom;                          // lower right                      var corner = new Rectangle(contentRect.Right' contentRect.Bottom' rightPad' bottomPad);                      if (corner.Contains(p))                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.LowerRightCorner                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                                              // upper left                      corner = new Rectangle(inflated.X' inflated.Y' leftPad' topPad);                      if (corner.Contains(p))                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.UpperLeftCorner                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                                              // upper right                      corner = new Rectangle(contentRect.Right' inflated.Y' rightPad' topPad);                      if (corner.Contains(p))                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.UpperRightCorner                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                        // lower left.                      corner = new Rectangle(inflated.X' contentRect.Bottom' leftPad' bottomPad);                      if (corner.Contains(p))                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.LowerLeftCorner                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                          // right border.                      if (p.X >= contentRect.Right)                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.Right                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                      // bottom border                      if (p.Y >= contentRect.Bottom)                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.Bottom                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                        // left border                      if (p.X <= contentRect.X)                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.Left                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                          // top border                      if (p.Y <= contentRect.Y)                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.Top                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                        }                                  }              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,Pick,The following statement contains a magic number: if (m_annotatedDiagram != null && !PickingDisabled)              {                  if (m_transformAdapter != null)                      p = GdiUtil.InverseTransform(m_transformAdapter.Transform' p);                    foreach (IAnnotation annotation in m_annotatedDiagram.Annotations.Reverse())                  {                        TextEditor textEditor;                      m_annotationEditors.TryGetValue(annotation' out textEditor);                      Rectangle bounds = GetBounds(annotation);                      if (bounds.IsEmpty && textEditor == null)                          continue;                      var inflated = bounds;                      int tolerance = m_theme.PickTolerance;                      inflated.Inflate(tolerance' tolerance);                        if (!inflated.Contains(p)) continue;                        Rectangle contentRect = bounds;                      contentRect.X += Margin.Left;                      contentRect.Y += Margin.Right;                      contentRect.Size -= Margin.Size;                      if (contentRect.Contains(p))                      {                                                    // check scroll bar                          if (textEditor != null && textEditor.VerticalScrollBarVisibe)                          {                              var scrollbarRect = new Rectangle(bounds.Right - Margin.Right - ScrollBarWidth - 2 * ScrollBarMargin' bounds.Y'                                  ScrollBarWidth + 2 * ScrollBarMargin' bounds.Height);                              if (scrollbarRect.Contains(p))                                  return new AnnotationHitEventArgs(annotation' new DiagramScrollBar(annotation' Orientation.Vertical));                          }                            //var textBounds = new Rectangle(contentRect.X' contentRect.Y'                          //    contentRect.Width' contentRect.Height);                            var textBounds = contentRect;                          DiagramLabel label = new DiagramLabel(textBounds' TextFormatFlags.LeftAndRightPadding);                            PointF origin = textEditor != null ?                              new PointF(contentRect.X' contentRect.Y - textEditor.GetLineYOffset(textEditor.TopLine))                          : contentRect.Location;                          var result = new AnnotationHitEventArgs(annotation' label);                          result.Position = new PointF(p.X - origin.X' p.Y - origin.Y);                          return result;                      }                        //// check titlebar                      //var titlebarRect = new RectangleF(bounds.Left + 2 * tolerance' bounds.Y - tolerance'                      //    bounds.Width - 4 * tolerance' Margin.Top + tolerance);                      //if (titlebarRect.Contains(p))                      //{                      //    return new AnnotationHitEventArgs(annotation' new DiagramTitleBar(annotation));                      //}                        // margin between inflated bounds and content bound.                      int leftPad = contentRect.X - inflated.X;                      int rightPad = inflated.Right - contentRect.Right;                      int topPad = contentRect.Y - inflated.Y;                      int bottomPad = inflated.Bottom - contentRect.Bottom;                          // lower right                      var corner = new Rectangle(contentRect.Right' contentRect.Bottom' rightPad' bottomPad);                      if (corner.Contains(p))                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.LowerRightCorner                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                                              // upper left                      corner = new Rectangle(inflated.X' inflated.Y' leftPad' topPad);                      if (corner.Contains(p))                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.UpperLeftCorner                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                                              // upper right                      corner = new Rectangle(contentRect.Right' inflated.Y' rightPad' topPad);                      if (corner.Contains(p))                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.UpperRightCorner                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                        // lower left.                      corner = new Rectangle(inflated.X' contentRect.Bottom' leftPad' bottomPad);                      if (corner.Contains(p))                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.LowerLeftCorner                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                          // right border.                      if (p.X >= contentRect.Right)                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.Right                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                      // bottom border                      if (p.Y >= contentRect.Bottom)                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.Bottom                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                        // left border                      if (p.X <= contentRect.X)                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.Left                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                      }                          // top border                      if (p.Y <= contentRect.Y)                      {                          var borderPart = new DiagramBorder(annotation)                          {                              Border = DiagramBorder.BorderType.Top                          };                          return new AnnotationHitEventArgs(annotation' borderPart);                        }                                  }              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_Paint,The following statement contains a magic number: foreach (IAnnotation annotation in m_annotatedDiagram.Annotations)              {                  Rectangle bounds = annotation.Bounds;                  if (bounds.Size.IsEmpty)                  {                      if (string.IsNullOrEmpty(annotation.Text))                      {                          annotation.SetTextSize(new Size(180'100));                      }                      else                      {                          // calculate size of text block                          SizeF textSizeF = gfx.MeasureText(annotation.Text' m_theme.TextFormat);                          Size textSize = new Size((int)Math.Ceiling(textSizeF.Width)' (int)Math.Ceiling(textSizeF.Height));                          textSize.Width += 2 * Margin.Size.Width;                          textSize.Height += 2 * Margin.Size.Height;                          bounds.Size = textSize;                          annotation.SetTextSize(textSize);                      }                                       }                  if (!graphBound.IntersectsWith(bounds))                      continue;                    DiagramDrawingStyle style = DiagramDrawingStyle.Normal;                  if (m_selectionContext.SelectionContains(annotation))                  {                      style = DiagramDrawingStyle.Selected;                      if (m_selectionContext.GetLastSelected<IAnnotation>() == annotation)                          style = DiagramDrawingStyle.LastSelected;                  }                    DrawAnnotation(annotation' style' gfx' drawText' graphBound);              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_Paint,The following statement contains a magic number: foreach (IAnnotation annotation in m_annotatedDiagram.Annotations)              {                  Rectangle bounds = annotation.Bounds;                  if (bounds.Size.IsEmpty)                  {                      if (string.IsNullOrEmpty(annotation.Text))                      {                          annotation.SetTextSize(new Size(180'100));                      }                      else                      {                          // calculate size of text block                          SizeF textSizeF = gfx.MeasureText(annotation.Text' m_theme.TextFormat);                          Size textSize = new Size((int)Math.Ceiling(textSizeF.Width)' (int)Math.Ceiling(textSizeF.Height));                          textSize.Width += 2 * Margin.Size.Width;                          textSize.Height += 2 * Margin.Size.Height;                          bounds.Size = textSize;                          annotation.SetTextSize(textSize);                      }                                       }                  if (!graphBound.IntersectsWith(bounds))                      continue;                    DiagramDrawingStyle style = DiagramDrawingStyle.Normal;                  if (m_selectionContext.SelectionContains(annotation))                  {                      style = DiagramDrawingStyle.Selected;                      if (m_selectionContext.GetLastSelected<IAnnotation>() == annotation)                          style = DiagramDrawingStyle.LastSelected;                  }                    DrawAnnotation(annotation' style' gfx' drawText' graphBound);              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_Paint,The following statement contains a magic number: foreach (IAnnotation annotation in m_annotatedDiagram.Annotations)              {                  Rectangle bounds = annotation.Bounds;                  if (bounds.Size.IsEmpty)                  {                      if (string.IsNullOrEmpty(annotation.Text))                      {                          annotation.SetTextSize(new Size(180'100));                      }                      else                      {                          // calculate size of text block                          SizeF textSizeF = gfx.MeasureText(annotation.Text' m_theme.TextFormat);                          Size textSize = new Size((int)Math.Ceiling(textSizeF.Width)' (int)Math.Ceiling(textSizeF.Height));                          textSize.Width += 2 * Margin.Size.Width;                          textSize.Height += 2 * Margin.Size.Height;                          bounds.Size = textSize;                          annotation.SetTextSize(textSize);                      }                                       }                  if (!graphBound.IntersectsWith(bounds))                      continue;                    DiagramDrawingStyle style = DiagramDrawingStyle.Normal;                  if (m_selectionContext.SelectionContains(annotation))                  {                      style = DiagramDrawingStyle.Selected;                      if (m_selectionContext.GetLastSelected<IAnnotation>() == annotation)                          style = DiagramDrawingStyle.LastSelected;                  }                    DrawAnnotation(annotation' style' gfx' drawText' graphBound);              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_Paint,The following statement contains a magic number: foreach (IAnnotation annotation in m_annotatedDiagram.Annotations)              {                  Rectangle bounds = annotation.Bounds;                  if (bounds.Size.IsEmpty)                  {                      if (string.IsNullOrEmpty(annotation.Text))                      {                          annotation.SetTextSize(new Size(180'100));                      }                      else                      {                          // calculate size of text block                          SizeF textSizeF = gfx.MeasureText(annotation.Text' m_theme.TextFormat);                          Size textSize = new Size((int)Math.Ceiling(textSizeF.Width)' (int)Math.Ceiling(textSizeF.Height));                          textSize.Width += 2 * Margin.Size.Width;                          textSize.Height += 2 * Margin.Size.Height;                          bounds.Size = textSize;                          annotation.SetTextSize(textSize);                      }                                       }                  if (!graphBound.IntersectsWith(bounds))                      continue;                    DiagramDrawingStyle style = DiagramDrawingStyle.Normal;                  if (m_selectionContext.SelectionContains(annotation))                  {                      style = DiagramDrawingStyle.Selected;                      if (m_selectionContext.GetLastSelected<IAnnotation>() == annotation)                          style = DiagramDrawingStyle.LastSelected;                  }                    DrawAnnotation(annotation' style' gfx' drawText' graphBound);              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,DrawAnnotation,The following statement contains a magic number: if (drawText)              {                  var contentBounds = new RectangleF(bounds.X + Margin.Left' bounds.Y + Margin.Top'                                                 bounds.Width - Margin.Size.Width' bounds.Height - Margin.Size.Height);                  contentBounds.Width = Math.Max(contentBounds.Width' MinimumWidth);                  contentBounds.Height = Math.Max(contentBounds.Height' MinimumHeight);                  var textBounds = contentBounds;                                    TextEditor textEditor;                  if (!m_annotationEditors.TryGetValue(annotation'out textEditor))                  {                      // first assume no v-scroll bar needed                      var textLayout = D2dFactory.CreateTextLayout(annotation.Text' m_theme.TextFormat' contentBounds.Width' contentBounds.Height);                      if (m_theme.TextFormat.Underlined)                          textLayout.SetUnderline(true' 0' annotation.Text.Length);                      if (m_theme.TextFormat.Strikeout)                          textLayout.SetStrikethrough(true' 0' annotation.Text.Length);                        if (textLayout.Height >  textLayout.LayoutHeight) // need v-scroll bar                      {                          textLayout.LayoutWidth = contentBounds.Width - ScrollBarWidth - 2 * ScrollBarMargin;                                              }                        textEditor = new TextEditor                      {                          TextLayout = textLayout'                          TextFormat = m_theme.TextFormat'                          TopLine =  0'                          VerticalScrollBarVisibe = textLayout.Height > textLayout.LayoutHeight                      };                      m_annotationEditors.Add(annotation' textEditor);                                          }                  else if (textEditor.TextLayout.Text != annotation.Text) // text content changed' for example' undo'redo                  {                                      textEditor.ResetText(annotation.Text);                                      }                    int topLine = textEditor.TopLine;                  textEditor.VerticalScrollBarVisibe = textEditor.TextLayout.Height > textEditor.TextLayout.LayoutHeight;                    if (textEditor.VerticalScrollBarVisibe)                      textBounds.Width -= ScrollBarWidth + 2 * ScrollBarMargin;                  if (Math.Abs(textEditor.TextLayout.LayoutWidth - textBounds.Width) +                      Math.Abs(textEditor.TextLayout.LayoutHeight - textBounds.Height) > 1.0)                  {                      textEditor.TextLayout.LayoutWidth = textBounds.Width; // layout width and height can be updated                      textEditor.TextLayout.LayoutHeight = textBounds.Height;                      textEditor.Validate();                  }                    float yOffset = textEditor.GetLineYOffset(topLine);                                  PointF origin = new PointF(contentBounds.Location.X' contentBounds.Location.Y - yOffset);                    g.PushAxisAlignedClip(contentBounds);                                       // adjust caret.                  // pull out this code to the caller.                  if ( annotation == m_editingAnnotation  && m_caretCreated)                  {                                          var caretRect = textEditor.GetCaretRect();                      caretRect.Offset(origin);                                         // set Windows caret position                                        if (contentBounds.IntersectsWith(caretRect) && AdaptedControl.Focused)                      {                          Matrix3x2F xform = m_transformAdapter != null ? m_transformAdapter.Transform                              : g.Transform;                          var caretClientRect = Matrix3x2F.Transform(xform' caretRect);                          float ratio = m_scaleX*m_theme.TextFormat.FontHeight/CaretHeight;                                                if (ratio > 1.1f || ratio < 0.9f) // adjust caret height                          {                              CaretHeight = (int)(m_scaleX*m_theme.TextFormat.FontHeight);                              User32.DestroyCaret();                              User32.CreateCaret(AdaptedControl.Handle' IntPtr.Zero' CaretWidth' CaretHeight);                          }                          // align bottom                              User32.SetCaretPos((int) caretClientRect.X' (int)(caretClientRect.Y + caretClientRect.Height - CaretHeight));                          if (!m_rmbPressed)                              AdaptedControl.HasKeyboardFocus = true;                      }                      else                          HideCaret();                  }                    // draw the selection range above the text.                  if (textEditor.SelectionLength > 0)                  {                      D2dBrush hibrush = AdaptedControl.Focused ? m_theme.TextHighlightBrush : m_solidBrush;                      var hitTestMetrics = textEditor.TextLayout.HitTestTextRange(textEditor.SelectionStart' textEditor.SelectionLength' 0' 0);                      for (int i = 0; i < hitTestMetrics.Length; ++i)                      {                          var highlightRect = new RectangleF(hitTestMetrics[i].Point.X' hitTestMetrics[i].Point.Y' hitTestMetrics[i].Width'                                                             hitTestMetrics[i].Height);                          highlightRect.Offset(origin);                          g.FillRectangle(highlightRect' hibrush);                      }                  }                                    // draw text                   g.DrawTextLayout(origin' textEditor.TextLayout' foreColor);                                        g.PopAxisAlignedClip();                    // draw v-scroll bar                 // if (contentBounds.Height < textEditor.TextLayout.Height)                  if(textEditor.VerticalScrollBarVisibe)                  {                      float visibleLines = textEditor.GetVisibleLines();                      float vMin = topLine * contentBounds.Height / textEditor.TextLayout.LineCount;                      float vMax = (topLine + visibleLines - 1) * contentBounds.Height / textEditor.TextLayout.LineCount;                     // if (m_scrolling)                     // {                          var trackBounds = new RectangleF(contentBounds.Right - ScrollBarMargin - ScrollBarWidth' contentBounds.Y' ScrollBarWidth' contentBounds.Height);                          g.FillRectangle(trackBounds' Color.Gainsboro);                                         // }                      var thumbBounds = new RectangleF(contentBounds.Right - ScrollBarMargin - ScrollBarWidth' contentBounds.Y + vMin' ScrollBarWidth' vMax - vMin);                      g.FillRectangle(thumbBounds' Color.DimGray);                  }                              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,DrawAnnotation,The following statement contains a magic number: if (drawText)              {                  var contentBounds = new RectangleF(bounds.X + Margin.Left' bounds.Y + Margin.Top'                                                 bounds.Width - Margin.Size.Width' bounds.Height - Margin.Size.Height);                  contentBounds.Width = Math.Max(contentBounds.Width' MinimumWidth);                  contentBounds.Height = Math.Max(contentBounds.Height' MinimumHeight);                  var textBounds = contentBounds;                                    TextEditor textEditor;                  if (!m_annotationEditors.TryGetValue(annotation'out textEditor))                  {                      // first assume no v-scroll bar needed                      var textLayout = D2dFactory.CreateTextLayout(annotation.Text' m_theme.TextFormat' contentBounds.Width' contentBounds.Height);                      if (m_theme.TextFormat.Underlined)                          textLayout.SetUnderline(true' 0' annotation.Text.Length);                      if (m_theme.TextFormat.Strikeout)                          textLayout.SetStrikethrough(true' 0' annotation.Text.Length);                        if (textLayout.Height >  textLayout.LayoutHeight) // need v-scroll bar                      {                          textLayout.LayoutWidth = contentBounds.Width - ScrollBarWidth - 2 * ScrollBarMargin;                                              }                        textEditor = new TextEditor                      {                          TextLayout = textLayout'                          TextFormat = m_theme.TextFormat'                          TopLine =  0'                          VerticalScrollBarVisibe = textLayout.Height > textLayout.LayoutHeight                      };                      m_annotationEditors.Add(annotation' textEditor);                                          }                  else if (textEditor.TextLayout.Text != annotation.Text) // text content changed' for example' undo'redo                  {                                      textEditor.ResetText(annotation.Text);                                      }                    int topLine = textEditor.TopLine;                  textEditor.VerticalScrollBarVisibe = textEditor.TextLayout.Height > textEditor.TextLayout.LayoutHeight;                    if (textEditor.VerticalScrollBarVisibe)                      textBounds.Width -= ScrollBarWidth + 2 * ScrollBarMargin;                  if (Math.Abs(textEditor.TextLayout.LayoutWidth - textBounds.Width) +                      Math.Abs(textEditor.TextLayout.LayoutHeight - textBounds.Height) > 1.0)                  {                      textEditor.TextLayout.LayoutWidth = textBounds.Width; // layout width and height can be updated                      textEditor.TextLayout.LayoutHeight = textBounds.Height;                      textEditor.Validate();                  }                    float yOffset = textEditor.GetLineYOffset(topLine);                                  PointF origin = new PointF(contentBounds.Location.X' contentBounds.Location.Y - yOffset);                    g.PushAxisAlignedClip(contentBounds);                                       // adjust caret.                  // pull out this code to the caller.                  if ( annotation == m_editingAnnotation  && m_caretCreated)                  {                                          var caretRect = textEditor.GetCaretRect();                      caretRect.Offset(origin);                                         // set Windows caret position                                        if (contentBounds.IntersectsWith(caretRect) && AdaptedControl.Focused)                      {                          Matrix3x2F xform = m_transformAdapter != null ? m_transformAdapter.Transform                              : g.Transform;                          var caretClientRect = Matrix3x2F.Transform(xform' caretRect);                          float ratio = m_scaleX*m_theme.TextFormat.FontHeight/CaretHeight;                                                if (ratio > 1.1f || ratio < 0.9f) // adjust caret height                          {                              CaretHeight = (int)(m_scaleX*m_theme.TextFormat.FontHeight);                              User32.DestroyCaret();                              User32.CreateCaret(AdaptedControl.Handle' IntPtr.Zero' CaretWidth' CaretHeight);                          }                          // align bottom                              User32.SetCaretPos((int) caretClientRect.X' (int)(caretClientRect.Y + caretClientRect.Height - CaretHeight));                          if (!m_rmbPressed)                              AdaptedControl.HasKeyboardFocus = true;                      }                      else                          HideCaret();                  }                    // draw the selection range above the text.                  if (textEditor.SelectionLength > 0)                  {                      D2dBrush hibrush = AdaptedControl.Focused ? m_theme.TextHighlightBrush : m_solidBrush;                      var hitTestMetrics = textEditor.TextLayout.HitTestTextRange(textEditor.SelectionStart' textEditor.SelectionLength' 0' 0);                      for (int i = 0; i < hitTestMetrics.Length; ++i)                      {                          var highlightRect = new RectangleF(hitTestMetrics[i].Point.X' hitTestMetrics[i].Point.Y' hitTestMetrics[i].Width'                                                             hitTestMetrics[i].Height);                          highlightRect.Offset(origin);                          g.FillRectangle(highlightRect' hibrush);                      }                  }                                    // draw text                   g.DrawTextLayout(origin' textEditor.TextLayout' foreColor);                                        g.PopAxisAlignedClip();                    // draw v-scroll bar                 // if (contentBounds.Height < textEditor.TextLayout.Height)                  if(textEditor.VerticalScrollBarVisibe)                  {                      float visibleLines = textEditor.GetVisibleLines();                      float vMin = topLine * contentBounds.Height / textEditor.TextLayout.LineCount;                      float vMax = (topLine + visibleLines - 1) * contentBounds.Height / textEditor.TextLayout.LineCount;                     // if (m_scrolling)                     // {                          var trackBounds = new RectangleF(contentBounds.Right - ScrollBarMargin - ScrollBarWidth' contentBounds.Y' ScrollBarWidth' contentBounds.Height);                          g.FillRectangle(trackBounds' Color.Gainsboro);                                         // }                      var thumbBounds = new RectangleF(contentBounds.Right - ScrollBarMargin - ScrollBarWidth' contentBounds.Y + vMin' ScrollBarWidth' vMax - vMin);                      g.FillRectangle(thumbBounds' Color.DimGray);                  }                              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,GetBounds,The following statement contains a magic number: if (bounds.Size.IsEmpty && m_theme != null)              {                  D2dGraphics g = ((D2dAdaptableControl)this.AdaptedControl).D2dGraphics;                    // calculate size of text block                  SizeF textSizeF = g.MeasureText(annotation.Text' m_theme.TextFormat);                  bounds.Size = new Size((int)textSizeF.Width + 2 * Margin.Size.Width' (int)textSizeF.Height + 2 * Margin.Size.Height);                    // Don't update the IAnnotation. http://forums.ship.scea.com/jive/thread.jspa?threadID=10751                  //annotation.SetTextSize(textSize);              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,GetBounds,The following statement contains a magic number: if (bounds.Size.IsEmpty && m_theme != null)              {                  D2dGraphics g = ((D2dAdaptableControl)this.AdaptedControl).D2dGraphics;                    // calculate size of text block                  SizeF textSizeF = g.MeasureText(annotation.Text' m_theme.TextFormat);                  bounds.Size = new Size((int)textSizeF.Width + 2 * Margin.Size.Width' (int)textSizeF.Height + 2 * Margin.Size.Height);                    // Don't update the IAnnotation. http://forums.ship.scea.com/jive/thread.jspa?threadID=10751                  //annotation.SetTextSize(textSize);              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_KeyPress,The following statement contains a magic number: switch (e.KeyChar)              {                  case  '\r':                                          transactionContext.DoTransaction(() =>                          {                              DeleteTextSelection(annotation);                              InsertText(annotation' "\r\n");                            }' EditAnnotation);                      annotationEditor.SetSelection(TextEditor.SelectionMode.AbsoluteLeading' annotationEditor.CaretAbsolutePosition + 2' false' false);                      break;                  case '\b':                      transactionContext.DoTransaction(() =>                          {                              if (annotationEditor.CaretAbsolutePosition != annotationEditor.CaretAnchorPosition)                                  DeleteTextSelection(annotation);                              else if (annotationEditor.CaretAbsolutePosition > 0)                              {                                  int count = 1;                                  // Need special case for surrogate pairs and CR/LF pair.                                  if (annotationEditor.CaretAbsolutePosition >= 2                                      && annotationEditor.CaretAbsolutePosition <= annotation.Text.Length)                                  {                                      char charBackOne = annotation.Text[annotationEditor.CaretAbsolutePosition - 1];                                      char charBackTwo = annotation.Text[annotationEditor.CaretAbsolutePosition - 2];                                      if ((char.IsLowSurrogate(charBackOne) && char.IsHighSurrogate(charBackTwo)) ||                                          (charBackOne == '\n' && charBackTwo == '\r'))                                      {                                          count = 2;                                      }                                  }                                  annotationEditor.SetSelection(TextEditor.SelectionMode.LeftChar' count' false' false);                                  string newText = annotationEditor.RemoveTextAt(annotation.Text' annotationEditor.CaretPosition' count);                                  textProperty.SetValue(annotation' newText' null);                              }                          }' EditAnnotation);                      break;                  default:                      if (e.KeyChar >= 0x20) // allow normal characters                       {                          InsertChar(annotation' annotationEditor' e.KeyChar);                          AdaptedControl.Invalidate();                      }                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_KeyPress,The following statement contains a magic number: switch (e.KeyChar)              {                  case  '\r':                                          transactionContext.DoTransaction(() =>                          {                              DeleteTextSelection(annotation);                              InsertText(annotation' "\r\n");                            }' EditAnnotation);                      annotationEditor.SetSelection(TextEditor.SelectionMode.AbsoluteLeading' annotationEditor.CaretAbsolutePosition + 2' false' false);                      break;                  case '\b':                      transactionContext.DoTransaction(() =>                          {                              if (annotationEditor.CaretAbsolutePosition != annotationEditor.CaretAnchorPosition)                                  DeleteTextSelection(annotation);                              else if (annotationEditor.CaretAbsolutePosition > 0)                              {                                  int count = 1;                                  // Need special case for surrogate pairs and CR/LF pair.                                  if (annotationEditor.CaretAbsolutePosition >= 2                                      && annotationEditor.CaretAbsolutePosition <= annotation.Text.Length)                                  {                                      char charBackOne = annotation.Text[annotationEditor.CaretAbsolutePosition - 1];                                      char charBackTwo = annotation.Text[annotationEditor.CaretAbsolutePosition - 2];                                      if ((char.IsLowSurrogate(charBackOne) && char.IsHighSurrogate(charBackTwo)) ||                                          (charBackOne == '\n' && charBackTwo == '\r'))                                      {                                          count = 2;                                      }                                  }                                  annotationEditor.SetSelection(TextEditor.SelectionMode.LeftChar' count' false' false);                                  string newText = annotationEditor.RemoveTextAt(annotation.Text' annotationEditor.CaretPosition' count);                                  textProperty.SetValue(annotation' newText' null);                              }                          }' EditAnnotation);                      break;                  default:                      if (e.KeyChar >= 0x20) // allow normal characters                       {                          InsertChar(annotation' annotationEditor' e.KeyChar);                          AdaptedControl.Invalidate();                      }                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_KeyPress,The following statement contains a magic number: switch (e.KeyChar)              {                  case  '\r':                                          transactionContext.DoTransaction(() =>                          {                              DeleteTextSelection(annotation);                              InsertText(annotation' "\r\n");                            }' EditAnnotation);                      annotationEditor.SetSelection(TextEditor.SelectionMode.AbsoluteLeading' annotationEditor.CaretAbsolutePosition + 2' false' false);                      break;                  case '\b':                      transactionContext.DoTransaction(() =>                          {                              if (annotationEditor.CaretAbsolutePosition != annotationEditor.CaretAnchorPosition)                                  DeleteTextSelection(annotation);                              else if (annotationEditor.CaretAbsolutePosition > 0)                              {                                  int count = 1;                                  // Need special case for surrogate pairs and CR/LF pair.                                  if (annotationEditor.CaretAbsolutePosition >= 2                                      && annotationEditor.CaretAbsolutePosition <= annotation.Text.Length)                                  {                                      char charBackOne = annotation.Text[annotationEditor.CaretAbsolutePosition - 1];                                      char charBackTwo = annotation.Text[annotationEditor.CaretAbsolutePosition - 2];                                      if ((char.IsLowSurrogate(charBackOne) && char.IsHighSurrogate(charBackTwo)) ||                                          (charBackOne == '\n' && charBackTwo == '\r'))                                      {                                          count = 2;                                      }                                  }                                  annotationEditor.SetSelection(TextEditor.SelectionMode.LeftChar' count' false' false);                                  string newText = annotationEditor.RemoveTextAt(annotation.Text' annotationEditor.CaretPosition' count);                                  textProperty.SetValue(annotation' newText' null);                              }                          }' EditAnnotation);                      break;                  default:                      if (e.KeyChar >= 0x20) // allow normal characters                       {                          InsertChar(annotation' annotationEditor' e.KeyChar);                          AdaptedControl.Invalidate();                      }                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_KeyPress,The following statement contains a magic number: switch (e.KeyChar)              {                  case  '\r':                                          transactionContext.DoTransaction(() =>                          {                              DeleteTextSelection(annotation);                              InsertText(annotation' "\r\n");                            }' EditAnnotation);                      annotationEditor.SetSelection(TextEditor.SelectionMode.AbsoluteLeading' annotationEditor.CaretAbsolutePosition + 2' false' false);                      break;                  case '\b':                      transactionContext.DoTransaction(() =>                          {                              if (annotationEditor.CaretAbsolutePosition != annotationEditor.CaretAnchorPosition)                                  DeleteTextSelection(annotation);                              else if (annotationEditor.CaretAbsolutePosition > 0)                              {                                  int count = 1;                                  // Need special case for surrogate pairs and CR/LF pair.                                  if (annotationEditor.CaretAbsolutePosition >= 2                                      && annotationEditor.CaretAbsolutePosition <= annotation.Text.Length)                                  {                                      char charBackOne = annotation.Text[annotationEditor.CaretAbsolutePosition - 1];                                      char charBackTwo = annotation.Text[annotationEditor.CaretAbsolutePosition - 2];                                      if ((char.IsLowSurrogate(charBackOne) && char.IsHighSurrogate(charBackTwo)) ||                                          (charBackOne == '\n' && charBackTwo == '\r'))                                      {                                          count = 2;                                      }                                  }                                  annotationEditor.SetSelection(TextEditor.SelectionMode.LeftChar' count' false' false);                                  string newText = annotationEditor.RemoveTextAt(annotation.Text' annotationEditor.CaretPosition' count);                                  textProperty.SetValue(annotation' newText' null);                              }                          }' EditAnnotation);                      break;                  default:                      if (e.KeyChar >= 0x20) // allow normal characters                       {                          InsertChar(annotation' annotationEditor' e.KeyChar);                          AdaptedControl.Invalidate();                      }                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,HideCaret,The following statement contains a magic number: if(m_caretCreated)                  User32.SetCaretPos(-10' 0);
Magic Number,Sce.Atf.Controls.Adaptable,D2dGridAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dGridAdapter.cs,SetGridColor,The following statement contains a magic number: float intensity = ((float)gridColor.R + (float)gridColor.G + (float)gridColor.B) / 3;
Magic Number,Sce.Atf.Controls.Adaptable,D2dGridAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dGridAdapter.cs,SetGridColor,The following statement contains a magic number: float shading = (intensity < 128) ? m_gridContrast : -m_gridContrast;
Magic Number,Sce.Atf.Controls.Adaptable,GridAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\GridAdapter.cs,SetGridColor,The following statement contains a magic number: float intensity = ((float)gridColor.R + (float)gridColor.G + (float)gridColor.B) / 3;
Magic Number,Sce.Atf.Controls.Adaptable,GridAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\GridAdapter.cs,SetGridColor,The following statement contains a magic number: float shading =  (intensity < 128) ? m_gridContrast : -m_gridContrast;
Magic Number,Sce.Atf.Controls.Adaptable,HoverAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\HoverAdapter.cs,HoverAdapter,The following statement contains a magic number: m_hoverTimer.Interval = 10;
Magic Number,Sce.Atf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\ITransformAdapter.cs,SetTransform,The following statement contains a magic number: transformAdapter.SetTransform(m[0]' m[3]' m[4]' m[5]);
Magic Number,Sce.Atf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\ITransformAdapter.cs,SetTransform,The following statement contains a magic number: transformAdapter.SetTransform(m[0]' m[3]' m[4]' m[5]);
Magic Number,Sce.Atf.Controls.Adaptable,TransformAdapters,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\ITransformAdapter.cs,SetTransform,The following statement contains a magic number: transformAdapter.SetTransform(m[0]' m[3]' m[4]' m[5]);
Magic Number,Sce.Atf.Controls.Adaptable,LabelEditAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\LabelEditAdapter.cs,BeginEdit,The following statement contains a magic number: if (m_transformAdapter != null)              {                  Matrix transform = m_transformAdapter.Transform;                  m_labelBounds = GdiUtil.Transform(transform' m_labelBounds);                  // in case of non-uniform scaling' prefer vertical (y) scale for magnification factor;                  //  Timeline control is the only example of non-uniform scale right now' and y-scale works                  //  better in this case.                  fontScale *= transform.Elements[3];              }
Magic Number,Sce.Atf.Controls.Adaptable,LabelEditAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\LabelEditAdapter.cs,SizeTextBox,The following statement contains a magic number: int textBoxY = m_labelBounds.Y + m_labelBounds.Height / 2 - actualSize.Height / 2;
Magic Number,Sce.Atf.Controls.Adaptable,LabelEditAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\LabelEditAdapter.cs,SizeTextBox,The following statement contains a magic number: int textBoxY = m_labelBounds.Y + m_labelBounds.Height / 2 - actualSize.Height / 2;
Magic Number,Sce.Atf.Controls.Adaptable,LabelEditAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\LabelEditAdapter.cs,SizeTextBox,The following statement contains a magic number: if (m_textBox.TextAlign == HorizontalAlignment.Right)                  textBoxX = m_labelBounds.Right - actualSize.Width;              else if (m_textBox.TextAlign == HorizontalAlignment.Center)                  textBoxX = m_labelBounds.X + m_labelBounds.Width / 2 - actualSize.Width / 2;
Magic Number,Sce.Atf.Controls.Adaptable,LabelEditAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\LabelEditAdapter.cs,SizeTextBox,The following statement contains a magic number: if (m_textBox.TextAlign == HorizontalAlignment.Right)                  textBoxX = m_labelBounds.Right - actualSize.Width;              else if (m_textBox.TextAlign == HorizontalAlignment.Center)                  textBoxX = m_labelBounds.X + m_labelBounds.Width / 2 - actualSize.Width / 2;
Magic Number,Sce.Atf.Controls.Adaptable,MouseLayoutManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseLayoutManipulator.cs,GetHandleRect,The following statement contains a magic number: Rectangle result = new Rectangle(                  bounds.X + bounds.Width / 2 - HandleSize'                  bounds.Y + bounds.Height / 2 - HandleSize'                  HandleSize * 2'                  HandleSize * 2);
Magic Number,Sce.Atf.Controls.Adaptable,MouseLayoutManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseLayoutManipulator.cs,GetHandleRect,The following statement contains a magic number: Rectangle result = new Rectangle(                  bounds.X + bounds.Width / 2 - HandleSize'                  bounds.Y + bounds.Height / 2 - HandleSize'                  HandleSize * 2'                  HandleSize * 2);
Magic Number,Sce.Atf.Controls.Adaptable,MouseLayoutManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseLayoutManipulator.cs,GetHandleRect,The following statement contains a magic number: Rectangle result = new Rectangle(                  bounds.X + bounds.Width / 2 - HandleSize'                  bounds.Y + bounds.Height / 2 - HandleSize'                  HandleSize * 2'                  HandleSize * 2);
Magic Number,Sce.Atf.Controls.Adaptable,MouseLayoutManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseLayoutManipulator.cs,GetHandleRect,The following statement contains a magic number: Rectangle result = new Rectangle(                  bounds.X + bounds.Width / 2 - HandleSize'                  bounds.Y + bounds.Height / 2 - HandleSize'                  HandleSize * 2'                  HandleSize * 2);
Magic Number,Sce.Atf.Controls.Adaptable,MouseTransformManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseTransformManipulator.cs,control_MouseMove,The following statement contains a magic number: if (m_isTranslating || m_isScaling)              {                  Point currentPoint = new Point(e.X' e.Y);                    int dx = currentPoint.X - m_firstPoint.X;                  int dy = currentPoint.Y - m_firstPoint.Y;                    if (m_selfSetTranslation != m_transformAdapter.Translation)                  {                      // It is quite possible that another transformation adapter binded to the same canvas can                       // modify the shared ITransformAdapter in succession without releasing the mouse button.                       // For example  MMD panning with this adapter followed by MouseWheelManipulator for zooming.                       // Need to resync mouse starting position                      m_startingTranslation = m_transformAdapter.Translation;                                      m_firstPoint = currentPoint;                  }                    Keys modifiers = Control.ModifierKeys;                    bool constrain =                      (                          ConstrainModifierKeys != Keys.None &&                          (modifiers & ConstrainModifierKeys) == ConstrainModifierKeys                      ) ||                      m_isScaling && m_transformAdapter.UniformScale;                    if (constrain)                  {                      if (!m_constrainXDetermined)                      {                          float xDistance = Math.Abs(dx);                          float yDistance = Math.Abs(dy);                          Size dragSize = SystemInformation.DragSize;                          if (xDistance > dragSize.Width ||                              yDistance > dragSize.Height)                          {                              m_constrainX = (xDistance < yDistance);                              m_constrainXDetermined = true;                          }                      }                  }                    if (m_isTranslating)                  {                      if (constrain)                      {                          if (m_constrainX)                              dx = 0;                          else                              dy = 0;                      }                        PointF translation = new PointF(                          m_startingTranslation.X + dx'                          m_startingTranslation.Y + dy);                        m_transformAdapter.Translation = m_selfSetTranslation = translation;                  }                  else if (m_isScaling)                  {                      float xScale = 4 * dx / (float)AdaptedControl.Width;                      float yScale = 4 * dy / (float)AdaptedControl.Height;                        if (constrain)                      {                          if (m_constrainX)                              xScale = yScale;                          else                              yScale = xScale;                      }                        PointF scale = new PointF(                          Math.Max(0.001f' m_scaleStart.X * (float)Math.Pow(2' xScale))'                          Math.Max(0.001f' m_scaleStart.Y * (float)Math.Pow(2' yScale)));                        // constrain scale before calculating translation to maintain scroll center position                      scale = m_transformAdapter.ConstrainScale(scale);                        PointF translation = new PointF(                          m_firstPoint.X - m_scaleCenterStart.X * scale.X'                          m_firstPoint.Y - m_scaleCenterStart.Y * scale.Y);                                            m_transformAdapter.SetTransform(                          scale.X'                          scale.Y'                          translation.X'                          translation.Y);                        m_selfSetTranslation = translation;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable,MouseTransformManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseTransformManipulator.cs,control_MouseMove,The following statement contains a magic number: if (m_isTranslating || m_isScaling)              {                  Point currentPoint = new Point(e.X' e.Y);                    int dx = currentPoint.X - m_firstPoint.X;                  int dy = currentPoint.Y - m_firstPoint.Y;                    if (m_selfSetTranslation != m_transformAdapter.Translation)                  {                      // It is quite possible that another transformation adapter binded to the same canvas can                       // modify the shared ITransformAdapter in succession without releasing the mouse button.                       // For example  MMD panning with this adapter followed by MouseWheelManipulator for zooming.                       // Need to resync mouse starting position                      m_startingTranslation = m_transformAdapter.Translation;                                      m_firstPoint = currentPoint;                  }                    Keys modifiers = Control.ModifierKeys;                    bool constrain =                      (                          ConstrainModifierKeys != Keys.None &&                          (modifiers & ConstrainModifierKeys) == ConstrainModifierKeys                      ) ||                      m_isScaling && m_transformAdapter.UniformScale;                    if (constrain)                  {                      if (!m_constrainXDetermined)                      {                          float xDistance = Math.Abs(dx);                          float yDistance = Math.Abs(dy);                          Size dragSize = SystemInformation.DragSize;                          if (xDistance > dragSize.Width ||                              yDistance > dragSize.Height)                          {                              m_constrainX = (xDistance < yDistance);                              m_constrainXDetermined = true;                          }                      }                  }                    if (m_isTranslating)                  {                      if (constrain)                      {                          if (m_constrainX)                              dx = 0;                          else                              dy = 0;                      }                        PointF translation = new PointF(                          m_startingTranslation.X + dx'                          m_startingTranslation.Y + dy);                        m_transformAdapter.Translation = m_selfSetTranslation = translation;                  }                  else if (m_isScaling)                  {                      float xScale = 4 * dx / (float)AdaptedControl.Width;                      float yScale = 4 * dy / (float)AdaptedControl.Height;                        if (constrain)                      {                          if (m_constrainX)                              xScale = yScale;                          else                              yScale = xScale;                      }                        PointF scale = new PointF(                          Math.Max(0.001f' m_scaleStart.X * (float)Math.Pow(2' xScale))'                          Math.Max(0.001f' m_scaleStart.Y * (float)Math.Pow(2' yScale)));                        // constrain scale before calculating translation to maintain scroll center position                      scale = m_transformAdapter.ConstrainScale(scale);                        PointF translation = new PointF(                          m_firstPoint.X - m_scaleCenterStart.X * scale.X'                          m_firstPoint.Y - m_scaleCenterStart.Y * scale.Y);                                            m_transformAdapter.SetTransform(                          scale.X'                          scale.Y'                          translation.X'                          translation.Y);                        m_selfSetTranslation = translation;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable,MouseTransformManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseTransformManipulator.cs,control_MouseMove,The following statement contains a magic number: if (m_isTranslating || m_isScaling)              {                  Point currentPoint = new Point(e.X' e.Y);                    int dx = currentPoint.X - m_firstPoint.X;                  int dy = currentPoint.Y - m_firstPoint.Y;                    if (m_selfSetTranslation != m_transformAdapter.Translation)                  {                      // It is quite possible that another transformation adapter binded to the same canvas can                       // modify the shared ITransformAdapter in succession without releasing the mouse button.                       // For example  MMD panning with this adapter followed by MouseWheelManipulator for zooming.                       // Need to resync mouse starting position                      m_startingTranslation = m_transformAdapter.Translation;                                      m_firstPoint = currentPoint;                  }                    Keys modifiers = Control.ModifierKeys;                    bool constrain =                      (                          ConstrainModifierKeys != Keys.None &&                          (modifiers & ConstrainModifierKeys) == ConstrainModifierKeys                      ) ||                      m_isScaling && m_transformAdapter.UniformScale;                    if (constrain)                  {                      if (!m_constrainXDetermined)                      {                          float xDistance = Math.Abs(dx);                          float yDistance = Math.Abs(dy);                          Size dragSize = SystemInformation.DragSize;                          if (xDistance > dragSize.Width ||                              yDistance > dragSize.Height)                          {                              m_constrainX = (xDistance < yDistance);                              m_constrainXDetermined = true;                          }                      }                  }                    if (m_isTranslating)                  {                      if (constrain)                      {                          if (m_constrainX)                              dx = 0;                          else                              dy = 0;                      }                        PointF translation = new PointF(                          m_startingTranslation.X + dx'                          m_startingTranslation.Y + dy);                        m_transformAdapter.Translation = m_selfSetTranslation = translation;                  }                  else if (m_isScaling)                  {                      float xScale = 4 * dx / (float)AdaptedControl.Width;                      float yScale = 4 * dy / (float)AdaptedControl.Height;                        if (constrain)                      {                          if (m_constrainX)                              xScale = yScale;                          else                              yScale = xScale;                      }                        PointF scale = new PointF(                          Math.Max(0.001f' m_scaleStart.X * (float)Math.Pow(2' xScale))'                          Math.Max(0.001f' m_scaleStart.Y * (float)Math.Pow(2' yScale)));                        // constrain scale before calculating translation to maintain scroll center position                      scale = m_transformAdapter.ConstrainScale(scale);                        PointF translation = new PointF(                          m_firstPoint.X - m_scaleCenterStart.X * scale.X'                          m_firstPoint.Y - m_scaleCenterStart.Y * scale.Y);                                            m_transformAdapter.SetTransform(                          scale.X'                          scale.Y'                          translation.X'                          translation.Y);                        m_selfSetTranslation = translation;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable,MouseTransformManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseTransformManipulator.cs,control_MouseMove,The following statement contains a magic number: if (m_isTranslating || m_isScaling)              {                  Point currentPoint = new Point(e.X' e.Y);                    int dx = currentPoint.X - m_firstPoint.X;                  int dy = currentPoint.Y - m_firstPoint.Y;                    if (m_selfSetTranslation != m_transformAdapter.Translation)                  {                      // It is quite possible that another transformation adapter binded to the same canvas can                       // modify the shared ITransformAdapter in succession without releasing the mouse button.                       // For example  MMD panning with this adapter followed by MouseWheelManipulator for zooming.                       // Need to resync mouse starting position                      m_startingTranslation = m_transformAdapter.Translation;                                      m_firstPoint = currentPoint;                  }                    Keys modifiers = Control.ModifierKeys;                    bool constrain =                      (                          ConstrainModifierKeys != Keys.None &&                          (modifiers & ConstrainModifierKeys) == ConstrainModifierKeys                      ) ||                      m_isScaling && m_transformAdapter.UniformScale;                    if (constrain)                  {                      if (!m_constrainXDetermined)                      {                          float xDistance = Math.Abs(dx);                          float yDistance = Math.Abs(dy);                          Size dragSize = SystemInformation.DragSize;                          if (xDistance > dragSize.Width ||                              yDistance > dragSize.Height)                          {                              m_constrainX = (xDistance < yDistance);                              m_constrainXDetermined = true;                          }                      }                  }                    if (m_isTranslating)                  {                      if (constrain)                      {                          if (m_constrainX)                              dx = 0;                          else                              dy = 0;                      }                        PointF translation = new PointF(                          m_startingTranslation.X + dx'                          m_startingTranslation.Y + dy);                        m_transformAdapter.Translation = m_selfSetTranslation = translation;                  }                  else if (m_isScaling)                  {                      float xScale = 4 * dx / (float)AdaptedControl.Width;                      float yScale = 4 * dy / (float)AdaptedControl.Height;                        if (constrain)                      {                          if (m_constrainX)                              xScale = yScale;                          else                              yScale = xScale;                      }                        PointF scale = new PointF(                          Math.Max(0.001f' m_scaleStart.X * (float)Math.Pow(2' xScale))'                          Math.Max(0.001f' m_scaleStart.Y * (float)Math.Pow(2' yScale)));                        // constrain scale before calculating translation to maintain scroll center position                      scale = m_transformAdapter.ConstrainScale(scale);                        PointF translation = new PointF(                          m_firstPoint.X - m_scaleCenterStart.X * scale.X'                          m_firstPoint.Y - m_scaleCenterStart.Y * scale.Y);                                            m_transformAdapter.SetTransform(                          scale.X'                          scale.Y'                          translation.X'                          translation.Y);                        m_selfSetTranslation = translation;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable,SelectionAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\SelectionAdapter.cs,control_DragDrop,The following statement contains a magic number: if (m_selectionContext != null)              {                  // Items may be selected programmatically after the drag & drop'                   // raise SelectedItemHit to enable label editor start editing with F2 without mouse click over the selected item first                     // items may be placed using mouse position as upper-left corner;                   // offset slightly of the mouse position to get better chance to pick the newly dropped item.                  const int offset = 20;                  var point = AdaptedControl.PointToClient(new Point(e.X + offset' e.Y + offset));                  m_hitRecord = Pick(point);                  if (m_hitRecord != null)                      SelectedItemHit.Raise(this' new DiagramHitEventArgs(m_hitRecord));              }
Magic Number,Sce.Atf.Controls.Adaptable,TransformAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\TransformAdapter.cs,SetTransform,The following statement contains a magic number: try              {                  m_settingTransform = true;                    bool transformChanged = false;                  float[] m = m_transform.Elements;                    PointF scale = EnforceConstraints ? this.ConstrainScale(new PointF(xScale' yScale)) : new PointF(xScale' yScale);                  if (m[0] != scale.X || m[3] != scale.Y)                  {                                                              transformChanged = true;                  }                    PointF translation = EnforceConstraints ? this.ConstrainTranslation(new PointF(xTranslation' yTranslation)) : new PointF(xTranslation' yTranslation);                  if (m[4] != translation.X || m[5] != translation.Y)                  {                                          transformChanged = true;                  }                    if (transformChanged)                  {                      m_transform = new Matrix(scale.X' 0' 0' scale.Y' translation.X' translation.Y);                      OnTransformChanged(EventArgs.Empty);                      TransformChanged.Raise(this' EventArgs.Empty);                        if (AdaptedControl != null)                          AdaptedControl.Invalidate();                  }              }              finally              {                  m_settingTransform = false;              }
Magic Number,Sce.Atf.Controls.Adaptable,TransformAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\TransformAdapter.cs,SetTransform,The following statement contains a magic number: try              {                  m_settingTransform = true;                    bool transformChanged = false;                  float[] m = m_transform.Elements;                    PointF scale = EnforceConstraints ? this.ConstrainScale(new PointF(xScale' yScale)) : new PointF(xScale' yScale);                  if (m[0] != scale.X || m[3] != scale.Y)                  {                                                              transformChanged = true;                  }                    PointF translation = EnforceConstraints ? this.ConstrainTranslation(new PointF(xTranslation' yTranslation)) : new PointF(xTranslation' yTranslation);                  if (m[4] != translation.X || m[5] != translation.Y)                  {                                          transformChanged = true;                  }                    if (transformChanged)                  {                      m_transform = new Matrix(scale.X' 0' 0' scale.Y' translation.X' translation.Y);                      OnTransformChanged(EventArgs.Empty);                      TransformChanged.Raise(this' EventArgs.Empty);                        if (AdaptedControl != null)                          AdaptedControl.Invalidate();                  }              }              finally              {                  m_settingTransform = false;              }
Magic Number,Sce.Atf.Controls.Adaptable,TransformAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\TransformAdapter.cs,SetTransform,The following statement contains a magic number: try              {                  m_settingTransform = true;                    bool transformChanged = false;                  float[] m = m_transform.Elements;                    PointF scale = EnforceConstraints ? this.ConstrainScale(new PointF(xScale' yScale)) : new PointF(xScale' yScale);                  if (m[0] != scale.X || m[3] != scale.Y)                  {                                                              transformChanged = true;                  }                    PointF translation = EnforceConstraints ? this.ConstrainTranslation(new PointF(xTranslation' yTranslation)) : new PointF(xTranslation' yTranslation);                  if (m[4] != translation.X || m[5] != translation.Y)                  {                                          transformChanged = true;                  }                    if (transformChanged)                  {                      m_transform = new Matrix(scale.X' 0' 0' scale.Y' translation.X' translation.Y);                      OnTransformChanged(EventArgs.Empty);                      TransformChanged.Raise(this' EventArgs.Empty);                        if (AdaptedControl != null)                          AdaptedControl.Invalidate();                  }              }              finally              {                  m_settingTransform = false;              }
Magic Number,Sce.Atf.Controls.Adaptable,TransformAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\TransformAdapter.cs,SetTranslation,The following statement contains a magic number: SetTransform(m[0]' m[3]' translation.X' translation.Y);
Magic Number,Sce.Atf.Controls.Adaptable,ViewingAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\ViewingAdapter.cs,Frame,The following statement contains a magic number: crect.X +=(int) (crect.Width - gBounds.Width * scale) / 2;
Magic Number,Sce.Atf.Controls.Adaptable,ViewingAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\ViewingAdapter.cs,Frame,The following statement contains a magic number: crect.Y += (int)(crect.Height - gBounds.Height * scale) / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,Draw,The following statement contains a magic number: if (g.ClipBounds.IntersectsWith(bounds))              {                  ICircuitElementType type = element.Type;                    if (info.Path == null)                      BuildGraphics(type' info' g);                    s_pathTransform.Translate(p.X' p.Y);                  info.Path.Transform(s_pathTransform);                    // try to use custom brush if registered                  Brush fillBrush = m_theme.GetCustomBrush(type.Name);                  if (fillBrush != null)                  {                      g.FillPath(fillBrush' info.Path);                  }                  else                  {                      // use a default brush                      using (LinearGradientBrush lgb = new LinearGradientBrush(                          bounds'                          Color.White'                          Color.LightSteelBlue'                          LinearGradientMode.Vertical))                      {                          g.FillPath(lgb' info.Path);                      }                  }                  g.DrawPath(m_theme.OutlinePen' info.Path);                    int titleHeight = m_rowSpacing + PinMargin;                  g.DrawLine(m_theme.OutlinePen' p.X' p.Y + titleHeight' p.X + info.Size.Width' p.Y + titleHeight);                  g.DrawString(type.Name' m_theme.Font' m_theme.TextBrush' p.X + PinMargin + 1' p.Y + PinMargin + 1);                    int pinY = p.Y + titleHeight + PinMargin;                  foreach (TPin inputPin in type.Inputs)                  {                      Pen pen = GetPen(inputPin);                      if (pen != null)                          g.DrawRectangle(pen' p.X + 1' pinY + m_pinOffset' m_pinSize' m_pinSize);                      g.DrawString(inputPin.Name' m_theme.Font' m_theme.TextBrush' p.X + m_pinSize + PinMargin' pinY);                      pinY += m_rowSpacing;                  }                    pinY = p.Y + titleHeight + PinMargin;                  int i = 0;                  foreach (TPin outputPin in type.Outputs)                  {                      Pen pen = GetPen(outputPin);                      if (pen != null)                          g.DrawRectangle(pen' p.X + info.Size.Width - m_pinSize' pinY + m_pinOffset' m_pinSize' m_pinSize);                      g.DrawString(outputPin.Name' m_theme.Font' m_theme.TextBrush' p.X + info.OutputLeftX[i]' pinY);                      pinY += m_rowSpacing;                      i++;                  }                    Image image = type.Image;                  if (image != null)                      g.DrawImage(image' p.X + info.Interior.X' p.Y + info.Interior.Y' info.Interior.Width' info.Interior.Height);                    s_pathTransform.Translate(-2 * p.X' -2 * p.Y);                  info.Path.Transform(s_pathTransform);                  s_pathTransform.Reset();                    string name = element.Name;                  if (!string.IsNullOrEmpty(name))                  {                      RectangleF alignRect = new RectangleF(                          bounds.Left - MaxNameOverhang' bounds.Bottom + PinMargin' bounds.Width + 2 * MaxNameOverhang' m_rowSpacing);                      g.DrawString(name' m_theme.Font' m_theme.TextBrush' alignRect' m_theme.CenterStringFormat);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,Draw,The following statement contains a magic number: if (g.ClipBounds.IntersectsWith(bounds))              {                  ICircuitElementType type = element.Type;                    if (info.Path == null)                      BuildGraphics(type' info' g);                    s_pathTransform.Translate(p.X' p.Y);                  info.Path.Transform(s_pathTransform);                    // try to use custom brush if registered                  Brush fillBrush = m_theme.GetCustomBrush(type.Name);                  if (fillBrush != null)                  {                      g.FillPath(fillBrush' info.Path);                  }                  else                  {                      // use a default brush                      using (LinearGradientBrush lgb = new LinearGradientBrush(                          bounds'                          Color.White'                          Color.LightSteelBlue'                          LinearGradientMode.Vertical))                      {                          g.FillPath(lgb' info.Path);                      }                  }                  g.DrawPath(m_theme.OutlinePen' info.Path);                    int titleHeight = m_rowSpacing + PinMargin;                  g.DrawLine(m_theme.OutlinePen' p.X' p.Y + titleHeight' p.X + info.Size.Width' p.Y + titleHeight);                  g.DrawString(type.Name' m_theme.Font' m_theme.TextBrush' p.X + PinMargin + 1' p.Y + PinMargin + 1);                    int pinY = p.Y + titleHeight + PinMargin;                  foreach (TPin inputPin in type.Inputs)                  {                      Pen pen = GetPen(inputPin);                      if (pen != null)                          g.DrawRectangle(pen' p.X + 1' pinY + m_pinOffset' m_pinSize' m_pinSize);                      g.DrawString(inputPin.Name' m_theme.Font' m_theme.TextBrush' p.X + m_pinSize + PinMargin' pinY);                      pinY += m_rowSpacing;                  }                    pinY = p.Y + titleHeight + PinMargin;                  int i = 0;                  foreach (TPin outputPin in type.Outputs)                  {                      Pen pen = GetPen(outputPin);                      if (pen != null)                          g.DrawRectangle(pen' p.X + info.Size.Width - m_pinSize' pinY + m_pinOffset' m_pinSize' m_pinSize);                      g.DrawString(outputPin.Name' m_theme.Font' m_theme.TextBrush' p.X + info.OutputLeftX[i]' pinY);                      pinY += m_rowSpacing;                      i++;                  }                    Image image = type.Image;                  if (image != null)                      g.DrawImage(image' p.X + info.Interior.X' p.Y + info.Interior.Y' info.Interior.Width' info.Interior.Height);                    s_pathTransform.Translate(-2 * p.X' -2 * p.Y);                  info.Path.Transform(s_pathTransform);                  s_pathTransform.Reset();                    string name = element.Name;                  if (!string.IsNullOrEmpty(name))                  {                      RectangleF alignRect = new RectangleF(                          bounds.Left - MaxNameOverhang' bounds.Bottom + PinMargin' bounds.Width + 2 * MaxNameOverhang' m_rowSpacing);                      g.DrawString(name' m_theme.Font' m_theme.TextBrush' alignRect' m_theme.CenterStringFormat);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,Draw,The following statement contains a magic number: if (g.ClipBounds.IntersectsWith(bounds))              {                  ICircuitElementType type = element.Type;                    if (info.Path == null)                      BuildGraphics(type' info' g);                    s_pathTransform.Translate(p.X' p.Y);                  info.Path.Transform(s_pathTransform);                    // try to use custom brush if registered                  Brush fillBrush = m_theme.GetCustomBrush(type.Name);                  if (fillBrush != null)                  {                      g.FillPath(fillBrush' info.Path);                  }                  else                  {                      // use a default brush                      using (LinearGradientBrush lgb = new LinearGradientBrush(                          bounds'                          Color.White'                          Color.LightSteelBlue'                          LinearGradientMode.Vertical))                      {                          g.FillPath(lgb' info.Path);                      }                  }                  g.DrawPath(m_theme.OutlinePen' info.Path);                    int titleHeight = m_rowSpacing + PinMargin;                  g.DrawLine(m_theme.OutlinePen' p.X' p.Y + titleHeight' p.X + info.Size.Width' p.Y + titleHeight);                  g.DrawString(type.Name' m_theme.Font' m_theme.TextBrush' p.X + PinMargin + 1' p.Y + PinMargin + 1);                    int pinY = p.Y + titleHeight + PinMargin;                  foreach (TPin inputPin in type.Inputs)                  {                      Pen pen = GetPen(inputPin);                      if (pen != null)                          g.DrawRectangle(pen' p.X + 1' pinY + m_pinOffset' m_pinSize' m_pinSize);                      g.DrawString(inputPin.Name' m_theme.Font' m_theme.TextBrush' p.X + m_pinSize + PinMargin' pinY);                      pinY += m_rowSpacing;                  }                    pinY = p.Y + titleHeight + PinMargin;                  int i = 0;                  foreach (TPin outputPin in type.Outputs)                  {                      Pen pen = GetPen(outputPin);                      if (pen != null)                          g.DrawRectangle(pen' p.X + info.Size.Width - m_pinSize' pinY + m_pinOffset' m_pinSize' m_pinSize);                      g.DrawString(outputPin.Name' m_theme.Font' m_theme.TextBrush' p.X + info.OutputLeftX[i]' pinY);                      pinY += m_rowSpacing;                      i++;                  }                    Image image = type.Image;                  if (image != null)                      g.DrawImage(image' p.X + info.Interior.X' p.Y + info.Interior.Y' info.Interior.Width' info.Interior.Height);                    s_pathTransform.Translate(-2 * p.X' -2 * p.Y);                  info.Path.Transform(s_pathTransform);                  s_pathTransform.Reset();                    string name = element.Name;                  if (!string.IsNullOrEmpty(name))                  {                      RectangleF alignRect = new RectangleF(                          bounds.Left - MaxNameOverhang' bounds.Bottom + PinMargin' bounds.Width + 2 * MaxNameOverhang' m_rowSpacing);                      g.DrawString(name' m_theme.Font' m_theme.TextBrush' alignRect' m_theme.CenterStringFormat);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,DrawGhost,The following statement contains a magic number: if (g.ClipBounds.IntersectsWith(bounds))              {                  if (info.Path == null)                  {                      ICircuitElementType type = element.Type;                      BuildGraphics(type' info' g);                  }                    s_pathTransform.Translate(p.X' p.Y);                  info.Path.Transform(s_pathTransform);                    g.FillPath(m_theme.GhostBrush' info.Path);                  g.DrawPath(m_theme.GhostPen' info.Path);                    s_pathTransform.Translate(-2 * p.X' -2 * p.Y);                  info.Path.Transform(s_pathTransform);                  s_pathTransform.Reset();              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,DrawGhost,The following statement contains a magic number: if (g.ClipBounds.IntersectsWith(bounds))              {                  if (info.Path == null)                  {                      ICircuitElementType type = element.Type;                      BuildGraphics(type' info' g);                  }                    s_pathTransform.Translate(p.X' p.Y);                  info.Path.Transform(s_pathTransform);                    g.FillPath(m_theme.GhostBrush' info.Path);                  g.DrawPath(m_theme.GhostPen' info.Path);                    s_pathTransform.Translate(-2 * p.X' -2 * p.Y);                  info.Path.Transform(s_pathTransform);                  s_pathTransform.Reset();              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,DrawOutline,The following statement contains a magic number: s_pathTransform.Translate(2 * -p.X' 2 * -p.Y);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,DrawOutline,The following statement contains a magic number: s_pathTransform.Translate(2 * -p.X' 2 * -p.Y);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,PickInput,The following statement contains a magic number: int y = ep.Y + m_rowSpacing + 2 * PinMargin + m_pinOffset;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,PickOutput,The following statement contains a magic number: int y = ep.Y + m_rowSpacing + 2 * PinMargin + m_pinOffset;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,GetElementSizeInfo,The following statement contains a magic number: int width = (int)typeNameSize.Width + 2 * PinMargin;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,GetElementSizeInfo,The following statement contains a magic number: int height = m_rowSpacing + 2 * PinMargin;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,GetElementSizeInfo,The following statement contains a magic number: for (int i = 0; i < maxRows; i++)              {                  double rowWidth = 2 * PinMargin;                  if (inputCount > i)                  {                      SizeF labelSize = g.MeasureString(inputPins[i].Name' m_theme.Font);                      rowWidth += labelSize.Width + m_pinSize + PinMargin;                  }                  else                  {                      rowWidth += type.InteriorSize.Width;                      imageRight = false;                  }                  if (outputCount > i)                  {                      SizeF labelSize = g.MeasureString(outputPins[i].Name' m_theme.Font);                      outputLeftX[i] = (int)labelSize.Width;                      rowWidth += labelSize.Width + m_pinSize + PinMargin;                  }                  else                  {                      rowWidth += type.InteriorSize.Width;                  }                  width = Math.Max(width' (int)rowWidth);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,GetElementSizeInfo,The following statement contains a magic number: if (inputCount == outputCount)                  width = Math.Max(width' type.InteriorSize.Width + 2);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,BuildGraphics,The following statement contains a magic number: const float r = 6;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,BuildGraphics,The following statement contains a magic number: const float d = 2 * r;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,BuildGraphics,The following statement contains a magic number: gp.AddArc(width - d' 0' d' d' 270' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,BuildGraphics,The following statement contains a magic number: gp.AddArc(width - d' 0' d' d' 270' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,BuildGraphics,The following statement contains a magic number: gp.AddArc(width - d' height - d' d' d' 0' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,BuildGraphics,The following statement contains a magic number: gp.AddArc(0' height - d' d' d' 90' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,BuildGraphics,The following statement contains a magic number: gp.AddArc(0' height - d' d' d' 90' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,BuildGraphics,The following statement contains a magic number: gp.AddArc(0' 0' d' d' 180' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,BuildGraphics,The following statement contains a magic number: gp.AddArc(0' 0' d' d' 180' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,GetTangentLength,The following statement contains a magic number: const int minTanLen = 32;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,GetTangentLength,The following statement contains a magic number: int tanLen = Math.Abs(x1 - x2) / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,GetPinOffset,The following statement contains a magic number: return m_rowSpacing + 2 * PinMargin + index * m_rowSpacing + m_pinOffset + m_pinSize / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,GetPinOffset,The following statement contains a magic number: return m_rowSpacing + 2 * PinMargin + index * m_rowSpacing + m_pinOffset + m_pinSize / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\CircuitRenderer.cs,SetPinSpacing,The following statement contains a magic number: m_pinOffset = (fontHeight - m_pinSize) / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,Insert,The following statement contains a magic number: Point center = new Point(control.Width / 2' control.Height / 2);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,CircuitEditingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\CircuitEditingContext.cs,Insert,The following statement contains a magic number: Point center = new Point(control.Width / 2' control.Height / 2);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,GroupingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupingCommands.cs,CreateGroup,The following statement contains a magic number: if (Placement == PlacementMode.Center)              {                  // position it at center of grouped modules                  Rectangle bounds = viewingContext.GetBounds(selectionContext.Selection.AsIEnumerable<Element>());                  circuitEditingContext.Center(new object[] { newGroup }' new Point(                      bounds.X + bounds.Width / 2'                      bounds.Y + bounds.Height / 2));              }              else              {                  // find upper-left corner of the subnodes                  Point minLocation = new Point(int.MaxValue' int.MaxValue);                  foreach (var module in selectionContext.Selection.AsIEnumerable<Element>())                  {                      if (minLocation.X > module.Bounds.Location.X)                          minLocation.X = module.Bounds.Location.X;                      if (minLocation.Y > module.Bounds.Location.Y)                          minLocation.Y = module.Bounds.Location.Y;                  }                  // position it at upper-left conner of grouped modules                  newGroup.Bounds = new Rectangle(minLocation.X' minLocation.Y' newGroup.Bounds.Width' newGroup.Bounds.Height);                  newGroup.Position = newGroup.Bounds.Location;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,GroupingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupingCommands.cs,CreateGroup,The following statement contains a magic number: if (Placement == PlacementMode.Center)              {                  // position it at center of grouped modules                  Rectangle bounds = viewingContext.GetBounds(selectionContext.Selection.AsIEnumerable<Element>());                  circuitEditingContext.Center(new object[] { newGroup }' new Point(                      bounds.X + bounds.Width / 2'                      bounds.Y + bounds.Height / 2));              }              else              {                  // find upper-left corner of the subnodes                  Point minLocation = new Point(int.MaxValue' int.MaxValue);                  foreach (var module in selectionContext.Selection.AsIEnumerable<Element>())                  {                      if (minLocation.X > module.Bounds.Location.X)                          minLocation.X = module.Bounds.Location.X;                      if (minLocation.Y > module.Bounds.Location.Y)                          minLocation.Y = module.Bounds.Location.Y;                  }                  // position it at upper-left conner of grouped modules                  newGroup.Bounds = new Rectangle(minLocation.X' minLocation.Y' newGroup.Bounds.Width' newGroup.Bounds.Height);                  newGroup.Position = newGroup.Bounds.Location;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,MeasureFakePins,The following statement contains a magic number: if (pinNodes.Any())              {                  //var subGraph = m_graph.As<Group>();                  //using (Graphics g = AdaptedControl.CreateGraphics())                  {                      //g.Transform = m_transformAdapter.Transform;                      if ( (measureParts & MeasurePinNode.DesiredLocation) !=0)                      {                          // a floating pin node maps to a subnode and its pin index' needed to sort by both                                                var pinList = pinNodes.OrderBy(x => x.InternalElement.Position.Y)                                                 .ThenBy(x => x.InternalElement.PinDisplayOrder(x.InternalPinIndex' inputSide)).ToList();                          //bool initialOrder = pinList.All(n => n.PinY == int.MinValue);                            //if (initialOrder && subGraph.DefaultPinOrder == Group.PinOrderStyle.DepthFirst)                          //{                          //    int topY = pinNodes.Min(x => x.GroupPin.InternalModule.Position.Y);                          //    foreach (var fakePinNode in pinList)                          //    {                            //        fakePinNode.DesiredLocation = new Point(offset.X' topY + offset.Y + fakePinNode.GroupPin.Index * (PinNodeHeight + PinNodeMargin));                          //    }                          //}                          //else                          {                              foreach (var fakePinNode in pinList)                              {                                  int pinOffset = GetPinOffset(fakePinNode.InternalElement' fakePinNode.InternalPinIndex' inputSide);                                  fakePinNode.DesiredLocation = new Point( offset.X' fakePinNode.InternalElement.Bounds.Location.Y + pinOffset - 8);                             }                                // ensure the minimum margin between pin nodes( avoid overlapping among the pin nodes)                                                                              int lastY = pinList[0].DesiredLocation.Y;                              for (int i = 1; i < pinList.Count; ++i)                              {                                  var pin = pinList[i];                                    int delta = pin.DesiredLocation.Y - lastY - (CircuitGroupPinInfo.FloatingPinNodeHeight + CircuitGroupPinInfo.FloatingPinNodeMargin);                                  if (delta < 0) // distance is less than the minimum interval for the current floating pin                                  {                                      // adjust the desired location to have a safe margin below the  preceding floating pin                                      pinList[i].DesiredLocation =  new Point(0'  pinList[i].DesiredLocation.Y - delta);                                  }                                  lastY = pin.DesiredLocation.Y;                              }                          }                                               }                        //if (measureParts.HasFlag(MeasurePinNode.MaximumNameWidth))                      //{                      //      foreach (var fakePinNode in pinNodes)                      //      {                      //          SizeF nameSize = g.MeasureString(fakePinNode.SubGraphPin.Name' m_subGraphRenderer.GetElementFont(fakePinNode' g));                      //          if (nameSize.Width > maximumNameWidth)                      //              maximumNameWidth = (int) (nameSize.Width+ 0.5) + PinNodeMargin;                      //      }                      //}                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,AdjustLayout,The following statement contains a magic number: for (int pass = 0; pass < 2; ++pass) //pass 0 for input side' pass 1 for output side              {                  var grpPins = (pass == 0 ? subGraph.InputGroupPins : subGraph.OutputGroupPins).ToList();                  // calculate all free pins of moving nodes' natural position'then ordered bottom up                  // note for selected floating pins( group pins being directly dragged) should sync the move with the mouse                  var freePinsToAdjust = grpPins                      .Where(x => !x.Info.Pinned)                      .Except(m_draggingGroupPins)                      .Where(x => movedNodes.Contains(x.InternalElement))                      .ToList();                    // now adjust free pins                  var againstPins = grpPins                      .Except(freePinsToAdjust)                      .OrderBy(y => y.Bounds.Location.Y).ToList();                    MeasureFakePins(freePinsToAdjust' MeasurePinNode.DesiredLocation' offset' pass==0);                    int minY     = int.MinValue; // minimum allowed new y location for free pins                    var floatingPins = freePinsToAdjust.OrderBy(x => x.DesiredLocation.Y).ToList();                  for (int i = 0; i < floatingPins.Count; ++i)                  {                      var floatingPin = floatingPins[i];                      PositioningFloatigPin(againstPins'  floatingPin' minY);                      minY = floatingPin.Bounds.Location.Y + CircuitGroupPinInfo.FloatingPinNodeHeight +                             CircuitGroupPinInfo.FloatingPinNodeMargin;                      // update desired location for the rest of the free pins                       int delta = floatingPin.Bounds.Location.Y - floatingPin.DesiredLocation.Y;                      for (int j = i + 1; j < floatingPins.Count; ++j)                          floatingPins[j].DesiredLocation = new Point(floatingPins[j].DesiredLocation.X' Math.Max(floatingPins[j].DesiredLocation.Y + delta' minY));                  }                }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,GroupPinEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\GroupPinEditor.cs,PositioningFloatigPin,The following statement contains a magic number: for (int p = 0; p < againstPinNodes.Count; ++p) // try to locate sufficient empty space between the static nodes              {                  var againstpin = againstPinNodes[p];                  if (againstpin.Bounds.Location.Y + CircuitGroupPinInfo.FloatingPinNodeHeight + CircuitGroupPinInfo.FloatingPinNodeMargin < minY)                      continue;                   if (PinOverlap(floatingPin' againstpin))                  {                      overlapped = true;                      // find next suitable place from p down (note againstPinNodes y-ascending order' i.e. higher notes appear first)                      for (int j = p; j < againstPinNodes.Count - 1; ++j)                      {                          if (againstPinNodes[j+1].Bounds.Location.Y - againstPinNodes[j ].Bounds.Location.Y >= 2 * (CircuitGroupPinInfo.FloatingPinNodeHeight + CircuitGroupPinInfo.FloatingPinNodeMargin))                          {                              // find empty space >=  pin node height + margin                              // place the floating pin just above static pin j                              int pinNewY = Constrain(againstPinNodes[j].Bounds.Location.Y + CircuitGroupPinInfo.FloatingPinNodeHeight + CircuitGroupPinInfo.FloatingPinNodeMargin);                              floatingPin.Bounds = new Rectangle(floatingPin.Bounds.Location.X' pinNewY' floatingPin.Bounds.Width' floatingPin.Bounds.Height);                              return;                          }                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,ViewingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\ViewingContext.cs,SetCanvasBounds,The following statement contains a magic number: if (m_control != null &&                  m_control.Visible)              {                  //get the bounds in client screen coordinates                  Rectangle bounds = GetBounds();                    //transform to world coordinates                  var transformAdapter = m_control.As<ITransformAdapter>();                  bounds = GdiUtil.InverseTransform(transformAdapter.Transform' bounds);                    // Make the canvas larger than it needs to be to give the user some room.                  // Use the client rectangle in world coordinates.                  Rectangle clientRect = GdiUtil.InverseTransform(transformAdapter.Transform' m_control.ClientRectangle);                  bounds.Width = Math.Max(bounds.Width * 2' clientRect.Width * 2);                  bounds.Height = Math.Max(bounds.Height * 2' clientRect.Height * 2);                    var canvasAdapter = m_control.As<ICanvasAdapter>();                  if (canvasAdapter != null)                      canvasAdapter.Bounds = bounds;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,ViewingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\ViewingContext.cs,SetCanvasBounds,The following statement contains a magic number: if (m_control != null &&                  m_control.Visible)              {                  //get the bounds in client screen coordinates                  Rectangle bounds = GetBounds();                    //transform to world coordinates                  var transformAdapter = m_control.As<ITransformAdapter>();                  bounds = GdiUtil.InverseTransform(transformAdapter.Transform' bounds);                    // Make the canvas larger than it needs to be to give the user some room.                  // Use the client rectangle in world coordinates.                  Rectangle clientRect = GdiUtil.InverseTransform(transformAdapter.Transform' m_control.ClientRectangle);                  bounds.Width = Math.Max(bounds.Width * 2' clientRect.Width * 2);                  bounds.Height = Math.Max(bounds.Height * 2' clientRect.Height * 2);                    var canvasAdapter = m_control.As<ICanvasAdapter>();                  if (canvasAdapter != null)                      canvasAdapter.Bounds = bounds;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,ViewingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\ViewingContext.cs,SetCanvasBounds,The following statement contains a magic number: if (m_control != null &&                  m_control.Visible)              {                  //get the bounds in client screen coordinates                  Rectangle bounds = GetBounds();                    //transform to world coordinates                  var transformAdapter = m_control.As<ITransformAdapter>();                  bounds = GdiUtil.InverseTransform(transformAdapter.Transform' bounds);                    // Make the canvas larger than it needs to be to give the user some room.                  // Use the client rectangle in world coordinates.                  Rectangle clientRect = GdiUtil.InverseTransform(transformAdapter.Transform' m_control.ClientRectangle);                  bounds.Width = Math.Max(bounds.Width * 2' clientRect.Width * 2);                  bounds.Height = Math.Max(bounds.Height * 2' clientRect.Height * 2);                    var canvasAdapter = m_control.As<ICanvasAdapter>();                  if (canvasAdapter != null)                      canvasAdapter.Bounds = bounds;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,ViewingContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\ViewingContext.cs,SetCanvasBounds,The following statement contains a magic number: if (m_control != null &&                  m_control.Visible)              {                  //get the bounds in client screen coordinates                  Rectangle bounds = GetBounds();                    //transform to world coordinates                  var transformAdapter = m_control.As<ITransformAdapter>();                  bounds = GdiUtil.InverseTransform(transformAdapter.Transform' bounds);                    // Make the canvas larger than it needs to be to give the user some room.                  // Use the client rectangle in world coordinates.                  Rectangle clientRect = GdiUtil.InverseTransform(transformAdapter.Transform' m_control.ClientRectangle);                  bounds.Width = Math.Max(bounds.Width * 2' clientRect.Width * 2);                  bounds.Height = Math.Max(bounds.Height * 2' clientRect.Height * 2);                    var canvasAdapter = m_control.As<ICanvasAdapter>();                  if (canvasAdapter != null)                      canvasAdapter.Bounds = bounds;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,D2dCircuitRenderer,The following statement contains a magic number: m_elementBody.RadiusX = 6;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,D2dCircuitRenderer,The following statement contains a magic number: m_elementBody.RadiusY = 6;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,D2dCircuitRenderer,The following statement contains a magic number: MaxCollapsedGroupPinNameLength = 25;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetPinPositionCenterY,The following statement contains a magic number: pt.Y += m_pinSize / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetPinPosition,The following statement contains a magic number: if (inputSide) // group pin box on the left edge              {                  Point op = element.Bounds.Location;                  op.Y += GetPinOffset(element' pinIndex' true);                  if (m_pinDrawStyle == PinStyle.OnBorderFilled)                      op.X -= m_pinSize / 2;                  return op;              }              else              {                  ElementTypeInfo info = GetElementTypeInfo(element' g);                  Point ip = element.Bounds.Location;                  ip.X += info.Size.Width;                  if (m_pinDrawStyle == PinStyle.OnBorderFilled)                      ip.X += m_pinSize / 2;                  ip.Y += GetPinOffset(element' pinIndex' false);                  return ip;                }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetPinPosition,The following statement contains a magic number: if (inputSide) // group pin box on the left edge              {                  Point op = element.Bounds.Location;                  op.Y += GetPinOffset(element' pinIndex' true);                  if (m_pinDrawStyle == PinStyle.OnBorderFilled)                      op.X -= m_pinSize / 2;                  return op;              }              else              {                  ElementTypeInfo info = GetElementTypeInfo(element' g);                  Point ip = element.Bounds.Location;                  ip.X += info.Size.Width;                  if (m_pinDrawStyle == PinStyle.OnBorderFilled)                      ip.X += m_pinSize / 2;                  ip.Y += GetPinOffset(element' pinIndex' false);                  return ip;                }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Pick,The following statement contains a magic number: if (pickedElement.Is<ICircuitGroupType<TElement' TWire' TPin>>())              {                  hitRecord = PickExpander(pickedElement.Cast<ICircuitGroupType<TElement' TWire' TPin>>()' p' g);                  if (hitRecord != null)                      return hitRecord;                    // check title bar                  var titleBar = new RectangleF(bounds.Left - m_theme.PickTolerance' bounds.Y' bounds.Width' TitleHeight);                  if (titleBar.Contains(p))                      return new GraphHitRecord<TElement' TWire' TPin>(pickedElement' new DiagramTitleBar(pickedElement));                    //pickedWire == null &&                   if (pickedOutput == null && pickedInput == null) // check border lastly                  {                      var border = new RectangleF(bounds.Left - m_theme.PickTolerance' bounds.Y' 2 * m_theme.PickTolerance' bounds.Height);                      if (border.Contains(p))                          borderPart.Border = DiagramBorder.BorderType.Left;                      else                      {                          border.Offset(bounds.Width' 0);                          if (border.Contains(p))                              borderPart.Border = DiagramBorder.BorderType.Right;                          else                          {                              border = new RectangleF(bounds.Left' bounds.Y - m_theme.PickTolerance' bounds.Width' 2 * m_theme.PickTolerance);                              if (border.Contains(p))                                  borderPart.Border = DiagramBorder.BorderType.Top;                              else                              {                                  border.Offset(0' bounds.Height);                                  if (border.Contains(p))                                      borderPart.Border = DiagramBorder.BorderType.Bottom;                              }                          }                      }                  }                    subPick = PickSubItem(pickedElement.Cast<ICircuitGroupType<TElement' TWire' TPin>>()' p' g'                      out pickedSubInput' out pickedSubOutput);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Pick,The following statement contains a magic number: if (pickedElement.Is<ICircuitGroupType<TElement' TWire' TPin>>())              {                  hitRecord = PickExpander(pickedElement.Cast<ICircuitGroupType<TElement' TWire' TPin>>()' p' g);                  if (hitRecord != null)                      return hitRecord;                    // check title bar                  var titleBar = new RectangleF(bounds.Left - m_theme.PickTolerance' bounds.Y' bounds.Width' TitleHeight);                  if (titleBar.Contains(p))                      return new GraphHitRecord<TElement' TWire' TPin>(pickedElement' new DiagramTitleBar(pickedElement));                    //pickedWire == null &&                   if (pickedOutput == null && pickedInput == null) // check border lastly                  {                      var border = new RectangleF(bounds.Left - m_theme.PickTolerance' bounds.Y' 2 * m_theme.PickTolerance' bounds.Height);                      if (border.Contains(p))                          borderPart.Border = DiagramBorder.BorderType.Left;                      else                      {                          border.Offset(bounds.Width' 0);                          if (border.Contains(p))                              borderPart.Border = DiagramBorder.BorderType.Right;                          else                          {                              border = new RectangleF(bounds.Left' bounds.Y - m_theme.PickTolerance' bounds.Width' 2 * m_theme.PickTolerance);                              if (border.Contains(p))                                  borderPart.Border = DiagramBorder.BorderType.Top;                              else                              {                                  border.Offset(0' bounds.Height);                                  if (border.Contains(p))                                      borderPart.Border = DiagramBorder.BorderType.Bottom;                              }                          }                      }                  }                    subPick = PickSubItem(pickedElement.Cast<ICircuitGroupType<TElement' TWire' TPin>>()' p' g'                      out pickedSubInput' out pickedSubOutput);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Draw,The following statement contains a magic number: if (!TitleBackgroundFilled &&                  (info.Size.Height > TitleHeight + 2 * m_pinMargin)) // check non-empty content                  g.DrawLine(p.X' p.Y + titleHeight' p.X + info.Size.Width' p.Y + titleHeight' m_theme.OutlineBrush);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Draw,The following statement contains a magic number: if (drawText)              {                  string title = GetElementTitle(element);                  if (!string.IsNullOrEmpty(title))                  {                      var hAlignment = m_theme.TextFormat.TextAlignment;                      var vAlignment = m_theme.TextFormat.ParagraphAlignment;                        m_theme.TextFormat.TextAlignment = D2dTextAlignment.Center;                      m_theme.TextFormat.ParagraphAlignment = D2dParagraphAlignment.Center;                        var textRect = new RectangleF(titleRect.X' titleRect.Y' titleRect.Width' titleRect.Height);                      g.DrawText(title' m_theme.TextFormat' textRect' m_theme.TextBrush);                        m_theme.TextFormat.TextAlignment = hAlignment;                      m_theme.TextFormat.ParagraphAlignment = vAlignment;                  }                    string displayName = GetElementDisplayName(element);                  if (!string.IsNullOrEmpty(displayName))                  {                      var alignRect = new RectangleF(bounds.Left - MaxNameOverhang' bounds.Bottom + m_pinMargin'                          bounds.Width + 2 * MaxNameOverhang' m_rowSpacing);                      var textAlignment = m_theme.TextFormat.TextAlignment;                      m_theme.TextFormat.TextAlignment = D2dTextAlignment.Center;                      g.DrawText(displayName' m_theme.TextFormat' alignRect' m_theme.TextBrush);                      m_theme.TextFormat.TextAlignment = textAlignment;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Draw,The following statement contains a magic number: if (element.Is<IReference<TElement>>())                  g.DrawLink(p.X + bounds.Width - m_pinMargin - 2 - 2 * ExpanderSize' //make room for GetShowPinsRect()                      p.Y + 2 * m_pinMargin + 1' ExpanderSize' m_theme.HotBrush);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Draw,The following statement contains a magic number: if (element.Is<IReference<TElement>>())                  g.DrawLink(p.X + bounds.Width - m_pinMargin - 2 - 2 * ExpanderSize' //make room for GetShowPinsRect()                      p.Y + 2 * m_pinMargin + 1' ExpanderSize' m_theme.HotBrush);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,Draw,The following statement contains a magic number: if (element.Is<IReference<TElement>>())                  g.DrawLink(p.X + bounds.Width - m_pinMargin - 2 - 2 * ExpanderSize' //make room for GetShowPinsRect()                      p.Y + 2 * m_pinMargin + 1' ExpanderSize' m_theme.HotBrush);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawExpandedGroupPins,The following statement contains a magic number: if (group.Info.ShowExpandedGroupPins)              {                  Point subOffset = SubGraphOffset(element);                    int x1' y1;                  foreach (var pin in group.Inputs)                  {                      var grpPin = pin.Cast<ICircuitGroupPin<TElement>>();                      // draw group pin box on the left edge                      Point op = group.Bounds.Location;                      op.Offset(ParentWorldOffset(m_graphPath));                      x1 = op.X;                      y1 = op.Y + grpPin.Bounds.Location.Y + m_groupPinExpandedOffset + subOffset.Y;                      g.DrawRectangle(new RectangleF(x1 - m_pinSize / 2' y1 - m_pinSize / 2' m_pinSize' m_pinSize)'                                      grpPin.Info.Color' 1.0f' null);                        // draw virtual link from the subnode to the group pin box when there are incoming wires                      if (!grpPin.Info.ExternalConnected && CircuitDefaultStyle.ShowVirtualLinks)                      {                          Point ip = grpPin.InternalElement.Bounds.Location;                          ip.Offset(WorldOffset(m_graphPath));                          int y2 = ip.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex' true);                          int x2 = ip.X;                            DrawWire(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                          //DrawLine(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                      }                    }                    foreach (var pin in group.Outputs)                  {                      var grpPin = pin.Cast<ICircuitGroupPin<TElement>>();                      ElementTypeInfo info = GetElementTypeInfo(element' g);                        // draw group pin box on the right edge                      Point op = group.Bounds.Location;                      op.Offset(ParentWorldOffset(m_graphPath));                      x1 = op.X + info.Size.Width;                      y1 = op.Y + grpPin.Bounds.Location.Y + m_groupPinExpandedOffset + subOffset.Y;                        g.DrawRectangle(new RectangleF(x1 - m_pinSize / 2' y1 - m_pinSize / 2' m_pinSize' m_pinSize)'                                      grpPin.Info.Color' 1.0f' null);                        // draw virtual link from the subnode to the group pin box when there are outgoing wires                      if (!grpPin.Info.ExternalConnected && CircuitDefaultStyle.ShowVirtualLinks)                      {                          info = GetElementTypeInfo(grpPin.InternalElement' g);                          Point ip = grpPin.InternalElement.Bounds.Location;                          ip.Offset(WorldOffset(m_graphPath));                          int y2 = ip.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex' false);                          int x2 = ip.X + info.Size.Width;                            DrawWire(g' SubGraphPinBrush' x2' y2' x1' y1' 1.0f' null);                          //DrawLine(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawExpandedGroupPins,The following statement contains a magic number: if (group.Info.ShowExpandedGroupPins)              {                  Point subOffset = SubGraphOffset(element);                    int x1' y1;                  foreach (var pin in group.Inputs)                  {                      var grpPin = pin.Cast<ICircuitGroupPin<TElement>>();                      // draw group pin box on the left edge                      Point op = group.Bounds.Location;                      op.Offset(ParentWorldOffset(m_graphPath));                      x1 = op.X;                      y1 = op.Y + grpPin.Bounds.Location.Y + m_groupPinExpandedOffset + subOffset.Y;                      g.DrawRectangle(new RectangleF(x1 - m_pinSize / 2' y1 - m_pinSize / 2' m_pinSize' m_pinSize)'                                      grpPin.Info.Color' 1.0f' null);                        // draw virtual link from the subnode to the group pin box when there are incoming wires                      if (!grpPin.Info.ExternalConnected && CircuitDefaultStyle.ShowVirtualLinks)                      {                          Point ip = grpPin.InternalElement.Bounds.Location;                          ip.Offset(WorldOffset(m_graphPath));                          int y2 = ip.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex' true);                          int x2 = ip.X;                            DrawWire(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                          //DrawLine(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                      }                    }                    foreach (var pin in group.Outputs)                  {                      var grpPin = pin.Cast<ICircuitGroupPin<TElement>>();                      ElementTypeInfo info = GetElementTypeInfo(element' g);                        // draw group pin box on the right edge                      Point op = group.Bounds.Location;                      op.Offset(ParentWorldOffset(m_graphPath));                      x1 = op.X + info.Size.Width;                      y1 = op.Y + grpPin.Bounds.Location.Y + m_groupPinExpandedOffset + subOffset.Y;                        g.DrawRectangle(new RectangleF(x1 - m_pinSize / 2' y1 - m_pinSize / 2' m_pinSize' m_pinSize)'                                      grpPin.Info.Color' 1.0f' null);                        // draw virtual link from the subnode to the group pin box when there are outgoing wires                      if (!grpPin.Info.ExternalConnected && CircuitDefaultStyle.ShowVirtualLinks)                      {                          info = GetElementTypeInfo(grpPin.InternalElement' g);                          Point ip = grpPin.InternalElement.Bounds.Location;                          ip.Offset(WorldOffset(m_graphPath));                          int y2 = ip.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex' false);                          int x2 = ip.X + info.Size.Width;                            DrawWire(g' SubGraphPinBrush' x2' y2' x1' y1' 1.0f' null);                          //DrawLine(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawExpandedGroupPins,The following statement contains a magic number: if (group.Info.ShowExpandedGroupPins)              {                  Point subOffset = SubGraphOffset(element);                    int x1' y1;                  foreach (var pin in group.Inputs)                  {                      var grpPin = pin.Cast<ICircuitGroupPin<TElement>>();                      // draw group pin box on the left edge                      Point op = group.Bounds.Location;                      op.Offset(ParentWorldOffset(m_graphPath));                      x1 = op.X;                      y1 = op.Y + grpPin.Bounds.Location.Y + m_groupPinExpandedOffset + subOffset.Y;                      g.DrawRectangle(new RectangleF(x1 - m_pinSize / 2' y1 - m_pinSize / 2' m_pinSize' m_pinSize)'                                      grpPin.Info.Color' 1.0f' null);                        // draw virtual link from the subnode to the group pin box when there are incoming wires                      if (!grpPin.Info.ExternalConnected && CircuitDefaultStyle.ShowVirtualLinks)                      {                          Point ip = grpPin.InternalElement.Bounds.Location;                          ip.Offset(WorldOffset(m_graphPath));                          int y2 = ip.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex' true);                          int x2 = ip.X;                            DrawWire(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                          //DrawLine(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                      }                    }                    foreach (var pin in group.Outputs)                  {                      var grpPin = pin.Cast<ICircuitGroupPin<TElement>>();                      ElementTypeInfo info = GetElementTypeInfo(element' g);                        // draw group pin box on the right edge                      Point op = group.Bounds.Location;                      op.Offset(ParentWorldOffset(m_graphPath));                      x1 = op.X + info.Size.Width;                      y1 = op.Y + grpPin.Bounds.Location.Y + m_groupPinExpandedOffset + subOffset.Y;                        g.DrawRectangle(new RectangleF(x1 - m_pinSize / 2' y1 - m_pinSize / 2' m_pinSize' m_pinSize)'                                      grpPin.Info.Color' 1.0f' null);                        // draw virtual link from the subnode to the group pin box when there are outgoing wires                      if (!grpPin.Info.ExternalConnected && CircuitDefaultStyle.ShowVirtualLinks)                      {                          info = GetElementTypeInfo(grpPin.InternalElement' g);                          Point ip = grpPin.InternalElement.Bounds.Location;                          ip.Offset(WorldOffset(m_graphPath));                          int y2 = ip.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex' false);                          int x2 = ip.X + info.Size.Width;                            DrawWire(g' SubGraphPinBrush' x2' y2' x1' y1' 1.0f' null);                          //DrawLine(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawExpandedGroupPins,The following statement contains a magic number: if (group.Info.ShowExpandedGroupPins)              {                  Point subOffset = SubGraphOffset(element);                    int x1' y1;                  foreach (var pin in group.Inputs)                  {                      var grpPin = pin.Cast<ICircuitGroupPin<TElement>>();                      // draw group pin box on the left edge                      Point op = group.Bounds.Location;                      op.Offset(ParentWorldOffset(m_graphPath));                      x1 = op.X;                      y1 = op.Y + grpPin.Bounds.Location.Y + m_groupPinExpandedOffset + subOffset.Y;                      g.DrawRectangle(new RectangleF(x1 - m_pinSize / 2' y1 - m_pinSize / 2' m_pinSize' m_pinSize)'                                      grpPin.Info.Color' 1.0f' null);                        // draw virtual link from the subnode to the group pin box when there are incoming wires                      if (!grpPin.Info.ExternalConnected && CircuitDefaultStyle.ShowVirtualLinks)                      {                          Point ip = grpPin.InternalElement.Bounds.Location;                          ip.Offset(WorldOffset(m_graphPath));                          int y2 = ip.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex' true);                          int x2 = ip.X;                            DrawWire(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                          //DrawLine(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                      }                    }                    foreach (var pin in group.Outputs)                  {                      var grpPin = pin.Cast<ICircuitGroupPin<TElement>>();                      ElementTypeInfo info = GetElementTypeInfo(element' g);                        // draw group pin box on the right edge                      Point op = group.Bounds.Location;                      op.Offset(ParentWorldOffset(m_graphPath));                      x1 = op.X + info.Size.Width;                      y1 = op.Y + grpPin.Bounds.Location.Y + m_groupPinExpandedOffset + subOffset.Y;                        g.DrawRectangle(new RectangleF(x1 - m_pinSize / 2' y1 - m_pinSize / 2' m_pinSize' m_pinSize)'                                      grpPin.Info.Color' 1.0f' null);                        // draw virtual link from the subnode to the group pin box when there are outgoing wires                      if (!grpPin.Info.ExternalConnected && CircuitDefaultStyle.ShowVirtualLinks)                      {                          info = GetElementTypeInfo(grpPin.InternalElement' g);                          Point ip = grpPin.InternalElement.Bounds.Location;                          ip.Offset(WorldOffset(m_graphPath));                          int y2 = ip.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex' false);                          int x2 = ip.X + info.Size.Width;                            DrawWire(g' SubGraphPinBrush' x2' y2' x1' y1' 1.0f' null);                          //DrawLine(g' SubGraphPinBrush' x1' y1' x2' y2' 1.0f' null);                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawOutline,The following statement contains a magic number: if (useRoundedRect)              {                  m_elementBody.Rect = bounds;                  g.DrawRoundedRectangle(m_elementBody' pen' 2);              }              else              {                  g.DrawRectangle(bounds' pen' 2);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawOutline,The following statement contains a magic number: if (useRoundedRect)              {                  m_elementBody.Rect = bounds;                  g.DrawRoundedRectangle(m_elementBody' pen' 2);              }              else              {                  g.DrawRectangle(bounds' pen' 2);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickOutput,The following statement contains a magic number: if (RouteConnecting == null)              {                  if (PinDrawStyle == PinStyle.OnBorderFilled)                      pinX = element.Bounds.X + info.Size.Width - m_pinSize / 2;                  else                      pinX = element.Bounds.X + info.Size.Width - m_pinSize;              }              else                  pinX = element.Bounds.X + info.Size.Width / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickOutput,The following statement contains a magic number: if (RouteConnecting == null)              {                  if (PinDrawStyle == PinStyle.OnBorderFilled)                      pinX = element.Bounds.X + info.Size.Width - m_pinSize / 2;                  else                      pinX = element.Bounds.X + info.Size.Width - m_pinSize;              }              else                  pinX = element.Bounds.X + info.Size.Width / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickSubItem,The following statement contains a magic number: if (pickedWire != null)              {                  result.First = stack;                  result.Second = pickedWire;              }              else if (stack.Peek() != pickedElement.Cast<TElement>())// stack top is the picked subitem              {                  var subItem = stack.Peek();                  result.First = stack; // get hit path                     // try pick subItem                  RectangleF bounds = GetElementBounds(subItem' g);                  bounds.Offset(ParentWorldOffset(stack));                  ElementTypeInfo info = GetElementTypeInfo(subItem' g);                    if (PinDrawStyle == PinStyle.OnBorderFilled)                  {                      pickedSubInput = PickPin(subItem' true' (int)bounds.X - m_pinSize / 2' (int)bounds.Y' info' p);                      pickedSubOutput = PickPin(subItem' false' (int)bounds.X + info.Size.Width - m_pinSize / 2' (int)bounds.Y' info' p);                    }                  else                  {                      pickedSubInput = PickPin(subItem' true' (int)bounds.X' (int)bounds.Y' info' p);                      pickedSubOutput = PickPin(subItem' false' (int)bounds.X + info.Size.Width - m_pinSize' (int)bounds.Y' info' p);                    }                  result.Second = pickedSubInput ?? pickedSubOutput;                  if (result.Second == null) // check border lastly                  {                      var border = new RectangleF(bounds.Left - m_theme.PickTolerance' bounds.Y' 2 * m_theme.PickTolerance' bounds.Height);                      if (border.Contains(p))                          result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Left);                      else                      {                          border.Offset(bounds.Width' 0);                          if (border.Contains(p))                              result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Right);                          else                          {                              border = new RectangleF(bounds.Left' bounds.Y - m_theme.PickTolerance' bounds.Width' 2 * m_theme.PickTolerance);                              if (border.Contains(p))                                  result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Top);                              else                              {                                  border.Offset(0' bounds.Height);                                  if (border.Contains(p))                                      result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Bottom);                              }                          }                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickSubItem,The following statement contains a magic number: if (pickedWire != null)              {                  result.First = stack;                  result.Second = pickedWire;              }              else if (stack.Peek() != pickedElement.Cast<TElement>())// stack top is the picked subitem              {                  var subItem = stack.Peek();                  result.First = stack; // get hit path                     // try pick subItem                  RectangleF bounds = GetElementBounds(subItem' g);                  bounds.Offset(ParentWorldOffset(stack));                  ElementTypeInfo info = GetElementTypeInfo(subItem' g);                    if (PinDrawStyle == PinStyle.OnBorderFilled)                  {                      pickedSubInput = PickPin(subItem' true' (int)bounds.X - m_pinSize / 2' (int)bounds.Y' info' p);                      pickedSubOutput = PickPin(subItem' false' (int)bounds.X + info.Size.Width - m_pinSize / 2' (int)bounds.Y' info' p);                    }                  else                  {                      pickedSubInput = PickPin(subItem' true' (int)bounds.X' (int)bounds.Y' info' p);                      pickedSubOutput = PickPin(subItem' false' (int)bounds.X + info.Size.Width - m_pinSize' (int)bounds.Y' info' p);                    }                  result.Second = pickedSubInput ?? pickedSubOutput;                  if (result.Second == null) // check border lastly                  {                      var border = new RectangleF(bounds.Left - m_theme.PickTolerance' bounds.Y' 2 * m_theme.PickTolerance' bounds.Height);                      if (border.Contains(p))                          result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Left);                      else                      {                          border.Offset(bounds.Width' 0);                          if (border.Contains(p))                              result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Right);                          else                          {                              border = new RectangleF(bounds.Left' bounds.Y - m_theme.PickTolerance' bounds.Width' 2 * m_theme.PickTolerance);                              if (border.Contains(p))                                  result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Top);                              else                              {                                  border.Offset(0' bounds.Height);                                  if (border.Contains(p))                                      result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Bottom);                              }                          }                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickSubItem,The following statement contains a magic number: if (pickedWire != null)              {                  result.First = stack;                  result.Second = pickedWire;              }              else if (stack.Peek() != pickedElement.Cast<TElement>())// stack top is the picked subitem              {                  var subItem = stack.Peek();                  result.First = stack; // get hit path                     // try pick subItem                  RectangleF bounds = GetElementBounds(subItem' g);                  bounds.Offset(ParentWorldOffset(stack));                  ElementTypeInfo info = GetElementTypeInfo(subItem' g);                    if (PinDrawStyle == PinStyle.OnBorderFilled)                  {                      pickedSubInput = PickPin(subItem' true' (int)bounds.X - m_pinSize / 2' (int)bounds.Y' info' p);                      pickedSubOutput = PickPin(subItem' false' (int)bounds.X + info.Size.Width - m_pinSize / 2' (int)bounds.Y' info' p);                    }                  else                  {                      pickedSubInput = PickPin(subItem' true' (int)bounds.X' (int)bounds.Y' info' p);                      pickedSubOutput = PickPin(subItem' false' (int)bounds.X + info.Size.Width - m_pinSize' (int)bounds.Y' info' p);                    }                  result.Second = pickedSubInput ?? pickedSubOutput;                  if (result.Second == null) // check border lastly                  {                      var border = new RectangleF(bounds.Left - m_theme.PickTolerance' bounds.Y' 2 * m_theme.PickTolerance' bounds.Height);                      if (border.Contains(p))                          result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Left);                      else                      {                          border.Offset(bounds.Width' 0);                          if (border.Contains(p))                              result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Right);                          else                          {                              border = new RectangleF(bounds.Left' bounds.Y - m_theme.PickTolerance' bounds.Width' 2 * m_theme.PickTolerance);                              if (border.Contains(p))                                  result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Top);                              else                              {                                  border.Offset(0' bounds.Height);                                  if (border.Contains(p))                                      result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Bottom);                              }                          }                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,PickSubItem,The following statement contains a magic number: if (pickedWire != null)              {                  result.First = stack;                  result.Second = pickedWire;              }              else if (stack.Peek() != pickedElement.Cast<TElement>())// stack top is the picked subitem              {                  var subItem = stack.Peek();                  result.First = stack; // get hit path                     // try pick subItem                  RectangleF bounds = GetElementBounds(subItem' g);                  bounds.Offset(ParentWorldOffset(stack));                  ElementTypeInfo info = GetElementTypeInfo(subItem' g);                    if (PinDrawStyle == PinStyle.OnBorderFilled)                  {                      pickedSubInput = PickPin(subItem' true' (int)bounds.X - m_pinSize / 2' (int)bounds.Y' info' p);                      pickedSubOutput = PickPin(subItem' false' (int)bounds.X + info.Size.Width - m_pinSize / 2' (int)bounds.Y' info' p);                    }                  else                  {                      pickedSubInput = PickPin(subItem' true' (int)bounds.X' (int)bounds.Y' info' p);                      pickedSubOutput = PickPin(subItem' false' (int)bounds.X + info.Size.Width - m_pinSize' (int)bounds.Y' info' p);                    }                  result.Second = pickedSubInput ?? pickedSubOutput;                  if (result.Second == null) // check border lastly                  {                      var border = new RectangleF(bounds.Left - m_theme.PickTolerance' bounds.Y' 2 * m_theme.PickTolerance' bounds.Height);                      if (border.Contains(p))                          result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Left);                      else                      {                          border.Offset(bounds.Width' 0);                          if (border.Contains(p))                              result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Right);                          else                          {                              border = new RectangleF(bounds.Left' bounds.Y - m_theme.PickTolerance' bounds.Width' 2 * m_theme.PickTolerance);                              if (border.Contains(p))                                  result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Top);                              else                              {                                  border.Offset(0' bounds.Height);                                  if (border.Contains(p))                                      result.Second = new DiagramBorder(subItem' DiagramBorder.BorderType.Bottom);                              }                          }                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetElementSizeInfo,The following statement contains a magic number: for (int i = 0; i < maxRows; i++)              {                  rowWidth = 2 * m_pinMargin;                  if (inputCount > i)                  {                      var pinText = inputPins[i].Name;                      if (isCollapsedGroup)                          pinText = TruncatePinText(pinText);                      SizeF labelSize = g.MeasureText(pinText' m_theme.TextFormat);                      rowWidth += labelSize.Width + m_pinSize + m_pinMargin;                  }                  else                  {                      imageRight = false;                  }                      if (outputCount > i)                  {                      var pinText = outputPins[i].Name;                      if (isCollapsedGroup)                          pinText = TruncatePinText(pinText);                      SizeF labelSize = g.MeasureText(pinText' m_theme.TextFormat);                      outputLeftX[i] = (int)labelSize.Width;                      rowWidth += labelSize.Width + m_pinSize + m_pinMargin;                  }                    rowWidth += type.InteriorSize.Width;                    width = Math.Max(width' (int)rowWidth);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetElementSizeInfo,The following statement contains a magic number: if (inputCount == outputCount)                  width = Math.Max(width' type.InteriorSize.Width + 2);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,CalculateElementHeight,The following statement contains a magic number: int height = m_rowSpacing + 2 * m_pinMargin;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawWire,The following statement contains a magic number: if (PinDrawStyle == PinStyle.OnBorderFilled)                  x1 += m_pinSize / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawWire,The following statement contains a magic number: int y1 = op.Y + GetPinOffset(outputElement' outputPin.Index' false)                  + m_pinSize / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawWire,The following statement contains a magic number: if (PinDrawStyle == PinStyle.OnBorderFilled)                  x2 -= m_pinSize / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawWire,The following statement contains a magic number: int y2 = ip.Y + GetPinOffset(inputElement' inputPin.Index' true)              + m_pinSize / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,DrawWire,The following statement contains a magic number: float y = m_pinSize / 2 + ep.Y + GetPinOffset(element' pin.Index' !fromOutput);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetTangentLength,The following statement contains a magic number: const int minTanLen = 32;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetTangentLength,The following statement contains a magic number: float tanLen = Math.Abs(x1 - x2) / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,SetPinSpacing,The following statement contains a magic number: m_groupPinExpandedOffset = 2 * m_rowSpacing;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,SetPinSpacing,The following statement contains a magic number: if (!m_subContentOffseExternalSet)                  m_subContentOffset = new Point(m_rowSpacing + 4 * m_pinMargin' m_rowSpacing + 4 * m_pinMargin);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,SetPinSpacing,The following statement contains a magic number: if (!m_subContentOffseExternalSet)                  m_subContentOffset = new Point(m_rowSpacing + 4 * m_pinMargin' m_rowSpacing + 4 * m_pinMargin);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetWireBounds,The following statement contains a magic number: if (wire.Is<IEdgeStyleProvider>())              {                  bool firstTime = true;                  foreach (var edgeInfo in wire.Cast<IEdgeStyleProvider>().GetData(this' WorldOffset(m_graphPath)' g))                  {                      if (edgeInfo.ShapeType == EdgeStyleData.EdgeShape.Bezier)                      {                          var curve = edgeInfo.EdgeData.As<BezierCurve2F>();                          var cpts = new PointF[] { curve.P1' curve.P2' curve.P3' curve.P4 };                          if (firstTime)                          {                              result = GetPointsBounds(cpts);                              firstTime = false;                          }                          else                              result = RectangleF.Union(result' GetPointsBounds(cpts));                      }                      else if (edgeInfo.ShapeType == EdgeStyleData.EdgeShape.Line)                      {                          var line = edgeInfo.EdgeData.As<PointF[]>();                          if (line != null)                          {                              if (firstTime)                              {                                  result = D2dUtil.MakeRectangle(line[0]' line[1]);                                  firstTime = false;                              }                              else                                  result = RectangleF.Union(result' D2dUtil.MakeRectangle(line[0]' line[1]));                          }                        }                      else if (edgeInfo.ShapeType == EdgeStyleData.EdgeShape.Polyline)                      {                          var lines = edgeInfo.EdgeData.As<PointF[]>();                          if (lines != null)                          {                              if (firstTime)                              {                                  result = GetPointsBounds(lines);                                  firstTime = false;                              }                              else                                  result = RectangleF.Union(result' GetPointsBounds(lines));                          }                      }                      else if (edgeInfo.ShapeType == EdgeStyleData.EdgeShape.BezierSpline)                      {                          var curves = edgeInfo.EdgeData.As<IEnumerable<BezierCurve2F>>();                            foreach (var curve in curves)                          {                              var cpts = new PointF[] { curve.P1' curve.P2' curve.P3' curve.P4 };                              if (firstTime)                              {                                  result = GetPointsBounds(cpts);                                  firstTime = false;                              }                              else                                  result = RectangleF.Union(result' GetPointsBounds(cpts));                          }                      }                    }              }              else              {                  Point op = wire.FromNode.Bounds.Location;                  op.Offset(WorldOffset(m_graphPath));                  int x1 = op.X + info.Size.Width;                  if (PinDrawStyle == PinStyle.OnBorderFilled)                      x1 += m_pinSize / 2;                  int y1 = op.Y + GetPinOffset(wire.FromNode' wire.FromRoute.Index' false);                    Point ip = wire.ToNode.Bounds.Location;                  ip.Offset(WorldOffset(m_graphPath));                  int x2 = ip.X;                  if (PinDrawStyle == PinStyle.OnBorderFilled)                      x2 -= m_pinSize / 2;                  int y2 = ip.Y + GetPinOffset(wire.ToNode' wire.ToRoute.Index' true);                  result = D2dUtil.MakeRectangle(new PointF(x1' y1)' new PointF(x2' y2));              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetWireBounds,The following statement contains a magic number: if (wire.Is<IEdgeStyleProvider>())              {                  bool firstTime = true;                  foreach (var edgeInfo in wire.Cast<IEdgeStyleProvider>().GetData(this' WorldOffset(m_graphPath)' g))                  {                      if (edgeInfo.ShapeType == EdgeStyleData.EdgeShape.Bezier)                      {                          var curve = edgeInfo.EdgeData.As<BezierCurve2F>();                          var cpts = new PointF[] { curve.P1' curve.P2' curve.P3' curve.P4 };                          if (firstTime)                          {                              result = GetPointsBounds(cpts);                              firstTime = false;                          }                          else                              result = RectangleF.Union(result' GetPointsBounds(cpts));                      }                      else if (edgeInfo.ShapeType == EdgeStyleData.EdgeShape.Line)                      {                          var line = edgeInfo.EdgeData.As<PointF[]>();                          if (line != null)                          {                              if (firstTime)                              {                                  result = D2dUtil.MakeRectangle(line[0]' line[1]);                                  firstTime = false;                              }                              else                                  result = RectangleF.Union(result' D2dUtil.MakeRectangle(line[0]' line[1]));                          }                        }                      else if (edgeInfo.ShapeType == EdgeStyleData.EdgeShape.Polyline)                      {                          var lines = edgeInfo.EdgeData.As<PointF[]>();                          if (lines != null)                          {                              if (firstTime)                              {                                  result = GetPointsBounds(lines);                                  firstTime = false;                              }                              else                                  result = RectangleF.Union(result' GetPointsBounds(lines));                          }                      }                      else if (edgeInfo.ShapeType == EdgeStyleData.EdgeShape.BezierSpline)                      {                          var curves = edgeInfo.EdgeData.As<IEnumerable<BezierCurve2F>>();                            foreach (var curve in curves)                          {                              var cpts = new PointF[] { curve.P1' curve.P2' curve.P3' curve.P4 };                              if (firstTime)                              {                                  result = GetPointsBounds(cpts);                                  firstTime = false;                              }                              else                                  result = RectangleF.Union(result' GetPointsBounds(cpts));                          }                      }                    }              }              else              {                  Point op = wire.FromNode.Bounds.Location;                  op.Offset(WorldOffset(m_graphPath));                  int x1 = op.X + info.Size.Width;                  if (PinDrawStyle == PinStyle.OnBorderFilled)                      x1 += m_pinSize / 2;                  int y1 = op.Y + GetPinOffset(wire.FromNode' wire.FromRoute.Index' false);                    Point ip = wire.ToNode.Bounds.Location;                  ip.Offset(WorldOffset(m_graphPath));                  int x2 = ip.X;                  if (PinDrawStyle == PinStyle.OnBorderFilled)                      x2 -= m_pinSize / 2;                  int y2 = ip.Y + GetPinOffset(wire.ToNode' wire.ToRoute.Index' true);                  result = D2dUtil.MakeRectangle(new PointF(x1' y1)' new PointF(x2' y2));              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetExpanderRect,The following statement contains a magic number: return new RectangleF(p.X + m_pinMargin + 1' p.Y + 2 * m_pinMargin + 1' ExpanderSize' ExpanderSize);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,GetShowPinsRect,The following statement contains a magic number: return new RectangleF(                  bounds.Right - m_pinMargin - 1 - ExpanderSize'                  bounds.Y + 2 * m_pinMargin + 1'                  ExpanderSize'                  ExpanderSize);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dCircuitRenderer.cs,ParentWorldOffset,The following statement contains a magic number: foreach (var element in graphPath.Skip(1)) // m_graphPath is a stack of groups and the top item is the most nested              {                  node_delta = SubGraphOffset(element);                    offset.X += element.Bounds.Location.X + node_delta.X;                  offset.Y += element.Bounds.Location.Y + node_delta.Y;                    // nested subgraph contents  offset                  int margin = m_rowSpacing + 4 * m_pinMargin;                  offset.Offset(margin' margin);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphAdapter.cs,DrawAssociatedEdges,The following statement contains a magic number: foreach (var edge in edges)              {                  int edgeVisit = m_edgeNodeEncounter[edge] + 1;                  m_edgeNodeEncounter[edge] = edgeVisit;                  if (edgeVisit == 2)                  {                      RectangleF bounds = m_renderer.GetBounds(edge' m_d2dGraphics);                      DiagramDrawingStyle style = GetStyle(edge);                      if (clipBounds.IntersectsWith(bounds) && style != DiagramDrawingStyle.Hidden)                          m_renderer.Draw(edge' style' m_d2dGraphics);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dGraphNodeEditAdapter<TNode;TEdge;TEdgeRoute>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dGraphNodeEditAdapter.cs,EndDrag,The following statement contains a magic number: if (m_movingNodesCrossContainer)              {                  m_editableGraphContainer.Move(m_targetItem' m_draggingNodes);                  m_movingNodesCrossContainer = false;              }              else if (m_resizing)              {                  Point currentPoint = GdiUtil.InverseTransform(m_transformAdapter.Transform' CurrentPoint);                  Point delta = new Point(currentPoint.X - m_firstPoint.X' currentPoint.Y - m_firstPoint.Y);                  m_editableGraphContainer.Resize(m_targetItem' (int)m_firstBound.Width + delta.X' (int)m_firstBound.Height + delta.Y);              }              else if (m_selectionPathProvider != null)              {                  Point currentPoint = GdiUtil.InverseTransform(m_transformAdapter.Transform' CurrentPoint);                  Point delta = new Point(currentPoint.X - m_firstPoint.X' currentPoint.Y - m_firstPoint.Y);                  if (delta.X < 0 || delta.Y < 0)  // negative offset' check whether we need to relocate group container                  {                      foreach (var node in m_draggingNodes)                      {                          var selectionPath = m_selectionPathProvider.GetSelectionPath(node);                          if (selectionPath == null)                              continue;                          int length = selectionPath.Count;                          if (length > 1)                          {                                var parent = selectionPath[length - 2];                              if (parent.Is<ICircuitGroupType<TNode' TEdge' TEdgeRoute>>())                              {                                  var group = parent.Cast<ICircuitGroupType<TNode' TEdge' TEdgeRoute>>();                                  if (node.Bounds.Location.X < -group.Info.Offset.X ||                                      node.Bounds.Location.Y < -group.Info.Offset.Y)                                  {                                      Rectangle bounds; //world coordinates                                      m_layoutContext.GetBounds(group' out bounds);                                      if (delta.X < 0)                                          bounds.X += delta.X;                                      if (delta.Y < 0)                                          bounds.Y += delta.Y;                                      m_layoutContext.SetBounds(group' bounds' BoundsSpecified.Location);                                  }                              }                          }                      }                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,Pick,The following statement contains a magic number: foreach (TNode state in graph.Nodes.Reverse())              {                  RectangleF bounds = state.Bounds;                  bounds.Inflate(tolerance' tolerance);                    if (bounds.Contains(p))                  {                      pickedNode = state;                        float position = PointToParameter(bounds' p);                        bounds.Inflate(-2 * tolerance' -2 * tolerance);                      bool onEdge = !bounds.Contains(p);                        if (pickedEdge == null)                      {                          if (onEdge)                          {                              // edge of node can be source or destination                              fromRoute = new BoundaryRoute(position);                              toRoute = new BoundaryRoute(position);                          }                      }                      else // hit on edge and node                      {                          if (onEdge)                          {                              if (pickedEdge.FromNode == pickedNode)                                  fromRoute = new BoundaryRoute(position);                              else if (pickedEdge.ToNode == pickedNode)                                  toRoute = new BoundaryRoute(position);                          }                      }                      break;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,Pick,The following statement contains a magic number: foreach (TNode state in graph.Nodes.Reverse())              {                  RectangleF bounds = state.Bounds;                  bounds.Inflate(tolerance' tolerance);                    if (bounds.Contains(p))                  {                      pickedNode = state;                        float position = PointToParameter(bounds' p);                        bounds.Inflate(-2 * tolerance' -2 * tolerance);                      bool onEdge = !bounds.Contains(p);                        if (pickedEdge == null)                      {                          if (onEdge)                          {                              // edge of node can be source or destination                              fromRoute = new BoundaryRoute(position);                              toRoute = new BoundaryRoute(position);                          }                      }                      else // hit on edge and node                      {                          if (onEdge)                          {                              if (pickedEdge.FromNode == pickedNode)                                  fromRoute = new BoundaryRoute(position);                              else if (pickedEdge.ToNode == pickedNode)                                  toRoute = new BoundaryRoute(position);                          }                      }                      break;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,Pick,The following statement contains a magic number: if (complexState != null && pickedEdge == null)              {                  RectangleF bounds = pickedNode.Bounds;                  RectangleF labelBounds = new RectangleF(                      bounds.X + CornerRadius'                      bounds.Y + Margin'                      bounds.Width - 2 * CornerRadius'                      m_theme.TextFormat.FontHeight);                    if (labelBounds.Contains(p))                  {                      DiagramLabel label = new DiagramLabel(Rectangle.Truncate(labelBounds)' TextFormatFlags.SingleLine);                      return new GraphHitRecord<TNode' TEdge' BoundaryRoute>(pickedNode' label);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: innerEllipse.RadiusX = 4;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: innerEllipse.RadiusY = 4;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,Draw,The following statement contains a magic number: midpoint.X += 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,GetTransitionPoints,The following statement contains a magic number: int d = (int)Math.Sqrt(dx * dx + dy * dy) / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,GetTransitionPoints,The following statement contains a magic number: d = Math.Min(d' 64);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,PointToParameter,The following statement contains a magic number: if (dy * px + dx * py > 0) // quadrant 0 or 1              {                  if (-dy * px + dx * py < 0) // quadrant 0                  {                      result = 0;                  }                  else // quadrant 1                  {                      result = 1;                      temp = px; px = -py; py = temp;                      temp = dx; dx = dy; dy = temp;                  }              }              else // quadrant 2 or 3              {                  if (dy * px + -dx * py < 0) // quadrant 2                  {                      result = 2;                      px = -px; py = -py;                  }                  else // quadrant 3                  {                      result = 3;                      temp = py; py = -px; px = temp;                      temp = dx; dx = dy; dy = temp;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,PointToParameter,The following statement contains a magic number: if (dy * px + dx * py > 0) // quadrant 0 or 1              {                  if (-dy * px + dx * py < 0) // quadrant 0                  {                      result = 0;                  }                  else // quadrant 1                  {                      result = 1;                      temp = px; px = -py; py = temp;                      temp = dx; dx = dy; dy = temp;                  }              }              else // quadrant 2 or 3              {                  if (dy * px + -dx * py < 0) // quadrant 2                  {                      result = 2;                      px = -px; py = -py;                  }                  else // quadrant 3                  {                      result = 3;                      temp = py; py = -px; px = temp;                      temp = dx; dx = dy; dy = temp;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,PointToParameter,The following statement contains a magic number: result += (y + dy) / (dy * 2);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,ParameterToPoint,The following statement contains a magic number: if (t < 2) // + side              {                  if (t < 1) // right                  {                      x0 = right;                      y0 = top;                      dy = height;                        normal = new Point(1' 0);                  }                  else // bottom                  {                      y0 = bottom;                      x0 = right;                      dx = -width;                      t -= 1;                        normal = new Point(0' 1);                  }              }              else // - side              {                  if (t < 3) // left                  {                      x0 = left;                      y0 = bottom;                      dy = -height;                      t -= 2;                        normal = new Point(-1' 0);                  }                  else // top                  {                      y0 = top;                      x0 = left;                      dx = width;                      t -= 3;                        normal = new Point(0' -1);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,ParameterToPoint,The following statement contains a magic number: if (t < 2) // + side              {                  if (t < 1) // right                  {                      x0 = right;                      y0 = top;                      dy = height;                        normal = new Point(1' 0);                  }                  else // bottom                  {                      y0 = bottom;                      x0 = right;                      dx = -width;                      t -= 1;                        normal = new Point(0' 1);                  }              }              else // - side              {                  if (t < 3) // left                  {                      x0 = left;                      y0 = bottom;                      dy = -height;                      t -= 2;                        normal = new Point(-1' 0);                  }                  else // top                  {                      y0 = top;                      x0 = left;                      dx = width;                      t -= 3;                        normal = new Point(0' -1);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,ParameterToPoint,The following statement contains a magic number: if (t < 2) // + side              {                  if (t < 1) // right                  {                      x0 = right;                      y0 = top;                      dy = height;                        normal = new Point(1' 0);                  }                  else // bottom                  {                      y0 = bottom;                      x0 = right;                      dx = -width;                      t -= 1;                        normal = new Point(0' 1);                  }              }              else // - side              {                  if (t < 3) // left                  {                      x0 = left;                      y0 = bottom;                      dy = -height;                      t -= 2;                        normal = new Point(-1' 0);                  }                  else // top                  {                      y0 = top;                      x0 = left;                      dx = width;                      t -= 3;                        normal = new Point(0' -1);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,ParameterToPoint,The following statement contains a magic number: if (t < 2) // + side              {                  if (t < 1) // right                  {                      x0 = right;                      y0 = top;                      dy = height;                        normal = new Point(1' 0);                  }                  else // bottom                  {                      y0 = bottom;                      x0 = right;                      dx = -width;                      t -= 1;                        normal = new Point(0' 1);                  }              }              else // - side              {                  if (t < 3) // left                  {                      x0 = left;                      y0 = bottom;                      dy = -height;                      t -= 2;                        normal = new Point(-1' 0);                  }                  else // top                  {                      y0 = top;                      x0 = left;                      dx = width;                      t -= 3;                        normal = new Point(0' -1);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,DrawFloatingGroupPin,The following statement contains a magic number: if (inputSide)              {                  p = GetGroupPinLocation(grpPin' true);                    RectangleF pinRect = new RectangleF(p.X + CircuitGroupPinInfo.FloatingPinBoxWidth - Theme.PinSize'                                               grpPin.Bounds.Location.Y + Theme.PinMargin + Theme.PinOffset'                                               Theme.PinSize' Theme.PinSize);                  // draw output pin for input floating pins                  g.DrawRectangle(pinRect' m_subGraphPinPen);                  if (grpPin.Info.Pinned)                      D2dUtil.DrawPin((int)(p.X + CircuitGroupPinInfo.FloatingPinBoxWidth)' (int)p.Y' true' true' m_pinBrush' g);                  else                      D2dUtil.DrawPin((int)(p.X + CircuitGroupPinInfo.FloatingPinBoxWidth)' (int)p.Y + Theme.PinSize / 2' false' true' m_pinBrush' g);                    RectangleF bounds = new RectangleF(p.X' p.Y' CircuitGroupPinInfo.FloatingPinBoxWidth' CircuitGroupPinInfo.FloatingPinBoxHeight);                  RectangleF alignRect = new RectangleF(                      bounds.Left' bounds.Bottom + Theme.PinMargin' pinNameSize.Width' Theme.RowSpacing);                  var textAlignment = Theme.TextFormat.TextAlignment;                                Theme.TextFormat.TextAlignment = D2dTextAlignment.Leading;                  g.DrawText(grpPin.Name' Theme.TextFormat' alignRect.Location' Theme.TextBrush);                  Theme.TextFormat.TextAlignment = textAlignment;                }              else              {                  // assume vertical scroll bar width = 16                  p = GetGroupPinLocation(grpPin' false);                    RectangleF pinRect = new RectangleF(p.X + 1' grpPin.Bounds.Location.Y + Theme.PinMargin + Theme.PinOffset'                                               Theme.PinSize' Theme.PinSize);                  // draw input pin for output floating pins                  g.DrawRectangle(pinRect' m_subGraphPinPen);                  // draw pin icon                                     if (grpPin.Info.Pinned)                      D2dUtil.DrawPin((int)p.X' (int)p.Y' true' false' m_pinBrush' g);                  else                      D2dUtil.DrawPin((int)p.X' (int)p.Y + Theme.PinSize / 2' false' false' m_pinBrush' g);                    // draw label                  RectangleF bounds = new RectangleF(p.X' p.Y' CircuitGroupPinInfo.FloatingPinBoxWidth' CircuitGroupPinInfo.FloatingPinBoxHeight);                  RectangleF alignRectF = new RectangleF(bounds.Right - pinNameSize.Width' bounds.Bottom + Theme.PinMargin'                      pinNameSize.Width' Theme.RowSpacing);                    var textAlignment = Theme.TextFormat.TextAlignment;                  Theme.TextFormat.TextAlignment = D2dTextAlignment.Trailing;                  g.DrawText(grpPin.Name' Theme.TextFormat' alignRectF' Theme.TextBrush);                  Theme.TextFormat.TextAlignment = textAlignment;                        }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,DrawFloatingGroupPin,The following statement contains a magic number: if (inputSide)              {                  p = GetGroupPinLocation(grpPin' true);                    RectangleF pinRect = new RectangleF(p.X + CircuitGroupPinInfo.FloatingPinBoxWidth - Theme.PinSize'                                               grpPin.Bounds.Location.Y + Theme.PinMargin + Theme.PinOffset'                                               Theme.PinSize' Theme.PinSize);                  // draw output pin for input floating pins                  g.DrawRectangle(pinRect' m_subGraphPinPen);                  if (grpPin.Info.Pinned)                      D2dUtil.DrawPin((int)(p.X + CircuitGroupPinInfo.FloatingPinBoxWidth)' (int)p.Y' true' true' m_pinBrush' g);                  else                      D2dUtil.DrawPin((int)(p.X + CircuitGroupPinInfo.FloatingPinBoxWidth)' (int)p.Y + Theme.PinSize / 2' false' true' m_pinBrush' g);                    RectangleF bounds = new RectangleF(p.X' p.Y' CircuitGroupPinInfo.FloatingPinBoxWidth' CircuitGroupPinInfo.FloatingPinBoxHeight);                  RectangleF alignRect = new RectangleF(                      bounds.Left' bounds.Bottom + Theme.PinMargin' pinNameSize.Width' Theme.RowSpacing);                  var textAlignment = Theme.TextFormat.TextAlignment;                                Theme.TextFormat.TextAlignment = D2dTextAlignment.Leading;                  g.DrawText(grpPin.Name' Theme.TextFormat' alignRect.Location' Theme.TextBrush);                  Theme.TextFormat.TextAlignment = textAlignment;                }              else              {                  // assume vertical scroll bar width = 16                  p = GetGroupPinLocation(grpPin' false);                    RectangleF pinRect = new RectangleF(p.X + 1' grpPin.Bounds.Location.Y + Theme.PinMargin + Theme.PinOffset'                                               Theme.PinSize' Theme.PinSize);                  // draw input pin for output floating pins                  g.DrawRectangle(pinRect' m_subGraphPinPen);                  // draw pin icon                                     if (grpPin.Info.Pinned)                      D2dUtil.DrawPin((int)p.X' (int)p.Y' true' false' m_pinBrush' g);                  else                      D2dUtil.DrawPin((int)p.X' (int)p.Y + Theme.PinSize / 2' false' false' m_pinBrush' g);                    // draw label                  RectangleF bounds = new RectangleF(p.X' p.Y' CircuitGroupPinInfo.FloatingPinBoxWidth' CircuitGroupPinInfo.FloatingPinBoxHeight);                  RectangleF alignRectF = new RectangleF(bounds.Right - pinNameSize.Width' bounds.Bottom + Theme.PinMargin'                      pinNameSize.Width' Theme.RowSpacing);                    var textAlignment = Theme.TextFormat.TextAlignment;                  Theme.TextFormat.TextAlignment = D2dTextAlignment.Trailing;                  g.DrawText(grpPin.Name' Theme.TextFormat' alignRectF' Theme.TextBrush);                  Theme.TextFormat.TextAlignment = textAlignment;                        }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,GetGroupPinLocation,The following statement contains a magic number: if (inputSide)                   return new PointF(VisibleWorldBounds.X + CircuitGroupPinInfo.FloatingPinBoxWidth + Theme.PinMargin' grpPin.Bounds.Location.Y);               else                   return new PointF(VisibleWorldBounds.X + VisibleWorldBounds.Width - Theme.PinMargin - 2 * CircuitGroupPinInfo.FloatingPinBoxWidth - 16' grpPin.Bounds.Location.Y);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,GetGroupPinLocation,The following statement contains a magic number: if (inputSide)                   return new PointF(VisibleWorldBounds.X + CircuitGroupPinInfo.FloatingPinBoxWidth + Theme.PinMargin' grpPin.Bounds.Location.Y);               else                   return new PointF(VisibleWorldBounds.X + VisibleWorldBounds.Width - Theme.PinMargin - 2 * CircuitGroupPinInfo.FloatingPinBoxWidth - 16' grpPin.Bounds.Location.Y);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,GetVisibilityCheckRect,The following statement contains a magic number: float width = CircuitGroupPinInfo.FloatingPinBoxWidth - Theme.PinSize - 3;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,GetVisibilityCheckRect,The following statement contains a magic number: if (inputSide)              {                  pinRect = new RectangleF(p.X + CircuitGroupPinInfo.FloatingPinBoxWidth - Theme.PinSize'                                           grpPin.Bounds.Location.Y + Theme.PinMargin + Theme.PinOffset'                                           Theme.PinSize' Theme.PinSize);                    eyeRect = new RectangleF(p.X - 2 - width' pinRect.Y' width' pinRect.Height);              }              else              {                  pinRect = new RectangleF(p.X + 1' grpPin.Bounds.Location.Y + Theme.PinMargin + Theme.PinOffset'                                             Theme.PinSize' Theme.PinSize);                  eyeRect = new RectangleF(p.X + CircuitGroupPinInfo.FloatingPinBoxWidth + 2' pinRect.Y' width' pinRect.Height);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,GetVisibilityCheckRect,The following statement contains a magic number: if (inputSide)              {                  pinRect = new RectangleF(p.X + CircuitGroupPinInfo.FloatingPinBoxWidth - Theme.PinSize'                                           grpPin.Bounds.Location.Y + Theme.PinMargin + Theme.PinOffset'                                           Theme.PinSize' Theme.PinSize);                    eyeRect = new RectangleF(p.X - 2 - width' pinRect.Y' width' pinRect.Height);              }              else              {                  pinRect = new RectangleF(p.X + 1' grpPin.Bounds.Location.Y + Theme.PinMargin + Theme.PinOffset'                                             Theme.PinSize' Theme.PinSize);                  eyeRect = new RectangleF(p.X + CircuitGroupPinInfo.FloatingPinBoxWidth + 2' pinRect.Y' width' pinRect.Height);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,DrawGroupPinNodeFakeEdge,The following statement contains a magic number: if (inputSide)              {                               PointF op = grpPinPos;                  float x1 = op.X + CircuitGroupPinInfo.FloatingPinBoxWidth;                  float y1 = op.Y + CircuitGroupPinInfo.FloatingPinBoxHeight / 2;                    Point ip = grpPin.InternalElement.Bounds.Location;                  float x2 = ip.X;                  float y2 = ip.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex' true );                    DrawWire(g' m_fakeInputLinkPen' x1' y1' x2' y2' 1.0f' m_VirtualLinkStrokeStyle);              }              else              {                  Point op = grpPin.InternalElement.Bounds.Location;                  float x1 = op.X + info.Size.Width;                  float y1 = op.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex'false);                    PointF ip = grpPinPos;                  float x2 = ip.X;                  float y2 = ip.Y + CircuitGroupPinInfo.FloatingPinBoxHeight / 2;                  DrawWire(g' m_fakeOutputLinkPen' x1' y1' x2' y2' 1.0f' m_VirtualLinkStrokeStyle);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dSubCircuitRenderer<TElement;TWire;TPin>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dSubCircuitRenderer.cs,DrawGroupPinNodeFakeEdge,The following statement contains a magic number: if (inputSide)              {                               PointF op = grpPinPos;                  float x1 = op.X + CircuitGroupPinInfo.FloatingPinBoxWidth;                  float y1 = op.Y + CircuitGroupPinInfo.FloatingPinBoxHeight / 2;                    Point ip = grpPin.InternalElement.Bounds.Location;                  float x2 = ip.X;                  float y2 = ip.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex' true );                    DrawWire(g' m_fakeInputLinkPen' x1' y1' x2' y2' 1.0f' m_VirtualLinkStrokeStyle);              }              else              {                  Point op = grpPin.InternalElement.Bounds.Location;                  float x1 = op.X + info.Size.Width;                  float y1 = op.Y + GetPinOffset(grpPin.InternalElement' grpPin.InternalPinIndex'false);                    PointF ip = grpPinPos;                  float x2 = ip.X;                  float y2 = ip.Y + CircuitGroupPinInfo.FloatingPinBoxHeight / 2;                  DrawWire(g' m_fakeOutputLinkPen' x1' y1' x2' y2' 1.0f' m_VirtualLinkStrokeStyle);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Draw,The following statement contains a magic number: if (CircleF.Project(new Vec2F(end)' boundary' ref proj))              {                  PointF start = new PointF(proj.X' proj.Y);                  g.DrawLine(m_theme.OutlinePen' start' end);                    if (fromNode == null)                  {                      PointF temp = end;                      end = start;                      start = temp;                  }                  Vec2F endTangent = new Vec2F(end.X - start.X' end.Y - start.Y);                  Vec2F arrowPosition = new Vec2F(end);                  DrawArrow(arrowPosition' endTangent' m_theme.OutlinePen' g);                    if (!string.IsNullOrEmpty(label))                  {                      PointF textPoint = new PointF((end.X + start.X) * 0.5f' (end.Y + start.Y) * 0.5f);                      RectangleF textBox = new RectangleF(textPoint.X - 512' textPoint.Y' 1024' m_theme.Font.Height);                      g.DrawString(label' m_theme.Font' m_theme.TextBrush' textBox' m_theme.CenterStringFormat);                  }                }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Draw,The following statement contains a magic number: if (CircleF.Project(new Vec2F(end)' boundary' ref proj))              {                  PointF start = new PointF(proj.X' proj.Y);                  g.DrawLine(m_theme.OutlinePen' start' end);                    if (fromNode == null)                  {                      PointF temp = end;                      end = start;                      start = temp;                  }                  Vec2F endTangent = new Vec2F(end.X - start.X' end.Y - start.Y);                  Vec2F arrowPosition = new Vec2F(end);                  DrawArrow(arrowPosition' endTangent' m_theme.OutlinePen' g);                    if (!string.IsNullOrEmpty(label))                  {                      PointF textPoint = new PointF((end.X + start.X) * 0.5f' (end.Y + start.Y) * 0.5f);                      RectangleF textBox = new RectangleF(textPoint.X - 512' textPoint.Y' 1024' m_theme.Font.Height);                      g.DrawString(label' m_theme.Font' m_theme.TextBrush' textBox' m_theme.CenterStringFormat);                  }                }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Pick,The following statement contains a magic number: if (pickedNode != null && pickedEdge == null)              {                  // label is centered in entire node                  Rectangle labelBounds = GetBounds(pickedNode' g);                  int dHeight = labelBounds.Height - m_theme.Font.Height;                  labelBounds = new Rectangle(                      labelBounds.X' labelBounds.Y + dHeight / 2' labelBounds.Width' labelBounds.Height - dHeight);                    if (labelBounds.Contains(p))                  {                      DiagramLabel label = new DiagramLabel(                          labelBounds'                          TextFormatFlags.SingleLine |                          TextFormatFlags.HorizontalCenter);                        return                          new GraphHitRecord<TNode' TEdge' NumberedRoute>(pickedNode' label);                  }                }              else if (pickedEdge != null)              {                  Rectangle labelBounds = GetLabelBounds(pickedEdge);                  DiagramLabel label = new DiagramLabel(                      labelBounds'                      TextFormatFlags.SingleLine |                      TextFormatFlags.HorizontalCenter);                    if (labelBounds.Contains(p))                  {                      return                          new GraphHitRecord<TNode' TEdge' NumberedRoute>(pickedEdge' label);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,GetEdgeGeometry,The following statement contains a magic number: if (edge.FromNode == edge.ToNode)              {                  CircleF c = GetBoundary(edge.FromNode);                  circle = c;                  circle.Center.X -= circle.Radius;                  circle.Radius *= 0.85f;                  float offset = route * m_routeOffset / 2;                  circle.Center.X -= offset;                  circle.Radius += offset;                  CircleF.Intersect(circle' c' ref startPoint' ref endPoint);                  moreThan180 = true;              }              else              {                  CircleF c1 = GetBoundary(edge.FromNode);                  CircleF c2 = GetBoundary(edge.ToNode);                  Vec2F d = Vec2F.Sub(c2.Center' c1.Center);                  float length = d.Length;                  if (length < c1.Radius + c2.Radius)                  {                      // overlapping nodes' don't try to draw arcs                      d = Vec2F.XAxis;                      straightLine = true;                  }                  else if (route == 0)                  {                      d *= 1.0f / length;                      straightLine = true;                  }                  else                  {                      Vec2F routePoint = c1.Center + d * 0.5f;                      float dLength = d.Length;                      Vec2F offset = d.Perp * (1.0f / dLength);                      routePoint -= offset * m_routeOffset * route;                      circle = new CircleF(c1.Center' routePoint' c2.Center);                        Vec2F dummy = new Vec2F();                      CircleF.Intersect(circle' c1' ref startPoint' ref dummy);                      CircleF.Intersect(circle' c2' ref dummy' ref endPoint);                        Vec2F startToEnd = startPoint - endPoint;                      Vec2F centerToEnd = circle.Center - endPoint;                      moreThan180 = Vec2F.PerpDot(centerToEnd' startToEnd) < 0;                  }                    if (straightLine)                  {                      startPoint = Vec2F.Add(c1.Center' Vec2F.Mul(d' c1.Radius));                      endPoint = Vec2F.Sub(c2.Center' Vec2F.Mul(d' c2.Radius));                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Draw,The following statement contains a magic number: if (GetEdgeGeometry(edge' route' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  g.DrawLine(pen' new PointF(startPoint.X' startPoint.Y)' new PointF(endPoint.X' endPoint.Y));                    endTangent = endPoint - startPoint;                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  // prepare to draw arc                  RectangleF rect = new RectangleF(c.Center.X - c.Radius' c.Center.Y - c.Radius' 2 * c.Radius' 2 * c.Radius);                    double angle1 = Math.Atan2(startPoint.Y - c.Center.Y' startPoint.X - c.Center.X);                  double angle2 = Math.Atan2(endPoint.Y - c.Center.Y' endPoint.X - c.Center.X);                  const double twoPi = 2 * Math.PI;                    // swap so we always go clockwise                  if (angle1 > angle2)                  {                      double temp = angle1;                      angle1 = angle2;                      angle2 = temp;                  }                    double startAngle = angle1;                  double sweepAngle = angle2 - angle1;                    if (moreThan180)                  {                      if (sweepAngle < Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                  else                  {                      if (sweepAngle > Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                    const double RadiansToDegrees = 360 / twoPi;                  startAngle *= RadiansToDegrees;                  sweepAngle *= RadiansToDegrees;                    //                g.DrawArc(Pens.LightGray' rect' 0' 360);                  //                g.DrawLine(Pens.LightGray' new PointF(c.Center.X' c.Center.Y)' new PointF(startPoint.X' startPoint.Y));                  //                g.DrawLine(Pens.LightGray' new PointF(c.Center.X' c.Center.Y)' new PointF(endPoint.X' endPoint.Y));                  g.DrawArc(pen' rect' (float)startAngle' (float)sweepAngle);                    endTangent = endPoint - c.Center; endTangent = endTangent.Perp;                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Draw,The following statement contains a magic number: if (GetEdgeGeometry(edge' route' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  g.DrawLine(pen' new PointF(startPoint.X' startPoint.Y)' new PointF(endPoint.X' endPoint.Y));                    endTangent = endPoint - startPoint;                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  // prepare to draw arc                  RectangleF rect = new RectangleF(c.Center.X - c.Radius' c.Center.Y - c.Radius' 2 * c.Radius' 2 * c.Radius);                    double angle1 = Math.Atan2(startPoint.Y - c.Center.Y' startPoint.X - c.Center.X);                  double angle2 = Math.Atan2(endPoint.Y - c.Center.Y' endPoint.X - c.Center.X);                  const double twoPi = 2 * Math.PI;                    // swap so we always go clockwise                  if (angle1 > angle2)                  {                      double temp = angle1;                      angle1 = angle2;                      angle2 = temp;                  }                    double startAngle = angle1;                  double sweepAngle = angle2 - angle1;                    if (moreThan180)                  {                      if (sweepAngle < Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                  else                  {                      if (sweepAngle > Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                    const double RadiansToDegrees = 360 / twoPi;                  startAngle *= RadiansToDegrees;                  sweepAngle *= RadiansToDegrees;                    //                g.DrawArc(Pens.LightGray' rect' 0' 360);                  //                g.DrawLine(Pens.LightGray' new PointF(c.Center.X' c.Center.Y)' new PointF(startPoint.X' startPoint.Y));                  //                g.DrawLine(Pens.LightGray' new PointF(c.Center.X' c.Center.Y)' new PointF(endPoint.X' endPoint.Y));                  g.DrawArc(pen' rect' (float)startAngle' (float)sweepAngle);                    endTangent = endPoint - c.Center; endTangent = endTangent.Perp;                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Draw,The following statement contains a magic number: if (GetEdgeGeometry(edge' route' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  g.DrawLine(pen' new PointF(startPoint.X' startPoint.Y)' new PointF(endPoint.X' endPoint.Y));                    endTangent = endPoint - startPoint;                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  // prepare to draw arc                  RectangleF rect = new RectangleF(c.Center.X - c.Radius' c.Center.Y - c.Radius' 2 * c.Radius' 2 * c.Radius);                    double angle1 = Math.Atan2(startPoint.Y - c.Center.Y' startPoint.X - c.Center.X);                  double angle2 = Math.Atan2(endPoint.Y - c.Center.Y' endPoint.X - c.Center.X);                  const double twoPi = 2 * Math.PI;                    // swap so we always go clockwise                  if (angle1 > angle2)                  {                      double temp = angle1;                      angle1 = angle2;                      angle2 = temp;                  }                    double startAngle = angle1;                  double sweepAngle = angle2 - angle1;                    if (moreThan180)                  {                      if (sweepAngle < Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                  else                  {                      if (sweepAngle > Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                    const double RadiansToDegrees = 360 / twoPi;                  startAngle *= RadiansToDegrees;                  sweepAngle *= RadiansToDegrees;                    //                g.DrawArc(Pens.LightGray' rect' 0' 360);                  //                g.DrawLine(Pens.LightGray' new PointF(c.Center.X' c.Center.Y)' new PointF(startPoint.X' startPoint.Y));                  //                g.DrawLine(Pens.LightGray' new PointF(c.Center.X' c.Center.Y)' new PointF(endPoint.X' endPoint.Y));                  g.DrawArc(pen' rect' (float)startAngle' (float)sweepAngle);                    endTangent = endPoint - c.Center; endTangent = endTangent.Perp;                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Draw,The following statement contains a magic number: if (GetEdgeGeometry(edge' route' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  g.DrawLine(pen' new PointF(startPoint.X' startPoint.Y)' new PointF(endPoint.X' endPoint.Y));                    endTangent = endPoint - startPoint;                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  // prepare to draw arc                  RectangleF rect = new RectangleF(c.Center.X - c.Radius' c.Center.Y - c.Radius' 2 * c.Radius' 2 * c.Radius);                    double angle1 = Math.Atan2(startPoint.Y - c.Center.Y' startPoint.X - c.Center.X);                  double angle2 = Math.Atan2(endPoint.Y - c.Center.Y' endPoint.X - c.Center.X);                  const double twoPi = 2 * Math.PI;                    // swap so we always go clockwise                  if (angle1 > angle2)                  {                      double temp = angle1;                      angle1 = angle2;                      angle2 = temp;                  }                    double startAngle = angle1;                  double sweepAngle = angle2 - angle1;                    if (moreThan180)                  {                      if (sweepAngle < Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                  else                  {                      if (sweepAngle > Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                    const double RadiansToDegrees = 360 / twoPi;                  startAngle *= RadiansToDegrees;                  sweepAngle *= RadiansToDegrees;                    //                g.DrawArc(Pens.LightGray' rect' 0' 360);                  //                g.DrawLine(Pens.LightGray' new PointF(c.Center.X' c.Center.Y)' new PointF(startPoint.X' startPoint.Y));                  //                g.DrawLine(Pens.LightGray' new PointF(c.Center.X' c.Center.Y)' new PointF(endPoint.X' endPoint.Y));                  g.DrawArc(pen' rect' (float)startAngle' (float)sweepAngle);                    endTangent = endPoint - c.Center; endTangent = endTangent.Perp;                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Draw,The following statement contains a magic number: if (GetEdgeGeometry(edge' route' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  g.DrawLine(pen' new PointF(startPoint.X' startPoint.Y)' new PointF(endPoint.X' endPoint.Y));                    endTangent = endPoint - startPoint;                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  // prepare to draw arc                  RectangleF rect = new RectangleF(c.Center.X - c.Radius' c.Center.Y - c.Radius' 2 * c.Radius' 2 * c.Radius);                    double angle1 = Math.Atan2(startPoint.Y - c.Center.Y' startPoint.X - c.Center.X);                  double angle2 = Math.Atan2(endPoint.Y - c.Center.Y' endPoint.X - c.Center.X);                  const double twoPi = 2 * Math.PI;                    // swap so we always go clockwise                  if (angle1 > angle2)                  {                      double temp = angle1;                      angle1 = angle2;                      angle2 = temp;                  }                    double startAngle = angle1;                  double sweepAngle = angle2 - angle1;                    if (moreThan180)                  {                      if (sweepAngle < Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                  else                  {                      if (sweepAngle > Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                    const double RadiansToDegrees = 360 / twoPi;                  startAngle *= RadiansToDegrees;                  sweepAngle *= RadiansToDegrees;                    //                g.DrawArc(Pens.LightGray' rect' 0' 360);                  //                g.DrawLine(Pens.LightGray' new PointF(c.Center.X' c.Center.Y)' new PointF(startPoint.X' startPoint.Y));                  //                g.DrawLine(Pens.LightGray' new PointF(c.Center.X' c.Center.Y)' new PointF(endPoint.X' endPoint.Y));                  g.DrawArc(pen' rect' (float)startAngle' (float)sweepAngle);                    endTangent = endPoint - c.Center; endTangent = endTangent.Perp;                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Draw,The following statement contains a magic number: if (!string.IsNullOrEmpty(label))              {                  RectangleF textBox = new RectangleF(textPoint.X - 512' textPoint.Y' 1024' m_theme.Font.Height);                  g.DrawString(label' m_theme.Font' m_theme.TextBrush' textBox' m_theme.CenterStringFormat);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,Draw,The following statement contains a magic number: if (!string.IsNullOrEmpty(label))              {                  RectangleF textBox = new RectangleF(textPoint.X - 512' textPoint.Y' 1024' m_theme.Font.Height);                  g.DrawString(label' m_theme.Font' m_theme.TextBrush' textBox' m_theme.CenterStringFormat);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,GetLabelBounds,The following statement contains a magic number: if (GetEdgeGeometry(edge' route' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,GetLabelBounds,The following statement contains a magic number: float width = 32;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,DrawArrow,The following statement contains a magic number: const double cos = -0.866;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,DrawArrow,The following statement contains a magic number: const double sin = -0.500;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,DigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\DigraphRenderer.cs,GetBoundary,The following statement contains a magic number: float r = bounds.Width / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,GraphViewCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\GraphViewCommands.cs,ZoomView,The following statement contains a magic number: if (!adaptableControl.ClientRectangle.Contains(clientPoint))                  clientPoint = new Point(adaptableControl.Width/2' adaptableControl.Height/2);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,GraphViewCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\GraphViewCommands.cs,ZoomView,The following statement contains a magic number: if (!adaptableControl.ClientRectangle.Contains(clientPoint))                  clientPoint = new Point(adaptableControl.Width/2' adaptableControl.Height/2);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Draw,The following statement contains a magic number: midpoint.X += 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Pick,The following statement contains a magic number: foreach (TNode state in graph.Nodes.Reverse())              {                  Rectangle bounds = state.Bounds;                  bounds.Inflate(tolerance' tolerance);                    if (bounds.Contains(p))                  {                      pickedNode = state;                        float position = PointToParameter(bounds' p);                        bounds.Inflate(-2 * tolerance' -2 * tolerance);                      bool onEdge = !bounds.Contains(p);                        if (pickedEdge == null)                      {                          if (onEdge)                          {                              // edge of node can be source or destination                              fromRoute = new BoundaryRoute(position);                              toRoute = new BoundaryRoute(position);                          }                      }                      else // hit on edge and node                      {                          if (onEdge)                          {                              if (pickedEdge.FromNode == pickedNode)                                  fromRoute = new BoundaryRoute(position);                              else if (pickedEdge.ToNode == pickedNode)                                  toRoute = new BoundaryRoute(position);                          }                      }                      break;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Pick,The following statement contains a magic number: foreach (TNode state in graph.Nodes.Reverse())              {                  Rectangle bounds = state.Bounds;                  bounds.Inflate(tolerance' tolerance);                    if (bounds.Contains(p))                  {                      pickedNode = state;                        float position = PointToParameter(bounds' p);                        bounds.Inflate(-2 * tolerance' -2 * tolerance);                      bool onEdge = !bounds.Contains(p);                        if (pickedEdge == null)                      {                          if (onEdge)                          {                              // edge of node can be source or destination                              fromRoute = new BoundaryRoute(position);                              toRoute = new BoundaryRoute(position);                          }                      }                      else // hit on edge and node                      {                          if (onEdge)                          {                              if (pickedEdge.FromNode == pickedNode)                                  fromRoute = new BoundaryRoute(position);                              else if (pickedEdge.ToNode == pickedNode)                                  toRoute = new BoundaryRoute(position);                          }                      }                      break;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Pick,The following statement contains a magic number: if (complexState != null && pickedEdge == null)              {                  Rectangle bounds = pickedNode.Bounds;                  Rectangle labelBounds = new Rectangle(                      bounds.X + CornerRadius'                      bounds.Y + Margin'                      bounds.Width - 2 * CornerRadius'                      m_theme.Font.Height);                    if (labelBounds.Contains(p))                  {                      DiagramLabel label = new DiagramLabel(labelBounds' TextFormatFlags.SingleLine);                      return                          new GraphHitRecord<TNode'TEdge' BoundaryRoute>(pickedNode' label);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Draw,The following statement contains a magic number: if (state.Type != StateType.Normal)              {                  DrawPseudostate(bounds.Location' state.Type' m_theme.OutlinePen' g);              }              else              {                  IComplexState<TNode' TEdge> complexState = state as IComplexState<TNode' TEdge>;                    // Prevent an exception being thrown by LinearGradientBrush.                  if (bounds.Width <= 0)                      bounds.Width = 1;                  if (bounds.Height <= 0)                      bounds.Height = 1;                    StateIndicators indicators = state.Indicators;                  if ((indicators & StateIndicators.Active) != 0)                  {                      g.FillEllipse(                          Brushes.SpringGreen'                          bounds.X - CornerRadius'                          bounds.Y - CornerRadius'                          2 * CornerRadius'                          2 * CornerRadius);                  }                    // draw state lozenge                  using (GraphicsPath gp = GetStatePath(bounds))                  {                      if (!IsPrinting)                      {                          using (LinearGradientBrush interiorBrush =                              new LinearGradientBrush(                                  bounds'                                  Color.WhiteSmoke'                                  Color.LightGray'                                  LinearGradientMode.ForwardDiagonal))                          {                              g.FillPath(interiorBrush' gp);                          }                      }                      else                      {                          g.FillPath(Brushes.White' gp);                      }                      g.DrawPath(m_theme.OutlinePen' gp);                  }                    g.DrawString(                      complexState.Name'                      m_theme.Font'                      m_theme.TextBrush'                      bounds.X + CornerRadius'                      bounds.Y + Margin);                    g.DrawLine(                      m_theme.OutlinePen'                      bounds.Left' bounds.Top + m_fontHeight + Margin'                      bounds.Right' bounds.Top + m_fontHeight + Margin);                    RectangleF textBounds = new RectangleF(                      (float)(bounds.Left + 4)'                      (float)(bounds.Top + m_fontHeight + 2)'                      (float)(bounds.Width - 5)'                      (float)(bounds.Height - m_fontHeight - 4));                    g.DrawString(complexState.Text' m_theme.Font' m_theme.TextBrush' textBounds' s_stateTextFormat);                    //IList<int> partitionWidths = complexState.PartitionSizes;                  //if (partitionWidths.Count > 0)                  //{                  //    // draw AND-state dividers                  //    int lastDivider = bounds.Left;                  //    foreach (int width in partitionWidths)                  //    {                  //        g.DrawLine(                  //            m_dividerPen'                  //            lastDivider' bounds.Y + m_fontHeight + Margin'                  //            lastDivider' bounds.Y + bounds.Height);                    //        lastDivider += width;                  //    }                  //}              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Draw,The following statement contains a magic number: if (state.Type != StateType.Normal)              {                  DrawPseudostate(bounds.Location' state.Type' m_theme.OutlinePen' g);              }              else              {                  IComplexState<TNode' TEdge> complexState = state as IComplexState<TNode' TEdge>;                    // Prevent an exception being thrown by LinearGradientBrush.                  if (bounds.Width <= 0)                      bounds.Width = 1;                  if (bounds.Height <= 0)                      bounds.Height = 1;                    StateIndicators indicators = state.Indicators;                  if ((indicators & StateIndicators.Active) != 0)                  {                      g.FillEllipse(                          Brushes.SpringGreen'                          bounds.X - CornerRadius'                          bounds.Y - CornerRadius'                          2 * CornerRadius'                          2 * CornerRadius);                  }                    // draw state lozenge                  using (GraphicsPath gp = GetStatePath(bounds))                  {                      if (!IsPrinting)                      {                          using (LinearGradientBrush interiorBrush =                              new LinearGradientBrush(                                  bounds'                                  Color.WhiteSmoke'                                  Color.LightGray'                                  LinearGradientMode.ForwardDiagonal))                          {                              g.FillPath(interiorBrush' gp);                          }                      }                      else                      {                          g.FillPath(Brushes.White' gp);                      }                      g.DrawPath(m_theme.OutlinePen' gp);                  }                    g.DrawString(                      complexState.Name'                      m_theme.Font'                      m_theme.TextBrush'                      bounds.X + CornerRadius'                      bounds.Y + Margin);                    g.DrawLine(                      m_theme.OutlinePen'                      bounds.Left' bounds.Top + m_fontHeight + Margin'                      bounds.Right' bounds.Top + m_fontHeight + Margin);                    RectangleF textBounds = new RectangleF(                      (float)(bounds.Left + 4)'                      (float)(bounds.Top + m_fontHeight + 2)'                      (float)(bounds.Width - 5)'                      (float)(bounds.Height - m_fontHeight - 4));                    g.DrawString(complexState.Text' m_theme.Font' m_theme.TextBrush' textBounds' s_stateTextFormat);                    //IList<int> partitionWidths = complexState.PartitionSizes;                  //if (partitionWidths.Count > 0)                  //{                  //    // draw AND-state dividers                  //    int lastDivider = bounds.Left;                  //    foreach (int width in partitionWidths)                  //    {                  //        g.DrawLine(                  //            m_dividerPen'                  //            lastDivider' bounds.Y + m_fontHeight + Margin'                  //            lastDivider' bounds.Y + bounds.Height);                    //        lastDivider += width;                  //    }                  //}              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Draw,The following statement contains a magic number: if (state.Type != StateType.Normal)              {                  DrawPseudostate(bounds.Location' state.Type' m_theme.OutlinePen' g);              }              else              {                  IComplexState<TNode' TEdge> complexState = state as IComplexState<TNode' TEdge>;                    // Prevent an exception being thrown by LinearGradientBrush.                  if (bounds.Width <= 0)                      bounds.Width = 1;                  if (bounds.Height <= 0)                      bounds.Height = 1;                    StateIndicators indicators = state.Indicators;                  if ((indicators & StateIndicators.Active) != 0)                  {                      g.FillEllipse(                          Brushes.SpringGreen'                          bounds.X - CornerRadius'                          bounds.Y - CornerRadius'                          2 * CornerRadius'                          2 * CornerRadius);                  }                    // draw state lozenge                  using (GraphicsPath gp = GetStatePath(bounds))                  {                      if (!IsPrinting)                      {                          using (LinearGradientBrush interiorBrush =                              new LinearGradientBrush(                                  bounds'                                  Color.WhiteSmoke'                                  Color.LightGray'                                  LinearGradientMode.ForwardDiagonal))                          {                              g.FillPath(interiorBrush' gp);                          }                      }                      else                      {                          g.FillPath(Brushes.White' gp);                      }                      g.DrawPath(m_theme.OutlinePen' gp);                  }                    g.DrawString(                      complexState.Name'                      m_theme.Font'                      m_theme.TextBrush'                      bounds.X + CornerRadius'                      bounds.Y + Margin);                    g.DrawLine(                      m_theme.OutlinePen'                      bounds.Left' bounds.Top + m_fontHeight + Margin'                      bounds.Right' bounds.Top + m_fontHeight + Margin);                    RectangleF textBounds = new RectangleF(                      (float)(bounds.Left + 4)'                      (float)(bounds.Top + m_fontHeight + 2)'                      (float)(bounds.Width - 5)'                      (float)(bounds.Height - m_fontHeight - 4));                    g.DrawString(complexState.Text' m_theme.Font' m_theme.TextBrush' textBounds' s_stateTextFormat);                    //IList<int> partitionWidths = complexState.PartitionSizes;                  //if (partitionWidths.Count > 0)                  //{                  //    // draw AND-state dividers                  //    int lastDivider = bounds.Left;                  //    foreach (int width in partitionWidths)                  //    {                  //        g.DrawLine(                  //            m_dividerPen'                  //            lastDivider' bounds.Y + m_fontHeight + Margin'                  //            lastDivider' bounds.Y + bounds.Height);                    //        lastDivider += width;                  //    }                  //}              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Draw,The following statement contains a magic number: if (state.Type != StateType.Normal)              {                  DrawPseudostate(bounds.Location' state.Type' m_theme.OutlinePen' g);              }              else              {                  IComplexState<TNode' TEdge> complexState = state as IComplexState<TNode' TEdge>;                    // Prevent an exception being thrown by LinearGradientBrush.                  if (bounds.Width <= 0)                      bounds.Width = 1;                  if (bounds.Height <= 0)                      bounds.Height = 1;                    StateIndicators indicators = state.Indicators;                  if ((indicators & StateIndicators.Active) != 0)                  {                      g.FillEllipse(                          Brushes.SpringGreen'                          bounds.X - CornerRadius'                          bounds.Y - CornerRadius'                          2 * CornerRadius'                          2 * CornerRadius);                  }                    // draw state lozenge                  using (GraphicsPath gp = GetStatePath(bounds))                  {                      if (!IsPrinting)                      {                          using (LinearGradientBrush interiorBrush =                              new LinearGradientBrush(                                  bounds'                                  Color.WhiteSmoke'                                  Color.LightGray'                                  LinearGradientMode.ForwardDiagonal))                          {                              g.FillPath(interiorBrush' gp);                          }                      }                      else                      {                          g.FillPath(Brushes.White' gp);                      }                      g.DrawPath(m_theme.OutlinePen' gp);                  }                    g.DrawString(                      complexState.Name'                      m_theme.Font'                      m_theme.TextBrush'                      bounds.X + CornerRadius'                      bounds.Y + Margin);                    g.DrawLine(                      m_theme.OutlinePen'                      bounds.Left' bounds.Top + m_fontHeight + Margin'                      bounds.Right' bounds.Top + m_fontHeight + Margin);                    RectangleF textBounds = new RectangleF(                      (float)(bounds.Left + 4)'                      (float)(bounds.Top + m_fontHeight + 2)'                      (float)(bounds.Width - 5)'                      (float)(bounds.Height - m_fontHeight - 4));                    g.DrawString(complexState.Text' m_theme.Font' m_theme.TextBrush' textBounds' s_stateTextFormat);                    //IList<int> partitionWidths = complexState.PartitionSizes;                  //if (partitionWidths.Count > 0)                  //{                  //    // draw AND-state dividers                  //    int lastDivider = bounds.Left;                  //    foreach (int width in partitionWidths)                  //    {                  //        g.DrawLine(                  //            m_dividerPen'                  //            lastDivider' bounds.Y + m_fontHeight + Margin'                  //            lastDivider' bounds.Y + bounds.Height);                    //        lastDivider += width;                  //    }                  //}              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Draw,The following statement contains a magic number: if (state.Type != StateType.Normal)              {                  DrawPseudostate(bounds.Location' state.Type' m_theme.OutlinePen' g);              }              else              {                  IComplexState<TNode' TEdge> complexState = state as IComplexState<TNode' TEdge>;                    // Prevent an exception being thrown by LinearGradientBrush.                  if (bounds.Width <= 0)                      bounds.Width = 1;                  if (bounds.Height <= 0)                      bounds.Height = 1;                    StateIndicators indicators = state.Indicators;                  if ((indicators & StateIndicators.Active) != 0)                  {                      g.FillEllipse(                          Brushes.SpringGreen'                          bounds.X - CornerRadius'                          bounds.Y - CornerRadius'                          2 * CornerRadius'                          2 * CornerRadius);                  }                    // draw state lozenge                  using (GraphicsPath gp = GetStatePath(bounds))                  {                      if (!IsPrinting)                      {                          using (LinearGradientBrush interiorBrush =                              new LinearGradientBrush(                                  bounds'                                  Color.WhiteSmoke'                                  Color.LightGray'                                  LinearGradientMode.ForwardDiagonal))                          {                              g.FillPath(interiorBrush' gp);                          }                      }                      else                      {                          g.FillPath(Brushes.White' gp);                      }                      g.DrawPath(m_theme.OutlinePen' gp);                  }                    g.DrawString(                      complexState.Name'                      m_theme.Font'                      m_theme.TextBrush'                      bounds.X + CornerRadius'                      bounds.Y + Margin);                    g.DrawLine(                      m_theme.OutlinePen'                      bounds.Left' bounds.Top + m_fontHeight + Margin'                      bounds.Right' bounds.Top + m_fontHeight + Margin);                    RectangleF textBounds = new RectangleF(                      (float)(bounds.Left + 4)'                      (float)(bounds.Top + m_fontHeight + 2)'                      (float)(bounds.Width - 5)'                      (float)(bounds.Height - m_fontHeight - 4));                    g.DrawString(complexState.Text' m_theme.Font' m_theme.TextBrush' textBounds' s_stateTextFormat);                    //IList<int> partitionWidths = complexState.PartitionSizes;                  //if (partitionWidths.Count > 0)                  //{                  //    // draw AND-state dividers                  //    int lastDivider = bounds.Left;                  //    foreach (int width in partitionWidths)                  //    {                  //        g.DrawLine(                  //            m_dividerPen'                  //            lastDivider' bounds.Y + m_fontHeight + Margin'                  //            lastDivider' bounds.Y + bounds.Height);                    //        lastDivider += width;                  //    }                  //}              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Draw,The following statement contains a magic number: if (state.Type != StateType.Normal)              {                  DrawPseudostate(bounds.Location' state.Type' m_theme.OutlinePen' g);              }              else              {                  IComplexState<TNode' TEdge> complexState = state as IComplexState<TNode' TEdge>;                    // Prevent an exception being thrown by LinearGradientBrush.                  if (bounds.Width <= 0)                      bounds.Width = 1;                  if (bounds.Height <= 0)                      bounds.Height = 1;                    StateIndicators indicators = state.Indicators;                  if ((indicators & StateIndicators.Active) != 0)                  {                      g.FillEllipse(                          Brushes.SpringGreen'                          bounds.X - CornerRadius'                          bounds.Y - CornerRadius'                          2 * CornerRadius'                          2 * CornerRadius);                  }                    // draw state lozenge                  using (GraphicsPath gp = GetStatePath(bounds))                  {                      if (!IsPrinting)                      {                          using (LinearGradientBrush interiorBrush =                              new LinearGradientBrush(                                  bounds'                                  Color.WhiteSmoke'                                  Color.LightGray'                                  LinearGradientMode.ForwardDiagonal))                          {                              g.FillPath(interiorBrush' gp);                          }                      }                      else                      {                          g.FillPath(Brushes.White' gp);                      }                      g.DrawPath(m_theme.OutlinePen' gp);                  }                    g.DrawString(                      complexState.Name'                      m_theme.Font'                      m_theme.TextBrush'                      bounds.X + CornerRadius'                      bounds.Y + Margin);                    g.DrawLine(                      m_theme.OutlinePen'                      bounds.Left' bounds.Top + m_fontHeight + Margin'                      bounds.Right' bounds.Top + m_fontHeight + Margin);                    RectangleF textBounds = new RectangleF(                      (float)(bounds.Left + 4)'                      (float)(bounds.Top + m_fontHeight + 2)'                      (float)(bounds.Width - 5)'                      (float)(bounds.Height - m_fontHeight - 4));                    g.DrawString(complexState.Text' m_theme.Font' m_theme.TextBrush' textBounds' s_stateTextFormat);                    //IList<int> partitionWidths = complexState.PartitionSizes;                  //if (partitionWidths.Count > 0)                  //{                  //    // draw AND-state dividers                  //    int lastDivider = bounds.Left;                  //    foreach (int width in partitionWidths)                  //    {                  //        g.DrawLine(                  //            m_dividerPen'                  //            lastDivider' bounds.Y + m_fontHeight + Margin'                  //            lastDivider' bounds.Y + bounds.Height);                    //        lastDivider += width;                  //    }                  //}              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: int size = CornerRadius * 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following statement contains a magic number: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetStatePath,The following statement contains a magic number: const int d = 2 * CornerRadius;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetStatePath,The following statement contains a magic number: gp.AddArc(bounds.X' bounds.Y' d' d' 180' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetStatePath,The following statement contains a magic number: gp.AddArc(bounds.X' bounds.Y' d' d' 180' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetStatePath,The following statement contains a magic number: gp.AddArc(bounds.X + bounds.Width - d' bounds.Y' d' d' 270' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetStatePath,The following statement contains a magic number: gp.AddArc(bounds.X + bounds.Width - d' bounds.Y' d' d' 270' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetStatePath,The following statement contains a magic number: gp.AddArc(bounds.X + bounds.Width - d' bounds.Y + bounds.Height - d' d' d' 0' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetStatePath,The following statement contains a magic number: gp.AddArc(bounds.X' bounds.Y + bounds.Height - d' d' d' 90' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetStatePath,The following statement contains a magic number: gp.AddArc(bounds.X' bounds.Y + bounds.Height - d' d' d' 90' 90);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetStatePath,The following statement contains a magic number: gp.AddLine(bounds.X' bounds.Y + bounds.Height - d' bounds.X' bounds.Y + d / 2);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,Draw,The following statement contains a magic number: midpoint.X += 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetTransitionPoints,The following statement contains a magic number: int d = (int)Math.Sqrt(dx * dx + dy * dy) / 2;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,GetTransitionPoints,The following statement contains a magic number: d = Math.Min(d' 64);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,PointToParameter,The following statement contains a magic number: if (dy * px + dx * py > 0) // quadrant 0 or 1              {                  if (-dy * px + dx * py < 0) // quadrant 0                  {                      result = 0;                  }                  else // quadrant 1                  {                      result = 1;                      temp = px; px = -py; py = temp;                      temp = dx; dx = dy; dy = temp;                  }              }              else // quadrant 2 or 3              {                  if (dy * px + -dx * py < 0) // quadrant 2                  {                      result = 2;                      px = -px; py = -py;                  }                  else // quadrant 3                  {                      result = 3;                      temp = py; py = -px; px = temp;                      temp = dx; dx = dy; dy = temp;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,PointToParameter,The following statement contains a magic number: if (dy * px + dx * py > 0) // quadrant 0 or 1              {                  if (-dy * px + dx * py < 0) // quadrant 0                  {                      result = 0;                  }                  else // quadrant 1                  {                      result = 1;                      temp = px; px = -py; py = temp;                      temp = dx; dx = dy; dy = temp;                  }              }              else // quadrant 2 or 3              {                  if (dy * px + -dx * py < 0) // quadrant 2                  {                      result = 2;                      px = -px; py = -py;                  }                  else // quadrant 3                  {                      result = 3;                      temp = py; py = -px; px = temp;                      temp = dx; dx = dy; dy = temp;                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,PointToParameter,The following statement contains a magic number: result += (y + dy) / (dy * 2);
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,ParameterToPoint,The following statement contains a magic number: if (t < 2) // + side              {                  if (t < 1) // right                  {                      x0 = right;                      y0 = top;                      dy = height;                        normal = new Point(1' 0);                  }                  else // bottom                  {                      y0 = bottom;                      x0 = right;                      dx = -width;                      t -= 1;                        normal = new Point(0' 1);                  }              }              else // - side              {                  if (t < 3) // left                  {                      x0 = left;                      y0 = bottom;                      dy = -height;                      t -= 2;                        normal = new Point(-1' 0);                  }                  else // top                  {                      y0 = top;                      x0 = left;                      dx = width;                      t -= 3;                        normal = new Point(0' -1);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,ParameterToPoint,The following statement contains a magic number: if (t < 2) // + side              {                  if (t < 1) // right                  {                      x0 = right;                      y0 = top;                      dy = height;                        normal = new Point(1' 0);                  }                  else // bottom                  {                      y0 = bottom;                      x0 = right;                      dx = -width;                      t -= 1;                        normal = new Point(0' 1);                  }              }              else // - side              {                  if (t < 3) // left                  {                      x0 = left;                      y0 = bottom;                      dy = -height;                      t -= 2;                        normal = new Point(-1' 0);                  }                  else // top                  {                      y0 = top;                      x0 = left;                      dx = width;                      t -= 3;                        normal = new Point(0' -1);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,ParameterToPoint,The following statement contains a magic number: if (t < 2) // + side              {                  if (t < 1) // right                  {                      x0 = right;                      y0 = top;                      dy = height;                        normal = new Point(1' 0);                  }                  else // bottom                  {                      y0 = bottom;                      x0 = right;                      dx = -width;                      t -= 1;                        normal = new Point(0' 1);                  }              }              else // - side              {                  if (t < 3) // left                  {                      x0 = left;                      y0 = bottom;                      dy = -height;                      t -= 2;                        normal = new Point(-1' 0);                  }                  else // top                  {                      y0 = top;                      x0 = left;                      dx = width;                      t -= 3;                        normal = new Point(0' -1);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,ParameterToPoint,The following statement contains a magic number: if (t < 2) // + side              {                  if (t < 1) // right                  {                      x0 = right;                      y0 = top;                      dy = height;                        normal = new Point(1' 0);                  }                  else // bottom                  {                      y0 = bottom;                      x0 = right;                      dx = -width;                      t -= 1;                        normal = new Point(0' 1);                  }              }              else // - side              {                  if (t < 3) // left                  {                      x0 = left;                      y0 = bottom;                      dy = -height;                      t -= 2;                        normal = new Point(-1' 0);                  }                  else // top                  {                      y0 = top;                      x0 = left;                      dx = width;                      t -= 3;                        normal = new Point(0' -1);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawArrow,The following statement contains a magic number: const double cos = 0.866;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawArrow,The following statement contains a magic number: const double sin = 0.500;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Draw,The following statement contains a magic number: if (CircleF.Project(new Vec2F(end)' boundary' ref proj))              {                  PointF start = new PointF(proj.X' proj.Y);                  g.DrawLine(start' end' m_theme.OutlineBrush);                    if (fromNode == null)                  {                      PointF temp = end;                      end = start;                      start = temp;                  }                  Vec2F endTangent = new Vec2F(end.X - start.X' end.Y - start.Y);                  Vec2F arrowPosition = new Vec2F(end);                                  DrawArrow(arrowPosition' endTangent' m_theme.OutlineBrush' g);                    if (!string.IsNullOrEmpty(label))                  {                      PointF textPoint = new PointF((end.X + start.X) * 0.5f' (end.Y + start.Y) * 0.5f);                      RectangleF textBox = new RectangleF(textPoint.X - 512' textPoint.Y' 1024' m_theme.TextFormat.FontHeight);                      //g.DrawString(label' m_theme.Font' m_theme.TextBrush' textBox' m_theme.CenterStringFormat);                      g.DrawText(label' m_theme.TextFormat' textBox' m_theme.TextBrush);                  }                }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Draw,The following statement contains a magic number: if (CircleF.Project(new Vec2F(end)' boundary' ref proj))              {                  PointF start = new PointF(proj.X' proj.Y);                  g.DrawLine(start' end' m_theme.OutlineBrush);                    if (fromNode == null)                  {                      PointF temp = end;                      end = start;                      start = temp;                  }                  Vec2F endTangent = new Vec2F(end.X - start.X' end.Y - start.Y);                  Vec2F arrowPosition = new Vec2F(end);                                  DrawArrow(arrowPosition' endTangent' m_theme.OutlineBrush' g);                    if (!string.IsNullOrEmpty(label))                  {                      PointF textPoint = new PointF((end.X + start.X) * 0.5f' (end.Y + start.Y) * 0.5f);                      RectangleF textBox = new RectangleF(textPoint.X - 512' textPoint.Y' 1024' m_theme.TextFormat.FontHeight);                      //g.DrawString(label' m_theme.Font' m_theme.TextBrush' textBox' m_theme.CenterStringFormat);                      g.DrawText(label' m_theme.TextFormat' textBox' m_theme.TextBrush);                  }                }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Pick,The following statement contains a magic number: if (pickedNode != null && pickedEdge == null)              {                  // label is centered in entire node                  RectangleF labelBounds = GetBounds(pickedNode' g);                  float dHeight = labelBounds.Height - m_theme.TextFormat.FontHeight;                  labelBounds = new RectangleF(                      labelBounds.X' labelBounds.Y + dHeight / 2' labelBounds.Width' labelBounds.Height - dHeight);                    if (labelBounds.Contains(p))                  {                      DiagramLabel label = new DiagramLabel(                          Rectangle.Truncate(labelBounds)'                          TextFormatFlags.SingleLine |                          TextFormatFlags.HorizontalCenter);                        return                          new GraphHitRecord<TNode' TEdge' NumberedRoute>(pickedNode' label);                  }                }              else if (pickedEdge != null)              {                  RectangleF labelBounds = GetLabelBounds(pickedEdge' g);                  DiagramLabel label = new DiagramLabel(                      Rectangle.Truncate(labelBounds)'                      TextFormatFlags.SingleLine |                      TextFormatFlags.HorizontalCenter);                    if (labelBounds.Contains(p))                  {                      return                          new GraphHitRecord<TNode' TEdge' NumberedRoute>(pickedEdge' label);                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,GetEdgeGeometry,The following statement contains a magic number: if (edge.FromNode == edge.ToNode)              {                  CircleF c = GetBoundary(edge.FromNode);                  circle = c;                  circle.Center.X -= circle.Radius;                  circle.Radius *= 0.85f;                  float offset = route * m_routeOffset / 2;                  circle.Center.X -= offset;                  circle.Radius += offset;                  CircleF.Intersect(circle' c' ref startPoint' ref endPoint);                  moreThan180 = true;              }              else              {                  CircleF c1 = GetBoundary(edge.FromNode);                  CircleF c2 = GetBoundary(edge.ToNode);                  Vec2F d = Vec2F.Sub(c2.Center' c1.Center);                  float length = d.Length;                  if (length < c1.Radius + c2.Radius)                  {                      // overlapping nodes' don't try to draw arcs                      d = Vec2F.XAxis;                      straightLine = true;                  }                  else if (route == 0)                  {                      d *= 1.0f / length;                      straightLine = true;                  }                  else                  {                      Vec2F routePoint = c1.Center + d * 0.5f;                      float dLength = d.Length;                      Vec2F offset = d.Perp * (1.0f / dLength);                      routePoint -= offset * m_routeOffset * route;                      circle = new CircleF(c1.Center' routePoint' c2.Center);                        Vec2F dummy = new Vec2F();                      CircleF.Intersect(circle' c1' ref startPoint' ref dummy);                      CircleF.Intersect(circle' c2' ref dummy' ref endPoint);                        Vec2F startToEnd = startPoint - endPoint;                      Vec2F centerToEnd = circle.Center - endPoint;                      moreThan180 = Vec2F.PerpDot(centerToEnd' startToEnd) < 0;                  }                    if (straightLine)                  {                      startPoint = Vec2F.Add(c1.Center' Vec2F.Mul(d' c1.Radius));                      endPoint = Vec2F.Sub(c2.Center' Vec2F.Mul(d' c2.Radius));                  }              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Draw,The following statement contains a magic number: if (GetEdgeGeometry(edge' route' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  g.DrawLine(new PointF(startPoint.X' startPoint.Y)'                      new PointF(endPoint.X' endPoint.Y)'                      brush'                      m_theme.StrokeWidth);                    endTangent = endPoint - startPoint;                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  // prepare to draw arc                  RectangleF rect = new RectangleF(c.Center.X - c.Radius' c.Center.Y - c.Radius' 2 * c.Radius' 2 * c.Radius);                    double angle1 = Math.Atan2(startPoint.Y - c.Center.Y' startPoint.X - c.Center.X);                  double angle2 = Math.Atan2(endPoint.Y - c.Center.Y' endPoint.X - c.Center.X);                  const double twoPi = 2 * Math.PI;                    // swap so we always go clockwise                  if (angle1 > angle2)                  {                      double temp = angle1;                      angle1 = angle2;                      angle2 = temp;                  }                    double startAngle = angle1;                  double sweepAngle = angle2 - angle1;                    if (moreThan180)                  {                      if (sweepAngle < Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                  else                  {                      if (sweepAngle > Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                    const double RadiansToDegrees = 360 / twoPi;                  startAngle *= RadiansToDegrees;                  sweepAngle *= RadiansToDegrees;                    g.DrawArc((D2dEllipse)rect'                      brush'                      (float)startAngle'                      (float)sweepAngle'                      m_theme.StrokeWidth);                    endTangent = endPoint - c.Center; endTangent = endTangent.Perp;                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Draw,The following statement contains a magic number: if (GetEdgeGeometry(edge' route' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  g.DrawLine(new PointF(startPoint.X' startPoint.Y)'                      new PointF(endPoint.X' endPoint.Y)'                      brush'                      m_theme.StrokeWidth);                    endTangent = endPoint - startPoint;                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  // prepare to draw arc                  RectangleF rect = new RectangleF(c.Center.X - c.Radius' c.Center.Y - c.Radius' 2 * c.Radius' 2 * c.Radius);                    double angle1 = Math.Atan2(startPoint.Y - c.Center.Y' startPoint.X - c.Center.X);                  double angle2 = Math.Atan2(endPoint.Y - c.Center.Y' endPoint.X - c.Center.X);                  const double twoPi = 2 * Math.PI;                    // swap so we always go clockwise                  if (angle1 > angle2)                  {                      double temp = angle1;                      angle1 = angle2;                      angle2 = temp;                  }                    double startAngle = angle1;                  double sweepAngle = angle2 - angle1;                    if (moreThan180)                  {                      if (sweepAngle < Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                  else                  {                      if (sweepAngle > Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                    const double RadiansToDegrees = 360 / twoPi;                  startAngle *= RadiansToDegrees;                  sweepAngle *= RadiansToDegrees;                    g.DrawArc((D2dEllipse)rect'                      brush'                      (float)startAngle'                      (float)sweepAngle'                      m_theme.StrokeWidth);                    endTangent = endPoint - c.Center; endTangent = endTangent.Perp;                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Draw,The following statement contains a magic number: if (GetEdgeGeometry(edge' route' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  g.DrawLine(new PointF(startPoint.X' startPoint.Y)'                      new PointF(endPoint.X' endPoint.Y)'                      brush'                      m_theme.StrokeWidth);                    endTangent = endPoint - startPoint;                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  // prepare to draw arc                  RectangleF rect = new RectangleF(c.Center.X - c.Radius' c.Center.Y - c.Radius' 2 * c.Radius' 2 * c.Radius);                    double angle1 = Math.Atan2(startPoint.Y - c.Center.Y' startPoint.X - c.Center.X);                  double angle2 = Math.Atan2(endPoint.Y - c.Center.Y' endPoint.X - c.Center.X);                  const double twoPi = 2 * Math.PI;                    // swap so we always go clockwise                  if (angle1 > angle2)                  {                      double temp = angle1;                      angle1 = angle2;                      angle2 = temp;                  }                    double startAngle = angle1;                  double sweepAngle = angle2 - angle1;                    if (moreThan180)                  {                      if (sweepAngle < Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                  else                  {                      if (sweepAngle > Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                    const double RadiansToDegrees = 360 / twoPi;                  startAngle *= RadiansToDegrees;                  sweepAngle *= RadiansToDegrees;                    g.DrawArc((D2dEllipse)rect'                      brush'                      (float)startAngle'                      (float)sweepAngle'                      m_theme.StrokeWidth);                    endTangent = endPoint - c.Center; endTangent = endTangent.Perp;                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Draw,The following statement contains a magic number: if (GetEdgeGeometry(edge' route' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  g.DrawLine(new PointF(startPoint.X' startPoint.Y)'                      new PointF(endPoint.X' endPoint.Y)'                      brush'                      m_theme.StrokeWidth);                    endTangent = endPoint - startPoint;                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  // prepare to draw arc                  RectangleF rect = new RectangleF(c.Center.X - c.Radius' c.Center.Y - c.Radius' 2 * c.Radius' 2 * c.Radius);                    double angle1 = Math.Atan2(startPoint.Y - c.Center.Y' startPoint.X - c.Center.X);                  double angle2 = Math.Atan2(endPoint.Y - c.Center.Y' endPoint.X - c.Center.X);                  const double twoPi = 2 * Math.PI;                    // swap so we always go clockwise                  if (angle1 > angle2)                  {                      double temp = angle1;                      angle1 = angle2;                      angle2 = temp;                  }                    double startAngle = angle1;                  double sweepAngle = angle2 - angle1;                    if (moreThan180)                  {                      if (sweepAngle < Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                  else                  {                      if (sweepAngle > Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                    const double RadiansToDegrees = 360 / twoPi;                  startAngle *= RadiansToDegrees;                  sweepAngle *= RadiansToDegrees;                    g.DrawArc((D2dEllipse)rect'                      brush'                      (float)startAngle'                      (float)sweepAngle'                      m_theme.StrokeWidth);                    endTangent = endPoint - c.Center; endTangent = endTangent.Perp;                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Draw,The following statement contains a magic number: if (GetEdgeGeometry(edge' route' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  g.DrawLine(new PointF(startPoint.X' startPoint.Y)'                      new PointF(endPoint.X' endPoint.Y)'                      brush'                      m_theme.StrokeWidth);                    endTangent = endPoint - startPoint;                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  // prepare to draw arc                  RectangleF rect = new RectangleF(c.Center.X - c.Radius' c.Center.Y - c.Radius' 2 * c.Radius' 2 * c.Radius);                    double angle1 = Math.Atan2(startPoint.Y - c.Center.Y' startPoint.X - c.Center.X);                  double angle2 = Math.Atan2(endPoint.Y - c.Center.Y' endPoint.X - c.Center.X);                  const double twoPi = 2 * Math.PI;                    // swap so we always go clockwise                  if (angle1 > angle2)                  {                      double temp = angle1;                      angle1 = angle2;                      angle2 = temp;                  }                    double startAngle = angle1;                  double sweepAngle = angle2 - angle1;                    if (moreThan180)                  {                      if (sweepAngle < Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                  else                  {                      if (sweepAngle > Math.PI)                          sweepAngle = -(twoPi - sweepAngle);                  }                    const double RadiansToDegrees = 360 / twoPi;                  startAngle *= RadiansToDegrees;                  sweepAngle *= RadiansToDegrees;                    g.DrawArc((D2dEllipse)rect'                      brush'                      (float)startAngle'                      (float)sweepAngle'                      m_theme.StrokeWidth);                    endTangent = endPoint - c.Center; endTangent = endTangent.Perp;                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Draw,The following statement contains a magic number: if (!string.IsNullOrEmpty(label))              {                  RectangleF textBox = new RectangleF(textPoint.X - 512' textPoint.Y' 1024' m_theme.TextFormat.FontHeight);                  g.DrawText(label' m_theme.TextFormat' textBox' m_theme.TextBrush);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,Draw,The following statement contains a magic number: if (!string.IsNullOrEmpty(label))              {                  RectangleF textBox = new RectangleF(textPoint.X - 512' textPoint.Y' 1024' m_theme.TextFormat.FontHeight);                  g.DrawText(label' m_theme.TextFormat' textBox' m_theme.TextBrush);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,GetLabelBounds,The following statement contains a magic number: if (GetEdgeGeometry(edge' edge.FromRoute.Index' ref startPoint' ref endPoint' ref c' ref moreThan180))              {                  textPoint = (endPoint + startPoint) * 0.5f;              }              else              {                  textPoint = (endPoint + startPoint) * 0.5f;                  CircleF.Project(textPoint' c' ref textPoint);                  if (moreThan180)                      textPoint -= 2 * (textPoint - c.Center);              }
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,GetLabelBounds,The following statement contains a magic number: float width = 32;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,DrawArrow,The following statement contains a magic number: const double cos = -0.866;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,DrawArrow,The following statement contains a magic number: const double sin = -0.500;
Magic Number,Sce.Atf.Controls.Adaptable.Graphs,D2dDigraphRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dDigraphRenderer.cs,GetBoundary,The following statement contains a magic number: float r = bounds.Width / 2;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: int alpha =    Round(255 * hsl.A);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: Max = Round(hsl.L * 255);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: Min = Round((1.0 - hsl.S)*(hsl.L/1.0)*255);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: q   = (double)(Max - Min)/255;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,HSL_to_RGB,The following statement contains a magic number: if ( hsl.H >= 0 && hsl.H <= (double)1/6 )              {                  Mid = Round(((hsl.H - 0) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Max'Mid'Min);              }              else if ( hsl.H <= (double)1/3 )              {                  Mid = Round(-((hsl.H - (double)1/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Mid'Max'Min);              }              else if ( hsl.H <= 0.5 )              {                  Mid = Round(((hsl.H - (double)1/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Min'Max'Mid);              }              else if ( hsl.H <= (double)2/3 )              {                  Mid = Round(-((hsl.H - 0.5) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Min'Mid'Max);              }              else if ( hsl.H <= (double)5/6 )              {                  Mid = Round(((hsl.H - (double)2/3) * q) * 1530 + Min);                  return Color.FromArgb(alpha'Mid'Min'Max);              }              else if ( hsl.H <= 1.0 )              {                  Mid = Round(-((hsl.H - (double)5/6) * q) * 1530 + Max);                  return Color.FromArgb(alpha'Max'Min'Mid);              }              else    return Color.FromArgb(alpha'0'0'0);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_HSL,The following statement contains a magic number: hsl.A = (double)c.A/255;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_HSL,The following statement contains a magic number: hsl.L = (double)Max/255;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_HSL,The following statement contains a magic number: if ( Diff == 0 ) q = 0; // Protecting from the impossible operation of division by zero.              else q = (double)60/Diff;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_HSL,The following statement contains a magic number: if ( Max == c.R )              {                  if ( c.G < c.B )    hsl.H = (double)(360 + q * (c.G - c.B))/360;                  else                hsl.H = (double)(q * (c.G - c.B))/360;              }              else if ( Max == c.G )    hsl.H = (double)(120 + q * (c.B - c.R))/360;              else if ( Max == c.B )    hsl.H = (double)(240 + q * (c.R - c.G))/360;              else                      hsl.H = 0.0;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_HSL,The following statement contains a magic number: if ( Max == c.R )              {                  if ( c.G < c.B )    hsl.H = (double)(360 + q * (c.G - c.B))/360;                  else                hsl.H = (double)(q * (c.G - c.B))/360;              }              else if ( Max == c.G )    hsl.H = (double)(120 + q * (c.B - c.R))/360;              else if ( Max == c.B )    hsl.H = (double)(240 + q * (c.R - c.G))/360;              else                      hsl.H = 0.0;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_HSL,The following statement contains a magic number: if ( Max == c.R )              {                  if ( c.G < c.B )    hsl.H = (double)(360 + q * (c.G - c.B))/360;                  else                hsl.H = (double)(q * (c.G - c.B))/360;              }              else if ( Max == c.G )    hsl.H = (double)(120 + q * (c.B - c.R))/360;              else if ( Max == c.B )    hsl.H = (double)(240 + q * (c.R - c.G))/360;              else                      hsl.H = 0.0;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_HSL,The following statement contains a magic number: if ( Max == c.R )              {                  if ( c.G < c.B )    hsl.H = (double)(360 + q * (c.G - c.B))/360;                  else                hsl.H = (double)(q * (c.G - c.B))/360;              }              else if ( Max == c.G )    hsl.H = (double)(120 + q * (c.B - c.R))/360;              else if ( Max == c.B )    hsl.H = (double)(240 + q * (c.R - c.G))/360;              else                      hsl.H = 0.0;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_HSL,The following statement contains a magic number: if ( Max == c.R )              {                  if ( c.G < c.B )    hsl.H = (double)(360 + q * (c.G - c.B))/360;                  else                hsl.H = (double)(q * (c.G - c.B))/360;              }              else if ( Max == c.G )    hsl.H = (double)(120 + q * (c.B - c.R))/360;              else if ( Max == c.B )    hsl.H = (double)(240 + q * (c.R - c.G))/360;              else                      hsl.H = 0.0;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_HSL,The following statement contains a magic number: if ( Max == c.R )              {                  if ( c.G < c.B )    hsl.H = (double)(360 + q * (c.G - c.B))/360;                  else                hsl.H = (double)(q * (c.G - c.B))/360;              }              else if ( Max == c.G )    hsl.H = (double)(120 + q * (c.B - c.R))/360;              else if ( Max == c.B )    hsl.H = (double)(240 + q * (c.R - c.G))/360;              else                      hsl.H = 0.0;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_HSL,The following statement contains a magic number: if ( Max == c.R )              {                  if ( c.G < c.B )    hsl.H = (double)(360 + q * (c.G - c.B))/360;                  else                hsl.H = (double)(q * (c.G - c.B))/360;              }              else if ( Max == c.G )    hsl.H = (double)(120 + q * (c.B - c.R))/360;              else if ( Max == c.B )    hsl.H = (double)(240 + q * (c.R - c.G))/360;              else                      hsl.H = 0.0;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_CMYK,The following statement contains a magic number: _cmyk.A = (double)c.A/255;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_CMYK,The following statement contains a magic number: _cmyk.C = (double)(255 - c.R)/255;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_CMYK,The following statement contains a magic number: _cmyk.C = (double)(255 - c.R)/255;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_CMYK,The following statement contains a magic number: _cmyk.M = (double)(255 - c.G)/255;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_CMYK,The following statement contains a magic number: _cmyk.M = (double)(255 - c.G)/255;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_CMYK,The following statement contains a magic number: _cmyk.Y = (double)(255 - c.B)/255;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,RGB_to_CMYK,The following statement contains a magic number: _cmyk.Y = (double)(255 - c.B)/255;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,CMYK_to_RGB,The following statement contains a magic number: alpha =    Round(255 * _cmyk.A);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,CMYK_to_RGB,The following statement contains a magic number: red =      Round(255 - (255 * _cmyk.C));
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,CMYK_to_RGB,The following statement contains a magic number: red =      Round(255 - (255 * _cmyk.C));
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,CMYK_to_RGB,The following statement contains a magic number: green =    Round(255 - (255 * _cmyk.M));
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,CMYK_to_RGB,The following statement contains a magic number: green =    Round(255 - (255 * _cmyk.M));
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,CMYK_to_RGB,The following statement contains a magic number: blue =     Round(255 - (255 * _cmyk.Y));
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,CMYK_to_RGB,The following statement contains a magic number: blue =     Round(255 - (255 * _cmyk.Y));
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,Round,The following statement contains a magic number: int temp = (int)(val * 100);
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,Round,The following statement contains a magic number: if ( (temp % 100) >= 50 )                  ret_val += 1;
Magic Number,Sce.Atf.Controls.ColorEditing,AdobeColors,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\AdobeColors.cs,Round,The following statement contains a magic number: if ( (temp % 100) >= 50 )                  ret_val += 1;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseDown,The following statement contains a magic number: int x = e.X - 2' y = e.Y - 2;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseDown,The following statement contains a magic number: int x = e.X - 2' y = e.Y - 2;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseDown,The following statement contains a magic number: if ( x > Width - 4 ) x = Width - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseDown,The following statement contains a magic number: if ( x > Width - 4 ) x = Width - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseDown,The following statement contains a magic number: if ( y > Height - 4 ) y = Height - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseDown,The following statement contains a magic number: if ( y > Height - 4 ) y = Height - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseMove,The following statement contains a magic number: int x = e.X - 2' y = e.Y - 2;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseMove,The following statement contains a magic number: int x = e.X - 2' y = e.Y - 2;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseMove,The following statement contains a magic number: if ( x > Width - 4 ) x = Width - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseMove,The following statement contains a magic number: if ( x > Width - 4 ) x = Width - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseMove,The following statement contains a magic number: if ( y > Height - 4 ) y = Height - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseMove,The following statement contains a magic number: if ( y > Height - 4 ) y = Height - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseUp,The following statement contains a magic number: int x = e.X - 2' y = e.Y - 2;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseUp,The following statement contains a magic number: int x = e.X - 2' y = e.Y - 2;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseUp,The following statement contains a magic number: if ( x > Width - 4 ) x = Width - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseUp,The following statement contains a magic number: if ( x > Width - 4 ) x = Width - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseUp,The following statement contains a magic number: if ( y > Height - 4 ) y = Height - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ctrl2DColorBox_MouseUp,The following statement contains a magic number: if ( y > Height - 4 ) y = Height - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: start_x = m_iMarker_X - 5;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: start_y = m_iMarker_Y - 5;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: end_x = m_iMarker_X + 5;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: end_y = m_iMarker_Y + 5;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: if ( end_x > Width - 4 ) end_x = Width - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: if ( end_x > Width - 4 ) end_x = Width - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: if ( end_y > Height - 4 ) end_y = Height - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: if ( end_y > Height - 4 ) end_y = Height - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following statement contains a magic number: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( x > Width - 4 ) x = Width - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( x > Width - 4 ) x = Width - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( y > Height - 4 ) y = Height - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( y > Height - 4 ) y = Height - 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( _hsl.L < (double)200/255 )                  pen = new Pen(Color.White);                                    //    White marker if selected color is dark              else if ( _hsl.H < (double)26/360 || _hsl.H > (double)200/360 )                  if ( _hsl.S > (double)70/255 )                      pen = new Pen(Color.White);                  else                      pen = new Pen(Color.Black);                                //    Else use a black marker for lighter colors              else                  pen = new Pen(Color.Black);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( _hsl.L < (double)200/255 )                  pen = new Pen(Color.White);                                    //    White marker if selected color is dark              else if ( _hsl.H < (double)26/360 || _hsl.H > (double)200/360 )                  if ( _hsl.S > (double)70/255 )                      pen = new Pen(Color.White);                  else                      pen = new Pen(Color.Black);                                //    Else use a black marker for lighter colors              else                  pen = new Pen(Color.Black);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( _hsl.L < (double)200/255 )                  pen = new Pen(Color.White);                                    //    White marker if selected color is dark              else if ( _hsl.H < (double)26/360 || _hsl.H > (double)200/360 )                  if ( _hsl.S > (double)70/255 )                      pen = new Pen(Color.White);                  else                      pen = new Pen(Color.Black);                                //    Else use a black marker for lighter colors              else                  pen = new Pen(Color.Black);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( _hsl.L < (double)200/255 )                  pen = new Pen(Color.White);                                    //    White marker if selected color is dark              else if ( _hsl.H < (double)26/360 || _hsl.H > (double)200/360 )                  if ( _hsl.S > (double)70/255 )                      pen = new Pen(Color.White);                  else                      pen = new Pen(Color.Black);                                //    Else use a black marker for lighter colors              else                  pen = new Pen(Color.Black);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( _hsl.L < (double)200/255 )                  pen = new Pen(Color.White);                                    //    White marker if selected color is dark              else if ( _hsl.H < (double)26/360 || _hsl.H > (double)200/360 )                  if ( _hsl.S > (double)70/255 )                      pen = new Pen(Color.White);                  else                      pen = new Pen(Color.Black);                                //    Else use a black marker for lighter colors              else                  pen = new Pen(Color.Black);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( _hsl.L < (double)200/255 )                  pen = new Pen(Color.White);                                    //    White marker if selected color is dark              else if ( _hsl.H < (double)26/360 || _hsl.H > (double)200/360 )                  if ( _hsl.S > (double)70/255 )                      pen = new Pen(Color.White);                  else                      pen = new Pen(Color.Black);                                //    Else use a black marker for lighter colors              else                  pen = new Pen(Color.Black);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( _hsl.L < (double)200/255 )                  pen = new Pen(Color.White);                                    //    White marker if selected color is dark              else if ( _hsl.H < (double)26/360 || _hsl.H > (double)200/360 )                  if ( _hsl.S > (double)70/255 )                      pen = new Pen(Color.White);                  else                      pen = new Pen(Color.Black);                                //    Else use a black marker for lighter colors              else                  pen = new Pen(Color.Black);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: if ( _hsl.L < (double)200/255 )                  pen = new Pen(Color.White);                                    //    White marker if selected color is dark              else if ( _hsl.H < (double)26/360 || _hsl.H > (double)200/360 )                  if ( _hsl.S > (double)70/255 )                      pen = new Pen(Color.White);                  else                      pen = new Pen(Color.Black);                                //    Else use a black marker for lighter colors              else                  pen = new Pen(Color.Black);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: g.DrawEllipse(pen' x - 3' y - 3' 10' 10);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: g.DrawEllipse(pen' x - 3' y - 3' 10' 10);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: g.DrawEllipse(pen' x - 3' y - 3' 10' 10);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawMarker,The following statement contains a magic number: g.DrawEllipse(pen' x - 3' y - 3' 10' 10);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawBorder,The following statement contains a magic number: pencil = new Pen(Color.FromArgb(172'168'153));
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawBorder,The following statement contains a magic number: pencil = new Pen(Color.FromArgb(172'168'153));
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawBorder,The following statement contains a magic number: pencil = new Pen(Color.FromArgb(172'168'153));
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 2' 0' 0' 0);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' 0' 0' 0' Height - 2);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawBorder,The following statement contains a magic number: g.DrawRectangle(pencil' 1' 1' Width - 3' Height - 3);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,DrawBorder,The following statement contains a magic number: g.DrawRectangle(pencil' 1' 1' Width - 3' Height - 3);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  hsl_start.L = 1.0 - (double)i/(Height - 4);    //    Calculate luminance at this line (Hue and Saturation are constant)                  hsl_end.L = hsl_start.L;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  hsl_start.L = 1.0 - (double)i/(Height - 4);    //    Calculate luminance at this line (Hue and Saturation are constant)                  hsl_end.L = hsl_start.L;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  hsl_start.L = 1.0 - (double)i/(Height - 4);    //    Calculate luminance at this line (Hue and Saturation are constant)                  hsl_end.L = hsl_start.L;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  hsl_start.L = 1.0 - (double)i/(Height - 4);    //    Calculate luminance at this line (Hue and Saturation are constant)                  hsl_end.L = hsl_start.L;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  hsl_start.L = 1.0 - (double)i/(Height - 4);    //    Calculate luminance at this line (Hue and Saturation are constant)                  hsl_end.L = hsl_start.L;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  hsl_start.L = 1.0 - (double)i/(Height - 4);    //    Calculate luminance at this line (Hue and Saturation are constant)                  hsl_end.L = hsl_start.L;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  hsl_start.L = 1.0 - (double)i/(Height - 4);    //    Calculate luminance at this line (Hue and Saturation are constant)                  hsl_end.L = hsl_start.L;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  hsl_start.L = 1.0 - (double)i/(Height - 4);    //    Calculate luminance at this line (Hue and Saturation are constant)                  hsl_end.L = hsl_start.L;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Width - 4; i++ )        //    For each vertical line in the control:              {                  hsl_start.H = (double)i/(Width - 4);    //    Calculate Hue at this line (Saturation and Luminance are constant)                  hsl_end.H = hsl_start.H;                                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' 1' Height - 4)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                   g.FillRectangle(br'new Rectangle(i + 2' 2' 1' Height - 4));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )                //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Red at this line (Green and Blue are constant)                  int red = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Red at this line (Green and Blue are constant)                  int red = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Red at this line (Green and Blue are constant)                  int red = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Red at this line (Green and Blue are constant)                  int red = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Red at this line (Green and Blue are constant)                  int red = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Red at this line (Green and Blue are constant)                  int red = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Red at this line (Green and Blue are constant)                  int red = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Red at this line (Green and Blue are constant)                  int red = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Red at this line (Green and Blue are constant)                  int red = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Red at this line (Green and Blue are constant)                  int red = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Red at this line (Green and Blue are constant)                  int red = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(red' green' 0)' Color.FromArgb(red' green' 255)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 4; i++ )    //    For each horizontal line in the control:              {                  //    Calculate Green at this line (Red and Blue are constant)                  int green = Round(255 - (255 * (double)i/(Height - 4)));                    LinearGradientBrush br = new LinearGradientBrush(new Rectangle(2'2' Width - 4' 1)' Color.FromArgb(0' green' blue)' Color.FromArgb(255' green' blue)' 0' false);                   g.FillRectangle(br'new Rectangle(2'i + 2' Width - 4' 1));               }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Round,The following statement contains a magic number: int temp = (int)(val * 100);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Round,The following statement contains a magic number: if ( (temp % 100) >= 50 )                  ret_val += 1;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Round,The following statement contains a magic number: if ( (temp % 100) >= 50 )                  ret_val += 1;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,SetStartColor,The following statement contains a magic number: if (enableAlpha)              {                  m_txt_A.Visible = true;                  m_lbl_A.Visible = true;                  m_txt_Hex.MaxLength = 8;              }              else              {                  starting_color = MakeOpaque(starting_color);                  m_txt_A.Visible = false;                  m_lbl_A.Visible = false;                  m_txt_Hex.MaxLength = 6;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,SetStartColor,The following statement contains a magic number: if (enableAlpha)              {                  m_txt_A.Visible = true;                  m_lbl_A.Visible = true;                  m_txt_Hex.MaxLength = 8;              }              else              {                  starting_color = MakeOpaque(starting_color);                  m_txt_A.Visible = false;                  m_lbl_A.Visible = false;                  m_txt_Hex.MaxLength = 6;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,SetStartColor,The following statement contains a magic number: m_txt_Hue.Text = Round(m_hsl.H * 360).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,SetStartColor,The following statement contains a magic number: m_txt_Sat.Text = Round(m_hsl.S * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,SetStartColor,The following statement contains a magic number: m_txt_Bright.Text = Round(m_hsl.L * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,SetStartColor,The following statement contains a magic number: m_txt_Cyan.Text = Round(m_cmyk.C * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,SetStartColor,The following statement contains a magic number: m_txt_Magenta.Text = Round(m_cmyk.M * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,SetStartColor,The following statement contains a magic number: m_txt_Yellow.Text = Round(m_cmyk.Y * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,SetStartColor,The following statement contains a magic number: m_txt_K.Text = Round(m_cmyk.K * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_pbx_BlankBox.Location = new System.Drawing.Point(316' 11);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_pbx_BlankBox.Location = new System.Drawing.Point(316' 11);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_pbx_BlankBox.Size = new System.Drawing.Size(62' 70);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_pbx_BlankBox.Size = new System.Drawing.Size(62' 70);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_pbx_BlankBox.TabIndex = 3;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_cmd_OK.Location = new System.Drawing.Point(412' 12);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_cmd_OK.Location = new System.Drawing.Point(412' 12);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_cmd_OK.Size = new System.Drawing.Size(72' 23);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_cmd_OK.Size = new System.Drawing.Size(72' 23);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_cmd_OK.TabIndex = 4;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_cmd_Cancel.Location = new System.Drawing.Point(412' 41);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_cmd_Cancel.Location = new System.Drawing.Point(412' 41);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_cmd_Cancel.Size = new System.Drawing.Size(72' 23);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_cmd_Cancel.Size = new System.Drawing.Size(72' 23);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_cmd_Cancel.TabIndex = 5;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Hue.Location = new System.Drawing.Point(352' 101);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Hue.Location = new System.Drawing.Point(352' 101);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Hue.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Hue.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Hue.TabIndex = 6;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Sat.Location = new System.Drawing.Point(352' 126);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Sat.Location = new System.Drawing.Point(352' 126);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Sat.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Sat.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Sat.TabIndex = 7;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Bright.Location = new System.Drawing.Point(352' 151);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Bright.Location = new System.Drawing.Point(352' 151);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Bright.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Bright.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Bright.TabIndex = 8;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Red.Location = new System.Drawing.Point(352' 190);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Red.Location = new System.Drawing.Point(352' 190);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Red.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Red.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Red.TabIndex = 9;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Green.Location = new System.Drawing.Point(352' 215);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Green.Location = new System.Drawing.Point(352' 215);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Green.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Green.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Green.TabIndex = 10;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Blue.Location = new System.Drawing.Point(352' 240);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Blue.Location = new System.Drawing.Point(352' 240);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Blue.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Blue.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Blue.TabIndex = 11;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Cyan.Location = new System.Drawing.Point(447' 101);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Cyan.Location = new System.Drawing.Point(447' 101);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Cyan.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Cyan.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Cyan.TabIndex = 15;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Magenta.Location = new System.Drawing.Point(447' 126);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Magenta.Location = new System.Drawing.Point(447' 126);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Magenta.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Magenta.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Magenta.TabIndex = 16;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Yellow.Location = new System.Drawing.Point(447' 151);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Yellow.Location = new System.Drawing.Point(447' 151);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Yellow.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Yellow.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Yellow.TabIndex = 17;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_K.Location = new System.Drawing.Point(447' 176);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_K.Location = new System.Drawing.Point(447' 176);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_K.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_K.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_K.TabIndex = 18;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Hex.Location = new System.Drawing.Point(416' 239);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Hex.Location = new System.Drawing.Point(416' 239);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Hex.MaxLength = 8;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Hex.Size = new System.Drawing.Size(66' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Hex.Size = new System.Drawing.Size(66' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_Hex.TabIndex = 19;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Hue.Location = new System.Drawing.Point(316' 101);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Hue.Location = new System.Drawing.Point(316' 101);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Hue.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Hue.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Hue.TabIndex = 20;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Sat.Location = new System.Drawing.Point(316' 126);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Sat.Location = new System.Drawing.Point(316' 126);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Sat.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Sat.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Sat.TabIndex = 21;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Bright.Location = new System.Drawing.Point(316' 151);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Bright.Location = new System.Drawing.Point(316' 151);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Bright.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Bright.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Bright.TabIndex = 22;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Red.Location = new System.Drawing.Point(316' 190);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Red.Location = new System.Drawing.Point(316' 190);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Red.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Red.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Red.TabIndex = 23;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Green.Location = new System.Drawing.Point(316' 215);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Green.Location = new System.Drawing.Point(316' 215);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Green.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Green.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Green.TabIndex = 24;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Blue.Location = new System.Drawing.Point(316' 240);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Blue.Location = new System.Drawing.Point(316' 240);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Blue.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Blue.Size = new System.Drawing.Size(38' 24);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_rbtn_Blue.TabIndex = 25;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_HexPound.Location = new System.Drawing.Point(402' 243);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_HexPound.Location = new System.Drawing.Point(402' 243);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_HexPound.Size = new System.Drawing.Size(16' 14);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_HexPound.Size = new System.Drawing.Size(16' 14);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_HexPound.TabIndex = 27;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Cyan.Location = new System.Drawing.Point(423' 105);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Cyan.Location = new System.Drawing.Point(423' 105);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Cyan.Size = new System.Drawing.Size(24' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Cyan.Size = new System.Drawing.Size(24' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Cyan.TabIndex = 31;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Magenta.Location = new System.Drawing.Point(423' 131);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Magenta.Location = new System.Drawing.Point(423' 131);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Magenta.Size = new System.Drawing.Size(24' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Magenta.Size = new System.Drawing.Size(24' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Magenta.TabIndex = 32;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Yellow.Location = new System.Drawing.Point(423' 156);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Yellow.Location = new System.Drawing.Point(423' 156);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Yellow.Size = new System.Drawing.Size(24' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Yellow.Size = new System.Drawing.Size(24' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Yellow.TabIndex = 33;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_K.Location = new System.Drawing.Point(423' 181);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_K.Location = new System.Drawing.Point(423' 181);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_K.Size = new System.Drawing.Size(24' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_K.Size = new System.Drawing.Size(24' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_K.TabIndex = 34;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Primary_Color.Location = new System.Drawing.Point(317' 12);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Primary_Color.Location = new System.Drawing.Point(317' 12);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Primary_Color.Size = new System.Drawing.Size(60' 34);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Primary_Color.Size = new System.Drawing.Size(60' 34);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Primary_Color.TabIndex = 36;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Secondary_Color.Location = new System.Drawing.Point(317' 46);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Secondary_Color.Location = new System.Drawing.Point(317' 46);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Secondary_Color.Size = new System.Drawing.Size(60' 34);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Secondary_Color.Size = new System.Drawing.Size(60' 34);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Secondary_Color.TabIndex = 37;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Hue_Symbol.Location = new System.Drawing.Point(389' 102);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Hue_Symbol.Location = new System.Drawing.Point(389' 102);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Hue_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Hue_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Hue_Symbol.TabIndex = 40;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Saturation_Symbol.Location = new System.Drawing.Point(389' 130);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Saturation_Symbol.Location = new System.Drawing.Point(389' 130);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Saturation_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Saturation_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Saturation_Symbol.TabIndex = 41;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Bright_Symbol.Location = new System.Drawing.Point(389' 155);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Bright_Symbol.Location = new System.Drawing.Point(389' 155);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Bright_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Bright_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Bright_Symbol.TabIndex = 42;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Cyan_Symbol.Location = new System.Drawing.Point(483' 103);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Cyan_Symbol.Location = new System.Drawing.Point(483' 103);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Cyan_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Cyan_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Cyan_Symbol.TabIndex = 43;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Magenta_Symbol.Location = new System.Drawing.Point(483' 130);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Magenta_Symbol.Location = new System.Drawing.Point(483' 130);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Magenta_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Magenta_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Magenta_Symbol.TabIndex = 44;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Yellow_Symbol.Location = new System.Drawing.Point(483' 155);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Yellow_Symbol.Location = new System.Drawing.Point(483' 155);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Yellow_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Yellow_Symbol.Size = new System.Drawing.Size(16' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_Yellow_Symbol.TabIndex = 45;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_A.Location = new System.Drawing.Point(447' 208);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_A.Location = new System.Drawing.Point(447' 208);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_A.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_A.Size = new System.Drawing.Size(35' 21);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_txt_A.TabIndex = 46;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_A.Location = new System.Drawing.Point(404' 213);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_A.Location = new System.Drawing.Point(404' 213);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_A.Size = new System.Drawing.Size(43' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_A.Size = new System.Drawing.Size(43' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_lbl_A.TabIndex = 47;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_ctrl_BigBox.Location = new System.Drawing.Point(10' 11);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_ctrl_BigBox.Location = new System.Drawing.Point(10' 11);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_ctrl_BigBox.RGB = System.Drawing.Color.FromArgb(((int)(((byte)(255))))' ((int)(((byte)(0))))' ((int)(((byte)(0)))));
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_ctrl_BigBox.Size = new System.Drawing.Size(260' 260);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_ctrl_BigBox.Size = new System.Drawing.Size(260' 260);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_ctrl_BigBox.TabIndex = 39;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_ctrl_ThinBox.Location = new System.Drawing.Point(271' 9);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_ctrl_ThinBox.Location = new System.Drawing.Point(271' 9);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_ctrl_ThinBox.Size = new System.Drawing.Size(40' 264);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_ctrl_ThinBox.Size = new System.Drawing.Size(40' 264);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.m_ctrl_ThinBox.TabIndex = 38;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(513' 280);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(513' 280);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_BigBox_ColorChanged,The following statement contains a magic number: m_txt_Hue.Text =        Round(m_hsl.H * 360).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_BigBox_ColorChanged,The following statement contains a magic number: m_txt_Sat.Text =        Round(m_hsl.S * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_BigBox_ColorChanged,The following statement contains a magic number: m_txt_Bright.Text =     Round(m_hsl.L * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_BigBox_ColorChanged,The following statement contains a magic number: m_txt_Cyan.Text =       Round(m_cmyk.C * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_BigBox_ColorChanged,The following statement contains a magic number: m_txt_Magenta.Text =    Round(m_cmyk.M * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_BigBox_ColorChanged,The following statement contains a magic number: m_txt_Yellow.Text =     Round(m_cmyk.Y * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_BigBox_ColorChanged,The following statement contains a magic number: m_txt_K.Text =          Round(m_cmyk.K * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_ThinBox_ColorChanged,The following statement contains a magic number: m_txt_Hue.Text =        Round(m_hsl.H * 360).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_ThinBox_ColorChanged,The following statement contains a magic number: m_txt_Sat.Text =        Round(m_hsl.S * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_ThinBox_ColorChanged,The following statement contains a magic number: m_txt_Bright.Text =     Round(m_hsl.L * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_ThinBox_ColorChanged,The following statement contains a magic number: m_txt_Cyan.Text =       Round(m_cmyk.C * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_ThinBox_ColorChanged,The following statement contains a magic number: m_txt_Magenta.Text =    Round(m_cmyk.M * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_ThinBox_ColorChanged,The following statement contains a magic number: m_txt_Yellow.Text =     Round(m_cmyk.Y * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_ctrl_ThinBox_ColorChanged,The following statement contains a magic number: m_txt_K.Text =          Round(m_cmyk.K * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Primary_Color_Click,The following statement contains a magic number: m_txt_Hue.Text =        Round(m_hsl.H * 360).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Primary_Color_Click,The following statement contains a magic number: m_txt_Sat.Text =        Round(m_hsl.S * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Primary_Color_Click,The following statement contains a magic number: m_txt_Bright.Text =     Round(m_hsl.L * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Primary_Color_Click,The following statement contains a magic number: m_txt_Cyan.Text =       Round(m_cmyk.C * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Primary_Color_Click,The following statement contains a magic number: m_txt_Magenta.Text =    Round(m_cmyk.M * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Primary_Color_Click,The following statement contains a magic number: m_txt_Yellow.Text =     Round(m_cmyk.Y * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Primary_Color_Click,The following statement contains a magic number: m_txt_K.Text =          Round(m_cmyk.K * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Secondary_Color_Click,The following statement contains a magic number: m_txt_Hue.Text =        Round(m_hsl.H * 360).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Secondary_Color_Click,The following statement contains a magic number: m_txt_Sat.Text =        Round(m_hsl.S * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Secondary_Color_Click,The following statement contains a magic number: m_txt_Bright.Text =     Round(m_hsl.L * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Secondary_Color_Click,The following statement contains a magic number: m_txt_Cyan.Text =       Round(m_cmyk.C * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Secondary_Color_Click,The following statement contains a magic number: m_txt_Magenta.Text =    Round(m_cmyk.M * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Secondary_Color_Click,The following statement contains a magic number: m_txt_Yellow.Text =     Round(m_cmyk.Y * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_lbl_Secondary_Color_Click,The following statement contains a magic number: m_txt_K.Text =          Round(m_cmyk.K * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Hue_Leave,The following statement contains a magic number: if ( hue < 0 )              {                  m_txt_Hue.Text = "0";                  m_hsl.H = 0.0;              }              else if ( hue > 360 )              {                  m_txt_Hue.Text = "360";                  m_hsl.H = 1.0;              }              else              {                  m_hsl.H = (double)hue/360;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Hue_Leave,The following statement contains a magic number: if ( hue < 0 )              {                  m_txt_Hue.Text = "0";                  m_hsl.H = 0.0;              }              else if ( hue > 360 )              {                  m_txt_Hue.Text = "360";                  m_hsl.H = 1.0;              }              else              {                  m_hsl.H = (double)hue/360;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Sat_Leave,The following statement contains a magic number: if ( sat < 0 )              {                  m_txt_Sat.Text = "0";                  m_hsl.S = 0.0;              }              else if ( sat > 100 )              {                  m_txt_Sat.Text = "100";                  m_hsl.S = 1.0;              }              else              {                  m_hsl.S = (double)sat/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Sat_Leave,The following statement contains a magic number: if ( sat < 0 )              {                  m_txt_Sat.Text = "0";                  m_hsl.S = 0.0;              }              else if ( sat > 100 )              {                  m_txt_Sat.Text = "100";                  m_hsl.S = 1.0;              }              else              {                  m_hsl.S = (double)sat/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Bright_Leave,The following statement contains a magic number: if ( lum < 0 )              {                  m_txt_Bright.Text = "0";                  m_hsl.L = 0.0;              }              else if ( lum > 100 )              {                  m_txt_Bright.Text = "100";                  m_hsl.L = 1.0;              }              else              {                  m_hsl.L = (double)lum/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Bright_Leave,The following statement contains a magic number: if ( lum < 0 )              {                  m_txt_Bright.Text = "0";                  m_hsl.L = 0.0;              }              else if ( lum > 100 )              {                  m_txt_Bright.Text = "100";                  m_hsl.L = 1.0;              }              else              {                  m_hsl.L = (double)lum/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Red_Leave,The following statement contains a magic number: if ( red < 0 )              {                  m_txt_Red.Text = "0";                  m_rgb = Color.FromArgb(m_rgb.A' 0' m_rgb.G' m_rgb.B);              }              else if ( red > 255 )              {                  m_txt_Red.Text = "255";                  m_rgb = Color.FromArgb(m_rgb.A' 255' m_rgb.G' m_rgb.B);              }              else              {                  m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' m_rgb.B);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Red_Leave,The following statement contains a magic number: if ( red < 0 )              {                  m_txt_Red.Text = "0";                  m_rgb = Color.FromArgb(m_rgb.A' 0' m_rgb.G' m_rgb.B);              }              else if ( red > 255 )              {                  m_txt_Red.Text = "255";                  m_rgb = Color.FromArgb(m_rgb.A' 255' m_rgb.G' m_rgb.B);              }              else              {                  m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' m_rgb.B);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Green_Leave,The following statement contains a magic number: if ( green < 0 )              {                  m_txt_Green.Text = "0";                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 0' m_rgb.B);              }              else if ( green > 255 )              {                  m_txt_Green.Text = "255";                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255' m_rgb.B);              }              else              {                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' m_rgb.B);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Green_Leave,The following statement contains a magic number: if ( green < 0 )              {                  m_txt_Green.Text = "0";                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 0' m_rgb.B);              }              else if ( green > 255 )              {                  m_txt_Green.Text = "255";                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255' m_rgb.B);              }              else              {                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' m_rgb.B);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Blue_Leave,The following statement contains a magic number: if ( blue < 0 )              {                  m_txt_Blue.Text = "0";                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 0);              }              else if ( blue > 255 )              {                  m_txt_Blue.Text = "255";                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255);              }              else              {                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' blue);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Blue_Leave,The following statement contains a magic number: if ( blue < 0 )              {                  m_txt_Blue.Text = "0";                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 0);              }              else if ( blue > 255 )              {                  m_txt_Blue.Text = "255";                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255);              }              else              {                  m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' blue);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_A_Leave,The following statement contains a magic number: if ( alpha < 0 )              {                  m_txt_Red.Text = "0";                  m_rgb = Color.FromArgb(0' m_rgb.R' m_rgb.G' m_rgb.B);              }              else if ( alpha > 255 )              {                  m_txt_Red.Text = "255";                  m_rgb = Color.FromArgb(255' m_rgb.R' m_rgb.G' m_rgb.B);              }              else              {                  m_rgb = Color.FromArgb(alpha' m_rgb.R' m_rgb.G' m_rgb.B);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_A_Leave,The following statement contains a magic number: if ( alpha < 0 )              {                  m_txt_Red.Text = "0";                  m_rgb = Color.FromArgb(0' m_rgb.R' m_rgb.G' m_rgb.B);              }              else if ( alpha > 255 )              {                  m_txt_Red.Text = "255";                  m_rgb = Color.FromArgb(255' m_rgb.R' m_rgb.G' m_rgb.B);              }              else              {                  m_rgb = Color.FromArgb(alpha' m_rgb.R' m_rgb.G' m_rgb.B);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Cyan_Leave,The following statement contains a magic number: if ( cyan < 0 )              {                  m_cmyk.C = 0.0;              }              else if ( cyan > 100 )              {                  m_cmyk.C = 1.0;              }              else              {                  m_cmyk.C = (double)cyan/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Cyan_Leave,The following statement contains a magic number: if ( cyan < 0 )              {                  m_cmyk.C = 0.0;              }              else if ( cyan > 100 )              {                  m_cmyk.C = 1.0;              }              else              {                  m_cmyk.C = (double)cyan/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Magenta_Leave,The following statement contains a magic number: if ( magenta < 0 )              {                  m_txt_Magenta.Text = "0";                  m_cmyk.M = 0.0;              }              else if ( magenta > 100 )              {                  m_txt_Magenta.Text = "100";                  m_cmyk.M = 1.0;              }              else              {                  m_cmyk.M = (double)magenta/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Magenta_Leave,The following statement contains a magic number: if ( magenta < 0 )              {                  m_txt_Magenta.Text = "0";                  m_cmyk.M = 0.0;              }              else if ( magenta > 100 )              {                  m_txt_Magenta.Text = "100";                  m_cmyk.M = 1.0;              }              else              {                  m_cmyk.M = (double)magenta/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Yellow_Leave,The following statement contains a magic number: if ( yellow < 0 )              {                  m_txt_Yellow.Text = "0";                  m_cmyk.Y = 0.0;              }              else if ( yellow > 100 )              {                  m_txt_Yellow.Text = "100";                  m_cmyk.Y = 1.0;              }              else              {                  m_cmyk.Y = (double)yellow/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_Yellow_Leave,The following statement contains a magic number: if ( yellow < 0 )              {                  m_txt_Yellow.Text = "0";                  m_cmyk.Y = 0.0;              }              else if ( yellow > 100 )              {                  m_txt_Yellow.Text = "100";                  m_cmyk.Y = 1.0;              }              else              {                  m_cmyk.Y = (double)yellow/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_K_Leave,The following statement contains a magic number: if ( key < 0 )              {                  m_txt_K.Text = "0";                  m_cmyk.K = 0.0;              }              else if ( key > 100 )              {                  m_txt_K.Text = "100";                  m_cmyk.K = 1.0;              }              else              {                  m_cmyk.K = (double)key/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,m_txt_K_Leave,The following statement contains a magic number: if ( key < 0 )              {                  m_txt_K.Text = "0";                  m_cmyk.K = 0.0;              }              else if ( key > 100 )              {                  m_txt_K.Text = "100";                  m_cmyk.K = 1.0;              }              else              {                  m_cmyk.K = (double)key/100;              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,Round,The following statement contains a magic number: int temp = (int)(val * 100);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,Round,The following statement contains a magic number: if ( (temp % 100) >= 50 )                  ret_val += 1;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,Round,The following statement contains a magic number: if ( (temp % 100) >= 50 )                  ret_val += 1;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,WriteHexData,The following statement contains a magic number: string alpha = Convert.ToString(rgb.A' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,WriteHexData,The following statement contains a magic number: if ( alpha.Length < 2 ) alpha = "0" + alpha;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,WriteHexData,The following statement contains a magic number: string red = Convert.ToString(rgb.R' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,WriteHexData,The following statement contains a magic number: if ( red.Length < 2 ) red = "0" + red;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,WriteHexData,The following statement contains a magic number: string green = Convert.ToString(rgb.G' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,WriteHexData,The following statement contains a magic number: if ( green.Length < 2 ) green = "0" + green;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,WriteHexData,The following statement contains a magic number: string blue = Convert.ToString(rgb.B' 16);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,WriteHexData,The following statement contains a magic number: if ( blue.Length < 2 ) blue = "0" + blue;
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: int length = (m_enableAlpha ? 8 : 6);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: int length = (m_enableAlpha ? 8 : 6);
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,ParseHexData,The following statement contains a magic number: if (m_enableAlpha)              {                  a_text = hex_data.Substring(0' 2);                  r_text = hex_data.Substring(2' 2);                  g_text = hex_data.Substring(4' 2);                  b_text = hex_data.Substring(6' 2);                    a = int.Parse(a_text' System.Globalization.NumberStyles.HexNumber);                  r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(a' r' g' b);              }              else              {                  r_text = hex_data.Substring(0' 2);                  g_text = hex_data.Substring(2' 2);                  b_text = hex_data.Substring(4' 2);                    r = int.Parse(r_text' System.Globalization.NumberStyles.HexNumber);                  g = int.Parse(g_text' System.Globalization.NumberStyles.HexNumber);                  b = int.Parse(b_text' System.Globalization.NumberStyles.HexNumber);                    return Color.FromArgb(r' g' b);              }
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,UpdateTextBoxes,The following statement contains a magic number: m_txt_Hue.Text =        Round(m_hsl.H * 360).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,UpdateTextBoxes,The following statement contains a magic number: m_txt_Sat.Text =        Round(m_hsl.S * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,UpdateTextBoxes,The following statement contains a magic number: m_txt_Bright.Text =     Round(m_hsl.L * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,UpdateTextBoxes,The following statement contains a magic number: m_txt_Cyan.Text =       Round(m_cmyk.C * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,UpdateTextBoxes,The following statement contains a magic number: m_txt_Magenta.Text =    Round(m_cmyk.M * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,UpdateTextBoxes,The following statement contains a magic number: m_txt_Yellow.Text =     Round(m_cmyk.Y * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,UpdateTextBoxes,The following statement contains a magic number: m_txt_K.Text =          Round(m_cmyk.K * 100).ToString();
Magic Number,Sce.Atf.Controls.ColorEditing,ColorPicker,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorPicker.cs,MakeOpaque,The following statement contains a magic number: return Color.FromArgb(255' color.R' color.G' color.B);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ctrl1DColorBar_MouseDown,The following statement contains a magic number: y -= 4;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ctrl1DColorBar_MouseDown,The following statement contains a magic number: if ( y > Height - 9 ) y = Height - 9;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ctrl1DColorBar_MouseDown,The following statement contains a magic number: if ( y > Height - 9 ) y = Height - 9;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ctrl1DColorBar_MouseMove,The following statement contains a magic number: y -= 4;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ctrl1DColorBar_MouseMove,The following statement contains a magic number: if ( y > Height - 9 ) y = Height - 9;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ctrl1DColorBar_MouseMove,The following statement contains a magic number: if ( y > Height - 9 ) y = Height - 9;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ctrl1DColorBar_MouseUp,The following statement contains a magic number: y -= 4;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ctrl1DColorBar_MouseUp,The following statement contains a magic number: if ( y > Height - 9 ) y = Height - 9;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ctrl1DColorBar_MouseUp,The following statement contains a magic number: if ( y > Height - 9 ) y = Height - 9;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ClearSlider,The following statement contains a magic number: g.FillRectangle(brush' 0' 0' 8' Height);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ClearSlider,The following statement contains a magic number: g.FillRectangle(brush' Width - 8' 0' 8' Height);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ClearSlider,The following statement contains a magic number: g.FillRectangle(brush' Width - 8' 0' 8' Height);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: if ( position > Height - 9 ) position = Height - 9;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: if ( position > Height - 9 ) position = Height - 9;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: Pen pencil = new Pen(Color.FromArgb(116'114'106));
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: Pen pencil = new Pen(Color.FromArgb(116'114'106));
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: Pen pencil = new Pen(Color.FromArgb(116'114'106));
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: Point[] arrow = new Point[7];
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[1] = new Point(3'position);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[2] = new Point(7'position + 4);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[2] = new Point(7'position + 4);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[2] = new Point(7'position + 4);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[3] = new Point(3'position + 8);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[3] = new Point(3'position + 8);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[3] = new Point(3'position + 8);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[4] = new Point(1'position + 8);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[4] = new Point(1'position + 8);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[5] = new Point(0'position + 7);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[5] = new Point(0'position + 7);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[6] = new Point(0'position + 1);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[0] = new Point(Width - 2'position);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[1] = new Point(Width - 4'position);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[2] = new Point(Width - 8'position + 4);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[2] = new Point(Width - 8'position + 4);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[2] = new Point(Width - 8'position + 4);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[3] = new Point(Width - 4'position + 8);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[3] = new Point(Width - 4'position + 8);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[3] = new Point(Width - 4'position + 8);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[4] = new Point(Width - 2'position + 8);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[4] = new Point(Width - 2'position + 8);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[4] = new Point(Width - 2'position + 8);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[5] = new Point(Width - 1'position + 7);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[5] = new Point(Width - 1'position + 7);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawSlider,The following statement contains a magic number: arrow[6] = new Point(Width - 1'position + 1);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: pencil = new Pen(Color.FromArgb(172'168'153));
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: pencil = new Pen(Color.FromArgb(172'168'153));
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: pencil = new Pen(Color.FromArgb(172'168'153));
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 10' 2' 9' 2);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 10' 2' 9' 2);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 10' 2' 9' 2);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 10' 2' 9' 2);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' 9' 2' 9' Height - 4);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' 9' 2' 9' Height - 4);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' 9' 2' 9' Height - 4);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' 9' 2' 9' Height - 4);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 9' 2' Width - 9'Height - 3);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 9' 2' Width - 9'Height - 3);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 9' 2' Width - 9'Height - 3);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 9' 2' Width - 9'Height - 3);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 9'Height - 3' 9'Height - 3);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 9'Height - 3' 9'Height - 3);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 9'Height - 3' 9'Height - 3);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawLine(pencil' Width - 9'Height - 3' 9'Height - 3);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawRectangle(pencil' 10' 3' Width - 20' Height - 7);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawRectangle(pencil' 10' 3' Width - 20' Height - 7);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawRectangle(pencil' 10' 3' Width - 20' Height - 7);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawBorder,The following statement contains a magic number: g.DrawRectangle(pencil' 10' 3' Width - 20' Height - 7);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ )    //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.H = 1.0 - (double)i/(Height - 8);            //    H (hue) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ )    //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.H = 1.0 - (double)i/(Height - 8);            //    H (hue) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ )    //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.H = 1.0 - (double)i/(Height - 8);            //    H (hue) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ )    //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.H = 1.0 - (double)i/(Height - 8);            //    H (hue) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ )    //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.H = 1.0 - (double)i/(Height - 8);            //    H (hue) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Hue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ )    //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.H = 1.0 - (double)i/(Height - 8);            //    H (hue) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.S = 1.0 - (double)i/(Height - 8);            //    S (Saturation) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.S = 1.0 - (double)i/(Height - 8);            //    S (Saturation) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.S = 1.0 - (double)i/(Height - 8);            //    S (Saturation) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.S = 1.0 - (double)i/(Height - 8);            //    S (Saturation) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.S = 1.0 - (double)i/(Height - 8);            //    S (Saturation) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Saturation,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.S = 1.0 - (double)i/(Height - 8);            //    S (Saturation) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.L = 1.0 - (double)i/(Height - 8);            //    L (Luminance) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.L = 1.0 - (double)i/(Height - 8);            //    L (Luminance) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.L = 1.0 - (double)i/(Height - 8);            //    L (Luminance) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.L = 1.0 - (double)i/(Height - 8);            //    L (Luminance) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.L = 1.0 - (double)i/(Height - 8);            //    L (Luminance) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Luminance,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  _hsl.L = 1.0 - (double)i/(Height - 8);            //    L (Luminance) is based on the current vertical position                  Pen pen = new Pen(AdobeColors.HSL_to_RGB(_hsl));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);    //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int red = 255 - Round(255 * (double)i/(Height - 8));       //    red is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(red' m_rgb.G' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);             //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int red = 255 - Round(255 * (double)i/(Height - 8));       //    red is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(red' m_rgb.G' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);             //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int red = 255 - Round(255 * (double)i/(Height - 8));       //    red is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(red' m_rgb.G' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);             //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int red = 255 - Round(255 * (double)i/(Height - 8));       //    red is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(red' m_rgb.G' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);             //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int red = 255 - Round(255 * (double)i/(Height - 8));       //    red is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(red' m_rgb.G' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);             //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int red = 255 - Round(255 * (double)i/(Height - 8));       //    red is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(red' m_rgb.G' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);             //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int red = 255 - Round(255 * (double)i/(Height - 8));       //    red is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(red' m_rgb.G' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);             //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Red,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int red = 255 - Round(255 * (double)i/(Height - 8));       //    red is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(red' m_rgb.G' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);             //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int green = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' green' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int green = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' green' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int green = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' green' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int green = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' green' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int green = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' green' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int green = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' green' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int green = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' green' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Green,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int green = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' green' m_rgb.B));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int blue = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' m_rgb.G' blue));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int blue = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' m_rgb.G' blue));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int blue = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' m_rgb.G' blue));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int blue = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' m_rgb.G' blue));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int blue = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' m_rgb.G' blue));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int blue = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' m_rgb.G' blue));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int blue = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' m_rgb.G' blue));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Draw_Style_Blue,The following statement contains a magic number: for ( int i = 0; i < Height - 8; i++ ) //    i represents the current line of pixels we want to draw horizontally              {                  int blue = 255 - Round(255 * (double)i/(Height - 8));       //    green is based on the current vertical position                  Pen pen = new Pen(Color.FromArgb(m_rgb.R' m_rgb.G' blue));  //    Get the Color for this line                    g.DrawLine(pen' 11' i + 4' Width - 11' i + 4);            //    Draw the line and loop back for next line              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following statement contains a magic number: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Round,The following statement contains a magic number: int temp = (int)(val * 100);
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Round,The following statement contains a magic number: if ( (temp % 100) >= 50 )                  ret_val += 1;
Magic Number,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Round,The following statement contains a magic number: if ( (temp % 100) >= 50 )                  ret_val += 1;
Magic Number,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,ConsoleTextBox,The following statement contains a magic number: m_suggestionListBox = new SuggestionListBox              {                  InsertText = InsertTextAtCaret'                  ItemHeight = 11'                  RemoveText = RemoveTextBeforeCaret'                  Suggest = Suggest              };
Magic Number,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,Suggest,The following statement contains a magic number: if (IsCaretAtWritablePosition)              {                  string text = GetCurrentLine();                  int offset = CaretOffsetFromCurrentLine;                    int charIndex;                  string partial;                  IEnumerable<string> suggestions;                    int triggerIndex = (offset > 0) ? text.LastIndexOfAny(s_triggers' offset - 1) : -1;                  if (triggerIndex > -1)                  {                      // Find partially completed string to right of trigger                      charIndex = triggerIndex;                      partial = text.Substring(triggerIndex + 1' offset - triggerIndex - 1);                        // Find string to left of trigger                      var startIndex = text.LastIndexOfAny(s_delimiters' triggerIndex) + 1;                      var value = text.Substring(startIndex' triggerIndex - startIndex);                        if (String.IsNullOrWhiteSpace(value))                      {                          m_suggestionListBox.Hide();                          return false;                      }                        var trigger = text[triggerIndex].ToString();                      var quoteType = String.Empty;                      if (trigger == "[")                          quoteType = partial.StartsWith("'''")                              ? "'''"                              : partial.StartsWith("\"\"\"")                                  ? "\"\"\""                                  : partial.StartsWith("'")                                      ? "'"                                      : "\"";                        suggestions = m_suggestionHandler(value' trigger)                          .Select(suggestion => String.Format("{0}{1}{0}"' quoteType' StringUtil.EscapeQuotes(suggestion)));                  }                  else                  {                      // Find partially completed string to right of ' '                      charIndex = (offset > 0) ? text.LastIndexOf(' '' offset - 1) : -1;                      partial = text.Substring(charIndex + 1' offset - charIndex - 1);                        suggestions = m_suggestionHandler(String.Empty' String.Empty);                  }                    // Only add unique suggestions                  var uniqueSuggestions = suggestions                      .Where(suggestion => suggestion.StartsWith(partial' StringComparison.InvariantCultureIgnoreCase))                      .Distinct();                    m_suggestionListBox.SetSuggestions(partial' uniqueSuggestions);                    // Show suggestions (if any)                  var count = m_suggestionListBox.Items.Count;                  if (count > 0)                  {                      int line = GetLineFromCharIndex(CaretIndex);                      int index = GetFirstCharIndexFromLine(line) + m_prompt.Length + charIndex;                      Point pt = GetPositionFromCharIndex(index);                        int itemCount = Math.Min(count' 8);                      int itemHeight = m_suggestionListBox.ItemHeight;                        int bottom = Height - itemHeight;                      if (pt.Y < bottom - 3)                      {                          int height = Math.Max(pt.Y - 8' bottom - pt.Y);                          height = Math.Min(height' itemHeight * itemCount + 4); // Limit to 8 entries                            int y;                          if (pt.Y < height)                              y = pt.Y + FontHeight;                          else                              y = pt.Y - height;                            // Set width based on longest item                          int maxWidth = 0;                          foreach (var item in m_suggestionListBox.Items)                          {                              int width = TextRenderer.MeasureText(item.ToString()' m_suggestionListBox.Font).Width;                              if (width > maxWidth)                                  maxWidth = width;                          }                            m_suggestionListBox.Bounds = new Rectangle(pt.X + 3' y' maxWidth + 25' height);                          m_suggestionListBox.SelectedIndex = 0;                            m_suggestionListBox.Show();                          m_suggestionListBox.Focus();                      }                        return true;                  }              }
Magic Number,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,Suggest,The following statement contains a magic number: if (IsCaretAtWritablePosition)              {                  string text = GetCurrentLine();                  int offset = CaretOffsetFromCurrentLine;                    int charIndex;                  string partial;                  IEnumerable<string> suggestions;                    int triggerIndex = (offset > 0) ? text.LastIndexOfAny(s_triggers' offset - 1) : -1;                  if (triggerIndex > -1)                  {                      // Find partially completed string to right of trigger                      charIndex = triggerIndex;                      partial = text.Substring(triggerIndex + 1' offset - triggerIndex - 1);                        // Find string to left of trigger                      var startIndex = text.LastIndexOfAny(s_delimiters' triggerIndex) + 1;                      var value = text.Substring(startIndex' triggerIndex - startIndex);                        if (String.IsNullOrWhiteSpace(value))                      {                          m_suggestionListBox.Hide();                          return false;                      }                        var trigger = text[triggerIndex].ToString();                      var quoteType = String.Empty;                      if (trigger == "[")                          quoteType = partial.StartsWith("'''")                              ? "'''"                              : partial.StartsWith("\"\"\"")                                  ? "\"\"\""                                  : partial.StartsWith("'")                                      ? "'"                                      : "\"";                        suggestions = m_suggestionHandler(value' trigger)                          .Select(suggestion => String.Format("{0}{1}{0}"' quoteType' StringUtil.EscapeQuotes(suggestion)));                  }                  else                  {                      // Find partially completed string to right of ' '                      charIndex = (offset > 0) ? text.LastIndexOf(' '' offset - 1) : -1;                      partial = text.Substring(charIndex + 1' offset - charIndex - 1);                        suggestions = m_suggestionHandler(String.Empty' String.Empty);                  }                    // Only add unique suggestions                  var uniqueSuggestions = suggestions                      .Where(suggestion => suggestion.StartsWith(partial' StringComparison.InvariantCultureIgnoreCase))                      .Distinct();                    m_suggestionListBox.SetSuggestions(partial' uniqueSuggestions);                    // Show suggestions (if any)                  var count = m_suggestionListBox.Items.Count;                  if (count > 0)                  {                      int line = GetLineFromCharIndex(CaretIndex);                      int index = GetFirstCharIndexFromLine(line) + m_prompt.Length + charIndex;                      Point pt = GetPositionFromCharIndex(index);                        int itemCount = Math.Min(count' 8);                      int itemHeight = m_suggestionListBox.ItemHeight;                        int bottom = Height - itemHeight;                      if (pt.Y < bottom - 3)                      {                          int height = Math.Max(pt.Y - 8' bottom - pt.Y);                          height = Math.Min(height' itemHeight * itemCount + 4); // Limit to 8 entries                            int y;                          if (pt.Y < height)                              y = pt.Y + FontHeight;                          else                              y = pt.Y - height;                            // Set width based on longest item                          int maxWidth = 0;                          foreach (var item in m_suggestionListBox.Items)                          {                              int width = TextRenderer.MeasureText(item.ToString()' m_suggestionListBox.Font).Width;                              if (width > maxWidth)                                  maxWidth = width;                          }                            m_suggestionListBox.Bounds = new Rectangle(pt.X + 3' y' maxWidth + 25' height);                          m_suggestionListBox.SelectedIndex = 0;                            m_suggestionListBox.Show();                          m_suggestionListBox.Focus();                      }                        return true;                  }              }
Magic Number,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,Suggest,The following statement contains a magic number: if (IsCaretAtWritablePosition)              {                  string text = GetCurrentLine();                  int offset = CaretOffsetFromCurrentLine;                    int charIndex;                  string partial;                  IEnumerable<string> suggestions;                    int triggerIndex = (offset > 0) ? text.LastIndexOfAny(s_triggers' offset - 1) : -1;                  if (triggerIndex > -1)                  {                      // Find partially completed string to right of trigger                      charIndex = triggerIndex;                      partial = text.Substring(triggerIndex + 1' offset - triggerIndex - 1);                        // Find string to left of trigger                      var startIndex = text.LastIndexOfAny(s_delimiters' triggerIndex) + 1;                      var value = text.Substring(startIndex' triggerIndex - startIndex);                        if (String.IsNullOrWhiteSpace(value))                      {                          m_suggestionListBox.Hide();                          return false;                      }                        var trigger = text[triggerIndex].ToString();                      var quoteType = String.Empty;                      if (trigger == "[")                          quoteType = partial.StartsWith("'''")                              ? "'''"                              : partial.StartsWith("\"\"\"")                                  ? "\"\"\""                                  : partial.StartsWith("'")                                      ? "'"                                      : "\"";                        suggestions = m_suggestionHandler(value' trigger)                          .Select(suggestion => String.Format("{0}{1}{0}"' quoteType' StringUtil.EscapeQuotes(suggestion)));                  }                  else                  {                      // Find partially completed string to right of ' '                      charIndex = (offset > 0) ? text.LastIndexOf(' '' offset - 1) : -1;                      partial = text.Substring(charIndex + 1' offset - charIndex - 1);                        suggestions = m_suggestionHandler(String.Empty' String.Empty);                  }                    // Only add unique suggestions                  var uniqueSuggestions = suggestions                      .Where(suggestion => suggestion.StartsWith(partial' StringComparison.InvariantCultureIgnoreCase))                      .Distinct();                    m_suggestionListBox.SetSuggestions(partial' uniqueSuggestions);                    // Show suggestions (if any)                  var count = m_suggestionListBox.Items.Count;                  if (count > 0)                  {                      int line = GetLineFromCharIndex(CaretIndex);                      int index = GetFirstCharIndexFromLine(line) + m_prompt.Length + charIndex;                      Point pt = GetPositionFromCharIndex(index);                        int itemCount = Math.Min(count' 8);                      int itemHeight = m_suggestionListBox.ItemHeight;                        int bottom = Height - itemHeight;                      if (pt.Y < bottom - 3)                      {                          int height = Math.Max(pt.Y - 8' bottom - pt.Y);                          height = Math.Min(height' itemHeight * itemCount + 4); // Limit to 8 entries                            int y;                          if (pt.Y < height)                              y = pt.Y + FontHeight;                          else                              y = pt.Y - height;                            // Set width based on longest item                          int maxWidth = 0;                          foreach (var item in m_suggestionListBox.Items)                          {                              int width = TextRenderer.MeasureText(item.ToString()' m_suggestionListBox.Font).Width;                              if (width > maxWidth)                                  maxWidth = width;                          }                            m_suggestionListBox.Bounds = new Rectangle(pt.X + 3' y' maxWidth + 25' height);                          m_suggestionListBox.SelectedIndex = 0;                            m_suggestionListBox.Show();                          m_suggestionListBox.Focus();                      }                        return true;                  }              }
Magic Number,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,Suggest,The following statement contains a magic number: if (IsCaretAtWritablePosition)              {                  string text = GetCurrentLine();                  int offset = CaretOffsetFromCurrentLine;                    int charIndex;                  string partial;                  IEnumerable<string> suggestions;                    int triggerIndex = (offset > 0) ? text.LastIndexOfAny(s_triggers' offset - 1) : -1;                  if (triggerIndex > -1)                  {                      // Find partially completed string to right of trigger                      charIndex = triggerIndex;                      partial = text.Substring(triggerIndex + 1' offset - triggerIndex - 1);                        // Find string to left of trigger                      var startIndex = text.LastIndexOfAny(s_delimiters' triggerIndex) + 1;                      var value = text.Substring(startIndex' triggerIndex - startIndex);                        if (String.IsNullOrWhiteSpace(value))                      {                          m_suggestionListBox.Hide();                          return false;                      }                        var trigger = text[triggerIndex].ToString();                      var quoteType = String.Empty;                      if (trigger == "[")                          quoteType = partial.StartsWith("'''")                              ? "'''"                              : partial.StartsWith("\"\"\"")                                  ? "\"\"\""                                  : partial.StartsWith("'")                                      ? "'"                                      : "\"";                        suggestions = m_suggestionHandler(value' trigger)                          .Select(suggestion => String.Format("{0}{1}{0}"' quoteType' StringUtil.EscapeQuotes(suggestion)));                  }                  else                  {                      // Find partially completed string to right of ' '                      charIndex = (offset > 0) ? text.LastIndexOf(' '' offset - 1) : -1;                      partial = text.Substring(charIndex + 1' offset - charIndex - 1);                        suggestions = m_suggestionHandler(String.Empty' String.Empty);                  }                    // Only add unique suggestions                  var uniqueSuggestions = suggestions                      .Where(suggestion => suggestion.StartsWith(partial' StringComparison.InvariantCultureIgnoreCase))                      .Distinct();                    m_suggestionListBox.SetSuggestions(partial' uniqueSuggestions);                    // Show suggestions (if any)                  var count = m_suggestionListBox.Items.Count;                  if (count > 0)                  {                      int line = GetLineFromCharIndex(CaretIndex);                      int index = GetFirstCharIndexFromLine(line) + m_prompt.Length + charIndex;                      Point pt = GetPositionFromCharIndex(index);                        int itemCount = Math.Min(count' 8);                      int itemHeight = m_suggestionListBox.ItemHeight;                        int bottom = Height - itemHeight;                      if (pt.Y < bottom - 3)                      {                          int height = Math.Max(pt.Y - 8' bottom - pt.Y);                          height = Math.Min(height' itemHeight * itemCount + 4); // Limit to 8 entries                            int y;                          if (pt.Y < height)                              y = pt.Y + FontHeight;                          else                              y = pt.Y - height;                            // Set width based on longest item                          int maxWidth = 0;                          foreach (var item in m_suggestionListBox.Items)                          {                              int width = TextRenderer.MeasureText(item.ToString()' m_suggestionListBox.Font).Width;                              if (width > maxWidth)                                  maxWidth = width;                          }                            m_suggestionListBox.Bounds = new Rectangle(pt.X + 3' y' maxWidth + 25' height);                          m_suggestionListBox.SelectedIndex = 0;                            m_suggestionListBox.Show();                          m_suggestionListBox.Focus();                      }                        return true;                  }              }
Magic Number,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,Suggest,The following statement contains a magic number: if (IsCaretAtWritablePosition)              {                  string text = GetCurrentLine();                  int offset = CaretOffsetFromCurrentLine;                    int charIndex;                  string partial;                  IEnumerable<string> suggestions;                    int triggerIndex = (offset > 0) ? text.LastIndexOfAny(s_triggers' offset - 1) : -1;                  if (triggerIndex > -1)                  {                      // Find partially completed string to right of trigger                      charIndex = triggerIndex;                      partial = text.Substring(triggerIndex + 1' offset - triggerIndex - 1);                        // Find string to left of trigger                      var startIndex = text.LastIndexOfAny(s_delimiters' triggerIndex) + 1;                      var value = text.Substring(startIndex' triggerIndex - startIndex);                        if (String.IsNullOrWhiteSpace(value))                      {                          m_suggestionListBox.Hide();                          return false;                      }                        var trigger = text[triggerIndex].ToString();                      var quoteType = String.Empty;                      if (trigger == "[")                          quoteType = partial.StartsWith("'''")                              ? "'''"                              : partial.StartsWith("\"\"\"")                                  ? "\"\"\""                                  : partial.StartsWith("'")                                      ? "'"                                      : "\"";                        suggestions = m_suggestionHandler(value' trigger)                          .Select(suggestion => String.Format("{0}{1}{0}"' quoteType' StringUtil.EscapeQuotes(suggestion)));                  }                  else                  {                      // Find partially completed string to right of ' '                      charIndex = (offset > 0) ? text.LastIndexOf(' '' offset - 1) : -1;                      partial = text.Substring(charIndex + 1' offset - charIndex - 1);                        suggestions = m_suggestionHandler(String.Empty' String.Empty);                  }                    // Only add unique suggestions                  var uniqueSuggestions = suggestions                      .Where(suggestion => suggestion.StartsWith(partial' StringComparison.InvariantCultureIgnoreCase))                      .Distinct();                    m_suggestionListBox.SetSuggestions(partial' uniqueSuggestions);                    // Show suggestions (if any)                  var count = m_suggestionListBox.Items.Count;                  if (count > 0)                  {                      int line = GetLineFromCharIndex(CaretIndex);                      int index = GetFirstCharIndexFromLine(line) + m_prompt.Length + charIndex;                      Point pt = GetPositionFromCharIndex(index);                        int itemCount = Math.Min(count' 8);                      int itemHeight = m_suggestionListBox.ItemHeight;                        int bottom = Height - itemHeight;                      if (pt.Y < bottom - 3)                      {                          int height = Math.Max(pt.Y - 8' bottom - pt.Y);                          height = Math.Min(height' itemHeight * itemCount + 4); // Limit to 8 entries                            int y;                          if (pt.Y < height)                              y = pt.Y + FontHeight;                          else                              y = pt.Y - height;                            // Set width based on longest item                          int maxWidth = 0;                          foreach (var item in m_suggestionListBox.Items)                          {                              int width = TextRenderer.MeasureText(item.ToString()' m_suggestionListBox.Font).Width;                              if (width > maxWidth)                                  maxWidth = width;                          }                            m_suggestionListBox.Bounds = new Rectangle(pt.X + 3' y' maxWidth + 25' height);                          m_suggestionListBox.SelectedIndex = 0;                            m_suggestionListBox.Show();                          m_suggestionListBox.Focus();                      }                        return true;                  }              }
Magic Number,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,Suggest,The following statement contains a magic number: if (IsCaretAtWritablePosition)              {                  string text = GetCurrentLine();                  int offset = CaretOffsetFromCurrentLine;                    int charIndex;                  string partial;                  IEnumerable<string> suggestions;                    int triggerIndex = (offset > 0) ? text.LastIndexOfAny(s_triggers' offset - 1) : -1;                  if (triggerIndex > -1)                  {                      // Find partially completed string to right of trigger                      charIndex = triggerIndex;                      partial = text.Substring(triggerIndex + 1' offset - triggerIndex - 1);                        // Find string to left of trigger                      var startIndex = text.LastIndexOfAny(s_delimiters' triggerIndex) + 1;                      var value = text.Substring(startIndex' triggerIndex - startIndex);                        if (String.IsNullOrWhiteSpace(value))                      {                          m_suggestionListBox.Hide();                          return false;                      }                        var trigger = text[triggerIndex].ToString();                      var quoteType = String.Empty;                      if (trigger == "[")                          quoteType = partial.StartsWith("'''")                              ? "'''"                              : partial.StartsWith("\"\"\"")                                  ? "\"\"\""                                  : partial.StartsWith("'")                                      ? "'"                                      : "\"";                        suggestions = m_suggestionHandler(value' trigger)                          .Select(suggestion => String.Format("{0}{1}{0}"' quoteType' StringUtil.EscapeQuotes(suggestion)));                  }                  else                  {                      // Find partially completed string to right of ' '                      charIndex = (offset > 0) ? text.LastIndexOf(' '' offset - 1) : -1;                      partial = text.Substring(charIndex + 1' offset - charIndex - 1);                        suggestions = m_suggestionHandler(String.Empty' String.Empty);                  }                    // Only add unique suggestions                  var uniqueSuggestions = suggestions                      .Where(suggestion => suggestion.StartsWith(partial' StringComparison.InvariantCultureIgnoreCase))                      .Distinct();                    m_suggestionListBox.SetSuggestions(partial' uniqueSuggestions);                    // Show suggestions (if any)                  var count = m_suggestionListBox.Items.Count;                  if (count > 0)                  {                      int line = GetLineFromCharIndex(CaretIndex);                      int index = GetFirstCharIndexFromLine(line) + m_prompt.Length + charIndex;                      Point pt = GetPositionFromCharIndex(index);                        int itemCount = Math.Min(count' 8);                      int itemHeight = m_suggestionListBox.ItemHeight;                        int bottom = Height - itemHeight;                      if (pt.Y < bottom - 3)                      {                          int height = Math.Max(pt.Y - 8' bottom - pt.Y);                          height = Math.Min(height' itemHeight * itemCount + 4); // Limit to 8 entries                            int y;                          if (pt.Y < height)                              y = pt.Y + FontHeight;                          else                              y = pt.Y - height;                            // Set width based on longest item                          int maxWidth = 0;                          foreach (var item in m_suggestionListBox.Items)                          {                              int width = TextRenderer.MeasureText(item.ToString()' m_suggestionListBox.Font).Width;                              if (width > maxWidth)                                  maxWidth = width;                          }                            m_suggestionListBox.Bounds = new Rectangle(pt.X + 3' y' maxWidth + 25' height);                          m_suggestionListBox.SelectedIndex = 0;                            m_suggestionListBox.Show();                          m_suggestionListBox.Focus();                      }                        return true;                  }              }
Magic Number,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,Next,The following statement contains a magic number: if (CaretOffsetFromPrompt < 0)              {                  // Move to prompt                  action(-CaretOffsetFromPrompt);              }              else if (IsCaretAtEnd && SelectionStart != TextLength)              {                  // Next line                  action(m_multilinePrompt.Length + 2);              }              else if (CaretOffsetFromCurrentLine < 0)              {                  // Move to prompt                  action(-CaretOffsetFromCurrentLine);              }              else              {                  action(count);              }
Magic Number,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,Prev,The following statement contains a magic number: if (CaretOffsetFromPrompt <= 0)              {                  // Move to prompt                  action(CaretOffsetFromPrompt);              }              else if (CaretOffsetFromCurrentLine > 0)              {                  action(count);              }              else              {                  // Previous line                  action(m_multilinePrompt.Length + CaretOffsetFromCurrentLine + 2);              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Cartesian2dCanvas,The following statement contains a magic number: Size = new Size(400' 400);
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Cartesian2dCanvas,The following statement contains a magic number: Size = new Size(400' 400);
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Cartesian2dCanvas,The following statement contains a magic number: BackColor =  Color.FromArgb(150' 150' 150);
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Cartesian2dCanvas,The following statement contains a magic number: BackColor =  Color.FromArgb(150' 150' 150);
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Cartesian2dCanvas,The following statement contains a magic number: BackColor =  Color.FromArgb(150' 150' 150);
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Cartesian2dCanvas,The following statement contains a magic number: MinimumSize = new Size(10' 10);
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Cartesian2dCanvas,The following statement contains a magic number: MinimumSize = new Size(10' 10);
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following statement contains a magic number: float hh = h / 2;
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following statement contains a magic number: float hw = w / 2;
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      {                          Zoom = new Vec2F(w / rect.Width' h / rect.Height);                          Vec2F center = new Vec2F(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          break;                      }                  case OriginLockMode.Center:                      {                          float absleft = Math.Abs(rect.Left);                          float absright = Math.Abs(rect.Right);                          float fx = Math.Max(absleft' absright);                          float abstop = Math.Abs(rect.Top);                          float absbottom = Math.Abs(rect.Bottom);                          float fy = Math.Max(abstop' absbottom);                          Zoom = new Vec2F(hw / fx' hh / fy);                          break;                      }                  case OriginLockMode.Left:                      {                                                  if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              Zoom = new Vec2F(w / fx' h / rect.Height);                              Vec2F center = new Vec2F(left + fx / 2' rect.Y + rect.Height / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftTop:                        if (rect.Right > 0 && rect.Bottom > 0)                      {                          float left = Math.Max(0' rect.Left);                          float fx = (left > 0) ? rect.Width : rect.Right;                            float top = Math.Max(0' rect.Top);                          float fy = (top > 0) ? rect.Height : rect.Bottom;                          Zoom = new Vec2F(w / fx' h / fy);                          Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                      }                                   break;                  case OriginLockMode.LeftBottom:                      {                          if (rect.Right > 0 && rect.Bottom > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                                float top = Math.Max(0' rect.Top);                              float fy = (top > 0) ? rect.Height : rect.Bottom;                              Zoom = new Vec2F(w / fx' h / fy);                              Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftMiddle:                      {                          if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              float abstop = Math.Abs(rect.Top);                              float absbottom = Math.Abs(rect.Bottom);                              float fy = Math.Max(abstop' absbottom);                              Zoom = new Vec2F(w / fx' hh / fy);                              Vec2F center = new Vec2F(left + fx / 2' 0);                              Pan = new Vec2F(hw - center.X * Zoom.X' Pan.Y);                          }                          break;                      }              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      {                          Zoom = new Vec2F(w / rect.Width' h / rect.Height);                          Vec2F center = new Vec2F(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          break;                      }                  case OriginLockMode.Center:                      {                          float absleft = Math.Abs(rect.Left);                          float absright = Math.Abs(rect.Right);                          float fx = Math.Max(absleft' absright);                          float abstop = Math.Abs(rect.Top);                          float absbottom = Math.Abs(rect.Bottom);                          float fy = Math.Max(abstop' absbottom);                          Zoom = new Vec2F(hw / fx' hh / fy);                          break;                      }                  case OriginLockMode.Left:                      {                                                  if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              Zoom = new Vec2F(w / fx' h / rect.Height);                              Vec2F center = new Vec2F(left + fx / 2' rect.Y + rect.Height / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftTop:                        if (rect.Right > 0 && rect.Bottom > 0)                      {                          float left = Math.Max(0' rect.Left);                          float fx = (left > 0) ? rect.Width : rect.Right;                            float top = Math.Max(0' rect.Top);                          float fy = (top > 0) ? rect.Height : rect.Bottom;                          Zoom = new Vec2F(w / fx' h / fy);                          Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                      }                                   break;                  case OriginLockMode.LeftBottom:                      {                          if (rect.Right > 0 && rect.Bottom > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                                float top = Math.Max(0' rect.Top);                              float fy = (top > 0) ? rect.Height : rect.Bottom;                              Zoom = new Vec2F(w / fx' h / fy);                              Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftMiddle:                      {                          if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              float abstop = Math.Abs(rect.Top);                              float absbottom = Math.Abs(rect.Bottom);                              float fy = Math.Max(abstop' absbottom);                              Zoom = new Vec2F(w / fx' hh / fy);                              Vec2F center = new Vec2F(left + fx / 2' 0);                              Pan = new Vec2F(hw - center.X * Zoom.X' Pan.Y);                          }                          break;                      }              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      {                          Zoom = new Vec2F(w / rect.Width' h / rect.Height);                          Vec2F center = new Vec2F(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          break;                      }                  case OriginLockMode.Center:                      {                          float absleft = Math.Abs(rect.Left);                          float absright = Math.Abs(rect.Right);                          float fx = Math.Max(absleft' absright);                          float abstop = Math.Abs(rect.Top);                          float absbottom = Math.Abs(rect.Bottom);                          float fy = Math.Max(abstop' absbottom);                          Zoom = new Vec2F(hw / fx' hh / fy);                          break;                      }                  case OriginLockMode.Left:                      {                                                  if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              Zoom = new Vec2F(w / fx' h / rect.Height);                              Vec2F center = new Vec2F(left + fx / 2' rect.Y + rect.Height / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftTop:                        if (rect.Right > 0 && rect.Bottom > 0)                      {                          float left = Math.Max(0' rect.Left);                          float fx = (left > 0) ? rect.Width : rect.Right;                            float top = Math.Max(0' rect.Top);                          float fy = (top > 0) ? rect.Height : rect.Bottom;                          Zoom = new Vec2F(w / fx' h / fy);                          Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                      }                                   break;                  case OriginLockMode.LeftBottom:                      {                          if (rect.Right > 0 && rect.Bottom > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                                float top = Math.Max(0' rect.Top);                              float fy = (top > 0) ? rect.Height : rect.Bottom;                              Zoom = new Vec2F(w / fx' h / fy);                              Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftMiddle:                      {                          if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              float abstop = Math.Abs(rect.Top);                              float absbottom = Math.Abs(rect.Bottom);                              float fy = Math.Max(abstop' absbottom);                              Zoom = new Vec2F(w / fx' hh / fy);                              Vec2F center = new Vec2F(left + fx / 2' 0);                              Pan = new Vec2F(hw - center.X * Zoom.X' Pan.Y);                          }                          break;                      }              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      {                          Zoom = new Vec2F(w / rect.Width' h / rect.Height);                          Vec2F center = new Vec2F(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          break;                      }                  case OriginLockMode.Center:                      {                          float absleft = Math.Abs(rect.Left);                          float absright = Math.Abs(rect.Right);                          float fx = Math.Max(absleft' absright);                          float abstop = Math.Abs(rect.Top);                          float absbottom = Math.Abs(rect.Bottom);                          float fy = Math.Max(abstop' absbottom);                          Zoom = new Vec2F(hw / fx' hh / fy);                          break;                      }                  case OriginLockMode.Left:                      {                                                  if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              Zoom = new Vec2F(w / fx' h / rect.Height);                              Vec2F center = new Vec2F(left + fx / 2' rect.Y + rect.Height / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftTop:                        if (rect.Right > 0 && rect.Bottom > 0)                      {                          float left = Math.Max(0' rect.Left);                          float fx = (left > 0) ? rect.Width : rect.Right;                            float top = Math.Max(0' rect.Top);                          float fy = (top > 0) ? rect.Height : rect.Bottom;                          Zoom = new Vec2F(w / fx' h / fy);                          Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                      }                                   break;                  case OriginLockMode.LeftBottom:                      {                          if (rect.Right > 0 && rect.Bottom > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                                float top = Math.Max(0' rect.Top);                              float fy = (top > 0) ? rect.Height : rect.Bottom;                              Zoom = new Vec2F(w / fx' h / fy);                              Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftMiddle:                      {                          if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              float abstop = Math.Abs(rect.Top);                              float absbottom = Math.Abs(rect.Bottom);                              float fy = Math.Max(abstop' absbottom);                              Zoom = new Vec2F(w / fx' hh / fy);                              Vec2F center = new Vec2F(left + fx / 2' 0);                              Pan = new Vec2F(hw - center.X * Zoom.X' Pan.Y);                          }                          break;                      }              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      {                          Zoom = new Vec2F(w / rect.Width' h / rect.Height);                          Vec2F center = new Vec2F(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          break;                      }                  case OriginLockMode.Center:                      {                          float absleft = Math.Abs(rect.Left);                          float absright = Math.Abs(rect.Right);                          float fx = Math.Max(absleft' absright);                          float abstop = Math.Abs(rect.Top);                          float absbottom = Math.Abs(rect.Bottom);                          float fy = Math.Max(abstop' absbottom);                          Zoom = new Vec2F(hw / fx' hh / fy);                          break;                      }                  case OriginLockMode.Left:                      {                                                  if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              Zoom = new Vec2F(w / fx' h / rect.Height);                              Vec2F center = new Vec2F(left + fx / 2' rect.Y + rect.Height / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftTop:                        if (rect.Right > 0 && rect.Bottom > 0)                      {                          float left = Math.Max(0' rect.Left);                          float fx = (left > 0) ? rect.Width : rect.Right;                            float top = Math.Max(0' rect.Top);                          float fy = (top > 0) ? rect.Height : rect.Bottom;                          Zoom = new Vec2F(w / fx' h / fy);                          Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                      }                                   break;                  case OriginLockMode.LeftBottom:                      {                          if (rect.Right > 0 && rect.Bottom > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                                float top = Math.Max(0' rect.Top);                              float fy = (top > 0) ? rect.Height : rect.Bottom;                              Zoom = new Vec2F(w / fx' h / fy);                              Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftMiddle:                      {                          if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              float abstop = Math.Abs(rect.Top);                              float absbottom = Math.Abs(rect.Bottom);                              float fy = Math.Max(abstop' absbottom);                              Zoom = new Vec2F(w / fx' hh / fy);                              Vec2F center = new Vec2F(left + fx / 2' 0);                              Pan = new Vec2F(hw - center.X * Zoom.X' Pan.Y);                          }                          break;                      }              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      {                          Zoom = new Vec2F(w / rect.Width' h / rect.Height);                          Vec2F center = new Vec2F(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          break;                      }                  case OriginLockMode.Center:                      {                          float absleft = Math.Abs(rect.Left);                          float absright = Math.Abs(rect.Right);                          float fx = Math.Max(absleft' absright);                          float abstop = Math.Abs(rect.Top);                          float absbottom = Math.Abs(rect.Bottom);                          float fy = Math.Max(abstop' absbottom);                          Zoom = new Vec2F(hw / fx' hh / fy);                          break;                      }                  case OriginLockMode.Left:                      {                                                  if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              Zoom = new Vec2F(w / fx' h / rect.Height);                              Vec2F center = new Vec2F(left + fx / 2' rect.Y + rect.Height / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftTop:                        if (rect.Right > 0 && rect.Bottom > 0)                      {                          float left = Math.Max(0' rect.Left);                          float fx = (left > 0) ? rect.Width : rect.Right;                            float top = Math.Max(0' rect.Top);                          float fy = (top > 0) ? rect.Height : rect.Bottom;                          Zoom = new Vec2F(w / fx' h / fy);                          Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                      }                                   break;                  case OriginLockMode.LeftBottom:                      {                          if (rect.Right > 0 && rect.Bottom > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                                float top = Math.Max(0' rect.Top);                              float fy = (top > 0) ? rect.Height : rect.Bottom;                              Zoom = new Vec2F(w / fx' h / fy);                              Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftMiddle:                      {                          if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              float abstop = Math.Abs(rect.Top);                              float absbottom = Math.Abs(rect.Bottom);                              float fy = Math.Max(abstop' absbottom);                              Zoom = new Vec2F(w / fx' hh / fy);                              Vec2F center = new Vec2F(left + fx / 2' 0);                              Pan = new Vec2F(hw - center.X * Zoom.X' Pan.Y);                          }                          break;                      }              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      {                          Zoom = new Vec2F(w / rect.Width' h / rect.Height);                          Vec2F center = new Vec2F(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          break;                      }                  case OriginLockMode.Center:                      {                          float absleft = Math.Abs(rect.Left);                          float absright = Math.Abs(rect.Right);                          float fx = Math.Max(absleft' absright);                          float abstop = Math.Abs(rect.Top);                          float absbottom = Math.Abs(rect.Bottom);                          float fy = Math.Max(abstop' absbottom);                          Zoom = new Vec2F(hw / fx' hh / fy);                          break;                      }                  case OriginLockMode.Left:                      {                                                  if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              Zoom = new Vec2F(w / fx' h / rect.Height);                              Vec2F center = new Vec2F(left + fx / 2' rect.Y + rect.Height / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftTop:                        if (rect.Right > 0 && rect.Bottom > 0)                      {                          float left = Math.Max(0' rect.Left);                          float fx = (left > 0) ? rect.Width : rect.Right;                            float top = Math.Max(0' rect.Top);                          float fy = (top > 0) ? rect.Height : rect.Bottom;                          Zoom = new Vec2F(w / fx' h / fy);                          Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                      }                                   break;                  case OriginLockMode.LeftBottom:                      {                          if (rect.Right > 0 && rect.Bottom > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                                float top = Math.Max(0' rect.Top);                              float fy = (top > 0) ? rect.Height : rect.Bottom;                              Zoom = new Vec2F(w / fx' h / fy);                              Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftMiddle:                      {                          if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              float abstop = Math.Abs(rect.Top);                              float absbottom = Math.Abs(rect.Bottom);                              float fy = Math.Max(abstop' absbottom);                              Zoom = new Vec2F(w / fx' hh / fy);                              Vec2F center = new Vec2F(left + fx / 2' 0);                              Pan = new Vec2F(hw - center.X * Zoom.X' Pan.Y);                          }                          break;                      }              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      {                          Zoom = new Vec2F(w / rect.Width' h / rect.Height);                          Vec2F center = new Vec2F(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          break;                      }                  case OriginLockMode.Center:                      {                          float absleft = Math.Abs(rect.Left);                          float absright = Math.Abs(rect.Right);                          float fx = Math.Max(absleft' absright);                          float abstop = Math.Abs(rect.Top);                          float absbottom = Math.Abs(rect.Bottom);                          float fy = Math.Max(abstop' absbottom);                          Zoom = new Vec2F(hw / fx' hh / fy);                          break;                      }                  case OriginLockMode.Left:                      {                                                  if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              Zoom = new Vec2F(w / fx' h / rect.Height);                              Vec2F center = new Vec2F(left + fx / 2' rect.Y + rect.Height / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftTop:                        if (rect.Right > 0 && rect.Bottom > 0)                      {                          float left = Math.Max(0' rect.Left);                          float fx = (left > 0) ? rect.Width : rect.Right;                            float top = Math.Max(0' rect.Top);                          float fy = (top > 0) ? rect.Height : rect.Bottom;                          Zoom = new Vec2F(w / fx' h / fy);                          Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                      }                                   break;                  case OriginLockMode.LeftBottom:                      {                          if (rect.Right > 0 && rect.Bottom > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                                float top = Math.Max(0' rect.Top);                              float fy = (top > 0) ? rect.Height : rect.Bottom;                              Zoom = new Vec2F(w / fx' h / fy);                              Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftMiddle:                      {                          if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              float abstop = Math.Abs(rect.Top);                              float absbottom = Math.Abs(rect.Bottom);                              float fy = Math.Max(abstop' absbottom);                              Zoom = new Vec2F(w / fx' hh / fy);                              Vec2F center = new Vec2F(left + fx / 2' 0);                              Pan = new Vec2F(hw - center.X * Zoom.X' Pan.Y);                          }                          break;                      }              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      {                          Zoom = new Vec2F(w / rect.Width' h / rect.Height);                          Vec2F center = new Vec2F(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          break;                      }                  case OriginLockMode.Center:                      {                          float absleft = Math.Abs(rect.Left);                          float absright = Math.Abs(rect.Right);                          float fx = Math.Max(absleft' absright);                          float abstop = Math.Abs(rect.Top);                          float absbottom = Math.Abs(rect.Bottom);                          float fy = Math.Max(abstop' absbottom);                          Zoom = new Vec2F(hw / fx' hh / fy);                          break;                      }                  case OriginLockMode.Left:                      {                                                  if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              Zoom = new Vec2F(w / fx' h / rect.Height);                              Vec2F center = new Vec2F(left + fx / 2' rect.Y + rect.Height / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftTop:                        if (rect.Right > 0 && rect.Bottom > 0)                      {                          float left = Math.Max(0' rect.Left);                          float fx = (left > 0) ? rect.Width : rect.Right;                            float top = Math.Max(0' rect.Top);                          float fy = (top > 0) ? rect.Height : rect.Bottom;                          Zoom = new Vec2F(w / fx' h / fy);                          Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                      }                                   break;                  case OriginLockMode.LeftBottom:                      {                          if (rect.Right > 0 && rect.Bottom > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                                float top = Math.Max(0' rect.Top);                              float fy = (top > 0) ? rect.Height : rect.Bottom;                              Zoom = new Vec2F(w / fx' h / fy);                              Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftMiddle:                      {                          if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              float abstop = Math.Abs(rect.Top);                              float absbottom = Math.Abs(rect.Bottom);                              float fy = Math.Max(abstop' absbottom);                              Zoom = new Vec2F(w / fx' hh / fy);                              Vec2F center = new Vec2F(left + fx / 2' 0);                              Pan = new Vec2F(hw - center.X * Zoom.X' Pan.Y);                          }                          break;                      }              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,PanToOrigin,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      Pan_d = new PointD(ClientSize.Width / 2' ClientSize.Height / 2);                      break;                  case OriginLockMode.LeftTop:                      Pan_d = new PointD(1' 1);                      break;                  case OriginLockMode.Left:                                      case OriginLockMode.LeftMiddle:                      Pan_d = new PointD(1' ClientSize.Height / 2);                      break;                  case OriginLockMode.LeftBottom:                      Pan_d = new PointD(1' ClientSize.Height);                      break;                                  }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,PanToOrigin,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      Pan_d = new PointD(ClientSize.Width / 2' ClientSize.Height / 2);                      break;                  case OriginLockMode.LeftTop:                      Pan_d = new PointD(1' 1);                      break;                  case OriginLockMode.Left:                                      case OriginLockMode.LeftMiddle:                      Pan_d = new PointD(1' ClientSize.Height / 2);                      break;                  case OriginLockMode.LeftBottom:                      Pan_d = new PointD(1' ClientSize.Height);                      break;                                  }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,PanToOrigin,The following statement contains a magic number: switch(m_lockorg)              {                  case OriginLockMode.Free:                      Pan_d = new PointD(ClientSize.Width / 2' ClientSize.Height / 2);                      break;                  case OriginLockMode.LeftTop:                      Pan_d = new PointD(1' 1);                      break;                  case OriginLockMode.Left:                                      case OriginLockMode.LeftMiddle:                      Pan_d = new PointD(1' ClientSize.Height / 2);                      break;                  case OriginLockMode.LeftBottom:                      Pan_d = new PointD(1' ClientSize.Height);                      break;                                  }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,DrawHorizontalScale,The following statement contains a magic number: for (; x <= xright; x += m_majorTickX)              {                                                  // xform x from graph to client space.                  float xpos = GraphToClient(x);                                  string strVal = Math.Round(x' 9).ToString();                  SizeF sz = g.MeasureString(strVal' m_scaleTextFont);                  float hw = sz.Width * 0.5f;                  // check for overlap                  if (lastTextEnd < (xpos - hw))                  {                      g.DrawString(strVal' m_scaleTextFont' m_scaleTextBrush' xpos - hw' heightWithMargin - sz.Height);                      lastTextEnd = xpos + hw;                  }                                }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,DrawVerticalScale,The following statement contains a magic number: for (; y <= ytop; y += m_majorTickY)              {                  float ypos = (float)(m_trans.Y + y * m_scale.Y);                                  string strVal = Math.Round(y' 9).ToString();                                  g.DrawString(strVal' m_scaleTextFont' m_scaleTextBrush' GridTextMargin' ypos - textHeight / 2);              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,DrawVerticalScale,The following statement contains a magic number: for (; y <= ytop; y += m_majorTickY)              {                  float ypos = (float)(m_trans.Y + y * m_scale.Y);                                  string strVal = Math.Round(y' 9).ToString();                                  g.DrawString(strVal' m_scaleTextFont' m_scaleTextBrush' GridTextMargin' ypos - textHeight / 2);              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,DrawXYLabel,The following statement contains a magic number: using (SolidBrush brush = new SolidBrush(c))              {                  float margin = Math.Min( 2.0f * m_axisLabelFont.Height'40);                  float leadingspace = 120;                  g.DrawString(xLabel' m_axisLabelFont' brush' leadingspace' ClientSize.Height - margin);                                 Matrix xform = g.Transform;                  g.RotateTransform(-90);                  g.TranslateTransform(margin' ClientSize.Height - leadingspace' MatrixOrder.Append);                  g.DrawString(yLabel' m_axisLabelFont' brush' 0' 0);                  g.Transform = xform;              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,DrawXYLabel,The following statement contains a magic number: using (SolidBrush brush = new SolidBrush(c))              {                  float margin = Math.Min( 2.0f * m_axisLabelFont.Height'40);                  float leadingspace = 120;                  g.DrawString(xLabel' m_axisLabelFont' brush' leadingspace' ClientSize.Height - margin);                                 Matrix xform = g.Transform;                  g.RotateTransform(-90);                  g.TranslateTransform(margin' ClientSize.Height - leadingspace' MatrixOrder.Append);                  g.DrawString(yLabel' m_axisLabelFont' brush' 0' 0);                  g.Transform = xform;              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,DrawXYLabel,The following statement contains a magic number: using (SolidBrush brush = new SolidBrush(c))              {                  float margin = Math.Min( 2.0f * m_axisLabelFont.Height'40);                  float leadingspace = 120;                  g.DrawString(xLabel' m_axisLabelFont' brush' leadingspace' ClientSize.Height - margin);                                 Matrix xform = g.Transform;                  g.RotateTransform(-90);                  g.TranslateTransform(margin' ClientSize.Height - leadingspace' MatrixOrder.Append);                  g.DrawString(yLabel' m_axisLabelFont' brush' 0' 0);                  g.Transform = xform;              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,UpdatePan,The following statement contains a magic number: switch (m_lockorg)              {                  case OriginLockMode.Free:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = float.MaxValue;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.Center:                      m_minOffsetX = w / 2;                                          m_maxOffsetX = w / 2;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.Left:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.LeftTop:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = -float.MaxValue;                      m_maxOffsetY = 1;                      break;                  case OriginLockMode.LeftMiddle:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.LeftBottom:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h - 1;                      m_maxOffsetY = float.MaxValue;                      break;              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,UpdatePan,The following statement contains a magic number: switch (m_lockorg)              {                  case OriginLockMode.Free:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = float.MaxValue;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.Center:                      m_minOffsetX = w / 2;                                          m_maxOffsetX = w / 2;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.Left:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.LeftTop:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = -float.MaxValue;                      m_maxOffsetY = 1;                      break;                  case OriginLockMode.LeftMiddle:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.LeftBottom:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h - 1;                      m_maxOffsetY = float.MaxValue;                      break;              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,UpdatePan,The following statement contains a magic number: switch (m_lockorg)              {                  case OriginLockMode.Free:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = float.MaxValue;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.Center:                      m_minOffsetX = w / 2;                                          m_maxOffsetX = w / 2;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.Left:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.LeftTop:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = -float.MaxValue;                      m_maxOffsetY = 1;                      break;                  case OriginLockMode.LeftMiddle:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.LeftBottom:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h - 1;                      m_maxOffsetY = float.MaxValue;                      break;              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,UpdatePan,The following statement contains a magic number: switch (m_lockorg)              {                  case OriginLockMode.Free:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = float.MaxValue;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.Center:                      m_minOffsetX = w / 2;                                          m_maxOffsetX = w / 2;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.Left:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.LeftTop:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = -float.MaxValue;                      m_maxOffsetY = 1;                      break;                  case OriginLockMode.LeftMiddle:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.LeftBottom:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h - 1;                      m_maxOffsetY = float.MaxValue;                      break;              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,UpdatePan,The following statement contains a magic number: switch (m_lockorg)              {                  case OriginLockMode.Free:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = float.MaxValue;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.Center:                      m_minOffsetX = w / 2;                                          m_maxOffsetX = w / 2;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.Left:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.LeftTop:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = -float.MaxValue;                      m_maxOffsetY = 1;                      break;                  case OriginLockMode.LeftMiddle:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.LeftBottom:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h - 1;                      m_maxOffsetY = float.MaxValue;                      break;              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,UpdatePan,The following statement contains a magic number: switch (m_lockorg)              {                  case OriginLockMode.Free:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = float.MaxValue;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.Center:                      m_minOffsetX = w / 2;                                          m_maxOffsetX = w / 2;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.Left:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.LeftTop:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = -float.MaxValue;                      m_maxOffsetY = 1;                      break;                  case OriginLockMode.LeftMiddle:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.LeftBottom:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h - 1;                      m_maxOffsetY = float.MaxValue;                      break;              }
Magic Number,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,ComputeGridSpan,The following statement contains a magic number: double baseNum = Math.Pow(10' digit);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,CurveCanvas,The following statement contains a magic number: s_marqueePen = new Pen(Color.FromArgb(40' 40' 40));
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,CurveCanvas,The following statement contains a magic number: s_marqueePen = new Pen(Color.FromArgb(40' 40' 40));
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,CurveCanvas,The following statement contains a magic number: s_marqueePen = new Pen(Color.FromArgb(40' 40' 40));
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,CurveCanvas,The following statement contains a magic number: s_marqueePen.DashPattern = new float[] { 3' 3 };
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,CurveCanvas,The following statement contains a magic number: s_marqueePen.DashPattern = new float[] { 3' 3 };
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: if (m_curves.Count > 0)              {                  float w = ClientSize.Width;                  float h = ClientSize.Height;                    e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                                    // draw axis labels for last selected and visible curve.                                 for (int index = m_selection.Count - 1; index >= 0; index--)                  {                      ICurve curve = m_selection[index].Parent;                      if (curve != null && curve.Visible)                      {                          DrawXYLabel(e.Graphics' curve.XLabel' curve.YLabel' curve.CurveColor);                          break;                      }                  }                    foreach (ICurve curve in m_curves)                  {                                      if (!curve.Visible)                          continue;                      float thickness = m_editSet.Contains(curve) ? 2.6f : 1.0f;                      m_renderer.DrawCurve(curve' e.Graphics' thickness);                  }                    e.Graphics.SmoothingMode = SmoothingMode.None;                  // draw control points.                  foreach (ICurve curve in m_curves)                  {                      if (!curve.Visible)                          continue;                      m_renderer.DrawControlPoints(curve' e.Graphics);                  }                    Pen pen = new Pen(Color.Black' 2);                  // draw curve limits for selected curves.                  foreach (ICurve curve in m_selectedCurves)                  {                      if (!curve.Visible)                          continue;                      Vec2F min = new Vec2F(curve.MinX' curve.MinY);                      Vec2F max = new Vec2F(curve.MaxX' curve.MaxY);                      min = GraphToClient(min);                      max = GraphToClient(max);                      float x1 = min.X;                      float x2 = max.X;                      float y1 = min.Y;                      float y2 = max.Y;                        // to avoind gdi+ overflow and drawing limit where the width or height                       // is less than one pixel.                       // can't use  e.Graphics.DrawRectangle(pen' rect);                         // cull' clip and draw curve limit guide lines.                      pen.Color = curve.CurveColor;                      bool cull = (x1 < 0 && x2 < 0) || (x1 > w && x2 > w);                      if (!cull)                      {                          // clip                          float lx1 = Math.Max(0' x1);                          float lx2 = Math.Min(w' x2);                            // draw top line                          if (y2 > 0 && y2 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y2' lx2' y2);                          }                          // draw bottom line                           if (y1 > 0 && y1 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y1' lx2' y1);                          }                      }                      cull = (y1 < 0 && y2 < 0) || (y1 > h && y2 > h);                      if (!cull)                      {                          // clip                          float ly1 = Math.Min(h' y1);                          float ly2 = Math.Max(0' y2);                          // draw left line                          if (x1 > 0 && x1 < w)                          {                              e.Graphics.DrawLine(pen' x1' ly2' x1' ly1);                          }                          // draw right line                          if (x2 > 0 && x2 < w)                          {                              e.Graphics.DrawLine(pen' x2' ly2' x2' ly1);                          }                      }                  }                    if (m_drawScalePivot)                  {                      Vec2F scalePivot = GraphToClient(m_scalePivot);                      Rectangle pvRect = new Rectangle((int)scalePivot.X - 4' (int)scalePivot.Y - 4' 8' 8);                      e.Graphics.DrawLine(Pens.Black' 0' scalePivot.Y' Width' scalePivot.Y);                      e.Graphics.DrawLine(Pens.Black' scalePivot.X' 0' scalePivot.X' Height);                      e.Graphics.DrawRectangle(Pens.Black' pvRect);                  }                  else if (m_drawInsertLine)                  {                      var insertLinePen = new Pen(m_insertLineColor);                      var insertLineBrush = new SolidBrush(m_insertLineColor);                                            e.Graphics.DrawLine(insertLinePen' CurrentPoint.X' 0' CurrentPoint.X' Height);                      IEnumerable<ICurve> curves = m_editSet.Count > 0 ? (IEnumerable<ICurve>)m_editSet : m_selectedCurves;                      foreach (ICurve curve in curves)                      {                          ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                                                                            float y = cv.Evaluate(CurrentGraphPoint.X);                          Vec2F gpt = new Vec2F(CurrentGraphPoint.X' y);                          Vec2F pt = GraphToClient(gpt);                          RectangleF ptRect = m_mouseRect;                                                                              ptRect.X = pt.X - ptRect.Width / 2;                          ptRect.Y = pt.Y - ptRect.Height / 2;                            bool inCurveLimit                              = AutoComputeCurveLimitsEnabled                              || (gpt.X >= curve.MinX                              && gpt.X <= curve.MaxX                              && gpt.Y >= curve.MinY                              && gpt.Y <= curve.MaxY);                            int index = CurveUtils.GetValidInsertionIndex(curve' CurrentGraphPoint.X);                          if (index >= 0 && inCurveLimit)                          {                              e.Graphics.FillRectangle(insertLineBrush' ptRect);                          }                          else                          {                              pt.X = pt.X - s_noAction.Width / 2;                              pt.Y = pt.Y - s_noAction.Height / 2;                              e.Graphics.DrawImage(s_noAction' pt);                          }                      }                        insertLinePen.Dispose();                      insertLineBrush.Dispose();                  }                    pen.Dispose();                  m_currentX.Draw(e.Graphics);                  DrawPasteAtIndicators(e.Graphics);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: if (m_curves.Count > 0)              {                  float w = ClientSize.Width;                  float h = ClientSize.Height;                    e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                                    // draw axis labels for last selected and visible curve.                                 for (int index = m_selection.Count - 1; index >= 0; index--)                  {                      ICurve curve = m_selection[index].Parent;                      if (curve != null && curve.Visible)                      {                          DrawXYLabel(e.Graphics' curve.XLabel' curve.YLabel' curve.CurveColor);                          break;                      }                  }                    foreach (ICurve curve in m_curves)                  {                                      if (!curve.Visible)                          continue;                      float thickness = m_editSet.Contains(curve) ? 2.6f : 1.0f;                      m_renderer.DrawCurve(curve' e.Graphics' thickness);                  }                    e.Graphics.SmoothingMode = SmoothingMode.None;                  // draw control points.                  foreach (ICurve curve in m_curves)                  {                      if (!curve.Visible)                          continue;                      m_renderer.DrawControlPoints(curve' e.Graphics);                  }                    Pen pen = new Pen(Color.Black' 2);                  // draw curve limits for selected curves.                  foreach (ICurve curve in m_selectedCurves)                  {                      if (!curve.Visible)                          continue;                      Vec2F min = new Vec2F(curve.MinX' curve.MinY);                      Vec2F max = new Vec2F(curve.MaxX' curve.MaxY);                      min = GraphToClient(min);                      max = GraphToClient(max);                      float x1 = min.X;                      float x2 = max.X;                      float y1 = min.Y;                      float y2 = max.Y;                        // to avoind gdi+ overflow and drawing limit where the width or height                       // is less than one pixel.                       // can't use  e.Graphics.DrawRectangle(pen' rect);                         // cull' clip and draw curve limit guide lines.                      pen.Color = curve.CurveColor;                      bool cull = (x1 < 0 && x2 < 0) || (x1 > w && x2 > w);                      if (!cull)                      {                          // clip                          float lx1 = Math.Max(0' x1);                          float lx2 = Math.Min(w' x2);                            // draw top line                          if (y2 > 0 && y2 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y2' lx2' y2);                          }                          // draw bottom line                           if (y1 > 0 && y1 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y1' lx2' y1);                          }                      }                      cull = (y1 < 0 && y2 < 0) || (y1 > h && y2 > h);                      if (!cull)                      {                          // clip                          float ly1 = Math.Min(h' y1);                          float ly2 = Math.Max(0' y2);                          // draw left line                          if (x1 > 0 && x1 < w)                          {                              e.Graphics.DrawLine(pen' x1' ly2' x1' ly1);                          }                          // draw right line                          if (x2 > 0 && x2 < w)                          {                              e.Graphics.DrawLine(pen' x2' ly2' x2' ly1);                          }                      }                  }                    if (m_drawScalePivot)                  {                      Vec2F scalePivot = GraphToClient(m_scalePivot);                      Rectangle pvRect = new Rectangle((int)scalePivot.X - 4' (int)scalePivot.Y - 4' 8' 8);                      e.Graphics.DrawLine(Pens.Black' 0' scalePivot.Y' Width' scalePivot.Y);                      e.Graphics.DrawLine(Pens.Black' scalePivot.X' 0' scalePivot.X' Height);                      e.Graphics.DrawRectangle(Pens.Black' pvRect);                  }                  else if (m_drawInsertLine)                  {                      var insertLinePen = new Pen(m_insertLineColor);                      var insertLineBrush = new SolidBrush(m_insertLineColor);                                            e.Graphics.DrawLine(insertLinePen' CurrentPoint.X' 0' CurrentPoint.X' Height);                      IEnumerable<ICurve> curves = m_editSet.Count > 0 ? (IEnumerable<ICurve>)m_editSet : m_selectedCurves;                      foreach (ICurve curve in curves)                      {                          ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                                                                            float y = cv.Evaluate(CurrentGraphPoint.X);                          Vec2F gpt = new Vec2F(CurrentGraphPoint.X' y);                          Vec2F pt = GraphToClient(gpt);                          RectangleF ptRect = m_mouseRect;                                                                              ptRect.X = pt.X - ptRect.Width / 2;                          ptRect.Y = pt.Y - ptRect.Height / 2;                            bool inCurveLimit                              = AutoComputeCurveLimitsEnabled                              || (gpt.X >= curve.MinX                              && gpt.X <= curve.MaxX                              && gpt.Y >= curve.MinY                              && gpt.Y <= curve.MaxY);                            int index = CurveUtils.GetValidInsertionIndex(curve' CurrentGraphPoint.X);                          if (index >= 0 && inCurveLimit)                          {                              e.Graphics.FillRectangle(insertLineBrush' ptRect);                          }                          else                          {                              pt.X = pt.X - s_noAction.Width / 2;                              pt.Y = pt.Y - s_noAction.Height / 2;                              e.Graphics.DrawImage(s_noAction' pt);                          }                      }                        insertLinePen.Dispose();                      insertLineBrush.Dispose();                  }                    pen.Dispose();                  m_currentX.Draw(e.Graphics);                  DrawPasteAtIndicators(e.Graphics);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: if (m_curves.Count > 0)              {                  float w = ClientSize.Width;                  float h = ClientSize.Height;                    e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                                    // draw axis labels for last selected and visible curve.                                 for (int index = m_selection.Count - 1; index >= 0; index--)                  {                      ICurve curve = m_selection[index].Parent;                      if (curve != null && curve.Visible)                      {                          DrawXYLabel(e.Graphics' curve.XLabel' curve.YLabel' curve.CurveColor);                          break;                      }                  }                    foreach (ICurve curve in m_curves)                  {                                      if (!curve.Visible)                          continue;                      float thickness = m_editSet.Contains(curve) ? 2.6f : 1.0f;                      m_renderer.DrawCurve(curve' e.Graphics' thickness);                  }                    e.Graphics.SmoothingMode = SmoothingMode.None;                  // draw control points.                  foreach (ICurve curve in m_curves)                  {                      if (!curve.Visible)                          continue;                      m_renderer.DrawControlPoints(curve' e.Graphics);                  }                    Pen pen = new Pen(Color.Black' 2);                  // draw curve limits for selected curves.                  foreach (ICurve curve in m_selectedCurves)                  {                      if (!curve.Visible)                          continue;                      Vec2F min = new Vec2F(curve.MinX' curve.MinY);                      Vec2F max = new Vec2F(curve.MaxX' curve.MaxY);                      min = GraphToClient(min);                      max = GraphToClient(max);                      float x1 = min.X;                      float x2 = max.X;                      float y1 = min.Y;                      float y2 = max.Y;                        // to avoind gdi+ overflow and drawing limit where the width or height                       // is less than one pixel.                       // can't use  e.Graphics.DrawRectangle(pen' rect);                         // cull' clip and draw curve limit guide lines.                      pen.Color = curve.CurveColor;                      bool cull = (x1 < 0 && x2 < 0) || (x1 > w && x2 > w);                      if (!cull)                      {                          // clip                          float lx1 = Math.Max(0' x1);                          float lx2 = Math.Min(w' x2);                            // draw top line                          if (y2 > 0 && y2 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y2' lx2' y2);                          }                          // draw bottom line                           if (y1 > 0 && y1 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y1' lx2' y1);                          }                      }                      cull = (y1 < 0 && y2 < 0) || (y1 > h && y2 > h);                      if (!cull)                      {                          // clip                          float ly1 = Math.Min(h' y1);                          float ly2 = Math.Max(0' y2);                          // draw left line                          if (x1 > 0 && x1 < w)                          {                              e.Graphics.DrawLine(pen' x1' ly2' x1' ly1);                          }                          // draw right line                          if (x2 > 0 && x2 < w)                          {                              e.Graphics.DrawLine(pen' x2' ly2' x2' ly1);                          }                      }                  }                    if (m_drawScalePivot)                  {                      Vec2F scalePivot = GraphToClient(m_scalePivot);                      Rectangle pvRect = new Rectangle((int)scalePivot.X - 4' (int)scalePivot.Y - 4' 8' 8);                      e.Graphics.DrawLine(Pens.Black' 0' scalePivot.Y' Width' scalePivot.Y);                      e.Graphics.DrawLine(Pens.Black' scalePivot.X' 0' scalePivot.X' Height);                      e.Graphics.DrawRectangle(Pens.Black' pvRect);                  }                  else if (m_drawInsertLine)                  {                      var insertLinePen = new Pen(m_insertLineColor);                      var insertLineBrush = new SolidBrush(m_insertLineColor);                                            e.Graphics.DrawLine(insertLinePen' CurrentPoint.X' 0' CurrentPoint.X' Height);                      IEnumerable<ICurve> curves = m_editSet.Count > 0 ? (IEnumerable<ICurve>)m_editSet : m_selectedCurves;                      foreach (ICurve curve in curves)                      {                          ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                                                                            float y = cv.Evaluate(CurrentGraphPoint.X);                          Vec2F gpt = new Vec2F(CurrentGraphPoint.X' y);                          Vec2F pt = GraphToClient(gpt);                          RectangleF ptRect = m_mouseRect;                                                                              ptRect.X = pt.X - ptRect.Width / 2;                          ptRect.Y = pt.Y - ptRect.Height / 2;                            bool inCurveLimit                              = AutoComputeCurveLimitsEnabled                              || (gpt.X >= curve.MinX                              && gpt.X <= curve.MaxX                              && gpt.Y >= curve.MinY                              && gpt.Y <= curve.MaxY);                            int index = CurveUtils.GetValidInsertionIndex(curve' CurrentGraphPoint.X);                          if (index >= 0 && inCurveLimit)                          {                              e.Graphics.FillRectangle(insertLineBrush' ptRect);                          }                          else                          {                              pt.X = pt.X - s_noAction.Width / 2;                              pt.Y = pt.Y - s_noAction.Height / 2;                              e.Graphics.DrawImage(s_noAction' pt);                          }                      }                        insertLinePen.Dispose();                      insertLineBrush.Dispose();                  }                    pen.Dispose();                  m_currentX.Draw(e.Graphics);                  DrawPasteAtIndicators(e.Graphics);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: if (m_curves.Count > 0)              {                  float w = ClientSize.Width;                  float h = ClientSize.Height;                    e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                                    // draw axis labels for last selected and visible curve.                                 for (int index = m_selection.Count - 1; index >= 0; index--)                  {                      ICurve curve = m_selection[index].Parent;                      if (curve != null && curve.Visible)                      {                          DrawXYLabel(e.Graphics' curve.XLabel' curve.YLabel' curve.CurveColor);                          break;                      }                  }                    foreach (ICurve curve in m_curves)                  {                                      if (!curve.Visible)                          continue;                      float thickness = m_editSet.Contains(curve) ? 2.6f : 1.0f;                      m_renderer.DrawCurve(curve' e.Graphics' thickness);                  }                    e.Graphics.SmoothingMode = SmoothingMode.None;                  // draw control points.                  foreach (ICurve curve in m_curves)                  {                      if (!curve.Visible)                          continue;                      m_renderer.DrawControlPoints(curve' e.Graphics);                  }                    Pen pen = new Pen(Color.Black' 2);                  // draw curve limits for selected curves.                  foreach (ICurve curve in m_selectedCurves)                  {                      if (!curve.Visible)                          continue;                      Vec2F min = new Vec2F(curve.MinX' curve.MinY);                      Vec2F max = new Vec2F(curve.MaxX' curve.MaxY);                      min = GraphToClient(min);                      max = GraphToClient(max);                      float x1 = min.X;                      float x2 = max.X;                      float y1 = min.Y;                      float y2 = max.Y;                        // to avoind gdi+ overflow and drawing limit where the width or height                       // is less than one pixel.                       // can't use  e.Graphics.DrawRectangle(pen' rect);                         // cull' clip and draw curve limit guide lines.                      pen.Color = curve.CurveColor;                      bool cull = (x1 < 0 && x2 < 0) || (x1 > w && x2 > w);                      if (!cull)                      {                          // clip                          float lx1 = Math.Max(0' x1);                          float lx2 = Math.Min(w' x2);                            // draw top line                          if (y2 > 0 && y2 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y2' lx2' y2);                          }                          // draw bottom line                           if (y1 > 0 && y1 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y1' lx2' y1);                          }                      }                      cull = (y1 < 0 && y2 < 0) || (y1 > h && y2 > h);                      if (!cull)                      {                          // clip                          float ly1 = Math.Min(h' y1);                          float ly2 = Math.Max(0' y2);                          // draw left line                          if (x1 > 0 && x1 < w)                          {                              e.Graphics.DrawLine(pen' x1' ly2' x1' ly1);                          }                          // draw right line                          if (x2 > 0 && x2 < w)                          {                              e.Graphics.DrawLine(pen' x2' ly2' x2' ly1);                          }                      }                  }                    if (m_drawScalePivot)                  {                      Vec2F scalePivot = GraphToClient(m_scalePivot);                      Rectangle pvRect = new Rectangle((int)scalePivot.X - 4' (int)scalePivot.Y - 4' 8' 8);                      e.Graphics.DrawLine(Pens.Black' 0' scalePivot.Y' Width' scalePivot.Y);                      e.Graphics.DrawLine(Pens.Black' scalePivot.X' 0' scalePivot.X' Height);                      e.Graphics.DrawRectangle(Pens.Black' pvRect);                  }                  else if (m_drawInsertLine)                  {                      var insertLinePen = new Pen(m_insertLineColor);                      var insertLineBrush = new SolidBrush(m_insertLineColor);                                            e.Graphics.DrawLine(insertLinePen' CurrentPoint.X' 0' CurrentPoint.X' Height);                      IEnumerable<ICurve> curves = m_editSet.Count > 0 ? (IEnumerable<ICurve>)m_editSet : m_selectedCurves;                      foreach (ICurve curve in curves)                      {                          ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                                                                            float y = cv.Evaluate(CurrentGraphPoint.X);                          Vec2F gpt = new Vec2F(CurrentGraphPoint.X' y);                          Vec2F pt = GraphToClient(gpt);                          RectangleF ptRect = m_mouseRect;                                                                              ptRect.X = pt.X - ptRect.Width / 2;                          ptRect.Y = pt.Y - ptRect.Height / 2;                            bool inCurveLimit                              = AutoComputeCurveLimitsEnabled                              || (gpt.X >= curve.MinX                              && gpt.X <= curve.MaxX                              && gpt.Y >= curve.MinY                              && gpt.Y <= curve.MaxY);                            int index = CurveUtils.GetValidInsertionIndex(curve' CurrentGraphPoint.X);                          if (index >= 0 && inCurveLimit)                          {                              e.Graphics.FillRectangle(insertLineBrush' ptRect);                          }                          else                          {                              pt.X = pt.X - s_noAction.Width / 2;                              pt.Y = pt.Y - s_noAction.Height / 2;                              e.Graphics.DrawImage(s_noAction' pt);                          }                      }                        insertLinePen.Dispose();                      insertLineBrush.Dispose();                  }                    pen.Dispose();                  m_currentX.Draw(e.Graphics);                  DrawPasteAtIndicators(e.Graphics);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: if (m_curves.Count > 0)              {                  float w = ClientSize.Width;                  float h = ClientSize.Height;                    e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                                    // draw axis labels for last selected and visible curve.                                 for (int index = m_selection.Count - 1; index >= 0; index--)                  {                      ICurve curve = m_selection[index].Parent;                      if (curve != null && curve.Visible)                      {                          DrawXYLabel(e.Graphics' curve.XLabel' curve.YLabel' curve.CurveColor);                          break;                      }                  }                    foreach (ICurve curve in m_curves)                  {                                      if (!curve.Visible)                          continue;                      float thickness = m_editSet.Contains(curve) ? 2.6f : 1.0f;                      m_renderer.DrawCurve(curve' e.Graphics' thickness);                  }                    e.Graphics.SmoothingMode = SmoothingMode.None;                  // draw control points.                  foreach (ICurve curve in m_curves)                  {                      if (!curve.Visible)                          continue;                      m_renderer.DrawControlPoints(curve' e.Graphics);                  }                    Pen pen = new Pen(Color.Black' 2);                  // draw curve limits for selected curves.                  foreach (ICurve curve in m_selectedCurves)                  {                      if (!curve.Visible)                          continue;                      Vec2F min = new Vec2F(curve.MinX' curve.MinY);                      Vec2F max = new Vec2F(curve.MaxX' curve.MaxY);                      min = GraphToClient(min);                      max = GraphToClient(max);                      float x1 = min.X;                      float x2 = max.X;                      float y1 = min.Y;                      float y2 = max.Y;                        // to avoind gdi+ overflow and drawing limit where the width or height                       // is less than one pixel.                       // can't use  e.Graphics.DrawRectangle(pen' rect);                         // cull' clip and draw curve limit guide lines.                      pen.Color = curve.CurveColor;                      bool cull = (x1 < 0 && x2 < 0) || (x1 > w && x2 > w);                      if (!cull)                      {                          // clip                          float lx1 = Math.Max(0' x1);                          float lx2 = Math.Min(w' x2);                            // draw top line                          if (y2 > 0 && y2 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y2' lx2' y2);                          }                          // draw bottom line                           if (y1 > 0 && y1 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y1' lx2' y1);                          }                      }                      cull = (y1 < 0 && y2 < 0) || (y1 > h && y2 > h);                      if (!cull)                      {                          // clip                          float ly1 = Math.Min(h' y1);                          float ly2 = Math.Max(0' y2);                          // draw left line                          if (x1 > 0 && x1 < w)                          {                              e.Graphics.DrawLine(pen' x1' ly2' x1' ly1);                          }                          // draw right line                          if (x2 > 0 && x2 < w)                          {                              e.Graphics.DrawLine(pen' x2' ly2' x2' ly1);                          }                      }                  }                    if (m_drawScalePivot)                  {                      Vec2F scalePivot = GraphToClient(m_scalePivot);                      Rectangle pvRect = new Rectangle((int)scalePivot.X - 4' (int)scalePivot.Y - 4' 8' 8);                      e.Graphics.DrawLine(Pens.Black' 0' scalePivot.Y' Width' scalePivot.Y);                      e.Graphics.DrawLine(Pens.Black' scalePivot.X' 0' scalePivot.X' Height);                      e.Graphics.DrawRectangle(Pens.Black' pvRect);                  }                  else if (m_drawInsertLine)                  {                      var insertLinePen = new Pen(m_insertLineColor);                      var insertLineBrush = new SolidBrush(m_insertLineColor);                                            e.Graphics.DrawLine(insertLinePen' CurrentPoint.X' 0' CurrentPoint.X' Height);                      IEnumerable<ICurve> curves = m_editSet.Count > 0 ? (IEnumerable<ICurve>)m_editSet : m_selectedCurves;                      foreach (ICurve curve in curves)                      {                          ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                                                                            float y = cv.Evaluate(CurrentGraphPoint.X);                          Vec2F gpt = new Vec2F(CurrentGraphPoint.X' y);                          Vec2F pt = GraphToClient(gpt);                          RectangleF ptRect = m_mouseRect;                                                                              ptRect.X = pt.X - ptRect.Width / 2;                          ptRect.Y = pt.Y - ptRect.Height / 2;                            bool inCurveLimit                              = AutoComputeCurveLimitsEnabled                              || (gpt.X >= curve.MinX                              && gpt.X <= curve.MaxX                              && gpt.Y >= curve.MinY                              && gpt.Y <= curve.MaxY);                            int index = CurveUtils.GetValidInsertionIndex(curve' CurrentGraphPoint.X);                          if (index >= 0 && inCurveLimit)                          {                              e.Graphics.FillRectangle(insertLineBrush' ptRect);                          }                          else                          {                              pt.X = pt.X - s_noAction.Width / 2;                              pt.Y = pt.Y - s_noAction.Height / 2;                              e.Graphics.DrawImage(s_noAction' pt);                          }                      }                        insertLinePen.Dispose();                      insertLineBrush.Dispose();                  }                    pen.Dispose();                  m_currentX.Draw(e.Graphics);                  DrawPasteAtIndicators(e.Graphics);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: if (m_curves.Count > 0)              {                  float w = ClientSize.Width;                  float h = ClientSize.Height;                    e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                                    // draw axis labels for last selected and visible curve.                                 for (int index = m_selection.Count - 1; index >= 0; index--)                  {                      ICurve curve = m_selection[index].Parent;                      if (curve != null && curve.Visible)                      {                          DrawXYLabel(e.Graphics' curve.XLabel' curve.YLabel' curve.CurveColor);                          break;                      }                  }                    foreach (ICurve curve in m_curves)                  {                                      if (!curve.Visible)                          continue;                      float thickness = m_editSet.Contains(curve) ? 2.6f : 1.0f;                      m_renderer.DrawCurve(curve' e.Graphics' thickness);                  }                    e.Graphics.SmoothingMode = SmoothingMode.None;                  // draw control points.                  foreach (ICurve curve in m_curves)                  {                      if (!curve.Visible)                          continue;                      m_renderer.DrawControlPoints(curve' e.Graphics);                  }                    Pen pen = new Pen(Color.Black' 2);                  // draw curve limits for selected curves.                  foreach (ICurve curve in m_selectedCurves)                  {                      if (!curve.Visible)                          continue;                      Vec2F min = new Vec2F(curve.MinX' curve.MinY);                      Vec2F max = new Vec2F(curve.MaxX' curve.MaxY);                      min = GraphToClient(min);                      max = GraphToClient(max);                      float x1 = min.X;                      float x2 = max.X;                      float y1 = min.Y;                      float y2 = max.Y;                        // to avoind gdi+ overflow and drawing limit where the width or height                       // is less than one pixel.                       // can't use  e.Graphics.DrawRectangle(pen' rect);                         // cull' clip and draw curve limit guide lines.                      pen.Color = curve.CurveColor;                      bool cull = (x1 < 0 && x2 < 0) || (x1 > w && x2 > w);                      if (!cull)                      {                          // clip                          float lx1 = Math.Max(0' x1);                          float lx2 = Math.Min(w' x2);                            // draw top line                          if (y2 > 0 && y2 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y2' lx2' y2);                          }                          // draw bottom line                           if (y1 > 0 && y1 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y1' lx2' y1);                          }                      }                      cull = (y1 < 0 && y2 < 0) || (y1 > h && y2 > h);                      if (!cull)                      {                          // clip                          float ly1 = Math.Min(h' y1);                          float ly2 = Math.Max(0' y2);                          // draw left line                          if (x1 > 0 && x1 < w)                          {                              e.Graphics.DrawLine(pen' x1' ly2' x1' ly1);                          }                          // draw right line                          if (x2 > 0 && x2 < w)                          {                              e.Graphics.DrawLine(pen' x2' ly2' x2' ly1);                          }                      }                  }                    if (m_drawScalePivot)                  {                      Vec2F scalePivot = GraphToClient(m_scalePivot);                      Rectangle pvRect = new Rectangle((int)scalePivot.X - 4' (int)scalePivot.Y - 4' 8' 8);                      e.Graphics.DrawLine(Pens.Black' 0' scalePivot.Y' Width' scalePivot.Y);                      e.Graphics.DrawLine(Pens.Black' scalePivot.X' 0' scalePivot.X' Height);                      e.Graphics.DrawRectangle(Pens.Black' pvRect);                  }                  else if (m_drawInsertLine)                  {                      var insertLinePen = new Pen(m_insertLineColor);                      var insertLineBrush = new SolidBrush(m_insertLineColor);                                            e.Graphics.DrawLine(insertLinePen' CurrentPoint.X' 0' CurrentPoint.X' Height);                      IEnumerable<ICurve> curves = m_editSet.Count > 0 ? (IEnumerable<ICurve>)m_editSet : m_selectedCurves;                      foreach (ICurve curve in curves)                      {                          ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                                                                            float y = cv.Evaluate(CurrentGraphPoint.X);                          Vec2F gpt = new Vec2F(CurrentGraphPoint.X' y);                          Vec2F pt = GraphToClient(gpt);                          RectangleF ptRect = m_mouseRect;                                                                              ptRect.X = pt.X - ptRect.Width / 2;                          ptRect.Y = pt.Y - ptRect.Height / 2;                            bool inCurveLimit                              = AutoComputeCurveLimitsEnabled                              || (gpt.X >= curve.MinX                              && gpt.X <= curve.MaxX                              && gpt.Y >= curve.MinY                              && gpt.Y <= curve.MaxY);                            int index = CurveUtils.GetValidInsertionIndex(curve' CurrentGraphPoint.X);                          if (index >= 0 && inCurveLimit)                          {                              e.Graphics.FillRectangle(insertLineBrush' ptRect);                          }                          else                          {                              pt.X = pt.X - s_noAction.Width / 2;                              pt.Y = pt.Y - s_noAction.Height / 2;                              e.Graphics.DrawImage(s_noAction' pt);                          }                      }                        insertLinePen.Dispose();                      insertLineBrush.Dispose();                  }                    pen.Dispose();                  m_currentX.Draw(e.Graphics);                  DrawPasteAtIndicators(e.Graphics);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: if (m_curves.Count > 0)              {                  float w = ClientSize.Width;                  float h = ClientSize.Height;                    e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                                    // draw axis labels for last selected and visible curve.                                 for (int index = m_selection.Count - 1; index >= 0; index--)                  {                      ICurve curve = m_selection[index].Parent;                      if (curve != null && curve.Visible)                      {                          DrawXYLabel(e.Graphics' curve.XLabel' curve.YLabel' curve.CurveColor);                          break;                      }                  }                    foreach (ICurve curve in m_curves)                  {                                      if (!curve.Visible)                          continue;                      float thickness = m_editSet.Contains(curve) ? 2.6f : 1.0f;                      m_renderer.DrawCurve(curve' e.Graphics' thickness);                  }                    e.Graphics.SmoothingMode = SmoothingMode.None;                  // draw control points.                  foreach (ICurve curve in m_curves)                  {                      if (!curve.Visible)                          continue;                      m_renderer.DrawControlPoints(curve' e.Graphics);                  }                    Pen pen = new Pen(Color.Black' 2);                  // draw curve limits for selected curves.                  foreach (ICurve curve in m_selectedCurves)                  {                      if (!curve.Visible)                          continue;                      Vec2F min = new Vec2F(curve.MinX' curve.MinY);                      Vec2F max = new Vec2F(curve.MaxX' curve.MaxY);                      min = GraphToClient(min);                      max = GraphToClient(max);                      float x1 = min.X;                      float x2 = max.X;                      float y1 = min.Y;                      float y2 = max.Y;                        // to avoind gdi+ overflow and drawing limit where the width or height                       // is less than one pixel.                       // can't use  e.Graphics.DrawRectangle(pen' rect);                         // cull' clip and draw curve limit guide lines.                      pen.Color = curve.CurveColor;                      bool cull = (x1 < 0 && x2 < 0) || (x1 > w && x2 > w);                      if (!cull)                      {                          // clip                          float lx1 = Math.Max(0' x1);                          float lx2 = Math.Min(w' x2);                            // draw top line                          if (y2 > 0 && y2 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y2' lx2' y2);                          }                          // draw bottom line                           if (y1 > 0 && y1 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y1' lx2' y1);                          }                      }                      cull = (y1 < 0 && y2 < 0) || (y1 > h && y2 > h);                      if (!cull)                      {                          // clip                          float ly1 = Math.Min(h' y1);                          float ly2 = Math.Max(0' y2);                          // draw left line                          if (x1 > 0 && x1 < w)                          {                              e.Graphics.DrawLine(pen' x1' ly2' x1' ly1);                          }                          // draw right line                          if (x2 > 0 && x2 < w)                          {                              e.Graphics.DrawLine(pen' x2' ly2' x2' ly1);                          }                      }                  }                    if (m_drawScalePivot)                  {                      Vec2F scalePivot = GraphToClient(m_scalePivot);                      Rectangle pvRect = new Rectangle((int)scalePivot.X - 4' (int)scalePivot.Y - 4' 8' 8);                      e.Graphics.DrawLine(Pens.Black' 0' scalePivot.Y' Width' scalePivot.Y);                      e.Graphics.DrawLine(Pens.Black' scalePivot.X' 0' scalePivot.X' Height);                      e.Graphics.DrawRectangle(Pens.Black' pvRect);                  }                  else if (m_drawInsertLine)                  {                      var insertLinePen = new Pen(m_insertLineColor);                      var insertLineBrush = new SolidBrush(m_insertLineColor);                                            e.Graphics.DrawLine(insertLinePen' CurrentPoint.X' 0' CurrentPoint.X' Height);                      IEnumerable<ICurve> curves = m_editSet.Count > 0 ? (IEnumerable<ICurve>)m_editSet : m_selectedCurves;                      foreach (ICurve curve in curves)                      {                          ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                                                                            float y = cv.Evaluate(CurrentGraphPoint.X);                          Vec2F gpt = new Vec2F(CurrentGraphPoint.X' y);                          Vec2F pt = GraphToClient(gpt);                          RectangleF ptRect = m_mouseRect;                                                                              ptRect.X = pt.X - ptRect.Width / 2;                          ptRect.Y = pt.Y - ptRect.Height / 2;                            bool inCurveLimit                              = AutoComputeCurveLimitsEnabled                              || (gpt.X >= curve.MinX                              && gpt.X <= curve.MaxX                              && gpt.Y >= curve.MinY                              && gpt.Y <= curve.MaxY);                            int index = CurveUtils.GetValidInsertionIndex(curve' CurrentGraphPoint.X);                          if (index >= 0 && inCurveLimit)                          {                              e.Graphics.FillRectangle(insertLineBrush' ptRect);                          }                          else                          {                              pt.X = pt.X - s_noAction.Width / 2;                              pt.Y = pt.Y - s_noAction.Height / 2;                              e.Graphics.DrawImage(s_noAction' pt);                          }                      }                        insertLinePen.Dispose();                      insertLineBrush.Dispose();                  }                    pen.Dispose();                  m_currentX.Draw(e.Graphics);                  DrawPasteAtIndicators(e.Graphics);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: if (m_curves.Count > 0)              {                  float w = ClientSize.Width;                  float h = ClientSize.Height;                    e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                                    // draw axis labels for last selected and visible curve.                                 for (int index = m_selection.Count - 1; index >= 0; index--)                  {                      ICurve curve = m_selection[index].Parent;                      if (curve != null && curve.Visible)                      {                          DrawXYLabel(e.Graphics' curve.XLabel' curve.YLabel' curve.CurveColor);                          break;                      }                  }                    foreach (ICurve curve in m_curves)                  {                                      if (!curve.Visible)                          continue;                      float thickness = m_editSet.Contains(curve) ? 2.6f : 1.0f;                      m_renderer.DrawCurve(curve' e.Graphics' thickness);                  }                    e.Graphics.SmoothingMode = SmoothingMode.None;                  // draw control points.                  foreach (ICurve curve in m_curves)                  {                      if (!curve.Visible)                          continue;                      m_renderer.DrawControlPoints(curve' e.Graphics);                  }                    Pen pen = new Pen(Color.Black' 2);                  // draw curve limits for selected curves.                  foreach (ICurve curve in m_selectedCurves)                  {                      if (!curve.Visible)                          continue;                      Vec2F min = new Vec2F(curve.MinX' curve.MinY);                      Vec2F max = new Vec2F(curve.MaxX' curve.MaxY);                      min = GraphToClient(min);                      max = GraphToClient(max);                      float x1 = min.X;                      float x2 = max.X;                      float y1 = min.Y;                      float y2 = max.Y;                        // to avoind gdi+ overflow and drawing limit where the width or height                       // is less than one pixel.                       // can't use  e.Graphics.DrawRectangle(pen' rect);                         // cull' clip and draw curve limit guide lines.                      pen.Color = curve.CurveColor;                      bool cull = (x1 < 0 && x2 < 0) || (x1 > w && x2 > w);                      if (!cull)                      {                          // clip                          float lx1 = Math.Max(0' x1);                          float lx2 = Math.Min(w' x2);                            // draw top line                          if (y2 > 0 && y2 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y2' lx2' y2);                          }                          // draw bottom line                           if (y1 > 0 && y1 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y1' lx2' y1);                          }                      }                      cull = (y1 < 0 && y2 < 0) || (y1 > h && y2 > h);                      if (!cull)                      {                          // clip                          float ly1 = Math.Min(h' y1);                          float ly2 = Math.Max(0' y2);                          // draw left line                          if (x1 > 0 && x1 < w)                          {                              e.Graphics.DrawLine(pen' x1' ly2' x1' ly1);                          }                          // draw right line                          if (x2 > 0 && x2 < w)                          {                              e.Graphics.DrawLine(pen' x2' ly2' x2' ly1);                          }                      }                  }                    if (m_drawScalePivot)                  {                      Vec2F scalePivot = GraphToClient(m_scalePivot);                      Rectangle pvRect = new Rectangle((int)scalePivot.X - 4' (int)scalePivot.Y - 4' 8' 8);                      e.Graphics.DrawLine(Pens.Black' 0' scalePivot.Y' Width' scalePivot.Y);                      e.Graphics.DrawLine(Pens.Black' scalePivot.X' 0' scalePivot.X' Height);                      e.Graphics.DrawRectangle(Pens.Black' pvRect);                  }                  else if (m_drawInsertLine)                  {                      var insertLinePen = new Pen(m_insertLineColor);                      var insertLineBrush = new SolidBrush(m_insertLineColor);                                            e.Graphics.DrawLine(insertLinePen' CurrentPoint.X' 0' CurrentPoint.X' Height);                      IEnumerable<ICurve> curves = m_editSet.Count > 0 ? (IEnumerable<ICurve>)m_editSet : m_selectedCurves;                      foreach (ICurve curve in curves)                      {                          ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                                                                            float y = cv.Evaluate(CurrentGraphPoint.X);                          Vec2F gpt = new Vec2F(CurrentGraphPoint.X' y);                          Vec2F pt = GraphToClient(gpt);                          RectangleF ptRect = m_mouseRect;                                                                              ptRect.X = pt.X - ptRect.Width / 2;                          ptRect.Y = pt.Y - ptRect.Height / 2;                            bool inCurveLimit                              = AutoComputeCurveLimitsEnabled                              || (gpt.X >= curve.MinX                              && gpt.X <= curve.MaxX                              && gpt.Y >= curve.MinY                              && gpt.Y <= curve.MaxY);                            int index = CurveUtils.GetValidInsertionIndex(curve' CurrentGraphPoint.X);                          if (index >= 0 && inCurveLimit)                          {                              e.Graphics.FillRectangle(insertLineBrush' ptRect);                          }                          else                          {                              pt.X = pt.X - s_noAction.Width / 2;                              pt.Y = pt.Y - s_noAction.Height / 2;                              e.Graphics.DrawImage(s_noAction' pt);                          }                      }                        insertLinePen.Dispose();                      insertLineBrush.Dispose();                  }                    pen.Dispose();                  m_currentX.Draw(e.Graphics);                  DrawPasteAtIndicators(e.Graphics);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: if (m_curves.Count > 0)              {                  float w = ClientSize.Width;                  float h = ClientSize.Height;                    e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;                                    // draw axis labels for last selected and visible curve.                                 for (int index = m_selection.Count - 1; index >= 0; index--)                  {                      ICurve curve = m_selection[index].Parent;                      if (curve != null && curve.Visible)                      {                          DrawXYLabel(e.Graphics' curve.XLabel' curve.YLabel' curve.CurveColor);                          break;                      }                  }                    foreach (ICurve curve in m_curves)                  {                                      if (!curve.Visible)                          continue;                      float thickness = m_editSet.Contains(curve) ? 2.6f : 1.0f;                      m_renderer.DrawCurve(curve' e.Graphics' thickness);                  }                    e.Graphics.SmoothingMode = SmoothingMode.None;                  // draw control points.                  foreach (ICurve curve in m_curves)                  {                      if (!curve.Visible)                          continue;                      m_renderer.DrawControlPoints(curve' e.Graphics);                  }                    Pen pen = new Pen(Color.Black' 2);                  // draw curve limits for selected curves.                  foreach (ICurve curve in m_selectedCurves)                  {                      if (!curve.Visible)                          continue;                      Vec2F min = new Vec2F(curve.MinX' curve.MinY);                      Vec2F max = new Vec2F(curve.MaxX' curve.MaxY);                      min = GraphToClient(min);                      max = GraphToClient(max);                      float x1 = min.X;                      float x2 = max.X;                      float y1 = min.Y;                      float y2 = max.Y;                        // to avoind gdi+ overflow and drawing limit where the width or height                       // is less than one pixel.                       // can't use  e.Graphics.DrawRectangle(pen' rect);                         // cull' clip and draw curve limit guide lines.                      pen.Color = curve.CurveColor;                      bool cull = (x1 < 0 && x2 < 0) || (x1 > w && x2 > w);                      if (!cull)                      {                          // clip                          float lx1 = Math.Max(0' x1);                          float lx2 = Math.Min(w' x2);                            // draw top line                          if (y2 > 0 && y2 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y2' lx2' y2);                          }                          // draw bottom line                           if (y1 > 0 && y1 < h)                          {                              e.Graphics.DrawLine(pen' lx1' y1' lx2' y1);                          }                      }                      cull = (y1 < 0 && y2 < 0) || (y1 > h && y2 > h);                      if (!cull)                      {                          // clip                          float ly1 = Math.Min(h' y1);                          float ly2 = Math.Max(0' y2);                          // draw left line                          if (x1 > 0 && x1 < w)                          {                              e.Graphics.DrawLine(pen' x1' ly2' x1' ly1);                          }                          // draw right line                          if (x2 > 0 && x2 < w)                          {                              e.Graphics.DrawLine(pen' x2' ly2' x2' ly1);                          }                      }                  }                    if (m_drawScalePivot)                  {                      Vec2F scalePivot = GraphToClient(m_scalePivot);                      Rectangle pvRect = new Rectangle((int)scalePivot.X - 4' (int)scalePivot.Y - 4' 8' 8);                      e.Graphics.DrawLine(Pens.Black' 0' scalePivot.Y' Width' scalePivot.Y);                      e.Graphics.DrawLine(Pens.Black' scalePivot.X' 0' scalePivot.X' Height);                      e.Graphics.DrawRectangle(Pens.Black' pvRect);                  }                  else if (m_drawInsertLine)                  {                      var insertLinePen = new Pen(m_insertLineColor);                      var insertLineBrush = new SolidBrush(m_insertLineColor);                                            e.Graphics.DrawLine(insertLinePen' CurrentPoint.X' 0' CurrentPoint.X' Height);                      IEnumerable<ICurve> curves = m_editSet.Count > 0 ? (IEnumerable<ICurve>)m_editSet : m_selectedCurves;                      foreach (ICurve curve in curves)                      {                          ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                                                                            float y = cv.Evaluate(CurrentGraphPoint.X);                          Vec2F gpt = new Vec2F(CurrentGraphPoint.X' y);                          Vec2F pt = GraphToClient(gpt);                          RectangleF ptRect = m_mouseRect;                                                                              ptRect.X = pt.X - ptRect.Width / 2;                          ptRect.Y = pt.Y - ptRect.Height / 2;                            bool inCurveLimit                              = AutoComputeCurveLimitsEnabled                              || (gpt.X >= curve.MinX                              && gpt.X <= curve.MaxX                              && gpt.Y >= curve.MinY                              && gpt.Y <= curve.MaxY);                            int index = CurveUtils.GetValidInsertionIndex(curve' CurrentGraphPoint.X);                          if (index >= 0 && inCurveLimit)                          {                              e.Graphics.FillRectangle(insertLineBrush' ptRect);                          }                          else                          {                              pt.X = pt.X - s_noAction.Width / 2;                              pt.Y = pt.Y - s_noAction.Height / 2;                              e.Graphics.DrawImage(s_noAction' pt);                          }                      }                        insertLinePen.Dispose();                      insertLineBrush.Dispose();                  }                    pen.Dispose();                  m_currentX.Draw(e.Graphics);                  DrawPasteAtIndicators(e.Graphics);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DrawPasteAtIndicators,The following statement contains a magic number: RectangleF ptRect = new RectangleF(0' 0' 9' 9);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DrawPasteAtIndicators,The following statement contains a magic number: RectangleF ptRect = new RectangleF(0' 0' 9' 9);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DrawPasteAtIndicators,The following statement contains a magic number: if (m_pasteOptions.Connect)              {                    foreach (var curve in targeCurves)                  {                      ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                      float gy = cv.Evaluate(gx) + m_pasteOptions.YOffset;                        Vec2F gpt = new Vec2F(gx' gy);                      Vec2F pt = GraphToClient(gpt);                      ptRect.X = pt.X - ptRect.Width / 2;                      ptRect.Y = pt.Y - ptRect.Height / 2;                      g.FillEllipse(s_genBrush' ptRect);                  }              }              else              {                  float gy = s_clipboard[0].Y + m_pasteOptions.YOffset;                  Vec2F gpt = new Vec2F(gx' gy);                  Vec2F pt = GraphToClient(gpt);                  ptRect.X = pt.X - ptRect.Width / 2;                  ptRect.Y = pt.Y - ptRect.Height / 2;                  g.FillEllipse(s_genBrush' ptRect);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DrawPasteAtIndicators,The following statement contains a magic number: if (m_pasteOptions.Connect)              {                    foreach (var curve in targeCurves)                  {                      ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                      float gy = cv.Evaluate(gx) + m_pasteOptions.YOffset;                        Vec2F gpt = new Vec2F(gx' gy);                      Vec2F pt = GraphToClient(gpt);                      ptRect.X = pt.X - ptRect.Width / 2;                      ptRect.Y = pt.Y - ptRect.Height / 2;                      g.FillEllipse(s_genBrush' ptRect);                  }              }              else              {                  float gy = s_clipboard[0].Y + m_pasteOptions.YOffset;                  Vec2F gpt = new Vec2F(gx' gy);                  Vec2F pt = GraphToClient(gpt);                  ptRect.X = pt.X - ptRect.Width / 2;                  ptRect.Y = pt.Y - ptRect.Height / 2;                  g.FillEllipse(s_genBrush' ptRect);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DrawPasteAtIndicators,The following statement contains a magic number: if (m_pasteOptions.Connect)              {                    foreach (var curve in targeCurves)                  {                      ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                      float gy = cv.Evaluate(gx) + m_pasteOptions.YOffset;                        Vec2F gpt = new Vec2F(gx' gy);                      Vec2F pt = GraphToClient(gpt);                      ptRect.X = pt.X - ptRect.Width / 2;                      ptRect.Y = pt.Y - ptRect.Height / 2;                      g.FillEllipse(s_genBrush' ptRect);                  }              }              else              {                  float gy = s_clipboard[0].Y + m_pasteOptions.YOffset;                  Vec2F gpt = new Vec2F(gx' gy);                  Vec2F pt = GraphToClient(gpt);                  ptRect.X = pt.X - ptRect.Width / 2;                  ptRect.Y = pt.Y - ptRect.Height / 2;                  g.FillEllipse(s_genBrush' ptRect);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DrawPasteAtIndicators,The following statement contains a magic number: if (m_pasteOptions.Connect)              {                    foreach (var curve in targeCurves)                  {                      ICurveEvaluator cv = CurveUtils.CreateCurveEvaluator(curve);                      float gy = cv.Evaluate(gx) + m_pasteOptions.YOffset;                        Vec2F gpt = new Vec2F(gx' gy);                      Vec2F pt = GraphToClient(gpt);                      ptRect.X = pt.X - ptRect.Width / 2;                      ptRect.Y = pt.Y - ptRect.Height / 2;                      g.FillEllipse(s_genBrush' ptRect);                  }              }              else              {                  float gy = s_clipboard[0].Y + m_pasteOptions.YOffset;                  Vec2F gpt = new Vec2F(gx' gy);                  Vec2F pt = GraphToClient(gpt);                  ptRect.X = pt.X - ptRect.Width / 2;                  ptRect.Y = pt.Y - ptRect.Height / 2;                  g.FillEllipse(s_genBrush' ptRect);              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,BasicOnMouseDown,The following statement contains a magic number: if (e.Button == MouseButtons.Left || e.Button == MouseButtons.Middle)              {                  if (Control.ModifierKeys == Keys.None && e.Button == MouseButtons.Left)                  {                      m_limitHit = PickCurveLimits(out m_limitSide);                                          if (m_limitHit != null)                      {                          m_mouseDownAction = MouseDownAction.CurveLimitResize;                          Cursor = (m_limitSide == CurveLimitSides.Left ||                             m_limitSide == CurveLimitSides.Right) ? m_cursors[CursorType.MoveHz]                             : m_cursors[CursorType.MoveVert];                      }                      else                      {                          List<IControlPoint> points = new List<IControlPoint>();                          List<PointSelectionRegions> regions = new List<PointSelectionRegions>();                          RectangleF pickRect = m_mouseRect;                          pickRect.X = CurrentPoint.X - m_mouseRect.Width / 2;                          pickRect.Y = CurrentPoint.Y - m_mouseRect.Height / 2;                          m_renderer.PickPoints(m_pickableCurves' pickRect' points' regions' true);                          IControlPoint pickedpt = (points.Count > 0) ? points[0] : null;                          PointSelectionRegions pickedRegion =                              (regions.Count > 0) ? regions[0] : PointSelectionRegions.None;                          if (pickedpt != null)                          {                              if (!m_selection.Contains(pickedpt))                              {                                  SetSelection(points' regions);                                }                              else if (pickedpt.EditorData.SelectedRegion != pickedRegion)                              {                                  SetSelection(points' regions);                              }                                                          m_mouseDownAction = MouseDownAction.FreeMove;                              saveSelection = true;                          }                          else                          {                              m_mouseDownAction = MouseDownAction.SelectionRectangle;                          }                      }                  }                  else if (Control.ModifierKeys == Keys.Shift)                  {                      if (m_editSet.Count > 0 || m_selection.Count > 0 || m_visibleCurveCount == 1)                          editAction = MouseEditAction.AddControlPoint;                      else if (m_curves.Count > 0)                          editAction = MouseEditAction.AddControlPointToEmptyCurve;                      }                  else if (Control.ModifierKeys == Keys.Alt)                  {                      m_mouseDownAction = MouseDownAction.Pan;                      Cursor = m_cursors[CursorType.Pan];                    }              }              else if (e.Button == MouseButtons.Right && Control.ModifierKeys == Keys.Alt)              {                  m_mouseDownAction = MouseDownAction.Zoom;              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,BasicOnMouseDown,The following statement contains a magic number: if (e.Button == MouseButtons.Left || e.Button == MouseButtons.Middle)              {                  if (Control.ModifierKeys == Keys.None && e.Button == MouseButtons.Left)                  {                      m_limitHit = PickCurveLimits(out m_limitSide);                                          if (m_limitHit != null)                      {                          m_mouseDownAction = MouseDownAction.CurveLimitResize;                          Cursor = (m_limitSide == CurveLimitSides.Left ||                             m_limitSide == CurveLimitSides.Right) ? m_cursors[CursorType.MoveHz]                             : m_cursors[CursorType.MoveVert];                      }                      else                      {                          List<IControlPoint> points = new List<IControlPoint>();                          List<PointSelectionRegions> regions = new List<PointSelectionRegions>();                          RectangleF pickRect = m_mouseRect;                          pickRect.X = CurrentPoint.X - m_mouseRect.Width / 2;                          pickRect.Y = CurrentPoint.Y - m_mouseRect.Height / 2;                          m_renderer.PickPoints(m_pickableCurves' pickRect' points' regions' true);                          IControlPoint pickedpt = (points.Count > 0) ? points[0] : null;                          PointSelectionRegions pickedRegion =                              (regions.Count > 0) ? regions[0] : PointSelectionRegions.None;                          if (pickedpt != null)                          {                              if (!m_selection.Contains(pickedpt))                              {                                  SetSelection(points' regions);                                }                              else if (pickedpt.EditorData.SelectedRegion != pickedRegion)                              {                                  SetSelection(points' regions);                              }                                                          m_mouseDownAction = MouseDownAction.FreeMove;                              saveSelection = true;                          }                          else                          {                              m_mouseDownAction = MouseDownAction.SelectionRectangle;                          }                      }                  }                  else if (Control.ModifierKeys == Keys.Shift)                  {                      if (m_editSet.Count > 0 || m_selection.Count > 0 || m_visibleCurveCount == 1)                          editAction = MouseEditAction.AddControlPoint;                      else if (m_curves.Count > 0)                          editAction = MouseEditAction.AddControlPointToEmptyCurve;                      }                  else if (Control.ModifierKeys == Keys.Alt)                  {                      m_mouseDownAction = MouseDownAction.Pan;                      Cursor = m_cursors[CursorType.Pan];                    }              }              else if (e.Button == MouseButtons.Right && Control.ModifierKeys == Keys.Alt)              {                  m_mouseDownAction = MouseDownAction.Zoom;              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PerformAction,The following statement contains a magic number: if (DraggingOverThreshold)              {                  pickRect = SelectionRect;              }              else              {                  pickRect = m_mouseRect;                  pickRect.X = CurrentPoint.X - m_mouseRect.Width / 2;                  pickRect.Y = CurrentPoint.Y - m_mouseRect.Height / 2;              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PerformAction,The following statement contains a magic number: if (DraggingOverThreshold)              {                  pickRect = SelectionRect;              }              else              {                  pickRect = m_mouseRect;                  pickRect.X = CurrentPoint.X - m_mouseRect.Width / 2;                  pickRect.Y = CurrentPoint.Y - m_mouseRect.Height / 2;              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PickCurveLimits,The following statement contains a magic number: const float pickTol = 4;
Magic Number,Sce.Atf.Controls.CurveEditing,CurrentX,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,CurrentX,The following statement contains a magic number: HoverColor = Color.FromArgb(255' 255' 128);
Magic Number,Sce.Atf.Controls.CurveEditing,CurrentX,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,CurrentX,The following statement contains a magic number: HoverColor = Color.FromArgb(255' 255' 128);
Magic Number,Sce.Atf.Controls.CurveEditing,CurrentX,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,CurrentX,The following statement contains a magic number: HoverColor = Color.FromArgb(255' 255' 128);
Magic Number,Sce.Atf.Controls.CurveEditing,CurrentX,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,HitTest,The following statement contains a magic number: const float pickTolerance = 3;
Magic Number,Sce.Atf.Controls.CurveEditing,CurrentX,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,Draw,The following statement contains a magic number: if (m_setInitialPosition)                  {// one time' set initial position.                      m_setInitialPosition = false;                      float xs = m_canvas.ClientRectangle.Width / 2;                      Position = m_canvas.ClientToGraph(xs);                  }
Magic Number,Sce.Atf.Controls.CurveEditing,CurrentX,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,Draw,The following statement contains a magic number: float leftEdge = crect.X + 3;
Magic Number,Sce.Atf.Controls.CurveEditing,CurrentX,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,Draw,The following statement contains a magic number: float rightEdge = crect.Right - 3;
Magic Number,Sce.Atf.Controls.CurveEditing,CurrentX,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,Draw,The following statement contains a magic number: string strVal = Math.Round(Position' 4).ToString();
Magic Number,Sce.Atf.Controls.CurveEditing,CurrentX,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,Draw,The following statement contains a magic number: g.DrawString(strVal' m_canvas.ScaleTextFont' s_brush' new PointF(cPos + 4' strValY));
Magic Number,Sce.Atf.Controls.CurveEditing,CustomToolStripMenuItem,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,GetButtonRect,The following statement contains a magic number: buttonRect.Height -= (2 * ButtonMargin + 1);
Magic Number,Sce.Atf.Controls.CurveEditing,CustomToolStripMenuItem,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: if (!m_mouseIsOnButton && Enabled && Selected)                  {                                          using (Brush b = new SolidBrush(bkgColor))                      {                          var fillRect = ContentRectangle;                          fillRect.X = m_buttonRect.X - ButtonMargin;                          fillRect.Width = ContentRectangle.Right - fillRect.X + 1;                          fillRect.Y -= 1;                          fillRect.Height += 2;                            e.Graphics.FillRectangle(b' fillRect);                                             }                  }
Magic Number,Sce.Atf.Controls.CurveEditing,CustomToolStripMenuItem,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: using (Pen p = new Pen(borderColor))                  {                      e.Graphics.DrawRectangle(p' m_buttonRect);                      var dotRect = m_buttonRect;                      dotRect.Size = new Size(1' 1);                      dotRect.Y = m_buttonRect.Bottom - 2;                      dotRect.X += (m_buttonRect.Width - 5) / 2;                      Brush b = new SolidBrush(borderColor);                        e.Graphics.FillRectangle(b' dotRect);                      dotRect.X += 2;                      e.Graphics.FillRectangle(b' dotRect);                      dotRect.X += 2;                      e.Graphics.FillRectangle(b' dotRect);                  }
Magic Number,Sce.Atf.Controls.CurveEditing,CustomToolStripMenuItem,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: using (Pen p = new Pen(borderColor))                  {                      e.Graphics.DrawRectangle(p' m_buttonRect);                      var dotRect = m_buttonRect;                      dotRect.Size = new Size(1' 1);                      dotRect.Y = m_buttonRect.Bottom - 2;                      dotRect.X += (m_buttonRect.Width - 5) / 2;                      Brush b = new SolidBrush(borderColor);                        e.Graphics.FillRectangle(b' dotRect);                      dotRect.X += 2;                      e.Graphics.FillRectangle(b' dotRect);                      dotRect.X += 2;                      e.Graphics.FillRectangle(b' dotRect);                  }
Magic Number,Sce.Atf.Controls.CurveEditing,CustomToolStripMenuItem,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: using (Pen p = new Pen(borderColor))                  {                      e.Graphics.DrawRectangle(p' m_buttonRect);                      var dotRect = m_buttonRect;                      dotRect.Size = new Size(1' 1);                      dotRect.Y = m_buttonRect.Bottom - 2;                      dotRect.X += (m_buttonRect.Width - 5) / 2;                      Brush b = new SolidBrush(borderColor);                        e.Graphics.FillRectangle(b' dotRect);                      dotRect.X += 2;                      e.Graphics.FillRectangle(b' dotRect);                      dotRect.X += 2;                      e.Graphics.FillRectangle(b' dotRect);                  }
Magic Number,Sce.Atf.Controls.CurveEditing,CustomToolStripMenuItem,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: using (Pen p = new Pen(borderColor))                  {                      e.Graphics.DrawRectangle(p' m_buttonRect);                      var dotRect = m_buttonRect;                      dotRect.Size = new Size(1' 1);                      dotRect.Y = m_buttonRect.Bottom - 2;                      dotRect.X += (m_buttonRect.Width - 5) / 2;                      Brush b = new SolidBrush(borderColor);                        e.Graphics.FillRectangle(b' dotRect);                      dotRect.X += 2;                      e.Graphics.FillRectangle(b' dotRect);                      dotRect.X += 2;                      e.Graphics.FillRectangle(b' dotRect);                  }
Magic Number,Sce.Atf.Controls.CurveEditing,CustomToolStripMenuItem,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnPaint,The following statement contains a magic number: using (Pen p = new Pen(borderColor))                  {                      e.Graphics.DrawRectangle(p' m_buttonRect);                      var dotRect = m_buttonRect;                      dotRect.Size = new Size(1' 1);                      dotRect.Y = m_buttonRect.Bottom - 2;                      dotRect.X += (m_buttonRect.Width - 5) / 2;                      Brush b = new SolidBrush(borderColor);                        e.Graphics.FillRectangle(b' dotRect);                      dotRect.X += 2;                      e.Graphics.FillRectangle(b' dotRect);                      dotRect.X += 2;                      e.Graphics.FillRectangle(b' dotRect);                  }
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_startField = new InputField<float>("Start".Localize()' 150);
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_xOffsetField = new InputField<float>("X Offset".Localize()' 150);
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_yOffsetField = new InputField<float>("Y Offset".Localize()' 150);
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_copiesField = new InputField<uint>("Copies".Localize()' 100);
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: ClientSize = new Size(530' 410);
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: ClientSize = new Size(530' 410);
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_clipboardRdo.TabIndex = 2;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_startField.TabIndex = 3;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_xOffsetField.TabIndex = 4;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_yOffsetField.TabIndex = 5;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_copiesField.TabIndex = 6;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_mergeRdo.TabIndex = 2;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_connectChk.TabIndex = 3;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_buttonsPanel.TabIndex = 2;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,PasteOptionsForm,The following statement contains a magic number: m_closeBtn.TabIndex = 2;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: int outerMargin = 4;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: int grpLeftRightMargin = 16;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: int leftPadding = 30;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: int vSpacing = 8;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: int vSpacingGrp = 16;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: int hSpacing = 4;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: int pad = 16;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: int cw = ClientSize.Width - 2 * grpLeftRightMargin;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: m_pasteAtgrp.Height = m_currentRdo.Height + 2 * pad + 3 * vSpacingGrp + vSpacing + 4 * m_startField.Height;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: m_pasteAtgrp.Height = m_currentRdo.Height + 2 * pad + 3 * vSpacingGrp + vSpacing + 4 * m_startField.Height;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: m_pasteAtgrp.Height = m_currentRdo.Height + 2 * pad + 3 * vSpacingGrp + vSpacing + 4 * m_startField.Height;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: int txtLeft = m_xlocLbl.Width + 6;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: m_xlocLbl.Location = new Point(leftPadding' pad + (m_startRdo.Height - m_xlocLbl.Height) / 2);
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: m_pasteMethodGrp.Height = 2 * pad + m_insertRdo.Height + vSpacing + m_connectChk.Height;
Magic Number,Sce.Atf.Controls.CurveEditing,PasteOptionsForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: btnW = Math.Max(btnW' okBtnW) * 2;
Magic Number,Sce.Atf.Controls.CurveEditing,InputField<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,InputField,The following statement contains a magic number: if (m_txtWidth < 20) m_txtWidth = 20;
Magic Number,Sce.Atf.Controls.CurveEditing,InputField<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,InputField,The following statement contains a magic number: if (m_txtWidth < 20) m_txtWidth = 20;
Magic Number,Sce.Atf.Controls.CurveEditing,InputField<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,InputField,The following statement contains a magic number: m_txtBox.Location = new Point(26' 1);
Magic Number,Sce.Atf.Controls.CurveEditing,InputField<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,InputField,The following statement contains a magic number: m_txtBox.Size = new Size(m_txtWidth' 30);
Magic Number,Sce.Atf.Controls.CurveEditing,InputField<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,InputField,The following statement contains a magic number: Size = new Size(200' 30);
Magic Number,Sce.Atf.Controls.CurveEditing,InputField<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,InputField,The following statement contains a magic number: Size = new Size(200' 30);
Magic Number,Sce.Atf.Controls.CurveEditing,InputField<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: Width = m_label.Width + m_txtBox.Width + 3;
Magic Number,Sce.Atf.Controls.CurveEditing,InputField<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: m_label.Location = new Point(1' (Height - m_label.Height) / 2);
Magic Number,Sce.Atf.Controls.CurveEditing,InputField<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,DoLayout,The following statement contains a magic number: m_txtBox.Location = new Point(m_label.Bounds.Right' (Height - m_txtBox.Height) / 2);
Magic Number,Sce.Atf.Controls.CurveEditing,NumberTextBox<T>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,OnMouseDown,The following statement contains a magic number: if (e.Button == MouseButtons.Left &&                          e.Clicks == 2)                      {                          SelectAll();                          return;                      }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_editModeButtons = new ToolStripButton[4];
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentBtns = new ToolStripButton[5];
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_infinityBtns = new ToolStripButton[4];
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_menu.Size = new Size(898' 31);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_menu.Size = new Size(898' 31);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentsMenuItem.Size = new Size(100' 27);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentsMenuItem.Size = new Size(100' 27);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_InTangentMenuItem.Size = new Size(205' 28);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_InTangentMenuItem.Size = new Size(205' 28);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_outTangentMenuItem.Size = new Size(205' 28);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_outTangentMenuItem.Size = new Size(205' 28);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_curveTypeSelector.Width = 70;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_topStrip.Location = new Point(0' 31);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_topStrip.Size = new Size(898' 32);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_topStrip.Size = new Size(898' 32);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_topStrip.MinimumSize = new Size(32' 32);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_topStrip.MinimumSize = new Size(32' 32);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_editModeButtons[2].Name = "InsertPoint";
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_editModeButtons[2].Tag = EditModes.InsertPoint;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_editModeButtons[2].Image = new Bitmap(typeof(CurveUtils)' "Resources.InsertKeysTool.png");
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_editModeButtons[2].ToolTipText = "Insert control point";
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_editModeButtons[3].Name = "AddPoint";
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_editModeButtons[3].Tag = EditModes.AddPoint;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_editModeButtons[3].Image = new Bitmap(typeof(CurveUtils)' "Resources.AddKeysTool.png");
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_editModeButtons[3].ToolTipText = "Add control point";
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_xTxtBox.Size = new Size(100' 30);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_xTxtBox.Size = new Size(100' 30);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_yTxtBox.Size = new Size(100' 30);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_yTxtBox.Size = new Size(100' 30);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentBtns[2].Tag = CurveTangentTypes.Linear;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentBtns[2].Image = new Bitmap(typeof(CurveUtils)' "Resources.LinearTangents.png");
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentBtns[2].ToolTipText = "Linear";
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentBtns[3].Tag = CurveTangentTypes.Flat;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentBtns[3].Image = new Bitmap(typeof(CurveUtils)' "Resources.FlatTangents.png");
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentBtns[3].ToolTipText = "Flat";
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentBtns[4].Tag = CurveTangentTypes.Stepped;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentBtns[4].Image = new Bitmap(typeof(CurveUtils)' "Resources.StepTangents.png");
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_tangentBtns[4].ToolTipText = "Step";
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: for (int i = 2; i <= 3; i++)              {                  m_infinityBtns[i].DisplayStyle = ToolStripItemDisplayStyle.Image;                  m_infinityBtns[i].Alignment = ToolStripItemAlignment.Left;                  m_infinityBtns[i].Name = "m_infinityBtns" + i;                  m_infinityBtns[i].ImageScaling = ToolStripItemImageScaling.None;                  m_infinityBtns[i].Click += delegate(object sender' EventArgs e)                  {                      var btn = sender as ToolStripButton;                      m_curveControl.SetPostInfinity((CurveLoopTypes)btn.Tag);                  };              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: for (int i = 2; i <= 3; i++)              {                  m_infinityBtns[i].DisplayStyle = ToolStripItemDisplayStyle.Image;                  m_infinityBtns[i].Alignment = ToolStripItemAlignment.Left;                  m_infinityBtns[i].Name = "m_infinityBtns" + i;                  m_infinityBtns[i].ImageScaling = ToolStripItemImageScaling.None;                  m_infinityBtns[i].Click += delegate(object sender' EventArgs e)                  {                      var btn = sender as ToolStripButton;                      m_curveControl.SetPostInfinity((CurveLoopTypes)btn.Tag);                  };              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_infinityBtns[2].Tag = CurveLoopTypes.Cycle;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_infinityBtns[2].Image = new Bitmap(typeof(CurveUtils)' "Resources.CycleAfter.png");
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_infinityBtns[2].ToolTipText = "Cycle After";
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_infinityBtns[3].Tag = CurveLoopTypes.CycleWithOffset;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_infinityBtns[3].Image = new Bitmap(typeof(CurveUtils)' "Resources.CycleAfterwithOffset.png");
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_infinityBtns[3].ToolTipText = "Cycle After with Offset";
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_bottomStrip.Location = new Point(0' 549);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_bottomStrip.Size = new Size(898' 26);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_bottomStrip.Size = new Size(898' 26);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_bottomStrip.TabIndex = 2;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_MousePos.Size = new Size(250' 27);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_MousePos.Size = new Size(250' 27);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_curveControl.Location = new Point(24' 61);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_curveControl.Location = new Point(24' 61);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_curveControl.Size = new Size(900' 600);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_curveControl.Size = new Size(900' 600);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_curveControl.MouseMove += delegate(object sender' MouseEventArgs e)              {                  PointD gp = m_curveControl.ClientToGraph_d(e.X' e.Y);                  m_MousePos.Text = string.Format("{0}' {1}"' Math.Round(gp.X' 4)' Math.Round(gp.Y' 4));              };
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_curveControl.MouseMove += delegate(object sender' MouseEventArgs e)              {                  PointD gp = m_curveControl.ClientToGraph_d(e.X' e.Y);                  m_MousePos.Text = string.Format("{0}' {1}"' Math.Round(gp.X' 4)' Math.Round(gp.Y' 4));              };
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_TangentsSep1.Size = new Size(202' 6);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_TangentsSep1.Size = new Size(202' 6);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: splitContainer1.Location = new Point(0' 48);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: splitContainer1.Panel1MinSize = 30;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: splitContainer1.Panel2MinSize = 30;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: splitContainer1.Size = new Size(898' 520);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: splitContainer1.Size = new Size(898' 520);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: splitContainer1.SplitterDistance = 180;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: splitContainer1.SplitterIncrement = 5;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: splitContainer1.SplitterWidth = 4;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_curvesListView.Size = new Size(300' 300);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_curvesListView.Size = new Size(300' 300);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: m_curvesListView.Columns.Add("Curves"' 250);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: ClientSize = new Size(898' 575);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,Init,The following statement contains a magic number: ClientSize = new Size(898' 575);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,PopulateListView,The following statement contains a magic number: try              {                  m_populatingListView = true;                  m_curvesListView.Items.Clear();                  if (curves == null || curves.Count == 0)                  {                      return;                  }                  m_curvesListView.BeginUpdate();                  foreach (ICurve curve in curves)                  {                      string name = string.IsNullOrWhiteSpace(curve.DisplayName)                          ? curve.Name : curve.DisplayName;                        if (name.Length > 250)                          name = name.Substring(0' 250);                      ListViewItem item = new ListViewItem(name);                      item.ForeColor = curve.CurveColor;                      item.Checked = curve.Visible;                      item.Tag = curve;                      m_curvesListView.Items.Add(item);                  }                  m_curvesListView.AutoResizeColumns(ColumnHeaderAutoResizeStyle.ColumnContent);                  m_curvesListView.EndUpdate();                  // select first visible curve.                  foreach (ListViewItem item in m_curvesListView.Items)                  {                      if (item.Checked)                      {                          item.Selected = true;                          break;                      }                  }              }              finally              {                  m_populatingListView = false;              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,PopulateListView,The following statement contains a magic number: try              {                  m_populatingListView = true;                  m_curvesListView.Items.Clear();                  if (curves == null || curves.Count == 0)                  {                      return;                  }                  m_curvesListView.BeginUpdate();                  foreach (ICurve curve in curves)                  {                      string name = string.IsNullOrWhiteSpace(curve.DisplayName)                          ? curve.Name : curve.DisplayName;                        if (name.Length > 250)                          name = name.Substring(0' 250);                      ListViewItem item = new ListViewItem(name);                      item.ForeColor = curve.CurveColor;                      item.Checked = curve.Visible;                      item.Tag = curve;                      m_curvesListView.Items.Add(item);                  }                  m_curvesListView.AutoResizeColumns(ColumnHeaderAutoResizeStyle.ColumnContent);                  m_curvesListView.EndUpdate();                  // select first visible curve.                  foreach (ListViewItem item in m_curvesListView.Items)                  {                      if (item.Checked)                      {                          item.Selected = true;                          break;                      }                  }              }              finally              {                  m_populatingListView = false;              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,InputBoxValidating,The following statement contains a magic number: try              {                  string str = txtBox.Text.Trim();                  var op = MathOperation.Assign;                  if (str.StartsWith("+="))                  {                      op = MathOperation.Add;                  }                  else if (str.StartsWith("-="))                  {                      op = MathOperation.Subtract;                    }                  else if (str.StartsWith("*="))                  {                      op = MathOperation.Multiply;                  }                  else if (str.StartsWith("/="))                  {                      op = MathOperation.Divide;                    }                  if (op != MathOperation.Assign)                  {                      str = str.Substring(2);                  }                    if (string.IsNullOrEmpty(str))                      return;                    var curveset = new HashSet<ICurve>();                  var orglist = new List<Vec2F>();                  foreach (IControlPoint cpt in m_curveControl.Selection)                  {                                          orglist.Add(new Vec2F(cpt.X' cpt.Y));                  }                    float f = float.Parse(str);                  m_curveControl.TransactionContext.DoTransaction(delegate                  {                      if (txtBox == m_xTxtBox)                      {                          bool canEdit = (bool)m_xTxtBox.Tag                          || ((op != MathOperation.Assign) && (op != MathOperation.Multiply                          || f != 0));                          if (canEdit)                          {                              foreach (IControlPoint cpt in m_curveControl.Selection)                              {                                  cpt.X = Operate(cpt.X' f' op);                                  if (!CurveUtils.IsSorted(cpt))                                      curveset.Add(cpt.Parent);                              }                              if (m_curveControl.RestrictedTranslationEnabled && curveset.Count > 0)                              {                                  for (int i = 0; i < m_curveControl.Selection.Count; i++)                                  {                                      IControlPoint cpt = m_curveControl.Selection[i];                                      var orgCpt = orglist[i];                                      cpt.X = orgCpt.X;                                      cpt.Y = orgCpt.Y;                                                                     }                              }                          }                      }                      else                      {                          foreach (IControlPoint cpt in m_curveControl.Selection)                          {                              cpt.Y = Operate(cpt.Y' f' op);                          }                      }                        foreach (ICurve curve in m_curveControl.SelectedCurves)                      {                          CurveUtils.Sort(curve);                          CurveUtils.ForceMinDistance(curve);                          CurveUtils.ComputeTangent(curve);                      }                      CurveCanvas.UpdateCurveLimits();                  }'"Edit Point".Localize());                  m_curveControl.Invalidate();              }              catch (Exception ex)              {                  string str = txtBox.Text;                  bool sameval = true;                  float val = 0.0f;                  if (txtBox == m_xTxtBox)                  {                      val = m_curveControl.Selection[0].X;                      foreach (IControlPoint cpt in m_curveControl.Selection)                      {                          if (cpt.X != val)                          {                              sameval = false;                              break;                          }                      }                  }                  else                  {                      val = m_curveControl.Selection[0].Y;                      foreach (IControlPoint cpt in m_curveControl.Selection)                      {                          if (cpt.Y != val)                          {                              sameval = false;                              break;                          }                      }                  }                  txtBox.Text = (sameval) ? val.ToString() : "";                  MessageBox.Show(this' str + " " + ex.Message' "CurveEditor");              }
Magic Number,Sce.Atf.Controls.CurveEditing,HelpForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,HelpForm,The following statement contains a magic number: Size = new Size(700' 450);
Magic Number,Sce.Atf.Controls.CurveEditing,HelpForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,HelpForm,The following statement contains a magic number: Size = new Size(700' 450);
Magic Number,Sce.Atf.Controls.CurveEditing,HelpForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,HelpForm,The following statement contains a magic number: Font = new Font(Font.Name' 12);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: label1.Location = new Point(12' 13);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: label1.Location = new Point(12' 13);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: label1.Size = new Size(18' 18);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: label1.Size = new Size(18' 18);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: label2.Location = new Point(13' 43);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: label2.Location = new Point(13' 43);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: label2.Size = new Size(17' 18);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: label2.Size = new Size(17' 18);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: txtBoxX.Location = new Point(36' 7);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: txtBoxX.Location = new Point(36' 7);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: txtBoxX.Size = new Size(197' 24);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: txtBoxX.Size = new Size(197' 24);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: txtBoxX.TabIndex = 2;
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: textBoxY.Location = new Point(36' 37);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: textBoxY.Location = new Point(36' 37);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: textBoxY.Size = new Size(197' 24);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: textBoxY.Size = new Size(197' 24);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: textBoxY.TabIndex = 3;
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: cancelBtn.Location = new Point(158' 77);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: cancelBtn.Location = new Point(158' 77);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: cancelBtn.Size = new Size(75' 29);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: cancelBtn.Size = new Size(75' 29);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: cancelBtn.TabIndex = 5;
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: OkBtn.Location = new Point(77' 77);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: OkBtn.Location = new Point(77' 77);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: OkBtn.Size = new Size(75' 29);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: OkBtn.Size = new Size(75' 29);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: OkBtn.TabIndex = 6;
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: ClientSize = new Size(248' 111);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: ClientSize = new Size(248' 111);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: Margin = new Padding(4' 4' 4' 4);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: Margin = new Padding(4' 4' 4' 4);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: Margin = new Padding(4' 4' 4' 4);
Magic Number,Sce.Atf.Controls.CurveEditing,AddPointDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,AddPointDialog,The following statement contains a magic number: Margin = new Padding(4' 4' 4' 4);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditor.cs,selectionContext_SelectionChanged,The following statement contains a magic number: if (MultiSelectionOverlay)              {                  // Restore original curve colors                  foreach (KeyValuePair<ICurve' Color> pair in m_originalCurveColors)                      pair.Key.CurveColor = pair.Value;                  m_originalCurveColors.Clear();                                    // Merge curves from all selected objects                  List<ICurve> curveList = new List<ICurve>();                  foreach (object obj in m_selectionContext.Selection)                      curveList.AddRange(GetCurves(obj));                    // Auto-assign curve colors (equally spaced in the color spectrum)                  if (m_selectionContext.SelectionCount > 1)                  {                         for (int i = 0; i < curveList.Count; i++)                      {                          ICurve curve = curveList[i];                          float hue = (i * 360.0f) / (float)curveList.Count;                          m_originalCurveColors[curve] = curve.CurveColor; // Remember original curve color                          curve.CurveColor = ColorUtil.FromAhsb(255' hue' 1.0f' 0.5f);                      }                  }                    curves = curveList;              }              else                  curves = GetCurves(m_selectionContext.LastSelected);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,DrawCurve,The following statement contains a magic number: float bound = 500;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,DrawControlPoints,The following statement contains a magic number: if (curve.CurveInterpolation == InterpolationTypes.Linear)              {                  for (int i = leftIndex; i <= rightIndex; i++)                  {                      IControlPoint pt = points[i];                      Vec2F cpt = m_canvas.GraphToClient(pt.X' pt.Y);                      RectangleF pointRect = new RectangleF();                      float halfPointSize = m_pointSize / 2;                      pointRect.X = cpt.X - halfPointSize;                      pointRect.Y = cpt.Y - halfPointSize;                      pointRect.Width = m_pointSize;                      pointRect.Height = m_pointSize;                      if (pt.EditorData.SelectedRegion == PointSelectionRegions.Point)                          g.FillRectangle(m_pointHiBrush' pointRect);                      else                          g.FillRectangle(m_pointBrush' pointRect);                  }              }              else              {                  for (int i = leftIndex; i <= rightIndex; i++)                  {                      CurveTangentTypes prevTanType = (i == 0) ? CurveTangentTypes.Flat :                          points[i - 1].TangentOutType;                      DrawControlPoint(prevTanType' points[i]' g);                  }              }
Magic Number,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,DrawControlPoint,The following statement contains a magic number: float halfPointSize = m_pointSize / 2;
Magic Number,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,DrawArrow,The following statement contains a magic number: s_arrowPts[2] = new PointF(leftFin.X' leftFin.Y);
Magic Number,Sce.Atf.Controls.CurveEditing,CurveRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveRenderer.cs,ComputeIndices,The following statement contains a magic number: rIndex = -2;
Magic Number,Sce.Atf.Controls.DataEditing,BoolDataEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataEditing\BoolDataEditor.cs,PaintValue,The following statement contains a magic number: const int checkBoxWidth = 12;
Magic Number,Sce.Atf.Controls.FolderSelection,FolderSelectDialog,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\FolderSelectDialog.cs,ShowDialog,The following statement contains a magic number: if (Environment.OSVersion.Version.Major >= 6)              {                  var r = new Reflector("System.Windows.Forms");                    uint num = 0;                  Type typeIFileDialog = r.GetType("FileDialogNative.IFileDialog");                  object dialog = r.Call(m_ofd' "CreateVistaDialog");                  r.Call(m_ofd' "OnBeforeVistaDialog"' dialog);                    uint options = (uint)r.CallAs(typeof(FileDialog)' m_ofd' "GetOptions");                  options |= (uint)r.GetEnum("FileDialogNative.FOS"' "FOS_PICKFOLDERS");                  r.CallAs(typeIFileDialog' dialog' "SetOptions"' options);                    object pfde = r.New("FileDialog.VistaDialogEvents"' m_ofd);                  object[] parameters = new[] { pfde' num };                  r.CallAs2(typeIFileDialog' dialog' "Advise"' parameters);                  num = (uint)parameters[1];                  try                  {                      int num2 = (int)r.CallAs(typeIFileDialog' dialog' "Show"' owner == null ? IntPtr.Zero : owner.Handle);                      result = (0 == num2) ? DialogResult.OK : DialogResult.Cancel;                  }                  finally                  {                      r.CallAs(typeIFileDialog' dialog' "Unadvise"' num);                      GC.KeepAlive(pfde);                  }              }              else              {                  using (var fbd = new FolderBrowserDialog())                  {                      fbd.Description = Description;                      fbd.SelectedPath = InitialDirectory;                      fbd.ShowNewFolderButton = false;                      result = fbd.ShowDialog(owner);                      if (result == DialogResult.OK)                          m_ofd.FileName = fbd.SelectedPath;                  }              }
Magic Number,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,TimerTick,The following statement contains a magic number: m_fps = (float)(m_intervalFrameCount * 1000 / actualInterval.TotalMilliseconds);
Magic Number,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,UpdateDisplay,The following statement contains a magic number: ManagedMemoryLabel.Text = (m_managedBytes / 1024).ToString("N0") + " K";
Magic Number,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,UpdateDisplay,The following statement contains a magic number: UnmanagedMemoryLabel.Text = (m_unmanagedBytes / 1024).ToString("N0") + " K";
Magic Number,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,ClipboardBtn_Click,The following statement contains a magic number: builder.AppendFormat("Managed memory (KB): {0}".Localize()' (m_managedBytes / 1024));
Magic Number,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,ClipboardBtn_Click,The following statement contains a magic number: builder.AppendFormat("Unmanaged memory (KB): {0}".Localize()' (m_unmanagedBytes / 1024));
Magic Number,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,StressTestBtn_Click,The following statement contains a magic number: var allFrames = new List<long>(1000);
Magic Number,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,StressTestBtn_Click,The following statement contains a magic number: try              {                  while (true)                  {                      long startTick = m_stopWatch.ElapsedTicks;                        m_target.DoEvent();                        long endTick = m_stopWatch.ElapsedTicks;                      allFrames.Add(endTick - startTick);                        // Update the frame count                      TargetEventHandler(sender' e);                        // Has the stress test duration elapsed?                      TimeSpan now = m_stopWatch.Elapsed;                      TimeSpan actualInterval = now - lastIntervalStart;                      if (actualInterval.TotalMilliseconds >= StressTestDuration)                          break;                        // Update the countdown timer                      int secondsRemaining = (StressTestDuration / 1000) - (int)actualInterval.TotalSeconds;                      string newCountdown = secondsRemaining.ToString();                      if (!StressTestBtn.Text.Equals(newCountdown))                      {                          StressTestBtn.Text = newCountdown;                          StressTestBtn.Refresh();                      }                  }              }              finally              {                  StressTestBtn.Text = originalStressText;                  StressTestBtn.Enabled = true;                  m_target.EventOccurred += TargetEventHandler;                  m_timer.Interval = Interval;                  m_timer.Tick += TimerTick;                  TimerTick(sender' e);                    if (allFrames.Count > 0)                  {                      allFrames.Sort(); //sort from lowest to highest                      long meanTicks = allFrames[allFrames.Count / 2];                      long fastestTicks = allFrames[0];                      long slowestTicks = allFrames[allFrames.Count - 1];                      long meanMs = (meanTicks * 1000) / Stopwatch.Frequency;                      long fastestMs = (fastestTicks * 1000) / Stopwatch.Frequency;                      long slowesttMs = (slowestTicks * 1000) / Stopwatch.Frequency;                      var report = new StringBuilder();                      report.AppendFormat("Target: {0}".Localize("'target' is the Windows Control that is being analyzed")' m_targetName);                      report.AppendLine();                      report.AppendFormat("Number of rendered frames: {0}".Localize()' allFrames.Count);                      report.AppendLine();                      report.AppendFormat("Mean rendering time: {0}ms or {1} ticks".Localize()' meanMs' meanTicks);                      report.AppendLine();                      report.AppendFormat("Fastest rendering time: {0}ms or {1} ticks".Localize()' fastestMs' fastestTicks);                      report.AppendLine();                      report.AppendFormat("Slowest rendering time: {0}ms or {1} ticks".Localize()' slowesttMs' slowestTicks);                      report.AppendLine();                      Clipboard.SetText(report.ToString());                       MessageBox.Show(report.ToString()' "The performance report is in the clipboard".Localize());                  }              }
Magic Number,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,StressTestBtn_Click,The following statement contains a magic number: try              {                  while (true)                  {                      long startTick = m_stopWatch.ElapsedTicks;                        m_target.DoEvent();                        long endTick = m_stopWatch.ElapsedTicks;                      allFrames.Add(endTick - startTick);                        // Update the frame count                      TargetEventHandler(sender' e);                        // Has the stress test duration elapsed?                      TimeSpan now = m_stopWatch.Elapsed;                      TimeSpan actualInterval = now - lastIntervalStart;                      if (actualInterval.TotalMilliseconds >= StressTestDuration)                          break;                        // Update the countdown timer                      int secondsRemaining = (StressTestDuration / 1000) - (int)actualInterval.TotalSeconds;                      string newCountdown = secondsRemaining.ToString();                      if (!StressTestBtn.Text.Equals(newCountdown))                      {                          StressTestBtn.Text = newCountdown;                          StressTestBtn.Refresh();                      }                  }              }              finally              {                  StressTestBtn.Text = originalStressText;                  StressTestBtn.Enabled = true;                  m_target.EventOccurred += TargetEventHandler;                  m_timer.Interval = Interval;                  m_timer.Tick += TimerTick;                  TimerTick(sender' e);                    if (allFrames.Count > 0)                  {                      allFrames.Sort(); //sort from lowest to highest                      long meanTicks = allFrames[allFrames.Count / 2];                      long fastestTicks = allFrames[0];                      long slowestTicks = allFrames[allFrames.Count - 1];                      long meanMs = (meanTicks * 1000) / Stopwatch.Frequency;                      long fastestMs = (fastestTicks * 1000) / Stopwatch.Frequency;                      long slowesttMs = (slowestTicks * 1000) / Stopwatch.Frequency;                      var report = new StringBuilder();                      report.AppendFormat("Target: {0}".Localize("'target' is the Windows Control that is being analyzed")' m_targetName);                      report.AppendLine();                      report.AppendFormat("Number of rendered frames: {0}".Localize()' allFrames.Count);                      report.AppendLine();                      report.AppendFormat("Mean rendering time: {0}ms or {1} ticks".Localize()' meanMs' meanTicks);                      report.AppendLine();                      report.AppendFormat("Fastest rendering time: {0}ms or {1} ticks".Localize()' fastestMs' fastestTicks);                      report.AppendLine();                      report.AppendFormat("Slowest rendering time: {0}ms or {1} ticks".Localize()' slowesttMs' slowestTicks);                      report.AppendLine();                      Clipboard.SetText(report.ToString());                       MessageBox.Show(report.ToString()' "The performance report is in the clipboard".Localize());                  }              }
Magic Number,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,StressTestBtn_Click,The following statement contains a magic number: try              {                  while (true)                  {                      long startTick = m_stopWatch.ElapsedTicks;                        m_target.DoEvent();                        long endTick = m_stopWatch.ElapsedTicks;                      allFrames.Add(endTick - startTick);                        // Update the frame count                      TargetEventHandler(sender' e);                        // Has the stress test duration elapsed?                      TimeSpan now = m_stopWatch.Elapsed;                      TimeSpan actualInterval = now - lastIntervalStart;                      if (actualInterval.TotalMilliseconds >= StressTestDuration)                          break;                        // Update the countdown timer                      int secondsRemaining = (StressTestDuration / 1000) - (int)actualInterval.TotalSeconds;                      string newCountdown = secondsRemaining.ToString();                      if (!StressTestBtn.Text.Equals(newCountdown))                      {                          StressTestBtn.Text = newCountdown;                          StressTestBtn.Refresh();                      }                  }              }              finally              {                  StressTestBtn.Text = originalStressText;                  StressTestBtn.Enabled = true;                  m_target.EventOccurred += TargetEventHandler;                  m_timer.Interval = Interval;                  m_timer.Tick += TimerTick;                  TimerTick(sender' e);                    if (allFrames.Count > 0)                  {                      allFrames.Sort(); //sort from lowest to highest                      long meanTicks = allFrames[allFrames.Count / 2];                      long fastestTicks = allFrames[0];                      long slowestTicks = allFrames[allFrames.Count - 1];                      long meanMs = (meanTicks * 1000) / Stopwatch.Frequency;                      long fastestMs = (fastestTicks * 1000) / Stopwatch.Frequency;                      long slowesttMs = (slowestTicks * 1000) / Stopwatch.Frequency;                      var report = new StringBuilder();                      report.AppendFormat("Target: {0}".Localize("'target' is the Windows Control that is being analyzed")' m_targetName);                      report.AppendLine();                      report.AppendFormat("Number of rendered frames: {0}".Localize()' allFrames.Count);                      report.AppendLine();                      report.AppendFormat("Mean rendering time: {0}ms or {1} ticks".Localize()' meanMs' meanTicks);                      report.AppendLine();                      report.AppendFormat("Fastest rendering time: {0}ms or {1} ticks".Localize()' fastestMs' fastestTicks);                      report.AppendLine();                      report.AppendFormat("Slowest rendering time: {0}ms or {1} ticks".Localize()' slowesttMs' slowestTicks);                      report.AppendLine();                      Clipboard.SetText(report.ToString());                       MessageBox.Show(report.ToString()' "The performance report is in the clipboard".Localize());                  }              }
Magic Number,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,StressTestBtn_Click,The following statement contains a magic number: try              {                  while (true)                  {                      long startTick = m_stopWatch.ElapsedTicks;                        m_target.DoEvent();                        long endTick = m_stopWatch.ElapsedTicks;                      allFrames.Add(endTick - startTick);                        // Update the frame count                      TargetEventHandler(sender' e);                        // Has the stress test duration elapsed?                      TimeSpan now = m_stopWatch.Elapsed;                      TimeSpan actualInterval = now - lastIntervalStart;                      if (actualInterval.TotalMilliseconds >= StressTestDuration)                          break;                        // Update the countdown timer                      int secondsRemaining = (StressTestDuration / 1000) - (int)actualInterval.TotalSeconds;                      string newCountdown = secondsRemaining.ToString();                      if (!StressTestBtn.Text.Equals(newCountdown))                      {                          StressTestBtn.Text = newCountdown;                          StressTestBtn.Refresh();                      }                  }              }              finally              {                  StressTestBtn.Text = originalStressText;                  StressTestBtn.Enabled = true;                  m_target.EventOccurred += TargetEventHandler;                  m_timer.Interval = Interval;                  m_timer.Tick += TimerTick;                  TimerTick(sender' e);                    if (allFrames.Count > 0)                  {                      allFrames.Sort(); //sort from lowest to highest                      long meanTicks = allFrames[allFrames.Count / 2];                      long fastestTicks = allFrames[0];                      long slowestTicks = allFrames[allFrames.Count - 1];                      long meanMs = (meanTicks * 1000) / Stopwatch.Frequency;                      long fastestMs = (fastestTicks * 1000) / Stopwatch.Frequency;                      long slowesttMs = (slowestTicks * 1000) / Stopwatch.Frequency;                      var report = new StringBuilder();                      report.AppendFormat("Target: {0}".Localize("'target' is the Windows Control that is being analyzed")' m_targetName);                      report.AppendLine();                      report.AppendFormat("Number of rendered frames: {0}".Localize()' allFrames.Count);                      report.AppendLine();                      report.AppendFormat("Mean rendering time: {0}ms or {1} ticks".Localize()' meanMs' meanTicks);                      report.AppendLine();                      report.AppendFormat("Fastest rendering time: {0}ms or {1} ticks".Localize()' fastestMs' fastestTicks);                      report.AppendLine();                      report.AppendFormat("Slowest rendering time: {0}ms or {1} ticks".Localize()' slowesttMs' slowestTicks);                      report.AppendLine();                      Clipboard.SetText(report.ToString());                       MessageBox.Show(report.ToString()' "The performance report is in the clipboard".Localize());                  }              }
Magic Number,Sce.Atf.Applications.Controls,PerformanceMonitorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PerformanceMonitorControl.cs,StressTestBtn_Click,The following statement contains a magic number: try              {                  while (true)                  {                      long startTick = m_stopWatch.ElapsedTicks;                        m_target.DoEvent();                        long endTick = m_stopWatch.ElapsedTicks;                      allFrames.Add(endTick - startTick);                        // Update the frame count                      TargetEventHandler(sender' e);                        // Has the stress test duration elapsed?                      TimeSpan now = m_stopWatch.Elapsed;                      TimeSpan actualInterval = now - lastIntervalStart;                      if (actualInterval.TotalMilliseconds >= StressTestDuration)                          break;                        // Update the countdown timer                      int secondsRemaining = (StressTestDuration / 1000) - (int)actualInterval.TotalSeconds;                      string newCountdown = secondsRemaining.ToString();                      if (!StressTestBtn.Text.Equals(newCountdown))                      {                          StressTestBtn.Text = newCountdown;                          StressTestBtn.Refresh();                      }                  }              }              finally              {                  StressTestBtn.Text = originalStressText;                  StressTestBtn.Enabled = true;                  m_target.EventOccurred += TargetEventHandler;                  m_timer.Interval = Interval;                  m_timer.Tick += TimerTick;                  TimerTick(sender' e);                    if (allFrames.Count > 0)                  {                      allFrames.Sort(); //sort from lowest to highest                      long meanTicks = allFrames[allFrames.Count / 2];                      long fastestTicks = allFrames[0];                      long slowestTicks = allFrames[allFrames.Count - 1];                      long meanMs = (meanTicks * 1000) / Stopwatch.Frequency;                      long fastestMs = (fastestTicks * 1000) / Stopwatch.Frequency;                      long slowesttMs = (slowestTicks * 1000) / Stopwatch.Frequency;                      var report = new StringBuilder();                      report.AppendFormat("Target: {0}".Localize("'target' is the Windows Control that is being analyzed")' m_targetName);                      report.AppendLine();                      report.AppendFormat("Number of rendered frames: {0}".Localize()' allFrames.Count);                      report.AppendLine();                      report.AppendFormat("Mean rendering time: {0}ms or {1} ticks".Localize()' meanMs' meanTicks);                      report.AppendLine();                      report.AppendFormat("Fastest rendering time: {0}ms or {1} ticks".Localize()' fastestMs' fastestTicks);                      report.AppendLine();                      report.AppendFormat("Slowest rendering time: {0}ms or {1} ticks".Localize()' slowesttMs' slowestTicks);                      report.AppendLine();                      Clipboard.SetText(report.ToString());                       MessageBox.Show(report.ToString()' "The performance report is in the clipboard".Localize());                  }              }
Magic Number,Sce.Atf.Controls.PropertyEditing,ArrayEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\ArrayEditingControl.cs,RebuildItemControls,The following statement contains a magic number: m_indexColumnWidth = Math.Max(30' (array.Length * 2).ToString().Length * 10);
Magic Number,Sce.Atf.Controls.PropertyEditing,ArrayEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\ArrayEditingControl.cs,RebuildItemControls,The following statement contains a magic number: m_indexColumnWidth = Math.Max(30' (array.Length * 2).ToString().Length * 10);
Magic Number,Sce.Atf.Controls.PropertyEditing,ArrayEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\ArrayEditingControl.cs,RebuildItemControls,The following statement contains a magic number: m_indexColumnWidth = Math.Max(30' (array.Length * 2).ToString().Length * 10);
Magic Number,Sce.Atf.Controls.PropertyEditing,BoolControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\BoolEditor.cs,OnSizeChanged,The following statement contains a magic number: m_checkBox.Location = new Point(m_topAndLeftMargin' (Height - m_checkBox.Height) / 2 + 1);
Magic Number,Sce.Atf.Controls.PropertyEditing,BoundedFloatEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\BoundedFloatEditor.cs,Initialize,The following statement contains a magic number: if (parameters.Length < 2 ||                  !Single.TryParse(parameters[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out min) ||                  !Single.TryParse(parameters[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out max) ||                  min >= max)              {                  throw new ArgumentException("Can't parse bounds for float control");              }
Magic Number,Sce.Atf.Controls.PropertyEditing,BoundedIntEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\BoundedIntEditor.cs,Initialize,The following statement contains a magic number: if (parameters.Length < 2 ||                  !Int32.TryParse(parameters[0]' NumberStyles.Integer' CultureInfo.InvariantCulture' out min) ||                  !Int32.TryParse(parameters[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out max) ||                  min >= max)              {                  throw new ArgumentException("Can't parse bounds for BoundedIntEditor");              }
Magic Number,Sce.Atf.Controls.PropertyEditing,CollectionEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\CollectionEditingControl.cs,GetInsertionIndex,The following statement contains a magic number: int index = ((y + (ItemHeight / 2)) / ItemHeight) + TopIndex;
Magic Number,Sce.Atf.Controls.PropertyEditing,EmbeddedCollectionEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EmbeddedCollectionEditor.cs,GetEditingControl,The following statement contains a magic number: bool toolStripLabelEnabled = (Parameters != null && Parameters.Length > 2 && Boolean.Parse(Parameters[2]));
Magic Number,Sce.Atf.Controls.PropertyEditing,EmbeddedCollectionEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EmbeddedCollectionEditor.cs,GetEditingControl,The following statement contains a magic number: bool toolStripLabelEnabled = (Parameters != null && Parameters.Length > 2 && Boolean.Parse(Parameters[2]));
Magic Number,Sce.Atf.Controls.PropertyEditing,CollectionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EmbeddedCollectionEditor.cs,ProcessPendingChanges,The following statement contains a magic number: try                  {                      m_processingPendingChanges = true;                      SuspendLayout();                      //m_toolStrip.Enabled = false; //This sets the focus to the next control in the tab group' which changes the property selection                        // Check if the selection has changed                      object selected = m_context.LastSelectedObject;                      if (m_activeCollectionNode != selected && selected != null)                      {                          ClearPendingChanges(); // no need to process pending changes as we're rebuilding anyway                            m_activeCollectionNode = selected;                            IEnumerable items = GetItemsFromContext();                          int itemCount = items.Cast<object>().Count();                            // Enable singleton mode iff the collection will always have exactly 1 item                          // in this case we can hide toolbar and the item's index column                          m_singletonMode =                              (m_editor.GetItemInsertersFunc == null || !m_editor.GetItemInsertersFunc(m_context).Any()) // can't insert                              && m_editor.RemoveItemFunc == null // can't remove                              && itemCount == 1; // currently 1 item                            // Set index column width to be big enough to display the highest expected index'                          // using double the number of current items as first estimate.                          // This could be done more accurately with MeasureString and could also be dynamically                          // adjusted if the number exceeds the current max due to add operations.                          m_indexColumnWidth = Math.Max(30' (itemCount * 2).ToString().Length * 10);                            m_toolStrip.Visible = !m_singletonMode;                            foreach (ItemControl itemControl in m_itemControls.Values)                          {                              itemControl.Visible = false;                              itemControl.Clear();                              m_unusedItemControls.Add(itemControl);                          }                          m_itemControls.Clear();                            // Add items for insertion.                          foreach (object item in items)                              m_pendingItemsInserted.Add(item);                            UpdateAddButton();                      }                        // Hide controls for removed items.                      int smallestRemovedIndex = int.MaxValue;                      foreach (object item in m_pendingItemsRemoved)                      {                          ItemControl itemControl;                            if (m_itemControls.TryGetValue(item' out itemControl))                          {                              if (itemControl.Index < smallestRemovedIndex)                                  smallestRemovedIndex = itemControl.Index;                                itemControl.Visible = false;                              UnsubscribeItemEvents(itemControl);                              m_itemControls.Remove(item);                              itemControl.Clear();                              m_unusedItemControls.Add(itemControl);                          }                      }                        // Set new item selection after any deletes.                      if (smallestRemovedIndex != int.MaxValue)                      {                          int i = m_itemControls.Count - 1;                          foreach (ItemControl itemObj in m_itemControls.Values.OrderBy(itemControl => itemControl.Index))                          {                              if (itemObj.Index > smallestRemovedIndex || i == 0)                              {                                  itemObj.Selected = true;                                  break;                              }                                --i;                          }                      }                        // Refresh controls for items that have changed.                      foreach (object item in m_pendingItemsChanged)                      {                          ItemControl itemControl;                          if (m_itemControls.TryGetValue(item' out itemControl))                              itemControl.Refresh();                      }                                                                // Reorder controls for items that have moved' either                      // because a lower index item was deleted' or because they've been                      // (directly or indirectly) been moved up or down.                      int index = 0;                      int top = m_singletonMode ? 0 : m_toolStrip.Height;                      foreach (object item in GetItemsFromContext())                      {                                                                          ItemControl itemControl;                          if (m_itemControls.TryGetValue(item' out itemControl))                          {                              itemControl.Index = index;                              itemControl.Top = top;                                index++;                              top += itemControl.Height;                          }                      }                        // Add controls for added items.                      // Currently only adding at the end is supported. If we ever want to support                       // inserting in the middle' then we'd probably want to have this step before .                      // the index-reordering one.                      foreach (object item in m_pendingItemsInserted)                      {                          ItemControl itemControl;                          if (m_unusedItemControls.Count > 0)                          {                              itemControl = m_unusedItemControls[m_unusedItemControls.Count - 1];                              m_unusedItemControls.RemoveAt(m_unusedItemControls.Count - 1);                              itemControl.Init(m_itemControls.Count' item'                                  m_singletonMode' m_indexColumnWidth' TransactionContext);                              itemControl.Visible = true;                            }                          else                          {                              itemControl = new ItemControl(m_itemControls.Count' item'                                  m_singletonMode' m_indexColumnWidth' TransactionContext' m_parentPropertyGridView);                              SkinService.ApplyActiveSkin(itemControl);                              Controls.Add(itemControl);                                                          itemControl.MouseUp += itemControl_MouseUp;                          }                          itemControl.Width = m_toolStrip.Width;                          itemControl.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;                          itemControl.Top = top;                            if (m_singletonMode)                              itemControl.Dock = DockStyle.Fill;                                                    top += itemControl.Height;                          m_itemControls.Add(item' itemControl);                          SubscribeItemEvents(itemControl);                                                    itemControl.Selected = false;                      }                        Height = top; // update height of main collection control                        ClearPendingChanges(); // all pending changes processed                        UpdateDeleteButton(true);                      UpdateMoveButtons(true);                      UpdateItemsCountLabel();                  }                  catch (Win32Exception ex)                  {                      // For very large collections (with 1000+ items) it is possible that Windows runs out of Window handles.                      // Such collections are currently not usable with this editor. To support such collections we'd have to                      // implement some kind of virtual mode (i.e. stream items in and out) but that would pose some new                      // challenges for editing operations (add' remove' move).                        // Clean up to release some window handles and keep the application running smoothly.                      foreach (ItemControl control in m_itemControls.Values)                      {                          if (Controls.Contains(control))                              Controls.Remove(control);                          control.Clear();                          control.Dispose();                      }                      m_itemControls.Clear();                        foreach (ItemControl control in m_unusedItemControls)                          control.Dispose();                      m_unusedItemControls.Clear();                        ClearPendingChanges();                        // Report error. Must be done after cleaning up' as before we may not even have the resources to show the message box.                      MessageBox.Show(                          "Failed to create item controls' probably because there were not enough Window handles available. Consider using a different editor for collections of this size and nature.\r\n\r\n"                          + ex.GetType().ToString() + Environment.NewLine                          + ex.Message'                          "Failed to create item controls"' MessageBoxButtons.OK' MessageBoxIcon.Error);                  }                  finally                  {                      //m_toolStrip.Enabled = true;                      ResumeLayout();                      m_processingPendingChanges = false;                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,CollectionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EmbeddedCollectionEditor.cs,ProcessPendingChanges,The following statement contains a magic number: try                  {                      m_processingPendingChanges = true;                      SuspendLayout();                      //m_toolStrip.Enabled = false; //This sets the focus to the next control in the tab group' which changes the property selection                        // Check if the selection has changed                      object selected = m_context.LastSelectedObject;                      if (m_activeCollectionNode != selected && selected != null)                      {                          ClearPendingChanges(); // no need to process pending changes as we're rebuilding anyway                            m_activeCollectionNode = selected;                            IEnumerable items = GetItemsFromContext();                          int itemCount = items.Cast<object>().Count();                            // Enable singleton mode iff the collection will always have exactly 1 item                          // in this case we can hide toolbar and the item's index column                          m_singletonMode =                              (m_editor.GetItemInsertersFunc == null || !m_editor.GetItemInsertersFunc(m_context).Any()) // can't insert                              && m_editor.RemoveItemFunc == null // can't remove                              && itemCount == 1; // currently 1 item                            // Set index column width to be big enough to display the highest expected index'                          // using double the number of current items as first estimate.                          // This could be done more accurately with MeasureString and could also be dynamically                          // adjusted if the number exceeds the current max due to add operations.                          m_indexColumnWidth = Math.Max(30' (itemCount * 2).ToString().Length * 10);                            m_toolStrip.Visible = !m_singletonMode;                            foreach (ItemControl itemControl in m_itemControls.Values)                          {                              itemControl.Visible = false;                              itemControl.Clear();                              m_unusedItemControls.Add(itemControl);                          }                          m_itemControls.Clear();                            // Add items for insertion.                          foreach (object item in items)                              m_pendingItemsInserted.Add(item);                            UpdateAddButton();                      }                        // Hide controls for removed items.                      int smallestRemovedIndex = int.MaxValue;                      foreach (object item in m_pendingItemsRemoved)                      {                          ItemControl itemControl;                            if (m_itemControls.TryGetValue(item' out itemControl))                          {                              if (itemControl.Index < smallestRemovedIndex)                                  smallestRemovedIndex = itemControl.Index;                                itemControl.Visible = false;                              UnsubscribeItemEvents(itemControl);                              m_itemControls.Remove(item);                              itemControl.Clear();                              m_unusedItemControls.Add(itemControl);                          }                      }                        // Set new item selection after any deletes.                      if (smallestRemovedIndex != int.MaxValue)                      {                          int i = m_itemControls.Count - 1;                          foreach (ItemControl itemObj in m_itemControls.Values.OrderBy(itemControl => itemControl.Index))                          {                              if (itemObj.Index > smallestRemovedIndex || i == 0)                              {                                  itemObj.Selected = true;                                  break;                              }                                --i;                          }                      }                        // Refresh controls for items that have changed.                      foreach (object item in m_pendingItemsChanged)                      {                          ItemControl itemControl;                          if (m_itemControls.TryGetValue(item' out itemControl))                              itemControl.Refresh();                      }                                                                // Reorder controls for items that have moved' either                      // because a lower index item was deleted' or because they've been                      // (directly or indirectly) been moved up or down.                      int index = 0;                      int top = m_singletonMode ? 0 : m_toolStrip.Height;                      foreach (object item in GetItemsFromContext())                      {                                                                          ItemControl itemControl;                          if (m_itemControls.TryGetValue(item' out itemControl))                          {                              itemControl.Index = index;                              itemControl.Top = top;                                index++;                              top += itemControl.Height;                          }                      }                        // Add controls for added items.                      // Currently only adding at the end is supported. If we ever want to support                       // inserting in the middle' then we'd probably want to have this step before .                      // the index-reordering one.                      foreach (object item in m_pendingItemsInserted)                      {                          ItemControl itemControl;                          if (m_unusedItemControls.Count > 0)                          {                              itemControl = m_unusedItemControls[m_unusedItemControls.Count - 1];                              m_unusedItemControls.RemoveAt(m_unusedItemControls.Count - 1);                              itemControl.Init(m_itemControls.Count' item'                                  m_singletonMode' m_indexColumnWidth' TransactionContext);                              itemControl.Visible = true;                            }                          else                          {                              itemControl = new ItemControl(m_itemControls.Count' item'                                  m_singletonMode' m_indexColumnWidth' TransactionContext' m_parentPropertyGridView);                              SkinService.ApplyActiveSkin(itemControl);                              Controls.Add(itemControl);                                                          itemControl.MouseUp += itemControl_MouseUp;                          }                          itemControl.Width = m_toolStrip.Width;                          itemControl.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;                          itemControl.Top = top;                            if (m_singletonMode)                              itemControl.Dock = DockStyle.Fill;                                                    top += itemControl.Height;                          m_itemControls.Add(item' itemControl);                          SubscribeItemEvents(itemControl);                                                    itemControl.Selected = false;                      }                        Height = top; // update height of main collection control                        ClearPendingChanges(); // all pending changes processed                        UpdateDeleteButton(true);                      UpdateMoveButtons(true);                      UpdateItemsCountLabel();                  }                  catch (Win32Exception ex)                  {                      // For very large collections (with 1000+ items) it is possible that Windows runs out of Window handles.                      // Such collections are currently not usable with this editor. To support such collections we'd have to                      // implement some kind of virtual mode (i.e. stream items in and out) but that would pose some new                      // challenges for editing operations (add' remove' move).                        // Clean up to release some window handles and keep the application running smoothly.                      foreach (ItemControl control in m_itemControls.Values)                      {                          if (Controls.Contains(control))                              Controls.Remove(control);                          control.Clear();                          control.Dispose();                      }                      m_itemControls.Clear();                        foreach (ItemControl control in m_unusedItemControls)                          control.Dispose();                      m_unusedItemControls.Clear();                        ClearPendingChanges();                        // Report error. Must be done after cleaning up' as before we may not even have the resources to show the message box.                      MessageBox.Show(                          "Failed to create item controls' probably because there were not enough Window handles available. Consider using a different editor for collections of this size and nature.\r\n\r\n"                          + ex.GetType().ToString() + Environment.NewLine                          + ex.Message'                          "Failed to create item controls"' MessageBoxButtons.OK' MessageBoxIcon.Error);                  }                  finally                  {                      //m_toolStrip.Enabled = true;                      ResumeLayout();                      m_processingPendingChanges = false;                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,CollectionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EmbeddedCollectionEditor.cs,ProcessPendingChanges,The following statement contains a magic number: try                  {                      m_processingPendingChanges = true;                      SuspendLayout();                      //m_toolStrip.Enabled = false; //This sets the focus to the next control in the tab group' which changes the property selection                        // Check if the selection has changed                      object selected = m_context.LastSelectedObject;                      if (m_activeCollectionNode != selected && selected != null)                      {                          ClearPendingChanges(); // no need to process pending changes as we're rebuilding anyway                            m_activeCollectionNode = selected;                            IEnumerable items = GetItemsFromContext();                          int itemCount = items.Cast<object>().Count();                            // Enable singleton mode iff the collection will always have exactly 1 item                          // in this case we can hide toolbar and the item's index column                          m_singletonMode =                              (m_editor.GetItemInsertersFunc == null || !m_editor.GetItemInsertersFunc(m_context).Any()) // can't insert                              && m_editor.RemoveItemFunc == null // can't remove                              && itemCount == 1; // currently 1 item                            // Set index column width to be big enough to display the highest expected index'                          // using double the number of current items as first estimate.                          // This could be done more accurately with MeasureString and could also be dynamically                          // adjusted if the number exceeds the current max due to add operations.                          m_indexColumnWidth = Math.Max(30' (itemCount * 2).ToString().Length * 10);                            m_toolStrip.Visible = !m_singletonMode;                            foreach (ItemControl itemControl in m_itemControls.Values)                          {                              itemControl.Visible = false;                              itemControl.Clear();                              m_unusedItemControls.Add(itemControl);                          }                          m_itemControls.Clear();                            // Add items for insertion.                          foreach (object item in items)                              m_pendingItemsInserted.Add(item);                            UpdateAddButton();                      }                        // Hide controls for removed items.                      int smallestRemovedIndex = int.MaxValue;                      foreach (object item in m_pendingItemsRemoved)                      {                          ItemControl itemControl;                            if (m_itemControls.TryGetValue(item' out itemControl))                          {                              if (itemControl.Index < smallestRemovedIndex)                                  smallestRemovedIndex = itemControl.Index;                                itemControl.Visible = false;                              UnsubscribeItemEvents(itemControl);                              m_itemControls.Remove(item);                              itemControl.Clear();                              m_unusedItemControls.Add(itemControl);                          }                      }                        // Set new item selection after any deletes.                      if (smallestRemovedIndex != int.MaxValue)                      {                          int i = m_itemControls.Count - 1;                          foreach (ItemControl itemObj in m_itemControls.Values.OrderBy(itemControl => itemControl.Index))                          {                              if (itemObj.Index > smallestRemovedIndex || i == 0)                              {                                  itemObj.Selected = true;                                  break;                              }                                --i;                          }                      }                        // Refresh controls for items that have changed.                      foreach (object item in m_pendingItemsChanged)                      {                          ItemControl itemControl;                          if (m_itemControls.TryGetValue(item' out itemControl))                              itemControl.Refresh();                      }                                                                // Reorder controls for items that have moved' either                      // because a lower index item was deleted' or because they've been                      // (directly or indirectly) been moved up or down.                      int index = 0;                      int top = m_singletonMode ? 0 : m_toolStrip.Height;                      foreach (object item in GetItemsFromContext())                      {                                                                          ItemControl itemControl;                          if (m_itemControls.TryGetValue(item' out itemControl))                          {                              itemControl.Index = index;                              itemControl.Top = top;                                index++;                              top += itemControl.Height;                          }                      }                        // Add controls for added items.                      // Currently only adding at the end is supported. If we ever want to support                       // inserting in the middle' then we'd probably want to have this step before .                      // the index-reordering one.                      foreach (object item in m_pendingItemsInserted)                      {                          ItemControl itemControl;                          if (m_unusedItemControls.Count > 0)                          {                              itemControl = m_unusedItemControls[m_unusedItemControls.Count - 1];                              m_unusedItemControls.RemoveAt(m_unusedItemControls.Count - 1);                              itemControl.Init(m_itemControls.Count' item'                                  m_singletonMode' m_indexColumnWidth' TransactionContext);                              itemControl.Visible = true;                            }                          else                          {                              itemControl = new ItemControl(m_itemControls.Count' item'                                  m_singletonMode' m_indexColumnWidth' TransactionContext' m_parentPropertyGridView);                              SkinService.ApplyActiveSkin(itemControl);                              Controls.Add(itemControl);                                                          itemControl.MouseUp += itemControl_MouseUp;                          }                          itemControl.Width = m_toolStrip.Width;                          itemControl.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;                          itemControl.Top = top;                            if (m_singletonMode)                              itemControl.Dock = DockStyle.Fill;                                                    top += itemControl.Height;                          m_itemControls.Add(item' itemControl);                          SubscribeItemEvents(itemControl);                                                    itemControl.Selected = false;                      }                        Height = top; // update height of main collection control                        ClearPendingChanges(); // all pending changes processed                        UpdateDeleteButton(true);                      UpdateMoveButtons(true);                      UpdateItemsCountLabel();                  }                  catch (Win32Exception ex)                  {                      // For very large collections (with 1000+ items) it is possible that Windows runs out of Window handles.                      // Such collections are currently not usable with this editor. To support such collections we'd have to                      // implement some kind of virtual mode (i.e. stream items in and out) but that would pose some new                      // challenges for editing operations (add' remove' move).                        // Clean up to release some window handles and keep the application running smoothly.                      foreach (ItemControl control in m_itemControls.Values)                      {                          if (Controls.Contains(control))                              Controls.Remove(control);                          control.Clear();                          control.Dispose();                      }                      m_itemControls.Clear();                        foreach (ItemControl control in m_unusedItemControls)                          control.Dispose();                      m_unusedItemControls.Clear();                        ClearPendingChanges();                        // Report error. Must be done after cleaning up' as before we may not even have the resources to show the message box.                      MessageBox.Show(                          "Failed to create item controls' probably because there were not enough Window handles available. Consider using a different editor for collections of this size and nature.\r\n\r\n"                          + ex.GetType().ToString() + Environment.NewLine                          + ex.Message'                          "Failed to create item controls"' MessageBoxButtons.OK' MessageBoxIcon.Error);                  }                  finally                  {                      //m_toolStrip.Enabled = true;                      ResumeLayout();                      m_processingPendingChanges = false;                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EnumUITypeEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EnumUITypeEditor.cs,EditValue,The following statement contains a magic number: if (m_editorService != null)              {                  ListBox listBox = new ListBox();                  listBox.DrawMode = DrawMode.OwnerDrawFixed;                  listBox.DrawItem += listBox_DrawItem;                  listBox.MouseMove += listBox_MouseMove;                    for (int i = 0; i < m_names.Length; i++)                  {                      listBox.Items.Add(m_names[i]);                      if (m_names[i].Equals(value) ||                          m_values[i].Equals(value))                      {                          listBox.SelectedIndex = i;                      }                  }                    // size control so all strings are completely visible                  using (Graphics g = listBox.CreateGraphics())                  {                      float width = 0f;                        foreach (string name in m_names)                      {                          float w = g.MeasureString(name' listBox.Font).Width;                          width = Math.Max(width' w);                      }                        float height = m_names.Length * listBox.ItemHeight;                      int scrollBarThickness = SystemInformation.VerticalScrollBarWidth;                      if (height > listBox.Height - 4) // vertical scrollbar?                          width += SystemInformation.VerticalScrollBarWidth;                        if (width > listBox.Width)                          listBox.Width = (int)width + 6;                  }                    listBox.SelectedIndexChanged += listBox_SelectedIndexChanged;                  listBox.MouseDown += listBox_OnMouseDown;                  listBox.MouseUp += listBox_OnMouseUp;                  listBox.MouseLeave += listBox_OnMouseLeave;                  listBox.PreviewKeyDown += listBox_OnPreviewKeyDown;                    m_editorService.DropDownControl(listBox);                  int index = listBox.SelectedIndex;                  if (index >= 0)                  {                      object newValue = null;                      if (value is int)                          newValue = m_values[index];                      else                          newValue = m_names[index];                      // be careful to return the same object if the value didn't change                      if (!newValue.Equals(value))                          value = newValue;                  }              }
Magic Number,Sce.Atf.Controls.PropertyEditing,EnumUITypeEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\EnumUITypeEditor.cs,EditValue,The following statement contains a magic number: if (m_editorService != null)              {                  ListBox listBox = new ListBox();                  listBox.DrawMode = DrawMode.OwnerDrawFixed;                  listBox.DrawItem += listBox_DrawItem;                  listBox.MouseMove += listBox_MouseMove;                    for (int i = 0; i < m_names.Length; i++)                  {                      listBox.Items.Add(m_names[i]);                      if (m_names[i].Equals(value) ||                          m_values[i].Equals(value))                      {                          listBox.SelectedIndex = i;                      }                  }                    // size control so all strings are completely visible                  using (Graphics g = listBox.CreateGraphics())                  {                      float width = 0f;                        foreach (string name in m_names)                      {                          float w = g.MeasureString(name' listBox.Font).Width;                          width = Math.Max(width' w);                      }                        float height = m_names.Length * listBox.ItemHeight;                      int scrollBarThickness = SystemInformation.VerticalScrollBarWidth;                      if (height > listBox.Height - 4) // vertical scrollbar?                          width += SystemInformation.VerticalScrollBarWidth;                        if (width > listBox.Width)                          listBox.Width = (int)width + 6;                  }                    listBox.SelectedIndexChanged += listBox_SelectedIndexChanged;                  listBox.MouseDown += listBox_OnMouseDown;                  listBox.MouseUp += listBox_OnMouseUp;                  listBox.MouseLeave += listBox_OnMouseLeave;                  listBox.PreviewKeyDown += listBox_OnPreviewKeyDown;                    m_editorService.DropDownControl(listBox);                  int index = listBox.SelectedIndex;                  if (index >= 0)                  {                      object newValue = null;                      if (value is int)                          newValue = m_values[index];                      else                          newValue = m_names[index];                      // be careful to return the same object if the value didn't change                      if (!newValue.Equals(value))                          value = newValue;                  }              }
Magic Number,Sce.Atf.Controls.PropertyEditing,FlagsUITypeEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\FlagsUITypeEditor.cs,EditValue,The following statement contains a magic number: if (m_editorService != null)              {                  CheckedListBox checkedListBox = new CheckedListBox();                  checkedListBox.CheckOnClick = true;                  foreach (string displayName in m_displayNames)                      checkedListBox.Items.Add(displayName);                    // size control so all strings are completely visible                  using (System.Drawing.Graphics g = checkedListBox.CreateGraphics())                  {                      float width = 0f;                        foreach (string displayName in m_displayNames)                      {                          float w = g.MeasureString(displayName' checkedListBox.Font).Width;                          width = Math.Max(width' w);                      }                        float height = m_displayNames.Length * checkedListBox.ItemHeight;                      int scrollBarThickness = SystemInformation.VerticalScrollBarWidth;                      if (height > checkedListBox.Height - 4) // vertical scrollbar?                          width += SystemInformation.VerticalScrollBarWidth;                        if (width > checkedListBox.Width)                          checkedListBox.Width = (int)width + 31; // magic number from Windows.Forms dll                  }                    if (value is string)                      FillCheckedListBoxFromString(value' checkedListBox);                  else if (value is int || value is uint)                      FillCheckedListBoxFromInt(value' checkedListBox);                  // otherwise' ignore value                    m_editorService.DropDownControl(checkedListBox);                    object newValue;                  if (value is string)                      newValue = ExtractStringFromCheckedListBox(checkedListBox);                  else                      newValue = ExtractIntFromCheckedListBox(checkedListBox);                  // be careful to return the same object if the value didn't change                  if (!newValue.Equals(value))                      value = newValue;              }
Magic Number,Sce.Atf.Controls.PropertyEditing,FlagsUITypeEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\FlagsUITypeEditor.cs,EditValue,The following statement contains a magic number: if (m_editorService != null)              {                  CheckedListBox checkedListBox = new CheckedListBox();                  checkedListBox.CheckOnClick = true;                  foreach (string displayName in m_displayNames)                      checkedListBox.Items.Add(displayName);                    // size control so all strings are completely visible                  using (System.Drawing.Graphics g = checkedListBox.CreateGraphics())                  {                      float width = 0f;                        foreach (string displayName in m_displayNames)                      {                          float w = g.MeasureString(displayName' checkedListBox.Font).Width;                          width = Math.Max(width' w);                      }                        float height = m_displayNames.Length * checkedListBox.ItemHeight;                      int scrollBarThickness = SystemInformation.VerticalScrollBarWidth;                      if (height > checkedListBox.Height - 4) // vertical scrollbar?                          width += SystemInformation.VerticalScrollBarWidth;                        if (width > checkedListBox.Width)                          checkedListBox.Width = (int)width + 31; // magic number from Windows.Forms dll                  }                    if (value is string)                      FillCheckedListBoxFromString(value' checkedListBox);                  else if (value is int || value is uint)                      FillCheckedListBoxFromInt(value' checkedListBox);                  // otherwise' ignore value                    m_editorService.DropDownControl(checkedListBox);                    object newValue;                  if (value is string)                      newValue = ExtractStringFromCheckedListBox(checkedListBox);                  else                      newValue = ExtractIntFromCheckedListBox(checkedListBox);                  // be careful to return the same object if the value didn't change                  if (!newValue.Equals(value))                      value = newValue;              }
Magic Number,Sce.Atf.Controls.PropertyEditing,GridControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridControl.cs,GridControl,The following statement contains a magic number: m_descriptionLabel.MaximumWidth = 5000;
Magic Number,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,ApplyColumnBestFit,The following statement contains a magic number: int padding = 4;
Magic Number,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnMouseWheel,The following statement contains a magic number: int value = m_vScrollBar.Value - e.Delta / 2;
Magic Number,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,Pick,The following statement contains a magic number: foreach (Property p in Properties)              {                  if (p.FirstInCategory)                  {                      if (pt.Y < HeaderHeight &&                          pt.X >= left &&                          pt.X <= left + ExpanderSize + 2 * xPadding)                      {                          result.Type = HitType.CategoryExpander;                          result.Property = p;                          result.Category = p.Category;                          result.Row = -1;                          result.Offset = new Point(pt.X - left' pt.Y);                          return result;                      }                        if (!GetVisible(p))                          left += RowHeight;                  }                    if (GetVisible(p))                  {                      int width = GetColumnInfo(p).Width;                      if (pt.X >= left && pt.X <= left + width)                      {                          result.Property = p;                          if ((pt.Y >= 0) && (pt.Y < HeaderHeight))                          {                              if (Math.Abs(left + width - pt.X) < SystemDragSize.Width)                              {                                  result.Type = HitType.ColumnHeaderRightEdge;                                  result.Offset = new Point(pt.X - left' pt.Y);                                  return result;                              }                              else                              {                                  result.Type = HitType.ColumnHeader;                                  result.Offset = new Point(pt.X - left' pt.Y);                                  return result;                              }                          }                            // check if after the property editing row                          int row = GetRowAtY(pt.Y);                          if (row < SelectedObjects.Length)                          {                              result.Offset = new Point(pt.X - left' pt.Y % RowHeight);                              result.Type = HitType.Cell;                              result.Row = row;                          }                          return result;                      }                        left += width;                  }              }
Magic Number,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,SetPens,The following statement contains a magic number: Color color = Color.FromArgb(255' backColor.R * 200 / 255' backColor.G * 200 / 255' backColor.B * 200 / 255);
Magic Number,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,SetPens,The following statement contains a magic number: Color color = Color.FromArgb(255' backColor.R * 200 / 255' backColor.G * 200 / 255' backColor.B * 200 / 255);
Magic Number,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,SetPens,The following statement contains a magic number: Color color = Color.FromArgb(255' backColor.R * 200 / 255' backColor.G * 200 / 255' backColor.B * 200 / 255);
Magic Number,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,SetPens,The following statement contains a magic number: Color color = Color.FromArgb(255' backColor.R * 200 / 255' backColor.G * 200 / 255' backColor.B * 200 / 255);
Magic Number,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,SetPens,The following statement contains a magic number: Color color = Color.FromArgb(255' backColor.R * 200 / 255' backColor.G * 200 / 255' backColor.B * 200 / 255);
Magic Number,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,SetPens,The following statement contains a magic number: Color color = Color.FromArgb(255' backColor.R * 200 / 255' backColor.G * 200 / 255' backColor.B * 200 / 255);
Magic Number,Sce.Atf.Controls.PropertyEditing,GridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,SetPens,The following statement contains a magic number: Color color = Color.FromArgb(255' backColor.R * 200 / 255' backColor.G * 200 / 255' backColor.B * 200 / 255);
Magic Number,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,DrawColumnHeader,The following statement contains a magic number: if (CanSort(p))                  {                      textRect.Width -= SortDirectionIndicatorWidth + xPadding;                      Sce.Atf.GdiUtil.DrawSortDirectionIndicator(                          textRect.Right + xPadding'                          textRect.Top + rowHeight / 2 - 1 - Sce.Atf.GdiUtil.SortDirectionIndicatorHeight / 2'                          info.NextSortDirection == ListSortDirection.Descending'                          g);                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,DrawColumnHeader,The following statement contains a magic number: if (CanSort(p))                  {                      textRect.Width -= SortDirectionIndicatorWidth + xPadding;                      Sce.Atf.GdiUtil.DrawSortDirectionIndicator(                          textRect.Right + xPadding'                          textRect.Top + rowHeight / 2 - 1 - Sce.Atf.GdiUtil.SortDirectionIndicatorHeight / 2'                          info.NextSortDirection == ListSortDirection.Descending'                          g);                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnMouseMove,The following statement contains a magic number: if (m_gridView.DragDropColumnsEnabed &&                      (s_columnHeaderMouseDownProperty != null) &&                      (!s_columnHeaderMouseDownProperty.DisableDragging))                  {                      // check to see if we should initiate a drag and drop of a column header                      // calc how far the mouse moved to make sure the mouse has moved a bit so we dont kick off a drag event on tiny movements                      int deltaSquared = ((e.Location.X - s_mouseDown.X) * (e.Location.X - s_mouseDown.X)) +                                         ((e.Location.Y - s_mouseDown.Y) * (e.Location.Y - s_mouseDown.Y));                        if ((s_columnHeaderMouseDown) && (e.Button == MouseButtons.Left) && (deltaSquared > 2))                      {                          s_draggingColumnHeader = true;                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnMouseMove,The following statement contains a magic number: if (s_draggingColumnHeader)                  {                      // figure out where to draw the drop column indicator and what property index we would insert at                      int left = -m_gridView.m_hScroll;                      int index = 0;                      m_dropColumnIndex = index;                      m_dropColumnX = 0;                      foreach (Property p in m_gridView.Properties)                      {                          if (m_gridView.GetVisible(p))                          {                              // walk the m_dropColumnIndex past columns that are not draggable.                               // we dont want to drop a column that would cause not draggable columns to move around                              if (p.DisableDragging &&                                  (index == m_dropColumnIndex))                              {                                  m_dropColumnX += m_gridView.GetColumnInfo(p).Width;                                  m_dropColumnIndex++;                              }                                // remember were the indicator should be drawn                              if (s_mouseMove.X >= (left + (int)(m_gridView.GetColumnInfo(p).Width * 0.5)))                              {                                  m_dropColumnX = left + m_gridView.GetColumnInfo(p).Width;                                  m_dropColumnIndex = index + 1;                              }                                left += m_gridView.GetColumnInfo(p).Width;                          }                          else if (p.FirstInCategory) // collapsed category                          {                              left += m_gridView.RowHeight;                          }                            index++;                      }                        // special case hacks so the indicator is clearly visible when it is on the edge of the grid                      if (m_dropColumnIndex == 0)                      {                          m_dropColumnX += 2;                      }                      if (m_dropColumnIndex == index)                      {                          m_dropColumnX -= 1;                      }                        Invalidate();                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnMouseMove,The following statement contains a magic number: if (s_draggingColumnHeader)                  {                      // figure out where to draw the drop column indicator and what property index we would insert at                      int left = -m_gridView.m_hScroll;                      int index = 0;                      m_dropColumnIndex = index;                      m_dropColumnX = 0;                      foreach (Property p in m_gridView.Properties)                      {                          if (m_gridView.GetVisible(p))                          {                              // walk the m_dropColumnIndex past columns that are not draggable.                               // we dont want to drop a column that would cause not draggable columns to move around                              if (p.DisableDragging &&                                  (index == m_dropColumnIndex))                              {                                  m_dropColumnX += m_gridView.GetColumnInfo(p).Width;                                  m_dropColumnIndex++;                              }                                // remember were the indicator should be drawn                              if (s_mouseMove.X >= (left + (int)(m_gridView.GetColumnInfo(p).Width * 0.5)))                              {                                  m_dropColumnX = left + m_gridView.GetColumnInfo(p).Width;                                  m_dropColumnIndex = index + 1;                              }                                left += m_gridView.GetColumnInfo(p).Width;                          }                          else if (p.FirstInCategory) // collapsed category                          {                              left += m_gridView.RowHeight;                          }                            index++;                      }                        // special case hacks so the indicator is clearly visible when it is on the edge of the grid                      if (m_dropColumnIndex == 0)                      {                          m_dropColumnX += 2;                      }                      if (m_dropColumnIndex == index)                      {                          m_dropColumnX -= 1;                      }                        Invalidate();                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EnumEditorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\LongEnumEditor.cs,EnumEditorControl,The following statement contains a magic number: MaxDropDownItems = 6;
Magic Number,Sce.Atf.Controls.PropertyEditing,NestedCollectionEditorForm,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NestedCollectionEditorForm.cs,Bind,The following statement contains a magic number: m_treeControl.Location = new Point(comboBox1.Location.X' comboBox1.Location.Y + 2 * FontHeight);
Magic Number,Sce.Atf.Controls.PropertyEditing,NumericTupleEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NumericTupleEditor.cs,Define,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls.PropertyEditing,NumericTupleEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NumericTupleEditor.cs,Define,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls.PropertyEditing,NumericTupleEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NumericTupleEditor.cs,Define,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls.PropertyEditing,NumericTupleEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NumericTupleEditor.cs,Define,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls.PropertyEditing,NumericTupleEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NumericTupleEditor.cs,Define,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls.PropertyEditing,NumericTupleEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NumericTupleEditor.cs,Define,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls.PropertyEditing,NumericTupleEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NumericTupleEditor.cs,Define,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls.PropertyEditing,NumericTupleEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NumericTupleEditor.cs,Define,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls.PropertyEditing,NumericTupleEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NumericTupleEditor.cs,Define,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls.PropertyEditing,NumericTupleEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NumericTupleEditor.cs,Define,The following statement contains a magic number: m_labelColors = new Color[]              {                  Color.FromArgb(200'40'0)'                  Color.FromArgb(100'160'0)'                  Color.FromArgb(40'120'240)'                  Color.FromArgb(20'20'20)'              };
Magic Number,Sce.Atf.Controls.PropertyEditing,NumericTupleEditor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\NumericTupleEditor.cs,GetEditingControl,The following statement contains a magic number: editingControl.Height = editingControl.Font.Height + 2;
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,PropertyEditingControl,The following statement contains a magic number: m_editButton.Left = base.Right - 18;
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,PropertyEditingControl,The following statement contains a magic number: m_editButton.Size = new Size(18' 18);
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,PropertyEditingControl,The following statement contains a magic number: m_editButton.Size = new Size(18' 18);
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,TrimStringLeftWithEllipses,The following statement contains a magic number: do              {                  float visibleRatio = (float)targetWidth / size.Width; // < 1                  int guessedTextLength = (int)(text.Length * visibleRatio);                    if (guessedTextLength == text.Length)                      --guessedTextLength;                    // Short text to guessedTextLength chars by removing chars at the front                  text = text.Remove(0' text.Length - guessedTextLength);                    size = graphics.MeasureString(text' font);              }              while (size.Width > targetWidth && ++iteration < 5 && text.Length > 0);
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,DropDownControl,The following statement contains a magic number: while (m_dropDownForm.Visible)              {                  Application.DoEvents();                  MsgWaitForMultipleObjects(0' 0' true' 250' 255);              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,DropDownControl,The following statement contains a magic number: while (m_dropDownForm.Visible)              {                  Application.DoEvents();                  MsgWaitForMultipleObjects(0' 0' true' 250' 255);              }
Magic Number,Sce.Atf.Controls.PropertyEditing,EditButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,OnPaint,The following statement contains a magic number: if (m_modal)                  {                      base.OnPaint(e);                      // draws "..."                      int x = r.X + r.Width / 2 - 5;                      int y = r.Bottom - 5;                      using (Brush brush = new SolidBrush(Enabled ? SystemColors.ControlText : SystemColors.GrayText))                      {                          g.FillRectangle(brush' x' y' 2' 2);                          g.FillRectangle(brush' x + 4' y' 2' 2);                          g.FillRectangle(brush' x + 8' y' 2' 2);                      }                  }                  else                  {                      if (Application.RenderWithVisualStyles)                      {                          ComboBoxRenderer.DrawDropDownButton(                              g'                              ClientRectangle'                              !Enabled ? ComboBoxState.Disabled : (m_pushed ? ComboBoxState.Pressed : ComboBoxState.Normal));                      }                      else                      {                          ControlPaint.DrawButton(                              g'                              ClientRectangle'                              !Enabled ? ButtonState.Inactive : (m_pushed ? ButtonState.Pushed : ButtonState.Normal));                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EditButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,OnPaint,The following statement contains a magic number: if (m_modal)                  {                      base.OnPaint(e);                      // draws "..."                      int x = r.X + r.Width / 2 - 5;                      int y = r.Bottom - 5;                      using (Brush brush = new SolidBrush(Enabled ? SystemColors.ControlText : SystemColors.GrayText))                      {                          g.FillRectangle(brush' x' y' 2' 2);                          g.FillRectangle(brush' x + 4' y' 2' 2);                          g.FillRectangle(brush' x + 8' y' 2' 2);                      }                  }                  else                  {                      if (Application.RenderWithVisualStyles)                      {                          ComboBoxRenderer.DrawDropDownButton(                              g'                              ClientRectangle'                              !Enabled ? ComboBoxState.Disabled : (m_pushed ? ComboBoxState.Pressed : ComboBoxState.Normal));                      }                      else                      {                          ControlPaint.DrawButton(                              g'                              ClientRectangle'                              !Enabled ? ButtonState.Inactive : (m_pushed ? ButtonState.Pushed : ButtonState.Normal));                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EditButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,OnPaint,The following statement contains a magic number: if (m_modal)                  {                      base.OnPaint(e);                      // draws "..."                      int x = r.X + r.Width / 2 - 5;                      int y = r.Bottom - 5;                      using (Brush brush = new SolidBrush(Enabled ? SystemColors.ControlText : SystemColors.GrayText))                      {                          g.FillRectangle(brush' x' y' 2' 2);                          g.FillRectangle(brush' x + 4' y' 2' 2);                          g.FillRectangle(brush' x + 8' y' 2' 2);                      }                  }                  else                  {                      if (Application.RenderWithVisualStyles)                      {                          ComboBoxRenderer.DrawDropDownButton(                              g'                              ClientRectangle'                              !Enabled ? ComboBoxState.Disabled : (m_pushed ? ComboBoxState.Pressed : ComboBoxState.Normal));                      }                      else                      {                          ControlPaint.DrawButton(                              g'                              ClientRectangle'                              !Enabled ? ButtonState.Inactive : (m_pushed ? ButtonState.Pushed : ButtonState.Normal));                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EditButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,OnPaint,The following statement contains a magic number: if (m_modal)                  {                      base.OnPaint(e);                      // draws "..."                      int x = r.X + r.Width / 2 - 5;                      int y = r.Bottom - 5;                      using (Brush brush = new SolidBrush(Enabled ? SystemColors.ControlText : SystemColors.GrayText))                      {                          g.FillRectangle(brush' x' y' 2' 2);                          g.FillRectangle(brush' x + 4' y' 2' 2);                          g.FillRectangle(brush' x + 8' y' 2' 2);                      }                  }                  else                  {                      if (Application.RenderWithVisualStyles)                      {                          ComboBoxRenderer.DrawDropDownButton(                              g'                              ClientRectangle'                              !Enabled ? ComboBoxState.Disabled : (m_pushed ? ComboBoxState.Pressed : ComboBoxState.Normal));                      }                      else                      {                          ControlPaint.DrawButton(                              g'                              ClientRectangle'                              !Enabled ? ButtonState.Inactive : (m_pushed ? ButtonState.Pushed : ButtonState.Normal));                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EditButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,OnPaint,The following statement contains a magic number: if (m_modal)                  {                      base.OnPaint(e);                      // draws "..."                      int x = r.X + r.Width / 2 - 5;                      int y = r.Bottom - 5;                      using (Brush brush = new SolidBrush(Enabled ? SystemColors.ControlText : SystemColors.GrayText))                      {                          g.FillRectangle(brush' x' y' 2' 2);                          g.FillRectangle(brush' x + 4' y' 2' 2);                          g.FillRectangle(brush' x + 8' y' 2' 2);                      }                  }                  else                  {                      if (Application.RenderWithVisualStyles)                      {                          ComboBoxRenderer.DrawDropDownButton(                              g'                              ClientRectangle'                              !Enabled ? ComboBoxState.Disabled : (m_pushed ? ComboBoxState.Pressed : ComboBoxState.Normal));                      }                      else                      {                          ControlPaint.DrawButton(                              g'                              ClientRectangle'                              !Enabled ? ButtonState.Inactive : (m_pushed ? ButtonState.Pushed : ButtonState.Normal));                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EditButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,OnPaint,The following statement contains a magic number: if (m_modal)                  {                      base.OnPaint(e);                      // draws "..."                      int x = r.X + r.Width / 2 - 5;                      int y = r.Bottom - 5;                      using (Brush brush = new SolidBrush(Enabled ? SystemColors.ControlText : SystemColors.GrayText))                      {                          g.FillRectangle(brush' x' y' 2' 2);                          g.FillRectangle(brush' x + 4' y' 2' 2);                          g.FillRectangle(brush' x + 8' y' 2' 2);                      }                  }                  else                  {                      if (Application.RenderWithVisualStyles)                      {                          ComboBoxRenderer.DrawDropDownButton(                              g'                              ClientRectangle'                              !Enabled ? ComboBoxState.Disabled : (m_pushed ? ComboBoxState.Pressed : ComboBoxState.Normal));                      }                      else                      {                          ControlPaint.DrawButton(                              g'                              ClientRectangle'                              !Enabled ? ButtonState.Inactive : (m_pushed ? ButtonState.Pushed : ButtonState.Normal));                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EditButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,OnPaint,The following statement contains a magic number: if (m_modal)                  {                      base.OnPaint(e);                      // draws "..."                      int x = r.X + r.Width / 2 - 5;                      int y = r.Bottom - 5;                      using (Brush brush = new SolidBrush(Enabled ? SystemColors.ControlText : SystemColors.GrayText))                      {                          g.FillRectangle(brush' x' y' 2' 2);                          g.FillRectangle(brush' x + 4' y' 2' 2);                          g.FillRectangle(brush' x + 8' y' 2' 2);                      }                  }                  else                  {                      if (Application.RenderWithVisualStyles)                      {                          ComboBoxRenderer.DrawDropDownButton(                              g'                              ClientRectangle'                              !Enabled ? ComboBoxState.Disabled : (m_pushed ? ComboBoxState.Pressed : ComboBoxState.Normal));                      }                      else                      {                          ControlPaint.DrawButton(                              g'                              ClientRectangle'                              !Enabled ? ButtonState.Inactive : (m_pushed ? ButtonState.Pushed : ButtonState.Normal));                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EditButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,OnPaint,The following statement contains a magic number: if (m_modal)                  {                      base.OnPaint(e);                      // draws "..."                      int x = r.X + r.Width / 2 - 5;                      int y = r.Bottom - 5;                      using (Brush brush = new SolidBrush(Enabled ? SystemColors.ControlText : SystemColors.GrayText))                      {                          g.FillRectangle(brush' x' y' 2' 2);                          g.FillRectangle(brush' x + 4' y' 2' 2);                          g.FillRectangle(brush' x + 8' y' 2' 2);                      }                  }                  else                  {                      if (Application.RenderWithVisualStyles)                      {                          ComboBoxRenderer.DrawDropDownButton(                              g'                              ClientRectangle'                              !Enabled ? ComboBoxState.Disabled : (m_pushed ? ComboBoxState.Pressed : ComboBoxState.Normal));                      }                      else                      {                          ControlPaint.DrawButton(                              g'                              ClientRectangle'                              !Enabled ? ButtonState.Inactive : (m_pushed ? ButtonState.Pushed : ButtonState.Normal));                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EditButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,OnPaint,The following statement contains a magic number: if (m_modal)                  {                      base.OnPaint(e);                      // draws "..."                      int x = r.X + r.Width / 2 - 5;                      int y = r.Bottom - 5;                      using (Brush brush = new SolidBrush(Enabled ? SystemColors.ControlText : SystemColors.GrayText))                      {                          g.FillRectangle(brush' x' y' 2' 2);                          g.FillRectangle(brush' x + 4' y' 2' 2);                          g.FillRectangle(brush' x + 8' y' 2' 2);                      }                  }                  else                  {                      if (Application.RenderWithVisualStyles)                      {                          ComboBoxRenderer.DrawDropDownButton(                              g'                              ClientRectangle'                              !Enabled ? ComboBoxState.Disabled : (m_pushed ? ComboBoxState.Pressed : ComboBoxState.Normal));                      }                      else                      {                          ControlPaint.DrawButton(                              g'                              ClientRectangle'                              !Enabled ? ButtonState.Inactive : (m_pushed ? ButtonState.Pushed : ButtonState.Normal));                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EditButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,OnPaint,The following statement contains a magic number: if (m_modal)                  {                      base.OnPaint(e);                      // draws "..."                      int x = r.X + r.Width / 2 - 5;                      int y = r.Bottom - 5;                      using (Brush brush = new SolidBrush(Enabled ? SystemColors.ControlText : SystemColors.GrayText))                      {                          g.FillRectangle(brush' x' y' 2' 2);                          g.FillRectangle(brush' x + 4' y' 2' 2);                          g.FillRectangle(brush' x + 8' y' 2' 2);                      }                  }                  else                  {                      if (Application.RenderWithVisualStyles)                      {                          ComboBoxRenderer.DrawDropDownButton(                              g'                              ClientRectangle'                              !Enabled ? ComboBoxState.Disabled : (m_pushed ? ComboBoxState.Pressed : ComboBoxState.Normal));                      }                      else                      {                          ControlPaint.DrawButton(                              g'                              ClientRectangle'                              !Enabled ? ButtonState.Inactive : (m_pushed ? ButtonState.Pushed : ButtonState.Normal));                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,EditButton,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyEditingControl.cs,OnPaint,The following statement contains a magic number: if (m_modal)                  {                      base.OnPaint(e);                      // draws "..."                      int x = r.X + r.Width / 2 - 5;                      int y = r.Bottom - 5;                      using (Brush brush = new SolidBrush(Enabled ? SystemColors.ControlText : SystemColors.GrayText))                      {                          g.FillRectangle(brush' x' y' 2' 2);                          g.FillRectangle(brush' x + 4' y' 2' 2);                          g.FillRectangle(brush' x + 8' y' 2' 2);                      }                  }                  else                  {                      if (Application.RenderWithVisualStyles)                      {                          ComboBoxRenderer.DrawDropDownButton(                              g'                              ClientRectangle'                              !Enabled ? ComboBoxState.Disabled : (m_pushed ? ComboBoxState.Pressed : ComboBoxState.Normal));                      }                      else                      {                          ControlPaint.DrawButton(                              g'                              ClientRectangle'                              !Enabled ? ButtonState.Inactive : (m_pushed ? ButtonState.Pushed : ButtonState.Normal));                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,PropertyGrid,The following statement contains a magic number: if ((mode & PropertyGridMode.DisableSearchControls) == 0)              {                  var dropDownButton = new ToolStripDropDownButton();                  dropDownButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  dropDownButton.Image = ResourceUtil.GetImage16(Resources.SearchImage);                  dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  dropDownButton.Name = "PropertyGridSearchButton";                  dropDownButton.Size = new System.Drawing.Size(29' 22);                  dropDownButton.Text = "Search".Localize("'Search' is a verb");                    m_patternTextBox = new ToolStripAutoFitTextBox();                  m_patternTextBox.Name = "patternTextBox";                  m_patternTextBox.MaximumWidth = 1080;                  m_patternTextBox.KeyUp += patternTextBox_KeyUp;                  m_patternTextBox.TextBox.PreviewKeyDown += patternTextBox_PreviewKeyDown;                    var clearSearchButton = new ToolStripButton();                  clearSearchButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  clearSearchButton.Image = ResourceUtil.GetImage16(Resources.DeleteImage);                  dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  clearSearchButton.Name = "PropertyGridClearSearchButton";                  clearSearchButton.Size = new System.Drawing.Size(29' 22);                  clearSearchButton.Text = "Clear Search".Localize("'Clear' is a verb");                  clearSearchButton.Click += clearSearchButton_Click;                    m_toolStrip.Items.AddRange(                      new ToolStripItem[] {                       dropDownButton'                       m_patternTextBox'                      clearSearchButton                      });              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,PropertyGrid,The following statement contains a magic number: if ((mode & PropertyGridMode.DisableSearchControls) == 0)              {                  var dropDownButton = new ToolStripDropDownButton();                  dropDownButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  dropDownButton.Image = ResourceUtil.GetImage16(Resources.SearchImage);                  dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  dropDownButton.Name = "PropertyGridSearchButton";                  dropDownButton.Size = new System.Drawing.Size(29' 22);                  dropDownButton.Text = "Search".Localize("'Search' is a verb");                    m_patternTextBox = new ToolStripAutoFitTextBox();                  m_patternTextBox.Name = "patternTextBox";                  m_patternTextBox.MaximumWidth = 1080;                  m_patternTextBox.KeyUp += patternTextBox_KeyUp;                  m_patternTextBox.TextBox.PreviewKeyDown += patternTextBox_PreviewKeyDown;                    var clearSearchButton = new ToolStripButton();                  clearSearchButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  clearSearchButton.Image = ResourceUtil.GetImage16(Resources.DeleteImage);                  dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  clearSearchButton.Name = "PropertyGridClearSearchButton";                  clearSearchButton.Size = new System.Drawing.Size(29' 22);                  clearSearchButton.Text = "Clear Search".Localize("'Clear' is a verb");                  clearSearchButton.Click += clearSearchButton_Click;                    m_toolStrip.Items.AddRange(                      new ToolStripItem[] {                       dropDownButton'                       m_patternTextBox'                      clearSearchButton                      });              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,PropertyGrid,The following statement contains a magic number: if ((mode & PropertyGridMode.DisableSearchControls) == 0)              {                  var dropDownButton = new ToolStripDropDownButton();                  dropDownButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  dropDownButton.Image = ResourceUtil.GetImage16(Resources.SearchImage);                  dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  dropDownButton.Name = "PropertyGridSearchButton";                  dropDownButton.Size = new System.Drawing.Size(29' 22);                  dropDownButton.Text = "Search".Localize("'Search' is a verb");                    m_patternTextBox = new ToolStripAutoFitTextBox();                  m_patternTextBox.Name = "patternTextBox";                  m_patternTextBox.MaximumWidth = 1080;                  m_patternTextBox.KeyUp += patternTextBox_KeyUp;                  m_patternTextBox.TextBox.PreviewKeyDown += patternTextBox_PreviewKeyDown;                    var clearSearchButton = new ToolStripButton();                  clearSearchButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  clearSearchButton.Image = ResourceUtil.GetImage16(Resources.DeleteImage);                  dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  clearSearchButton.Name = "PropertyGridClearSearchButton";                  clearSearchButton.Size = new System.Drawing.Size(29' 22);                  clearSearchButton.Text = "Clear Search".Localize("'Clear' is a verb");                  clearSearchButton.Click += clearSearchButton_Click;                    m_toolStrip.Items.AddRange(                      new ToolStripItem[] {                       dropDownButton'                       m_patternTextBox'                      clearSearchButton                      });              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,PropertyGrid,The following statement contains a magic number: if ((mode & PropertyGridMode.DisableSearchControls) == 0)              {                  var dropDownButton = new ToolStripDropDownButton();                  dropDownButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  dropDownButton.Image = ResourceUtil.GetImage16(Resources.SearchImage);                  dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  dropDownButton.Name = "PropertyGridSearchButton";                  dropDownButton.Size = new System.Drawing.Size(29' 22);                  dropDownButton.Text = "Search".Localize("'Search' is a verb");                    m_patternTextBox = new ToolStripAutoFitTextBox();                  m_patternTextBox.Name = "patternTextBox";                  m_patternTextBox.MaximumWidth = 1080;                  m_patternTextBox.KeyUp += patternTextBox_KeyUp;                  m_patternTextBox.TextBox.PreviewKeyDown += patternTextBox_PreviewKeyDown;                    var clearSearchButton = new ToolStripButton();                  clearSearchButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  clearSearchButton.Image = ResourceUtil.GetImage16(Resources.DeleteImage);                  dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  clearSearchButton.Name = "PropertyGridClearSearchButton";                  clearSearchButton.Size = new System.Drawing.Size(29' 22);                  clearSearchButton.Text = "Clear Search".Localize("'Clear' is a verb");                  clearSearchButton.Click += clearSearchButton_Click;                    m_toolStrip.Items.AddRange(                      new ToolStripItem[] {                       dropDownButton'                       m_patternTextBox'                      clearSearchButton                      });              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,PropertyGrid,The following statement contains a magic number: if ((mode & PropertyGridMode.DisableSearchControls) == 0)              {                  var dropDownButton = new ToolStripDropDownButton();                  dropDownButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  dropDownButton.Image = ResourceUtil.GetImage16(Resources.SearchImage);                  dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  dropDownButton.Name = "PropertyGridSearchButton";                  dropDownButton.Size = new System.Drawing.Size(29' 22);                  dropDownButton.Text = "Search".Localize("'Search' is a verb");                    m_patternTextBox = new ToolStripAutoFitTextBox();                  m_patternTextBox.Name = "patternTextBox";                  m_patternTextBox.MaximumWidth = 1080;                  m_patternTextBox.KeyUp += patternTextBox_KeyUp;                  m_patternTextBox.TextBox.PreviewKeyDown += patternTextBox_PreviewKeyDown;                    var clearSearchButton = new ToolStripButton();                  clearSearchButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  clearSearchButton.Image = ResourceUtil.GetImage16(Resources.DeleteImage);                  dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  clearSearchButton.Name = "PropertyGridClearSearchButton";                  clearSearchButton.Size = new System.Drawing.Size(29' 22);                  clearSearchButton.Text = "Clear Search".Localize("'Clear' is a verb");                  clearSearchButton.Click += clearSearchButton_Click;                    m_toolStrip.Items.AddRange(                      new ToolStripItem[] {                       dropDownButton'                       m_patternTextBox'                      clearSearchButton                      });              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,PropertyGrid,The following statement contains a magic number: if ((mode & PropertyGridMode.HideResetAllButton) == 0)              {                  // Reset all button.                  var resetAllButton = new ToolStripButton();                  resetAllButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  resetAllButton.Image = ResourceUtil.GetImage16(Resources.ResetImage);                  resetAllButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  resetAllButton.Name = "PropertyGridResetAllButton";                  resetAllButton.Size = new Size(29' 22);                  resetAllButton.ToolTipText = "Reset all properties".Localize();                  resetAllButton.Click += (sender' e) =>                      {                          ITransactionContext transaction = m_propertyGridView.EditingContext.As<ITransactionContext>();                                                  transaction.DoTransaction(delegate                          {                              ResetAll();                          }'                          "Reset All Properties".Localize("'Reset' is a verb and this is the name of a command"));                      };                  m_toolStrip.Items.Add(resetAllButton);              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,PropertyGrid,The following statement contains a magic number: if ((mode & PropertyGridMode.HideResetAllButton) == 0)              {                  // Reset all button.                  var resetAllButton = new ToolStripButton();                  resetAllButton.DisplayStyle = ToolStripItemDisplayStyle.Image;                  resetAllButton.Image = ResourceUtil.GetImage16(Resources.ResetImage);                  resetAllButton.ImageTransparentColor = System.Drawing.Color.Magenta;                  resetAllButton.Name = "PropertyGridResetAllButton";                  resetAllButton.Size = new Size(29' 22);                  resetAllButton.ToolTipText = "Reset all properties".Localize();                  resetAllButton.Click += (sender' e) =>                      {                          ITransactionContext transaction = m_propertyGridView.EditingContext.As<ITransactionContext>();                                                  transaction.DoTransaction(delegate                          {                              ResetAll();                          }'                          "Reset All Properties".Localize("'Reset' is a verb and this is the name of a command"));                      };                  m_toolStrip.Items.Add(resetAllButton);              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGrid,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,PropertyGrid,The following statement contains a magic number: if ((mode & PropertyGridMode.DisplayDescriptions) == 0)                  Controls.Add(m_propertyGridView);              else              {                  m_splitContainer.Orientation = Orientation.Horizontal;                  m_splitContainer.BackColor = SystemColors.InactiveBorder;                  m_splitContainer.FixedPanel = FixedPanel.Panel2;                  m_splitContainer.SplitterWidth = 8;                  m_splitContainer.Dock = DockStyle.Fill;                    m_splitContainer.Panel1.Controls.Add(m_propertyGridView);                    m_descriptionTextBox = new DescriptionControl(this);                  m_descriptionTextBox.BackColor = SystemColors.Window;                  m_descriptionTextBox.Dock = DockStyle.Fill;                    m_splitContainer.Panel2.Controls.Add(m_descriptionTextBox);                  Controls.Add(m_splitContainer);                    m_propertyGridView.SelectedPropertyChanged += propertyGrid_SelectedRowChanged;                  m_descriptionTextBox.ClearDescription();              }
Magic Number,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,SetDescription,The following statement contains a magic number: if (string.IsNullOrEmpty(m_name) && string.IsNullOrEmpty(visibleDescription))                  {                      m_propertyGrid.m_splitContainer.Panel2Collapsed = true;                  }                  else                  {                      m_propertyGrid.m_splitContainer.Panel2Collapsed = false;                      Size sz = new Size(ClientSize.Width' int.MaxValue);                      sz = TextRenderer.MeasureText(visibleDescription' Font' sz' m_TextFormatFlags);                      if (!string.IsNullOrEmpty(m_name))                          sz.Height += m_boldFont.Height + 2 + 12;                        int splitter_distance = (int)Math.Max(m_propertyGrid.m_splitContainer.Height - sz.Height' 0.5f * m_propertyGrid.m_splitContainer.Height);                        // SplitterDistance must be between Panel1MinSize and Height - Panel2MinSize.                      splitter_distance = Math.Max(splitter_distance' m_propertyGrid.m_splitContainer.Panel1MinSize);                      splitter_distance = Math.Min(splitter_distance' m_propertyGrid.m_splitContainer.Height - m_propertyGrid.m_splitContainer.Panel2MinSize);                        // m_propertyGrid.m_splitContainer.Height can be zero under some unusual circumstances involving                      //  the auto-hide feature. So' let's make sure splitter_distance is non-negative.                      if (splitter_distance >= 0)                          m_propertyGrid.m_splitContainer.SplitterDistance = splitter_distance;                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,SetDescription,The following statement contains a magic number: if (string.IsNullOrEmpty(m_name) && string.IsNullOrEmpty(visibleDescription))                  {                      m_propertyGrid.m_splitContainer.Panel2Collapsed = true;                  }                  else                  {                      m_propertyGrid.m_splitContainer.Panel2Collapsed = false;                      Size sz = new Size(ClientSize.Width' int.MaxValue);                      sz = TextRenderer.MeasureText(visibleDescription' Font' sz' m_TextFormatFlags);                      if (!string.IsNullOrEmpty(m_name))                          sz.Height += m_boldFont.Height + 2 + 12;                        int splitter_distance = (int)Math.Max(m_propertyGrid.m_splitContainer.Height - sz.Height' 0.5f * m_propertyGrid.m_splitContainer.Height);                        // SplitterDistance must be between Panel1MinSize and Height - Panel2MinSize.                      splitter_distance = Math.Max(splitter_distance' m_propertyGrid.m_splitContainer.Panel1MinSize);                      splitter_distance = Math.Min(splitter_distance' m_propertyGrid.m_splitContainer.Height - m_propertyGrid.m_splitContainer.Panel2MinSize);                        // m_propertyGrid.m_splitContainer.Height can be zero under some unusual circumstances involving                      //  the auto-hide feature. So' let's make sure splitter_distance is non-negative.                      if (splitter_distance >= 0)                          m_propertyGrid.m_splitContainer.SplitterDistance = splitter_distance;                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,ParseMarkup,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++)                  {                      string text' url;                                            // Look for a wiki-formed hyperlink.                      string a = tokens[i];                      text = a;                      url = null;                        if (a == "[")                      {                          string b = i + 1 < tokens.Count ? tokens[i + 1] : string.Empty;                          string c = i + 2 < tokens.Count ? tokens[i + 2] : string.Empty;                          string d = i + 3 < tokens.Count ? tokens[i + 3] : string.Empty;                          string e = i + 4 < tokens.Count ? tokens[i + 4] : string.Empty;                          if (c == "|" && e == "]")                          {                              text = b;                              url = d;                              i += 4;                          }                      }                        yield return new MarkupToken { Text = text' Url = url };                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,ParseMarkup,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++)                  {                      string text' url;                                            // Look for a wiki-formed hyperlink.                      string a = tokens[i];                      text = a;                      url = null;                        if (a == "[")                      {                          string b = i + 1 < tokens.Count ? tokens[i + 1] : string.Empty;                          string c = i + 2 < tokens.Count ? tokens[i + 2] : string.Empty;                          string d = i + 3 < tokens.Count ? tokens[i + 3] : string.Empty;                          string e = i + 4 < tokens.Count ? tokens[i + 4] : string.Empty;                          if (c == "|" && e == "]")                          {                              text = b;                              url = d;                              i += 4;                          }                      }                        yield return new MarkupToken { Text = text' Url = url };                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,ParseMarkup,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++)                  {                      string text' url;                                            // Look for a wiki-formed hyperlink.                      string a = tokens[i];                      text = a;                      url = null;                        if (a == "[")                      {                          string b = i + 1 < tokens.Count ? tokens[i + 1] : string.Empty;                          string c = i + 2 < tokens.Count ? tokens[i + 2] : string.Empty;                          string d = i + 3 < tokens.Count ? tokens[i + 3] : string.Empty;                          string e = i + 4 < tokens.Count ? tokens[i + 4] : string.Empty;                          if (c == "|" && e == "]")                          {                              text = b;                              url = d;                              i += 4;                          }                      }                        yield return new MarkupToken { Text = text' Url = url };                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,ParseMarkup,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++)                  {                      string text' url;                                            // Look for a wiki-formed hyperlink.                      string a = tokens[i];                      text = a;                      url = null;                        if (a == "[")                      {                          string b = i + 1 < tokens.Count ? tokens[i + 1] : string.Empty;                          string c = i + 2 < tokens.Count ? tokens[i + 2] : string.Empty;                          string d = i + 3 < tokens.Count ? tokens[i + 3] : string.Empty;                          string e = i + 4 < tokens.Count ? tokens[i + 4] : string.Empty;                          if (c == "|" && e == "]")                          {                              text = b;                              url = d;                              i += 4;                          }                      }                        yield return new MarkupToken { Text = text' Url = url };                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,ParseMarkup,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++)                  {                      string text' url;                                            // Look for a wiki-formed hyperlink.                      string a = tokens[i];                      text = a;                      url = null;                        if (a == "[")                      {                          string b = i + 1 < tokens.Count ? tokens[i + 1] : string.Empty;                          string c = i + 2 < tokens.Count ? tokens[i + 2] : string.Empty;                          string d = i + 3 < tokens.Count ? tokens[i + 3] : string.Empty;                          string e = i + 4 < tokens.Count ? tokens[i + 4] : string.Empty;                          if (c == "|" && e == "]")                          {                              text = b;                              url = d;                              i += 4;                          }                      }                        yield return new MarkupToken { Text = text' Url = url };                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,ParseMarkup,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++)                  {                      string text' url;                                            // Look for a wiki-formed hyperlink.                      string a = tokens[i];                      text = a;                      url = null;                        if (a == "[")                      {                          string b = i + 1 < tokens.Count ? tokens[i + 1] : string.Empty;                          string c = i + 2 < tokens.Count ? tokens[i + 2] : string.Empty;                          string d = i + 3 < tokens.Count ? tokens[i + 3] : string.Empty;                          string e = i + 4 < tokens.Count ? tokens[i + 4] : string.Empty;                          if (c == "|" && e == "]")                          {                              text = b;                              url = d;                              i += 4;                          }                      }                        yield return new MarkupToken { Text = text' Url = url };                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,ParseMarkup,The following statement contains a magic number: for (int i = 0; i < tokens.Count; i++)                  {                      string text' url;                                            // Look for a wiki-formed hyperlink.                      string a = tokens[i];                      text = a;                      url = null;                        if (a == "[")                      {                          string b = i + 1 < tokens.Count ? tokens[i + 1] : string.Empty;                          string c = i + 2 < tokens.Count ? tokens[i + 2] : string.Empty;                          string d = i + 3 < tokens.Count ? tokens[i + 3] : string.Empty;                          string e = i + 4 < tokens.Count ? tokens[i + 4] : string.Empty;                          if (c == "|" && e == "]")                          {                              text = b;                              url = d;                              i += 4;                          }                      }                        yield return new MarkupToken { Text = text' Url = url };                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,ConvertToRtf,The following statement contains a magic number: foreach (int codePoint in codePoints)                  {                      if (codePoint < 128) //RTF is 7-bit ASCII                      {                          sb.Append((char) codePoint);                      }                      else if (codePoint < 65536) //escaped character can be signed 16 bit                      {                          sb.Append(@"\u");                          sb.Append((short) codePoint);                          sb.Append(substitutionChar);                      }                      else //too large! Maybe a code page could be set and then referenced?                      {                          sb.Append(substitutionChar);                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,DescriptionControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGrid.cs,ConvertToRtf,The following statement contains a magic number: foreach (int codePoint in codePoints)                  {                      if (codePoint < 128) //RTF is 7-bit ASCII                      {                          sb.Append((char) codePoint);                      }                      else if (codePoint < 65536) //escaped character can be signed 16 bit                      {                          sb.Append(@"\u");                          sb.Append((short) codePoint);                          sb.Append(substitutionChar);                      }                      else //too large! Maybe a code page could be set and then referenced?                      {                          sb.Append(substitutionChar);                      }                  }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,PropertyGridView,The following statement contains a magic number: m_editingControl.EditButtonSize = new Size(17' 17);
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,PropertyGridView,The following statement contains a magic number: m_editingControl.EditButtonSize = new Size(17' 17);
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,OnMouseMove,The following statement contains a magic number: if (property != m_hoverProperty)              {                  m_hoverProperty = property;                  if (m_allowTooltips)                  {                      m_toolTip.RemoveAll();                      if (m_hoverProperty != null && !m_dragging)                      {                          m_toolTip.Show(property.Descriptor.Description' this' e.X' e.Y + 20);                      }                  }              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,OnMouseWheel,The following statement contains a magic number: int value = m_scrollBar.Value - e.Delta / 2;
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,OnPaint,The following statement contains a magic number: const int SubCategoryIndent = 13;
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,AutoAdjustSplitter,The following statement contains a magic number: int maxPropNameWidth = ExpanderSize * 2;
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,AutoAdjustSplitter,The following statement contains a magic number: foreach (Property property in Properties)              {                  int depth = GetDepth(property) + (ShowCategories ? 1 : 0);                  int expanderX = ExpanderSize * 2 * (depth + 1);                  int width = expanderX + TextRenderer.MeasureText(property.Descriptor.DisplayName' Font).Width;                  if (width > maxPropNameWidth)                      maxPropNameWidth = width;              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,TryMakeSelectionVisible,The following statement contains a magic number: if (SelectedProperty != null)              {                  foreach (Pair<object' int> itemPosition in ItemPositions)                  {                      Property p = itemPosition.First as Property;                      if (p != null && p == SelectedProperty)                      {                          int currPos = itemPosition.Second;                          if (currPos < m_scroll)                              SetVerticalScroll(currPos);                          else if (currPos + RowHeight > m_scroll + Height - RowHeight * 2)                              SetVerticalScroll(currPos + RowHeight - (Height - RowHeight * 2));                          break;                      }                  }              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,TryMakeSelectionVisible,The following statement contains a magic number: if (SelectedProperty != null)              {                  foreach (Pair<object' int> itemPosition in ItemPositions)                  {                      Property p = itemPosition.First as Property;                      if (p != null && p == SelectedProperty)                      {                          int currPos = itemPosition.Second;                          if (currPos < m_scroll)                              SetVerticalScroll(currPos);                          else if (currPos + RowHeight > m_scroll + Height - RowHeight * 2)                              SetVerticalScroll(currPos + RowHeight - (Height - RowHeight * 2));                          break;                      }                  }              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,SelectProperty,The following statement contains a magic number: foreach (Pair<object' int> itemPosition in ItemPositions)              {                  Property p = itemPosition.First as Property;                  if (p != null && p.Descriptor.Equals(descriptor))                  {                      SetVerticalScroll(itemPosition.Second - 2 * RowHeight);                      StartPropertyEdit(p);                      return true;                  }              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawCategoryRow,The following statement contains a magic number: int yPadding = (int)((RowHeight - FontHeight) / 2);
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawCategoryRow,The following statement contains a magic number: GdiUtil.DrawExpander(x + xPadding' y + (RowHeight - ExpanderSize) / 2' expanded' g' CategoryExpanderPen);
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawCategoryRow,The following statement contains a magic number: int offset = ExpanderSize + 2 * xPadding;
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawPropertyRow,The following statement contains a magic number: int yPadding = (int)((RowHeight - FontHeight) / 2);
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawPropertyRow,The following statement contains a magic number: int expanderX = ExpanderSize * 2 * depth;
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawPropertyRow,The following statement contains a magic number: if (property.ChildProperties != null && property.ChildProperties.Count > 0)                  GdiUtil.DrawExpander(x + expanderX' y + (RowHeight - ExpanderSize) / 2' property.ChildrenExpanded' g' PropertyExpanderPen);
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawPropertyRow,The following statement contains a magic number: if (property.NameHasWholeRow)              {                  nameWidth = width - 2*xPadding;                  verticalLineOffset = RowHeight + 1;              }              else              {                  nameWidth = middle - 2*xPadding;                  verticalLineOffset = 0;              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawPropertyRow,The following statement contains a magic number: if (property.NameHasWholeRow)              {                  nameWidth = width - 2*xPadding;                  verticalLineOffset = RowHeight + 1;              }              else              {                  nameWidth = middle - 2*xPadding;                  verticalLineOffset = 0;              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawPropertyRow,The following statement contains a magic number: if (SelectedProperty == property)              {                                  // show reset button                  if (ShowResetButton && CanResetCurrent                      && middle > m_resetButton.Width)                  {                      m_resetButton.Visible = true;                      m_resetButton.Top = (height - m_resetButton.Height) / 2 + y;                      m_resetButton.Left = middle - m_resetButton.Width - 3;                                        m_resetButton.Draw(g);                  }                              }
Magic Number,Sce.Atf.Controls.PropertyEditing,PropertyGridView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\PropertyGridView.cs,DrawPropertyRow,The following statement contains a magic number: if (SelectedProperty == property)              {                                  // show reset button                  if (ShowResetButton && CanResetCurrent                      && middle > m_resetButton.Width)                  {                      m_resetButton.Visible = true;                      m_resetButton.Top = (height - m_resetButton.Height) / 2 + y;                      m_resetButton.Left = middle - m_resetButton.Width - 3;                                        m_resetButton.Draw(g);                  }                              }
Magic Number,Sce.Atf.Dom,DomNodeReplaceToolStrip,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeReplaceToolStrip.cs,DomNodeReplaceToolStrip,The following statement contains a magic number: Size = new System.Drawing.Size(292' 25);
Magic Number,Sce.Atf.Dom,DomNodeReplaceToolStrip,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeReplaceToolStrip.cs,DomNodeReplaceToolStrip,The following statement contains a magic number: Size = new System.Drawing.Size(292' 25);
Magic Number,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,DomNodeSearchResultsListView,The following statement contains a magic number: Columns.Add("Node Name"' -2' HorizontalAlignment.Center);
Magic Number,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,DomNodeSearchResultsListView,The following statement contains a magic number: Columns.Add("Type"' -2' HorizontalAlignment.Center);
Magic Number,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,DomNodeSearchResultsListView,The following statement contains a magic number: Columns.Add("Property"' -2' HorizontalAlignment.Right);
Magic Number,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,DomNodeSearchResultsListView,The following statement contains a magic number: Columns.Add("Value"' -2' HorizontalAlignment.Left);
Magic Number,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,DomNodeSearchResultsListView,The following statement contains a magic number: Columns.Add("Node Name"' -2' HorizontalAlignment.Center);
Magic Number,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,DomNodeSearchResultsListView,The following statement contains a magic number: Columns.Add("Type"' -2' HorizontalAlignment.Center);
Magic Number,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,DomNodeSearchResultsListView,The following statement contains a magic number: Columns.Add("Property"' -2' HorizontalAlignment.Right);
Magic Number,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,DomNodeSearchResultsListView,The following statement contains a magic number: Columns.Add("Value"' -2' HorizontalAlignment.Left);
Magic Number,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,UpdateResults,The following statement contains a magic number: foreach (object resultObject in QueryResultContext.Results)              {                  // DomNodeQueryMatch is a DomNode' paired with a list of its properties that matched the search                  DomNodeQueryMatch queryMatch = resultObject as DomNodeQueryMatch;                    if (queryMatch == null)                      throw new InvalidOperationException("The class implementing IQueryableContext' which produced the results passed in' did not create results of type DomNodeQueryMatch.  Consider use DomNodeQueryable to create your search results.");                    // Add the "Node Name" and "Type" headers if none have been created yet                  int headerIndex = 0;                  if (headerList.Count <= headerIndex)                  {                      headerList.Add(new HeaderData("Node Name"' HorizontalAlignment.Left));                      headerList.Add(new HeaderData("Type"' HorizontalAlignment.Center));                  }                    // Display DomNode name and type                  string nodeName = GetDomNodeName(queryMatch.DomNode);                  string nodeType = queryMatch.DomNode.Type.ToString();                    // This will allow the results list to be updated when one of its items has changed                  // (for instance' from an 'undo' or 'redo')                  queryMatch.DomNode.AttributeChanged += DomNode_Changed;                    ListViewItem newItem = new ListViewItem(new string[2] { nodeName' nodeType });                  newItem.Tag = queryMatch.DomNode;                    headerList[headerIndex++].RegisterColumnString(nodeName);                  headerList[headerIndex++].RegisterColumnString(nodeType);                    // After the DomNode's name and type' include the name and value of each property of this DomNode that matched                  foreach (object predicateResult in queryMatch.PredicateMatchResults.Values)                  {                      List<IQueryMatch> matchingItems = predicateResult as List<IQueryMatch>;                      if (matchingItems != null)                      {                          foreach (DomNodePropertyMatch matchingItem in matchingItems)                          {                              // Add additional "Property" and "Value" headers (if need be)                              if (headerList.Count <= headerIndex)                              {                                  headerList.Add(new HeaderData("Property"' HorizontalAlignment.Right));                                  headerList.Add(new HeaderData("Value"' HorizontalAlignment.Left));                              }                                // Each property name and value pair are added as subitems of the list item                              string newPropertyName = matchingItem.Name;                              string newPropertyValue = matchingItem.GetValue().ToString();                                // Add each subitem' tagged with the PropertyDescriptor to which it is associated                              ListViewItem.ListViewSubItem subItemName = new ListViewItem.ListViewSubItem(newItem' newPropertyName);                              ListViewItem.ListViewSubItem subItemValue = new ListViewItem.ListViewSubItem(newItem' newPropertyValue);                              subItemName.Tag = matchingItem.PropertyDescriptor;                              subItemValue.Tag = matchingItem.PropertyDescriptor;                              newItem.SubItems.Add(subItemName);                              newItem.SubItems.Add(subItemValue);                                headerList[headerIndex++].RegisterColumnString(newPropertyName);                              headerList[headerIndex++].RegisterColumnString(newPropertyValue);                          }                      }                  }                    // Add the matching DomNode' with all matching properties' to the results list                  itemList.Add(newItem);              }
Magic Number,Sce.Atf.Dom,DomNodeSearchResultsListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchResultsListView.cs,UpdateResults,The following statement contains a magic number: foreach (HeaderData headerData in headerList)              {                  // Width of header determined by longest string found in that column                  int width = g.MeasureString(headerData.LongestString' Font).ToSize().Width + 15;                  Columns.Add(headerData.Name' width' headerData.HorizontalAlignment);              }
Magic Number,Sce.Atf.Dom,DomNodeSearchToolStrip,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchToolStrip.cs,DomNodeSearchToolStrip,The following statement contains a magic number: Size = new System.Drawing.Size(292' 25);
Magic Number,Sce.Atf.Dom,DomNodeSearchToolStrip,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\DomNodeSearchToolStrip.cs,DomNodeSearchToolStrip,The following statement contains a magic number: Size = new System.Drawing.Size(292' 25);
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: int x = 2;
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: int y = 2;
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: btn.Width = size.Width + 20;
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: x += btn.Width + 2;
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: btn.Width = size.Width + 20;
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: x += btn.Width + 2;
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: TreeListView.Columns[0].Width = 60;
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: TreeListView.Columns[1].Width = 600;
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: TreeListView.Columns[2].Width = 400;
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: TreeListView.Columns[2].Width = 400;
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: TreeListView.Control.Location = new Point(0' y + 2);
Magic Number,Sce.Atf.Dom,DomRecorder,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Dom\DomRecorder.cs,DomRecorder,The following statement contains a magic number: TreeListView.Control.Height = m_uberControl.Height - y - 2;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Init,The following statement contains a magic number: GhostGroupBrush = graphics.CreateSolidBrush(Color.FromArgb(128' Color.Gray));
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Init,The following statement contains a magic number: GhostTrackBrush = graphics.CreateSolidBrush(Color.FromArgb(128' Color.Gray));
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                        float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                      c.Graphics.FillRectangle(                          realPart'                          new PointF(0' realPart.Top)'new PointF(0' realPart.Bottom)'                          color' endColor);                        if (hasTail)                      {                          endColor = ColorUtil.FromAhsb(64' h' s * 0.3f' b);                          RectangleF tailPart = new RectangleF(                              realPart.Right'                              bounds.Y'                              bounds.Width - realPart.Width'                              bounds.Height);                          c.Graphics.FillRectangle(tailPart' endColor);                      }                        if (color.R + color.G + color.B < 3 * 160)                          TextBrush.Color = SystemColors.HighlightText;                      else                          TextBrush.Color = SystemColors.WindowText;                        c.Graphics.DrawText(interval.Name' c.TextFormat' bounds.Location' TextBrush);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(                              new RectangleF(bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2)'                              SelectedBrush' 3.0f);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(bounds' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.FillRectangle(bounds' Color.FromArgb(128' color));                      bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                      float x = showRight ? bounds.Right : bounds.Left;                      c.Graphics.DrawText(                          GetXPositionString(x' c)'                          c.TextFormat'                          new PointF(x' bounds.Bottom - c.FontHeight)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(bounds' InvalidBrush);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                        float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                      c.Graphics.FillRectangle(                          realPart'                          new PointF(0' realPart.Top)'new PointF(0' realPart.Bottom)'                          color' endColor);                        if (hasTail)                      {                          endColor = ColorUtil.FromAhsb(64' h' s * 0.3f' b);                          RectangleF tailPart = new RectangleF(                              realPart.Right'                              bounds.Y'                              bounds.Width - realPart.Width'                              bounds.Height);                          c.Graphics.FillRectangle(tailPart' endColor);                      }                        if (color.R + color.G + color.B < 3 * 160)                          TextBrush.Color = SystemColors.HighlightText;                      else                          TextBrush.Color = SystemColors.WindowText;                        c.Graphics.DrawText(interval.Name' c.TextFormat' bounds.Location' TextBrush);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(                              new RectangleF(bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2)'                              SelectedBrush' 3.0f);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(bounds' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.FillRectangle(bounds' Color.FromArgb(128' color));                      bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                      float x = showRight ? bounds.Right : bounds.Left;                      c.Graphics.DrawText(                          GetXPositionString(x' c)'                          c.TextFormat'                          new PointF(x' bounds.Bottom - c.FontHeight)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(bounds' InvalidBrush);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                        float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                      c.Graphics.FillRectangle(                          realPart'                          new PointF(0' realPart.Top)'new PointF(0' realPart.Bottom)'                          color' endColor);                        if (hasTail)                      {                          endColor = ColorUtil.FromAhsb(64' h' s * 0.3f' b);                          RectangleF tailPart = new RectangleF(                              realPart.Right'                              bounds.Y'                              bounds.Width - realPart.Width'                              bounds.Height);                          c.Graphics.FillRectangle(tailPart' endColor);                      }                        if (color.R + color.G + color.B < 3 * 160)                          TextBrush.Color = SystemColors.HighlightText;                      else                          TextBrush.Color = SystemColors.WindowText;                        c.Graphics.DrawText(interval.Name' c.TextFormat' bounds.Location' TextBrush);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(                              new RectangleF(bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2)'                              SelectedBrush' 3.0f);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(bounds' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.FillRectangle(bounds' Color.FromArgb(128' color));                      bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                      float x = showRight ? bounds.Right : bounds.Left;                      c.Graphics.DrawText(                          GetXPositionString(x' c)'                          c.TextFormat'                          new PointF(x' bounds.Bottom - c.FontHeight)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(bounds' InvalidBrush);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                        float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                      c.Graphics.FillRectangle(                          realPart'                          new PointF(0' realPart.Top)'new PointF(0' realPart.Bottom)'                          color' endColor);                        if (hasTail)                      {                          endColor = ColorUtil.FromAhsb(64' h' s * 0.3f' b);                          RectangleF tailPart = new RectangleF(                              realPart.Right'                              bounds.Y'                              bounds.Width - realPart.Width'                              bounds.Height);                          c.Graphics.FillRectangle(tailPart' endColor);                      }                        if (color.R + color.G + color.B < 3 * 160)                          TextBrush.Color = SystemColors.HighlightText;                      else                          TextBrush.Color = SystemColors.WindowText;                        c.Graphics.DrawText(interval.Name' c.TextFormat' bounds.Location' TextBrush);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(                              new RectangleF(bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2)'                              SelectedBrush' 3.0f);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(bounds' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.FillRectangle(bounds' Color.FromArgb(128' color));                      bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                      float x = showRight ? bounds.Right : bounds.Left;                      c.Graphics.DrawText(                          GetXPositionString(x' c)'                          c.TextFormat'                          new PointF(x' bounds.Bottom - c.FontHeight)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(bounds' InvalidBrush);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                        float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                      c.Graphics.FillRectangle(                          realPart'                          new PointF(0' realPart.Top)'new PointF(0' realPart.Bottom)'                          color' endColor);                        if (hasTail)                      {                          endColor = ColorUtil.FromAhsb(64' h' s * 0.3f' b);                          RectangleF tailPart = new RectangleF(                              realPart.Right'                              bounds.Y'                              bounds.Width - realPart.Width'                              bounds.Height);                          c.Graphics.FillRectangle(tailPart' endColor);                      }                        if (color.R + color.G + color.B < 3 * 160)                          TextBrush.Color = SystemColors.HighlightText;                      else                          TextBrush.Color = SystemColors.WindowText;                        c.Graphics.DrawText(interval.Name' c.TextFormat' bounds.Location' TextBrush);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(                              new RectangleF(bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2)'                              SelectedBrush' 3.0f);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(bounds' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.FillRectangle(bounds' Color.FromArgb(128' color));                      bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                      float x = showRight ? bounds.Right : bounds.Left;                      c.Graphics.DrawText(                          GetXPositionString(x' c)'                          c.TextFormat'                          new PointF(x' bounds.Bottom - c.FontHeight)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(bounds' InvalidBrush);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                        float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                      c.Graphics.FillRectangle(                          realPart'                          new PointF(0' realPart.Top)'new PointF(0' realPart.Bottom)'                          color' endColor);                        if (hasTail)                      {                          endColor = ColorUtil.FromAhsb(64' h' s * 0.3f' b);                          RectangleF tailPart = new RectangleF(                              realPart.Right'                              bounds.Y'                              bounds.Width - realPart.Width'                              bounds.Height);                          c.Graphics.FillRectangle(tailPart' endColor);                      }                        if (color.R + color.G + color.B < 3 * 160)                          TextBrush.Color = SystemColors.HighlightText;                      else                          TextBrush.Color = SystemColors.WindowText;                        c.Graphics.DrawText(interval.Name' c.TextFormat' bounds.Location' TextBrush);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(                              new RectangleF(bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2)'                              SelectedBrush' 3.0f);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(bounds' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.FillRectangle(bounds' Color.FromArgb(128' color));                      bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                      float x = showRight ? bounds.Right : bounds.Left;                      c.Graphics.DrawText(                          GetXPositionString(x' c)'                          c.TextFormat'                          new PointF(x' bounds.Bottom - c.FontHeight)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(bounds' InvalidBrush);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      c.Graphics.FillEllipse(bounds' color);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          D2dAntialiasMode originalAntiAliasMode = c.Graphics.AntialiasMode;                          c.Graphics.AntialiasMode = D2dAntialiasMode.PerPrimitive;                          c.Graphics.DrawEllipse(                              new D2dEllipse(                                  new PointF(bounds.X + bounds.Width * 0.5f' bounds.Y + bounds.Height * 0.5f)'                                  bounds.Width * 0.5f' bounds.Height * 0.5f)'                              SelectedBrush' 3.0f);                          c.Graphics.AntialiasMode = originalAntiAliasMode;                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillEllipse(bounds' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.FillEllipse(bounds' Color.FromArgb(128' color));                      c.Graphics.DrawText(                          GetXPositionString(bounds.Left + KeySize * 0.5f' c)'                          c.TextFormat'                          new PointF(bounds.Right + 16' bounds.Y)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.FillEllipse(bounds' InvalidBrush);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      c.Graphics.FillEllipse(bounds' color);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          D2dAntialiasMode originalAntiAliasMode = c.Graphics.AntialiasMode;                          c.Graphics.AntialiasMode = D2dAntialiasMode.PerPrimitive;                          c.Graphics.DrawEllipse(                              new D2dEllipse(                                  new PointF(bounds.X + bounds.Width * 0.5f' bounds.Y + bounds.Height * 0.5f)'                                  bounds.Width * 0.5f' bounds.Height * 0.5f)'                              SelectedBrush' 3.0f);                          c.Graphics.AntialiasMode = originalAntiAliasMode;                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillEllipse(bounds' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.FillEllipse(bounds' Color.FromArgb(128' color));                      c.Graphics.DrawText(                          GetXPositionString(bounds.Left + KeySize * 0.5f' c)'                          c.TextFormat'                          new PointF(bounds.Right + 16' bounds.Y)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.FillEllipse(bounds' InvalidBrush);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: float middle = bounds.X + bounds.Width / 2;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      c.Graphics.DrawLine(middle' bounds.Top' middle' bounds.Bottom' color' 1.0f' null);                        bool selected = (drawMode & DrawMode.Selected) != 0;                      Color handleColor = selected ? Color.Tomato : color;                      RectangleF handleRect =                          new RectangleF(bounds.X' bounds.Y' bounds.Width' bounds.Width);                      c.Graphics.FillRectangle(handleRect' handleColor);                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(                          new RectangleF(middle' bounds.Y' 1' bounds.Height)' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.DrawLine(middle' bounds.Top' middle' bounds.Bottom' Color.FromArgb(128' color)' 1.0f' null);                      c.Graphics.DrawText(                          GetXPositionString(middle' c)'                          c.TextFormat'                          new PointF(bounds.Right + 16' bounds.Y)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.DrawRectangle(bounds' Color.DimGray' 1.0f' null);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      c.Graphics.DrawLine(middle' bounds.Top' middle' bounds.Bottom' color' 1.0f' null);                        bool selected = (drawMode & DrawMode.Selected) != 0;                      Color handleColor = selected ? Color.Tomato : color;                      RectangleF handleRect =                          new RectangleF(bounds.X' bounds.Y' bounds.Width' bounds.Width);                      c.Graphics.FillRectangle(handleRect' handleColor);                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(                          new RectangleF(middle' bounds.Y' 1' bounds.Height)' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.DrawLine(middle' bounds.Top' middle' bounds.Bottom' Color.FromArgb(128' color)' 1.0f' null);                      c.Graphics.DrawText(                          GetXPositionString(middle' c)'                          c.TextFormat'                          new PointF(bounds.Right + 16' bounds.Y)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.DrawRectangle(bounds' Color.DimGray' 1.0f' null);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,GetBounds,The following statement contains a magic number: return new RectangleF(                  key.Start - keyWidth / 2'                  trackTop'                  keyWidth'                  keyHeight);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,GetBounds,The following statement contains a magic number: const float DefaultMarkerHandleSize = 10;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,GetBounds,The following statement contains a magic number: return new RectangleF(                  marker.Start - handleSize / 2'                  c.Bounds.Top'                  handleSize'                  c.Bounds.Height);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,GetXPositionString,The following statement contains a magic number: float frame = x * c.InverseTransform.Elements[0] + c.InverseTransform.Elements[4];
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dMoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dMoveManipulator.cs,GetMoveGhostInfo,The following statement contains a magic number: List<float> movingPoints = new List<float>(2);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dMoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dMoveManipulator.cs,GetMoveGhostInfo,The following statement contains a magic number: float yOffset = dragOffset.Y * worldToView.Elements[3];
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScaleManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScaleManipulator.cs,DrawManipulator,The following statement contains a magic number: const float penWidth = 3;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: handleRect = new RectangleF(                  viewX - 5'                  clipRectangle.Top'                  10'                  7);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: handleRect = new RectangleF(                  viewX - 5'                  clipRectangle.Top'                  10'                  7);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: handleRect = new RectangleF(                  viewX - 5'                  clipRectangle.Top'                  10'                  7);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: float pos_y = clipRectangle.Top + 5;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[0] = new PointF(pos_x - 4' pos_y - 5);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[0] = new PointF(pos_x - 4' pos_y - 5);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[1] = new PointF(pos_x - 4' pos_y);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[2] = new PointF(pos_x - 5' pos_y + 1);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[2] = new PointF(pos_x - 5' pos_y + 1);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[3] = new PointF(pos_x - 5' pos_y + 2);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[3] = new PointF(pos_x - 5' pos_y + 2);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[3] = new PointF(pos_x - 5' pos_y + 2);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[4] = new PointF(pos_x' pos_y + 7);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[4] = new PointF(pos_x' pos_y + 7);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[5] = new PointF(pos_x + 5' pos_y + 2);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[5] = new PointF(pos_x + 5' pos_y + 2);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[5] = new PointF(pos_x + 5' pos_y + 2);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[6] = new PointF(pos_x + 5' pos_y + 1);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[6] = new PointF(pos_x + 5' pos_y + 1);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[7] = new PointF(pos_x + 4' pos_y);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[7] = new PointF(pos_x + 4' pos_y);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[8] = new PointF(pos_x + 4' pos_y - 5);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[8] = new PointF(pos_x + 4' pos_y - 5);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: s_arrow[8] = new PointF(pos_x + 4' pos_y - 5);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: g.DrawText(label' Owner.Renderer.TextFormat' new PointF(pos_x + 6' clipRectangle.Top)' SystemColors.WindowText);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dSplitManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dSplitManipulator.cs,SplitSelectedIntervals,The following statement contains a magic number: m_owner.TransactionContext.DoTransaction(delegate                  {                      List<IInterval> newSelection = new List<IInterval>(m_owner.Selection.SelectionCount * 2);                      newSelection.AddRange(m_owner.Selection.GetSelection<IInterval>());                      foreach (IInterval interval in m_owner.Selection.GetSelection<IInterval>())                      {                          IInterval rightSide = DoSplit(interval' fraction);                          if (rightSide != null)                              newSelection.Add(rightSide);                      }                      m_owner.Selection.SetRange(newSelection);                  }'                  "Split Interval");
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,D2dTimelineControl,The following statement contains a magic number: m_toolTip.InitialDelay = 100;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,D2dTimelineControl,The following statement contains a magic number: m_toolTip.ReshowDelay = 100;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,GetCanvasSize,The following statement contains a magic number: int canvasWidth = (int)Math.Ceiling(bounds.Right) - offset.X + Width / 2;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,GetCanvasSize,The following statement contains a magic number: int canvasHeight = (int)Math.Ceiling(bounds.Bottom) - offset.Y + Height / 2;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,TurnOffToolTip,The following statement contains a magic number: new System.Threading.Timer(                  delegate                  {                      InvalidateControl();                  }'                  m_toolTip' 20' Timeout.Infinite);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,OnMouseHover,The following statement contains a magic number: if (willDisplayToolTip)              {                  //Use Show() because SetToolTip() doesn't work reliably.                  m_toolTip.Show(GetToolTipText(hitObject)' this' m_lastMouseMove.X' m_lastMouseMove.Y + 20);                    //Show() can't seem to be undone. Use a timer to turn off the tooltip.                  m_timer = new System.Threading.Timer(                      delegate                      {                          TurnOffToolTip();                      }'                      m_toolTip' m_toolTipDuration' Timeout.Infinite);              }              else if (alreadyDisplayingToolTip)              {                  m_toolTip.SetToolTip(this' "");                  m_toolTip.Hide(this);              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,GetPickingRectangle,The following statement contains a magic number: return new RectangleF(                  clientPoint.X - tolerance'                  clientPoint.Y - tolerance'                  2 * tolerance'                  2 * tolerance);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineControl.cs,GetPickingRectangle,The following statement contains a magic number: return new RectangleF(                  clientPoint.X - tolerance'                  clientPoint.Y - tolerance'                  2 * tolerance'                  2 * tolerance);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,Init,The following statement contains a magic number: m_gridPen = m_graphics.CreateSolidBrush(Color.FromArgb(128' 128' 128' 128));
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,Init,The following statement contains a magic number: m_gridPen = m_graphics.CreateSolidBrush(Color.FromArgb(128' 128' 128' 128));
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,Init,The following statement contains a magic number: m_gridPen = m_graphics.CreateSolidBrush(Color.FromArgb(128' 128' 128' 128));
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,Init,The following statement contains a magic number: m_gridPen = m_graphics.CreateSolidBrush(Color.FromArgb(128' 128' 128' 128));
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,PickSubTimeline,The following statement contains a magic number: if (pickRect.Left > HeaderWidth &&                  pickRect.Right < clientRectangle.Width &&                  pickRect.Bottom > 0 &&                  pickRect.Bottom < TimeScaleHeight)              {                  if ((result.Count == 0) && (pickRect.Height <= 2 * PickTolerance) && (pickRect.Width <= 2 * PickTolerance))                      result.Add(new HitRecord(HitType.TimeScale' null));                  return;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,PickSubTimeline,The following statement contains a magic number: if (pickRect.Left > HeaderWidth &&                  pickRect.Right < clientRectangle.Width &&                  pickRect.Bottom > 0 &&                  pickRect.Bottom < TimeScaleHeight)              {                  if ((result.Count == 0) && (pickRect.Height <= 2 * PickTolerance) && (pickRect.Width <= 2 * PickTolerance))                      result.Add(new HitRecord(HitType.TimeScale' null));                  return;              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,DrawTimelineReference,The following statement contains a magic number: originRect.X = screenStart - 4;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,DrawTimelineReference,The following statement contains a magic number: originRect.Width = 8;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,DrawTimelineReference,The following statement contains a magic number: originRect.Height = 16;
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,LayoutSubTimeline,The following statement contains a magic number: float docRowHeight = Math.Max(margin * 2' MinimumTrackSize);
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,D2dTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,LayoutSubTimeline,The following statement contains a magic number: foreach (IGroup group in timeline.Groups)              {                  bool expanded = expandedTimeline && group.Expanded;                    float groupBottom = groupTop;                  float trackTop = groupTop;                  foreach (ITrack track in group.Tracks)                  {                      float eventTop = trackTop + margin;                      float trackBottom = eventTop;                        foreach (IInterval interval in track.Intervals)                      {                          bounds = GetBounds(interval' eventTop' c);                          trackBottom = Math.Max(trackBottom' bounds.Bottom);                          bounds = GdiUtil.Transform(c.Transform' bounds);                          // add it' even if 'expandedTimeline' is false' to get the shadow effect                          result.Add(path + interval' bounds);                      }                        foreach (IKey key in track.Keys)                      {                          bounds = GetBounds(key' eventTop' c);                          trackBottom = Math.Max(trackBottom' bounds.Bottom);                          bounds = GdiUtil.Transform(c.Transform' bounds);                          // add it' even if 'expandedTimeline' is false' to get the shadow effect                          result.Add(path + key' bounds);                      }                        trackBottom += margin;                      trackBottom = Math.Max(trackBottom' trackTop + MinimumTrackSize); // need height for track' even if it's empty                        bounds = new RectangleF(c.Bounds.X' trackTop' c.Bounds.Width' trackBottom - trackTop);                      bounds = GdiUtil.Transform(c.Transform' bounds);                      bounds.X = c.ClientRectangle.X;                      // add it' even if 'expandedTimeline' is false' to get the shadow effect                      result.Add(path + track' bounds);                        if (expanded)                          trackTop = trackBottom;                        groupBottom = Math.Max(groupBottom' trackBottom);                  }                    // need height for group' even if it's empty                  groupBottom = Math.Max(groupBottom' groupTop + Math.Max(margin*2' MinimumTrackSize));                    float groupHeight = groupBottom - groupTop;                  bounds = new RectangleF(0' groupTop' c.Bounds.Width' groupHeight);                  bounds = GdiUtil.Transform(c.Transform' bounds);                  bounds.X = c.ClientRectangle.X;                  // add it' even if 'expandedTimeline' is false' to get the shadow effect                  result.Add(path + group' bounds);                  if (expandedTimeline)                      groupTop = groupBottom;                  documentBottom = Math.Max(documentBottom' groupBottom);              }
Magic Number,Sce.Atf.Controls.Timelines.Direct2D,Context,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dTimelineRenderer.cs,Context,The following statement contains a magic number: PixelSize = new SizeF(1 / transform.Elements[0]' 1 / transform.Elements[3]);
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,DefaultTimelineRenderer,The following statement contains a magic number: m_selectedPen = new Pen(Color.Tomato' 3);
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                  case DrawMode.Collapsed:                      using (Brush brush = new LinearGradientBrush(                          bounds' Color.LightGoldenrodYellow' Color.Khaki' LinearGradientMode.Vertical))                      {                          c.Graphics.FillRectangle(brush' bounds);                      }                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' Color.Gray)))                      {                          c.Graphics.FillRectangle(brush' bounds);                      }                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      c.Graphics.DrawRectangle(Pens.LightGray' bounds.X' bounds.Y' bounds.Width' bounds.Height);                      break;                  case DrawMode.Collapsed:                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' Color.Gray)))                      {                          c.Graphics.FillRectangle(brush' bounds);                      }                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                                            float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                        using (LinearGradientBrush intervalBrush =                          new LinearGradientBrush(realPart' color' endColor' LinearGradientMode.Vertical))                      {                          c.Graphics.FillRectangle(intervalBrush' realPart);                          if (hasTail)                          {                              Color[] colors = intervalBrush.LinearColors;                              colors[0] = Color.FromArgb(64' colors[0]);                              colors[1] = Color.FromArgb(64' colors[1]);                              intervalBrush.LinearColors = colors;                              RectangleF tailPart = new RectangleF(                                  realPart.Right'                                  bounds.Y'                                  bounds.Width - realPart.Width'                                  bounds.Height);                              c.Graphics.FillRectangle(intervalBrush' tailPart);                          }                      }                        Brush textBrush = SystemBrushes.WindowText;                      if ((int)color.R + (int)color.G + (int)color.B < 3 * 160)                          textBrush = SystemBrushes.HighlightText;                      c.Graphics.DrawString(interval.Name' c.Font' textBrush' bounds.Location);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillRectangle(brush' bounds);                          bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                          float x = showRight ? bounds.Right : bounds.Left;                          c.Graphics.DrawString(GetXPositionString(x' c)' c.Font' SystemBrushes.WindowText' x' bounds.Bottom - c.FontHeight);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                                            float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                        using (LinearGradientBrush intervalBrush =                          new LinearGradientBrush(realPart' color' endColor' LinearGradientMode.Vertical))                      {                          c.Graphics.FillRectangle(intervalBrush' realPart);                          if (hasTail)                          {                              Color[] colors = intervalBrush.LinearColors;                              colors[0] = Color.FromArgb(64' colors[0]);                              colors[1] = Color.FromArgb(64' colors[1]);                              intervalBrush.LinearColors = colors;                              RectangleF tailPart = new RectangleF(                                  realPart.Right'                                  bounds.Y'                                  bounds.Width - realPart.Width'                                  bounds.Height);                              c.Graphics.FillRectangle(intervalBrush' tailPart);                          }                      }                        Brush textBrush = SystemBrushes.WindowText;                      if ((int)color.R + (int)color.G + (int)color.B < 3 * 160)                          textBrush = SystemBrushes.HighlightText;                      c.Graphics.DrawString(interval.Name' c.Font' textBrush' bounds.Location);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillRectangle(brush' bounds);                          bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                          float x = showRight ? bounds.Right : bounds.Left;                          c.Graphics.DrawString(GetXPositionString(x' c)' c.Font' SystemBrushes.WindowText' x' bounds.Bottom - c.FontHeight);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                                            float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                        using (LinearGradientBrush intervalBrush =                          new LinearGradientBrush(realPart' color' endColor' LinearGradientMode.Vertical))                      {                          c.Graphics.FillRectangle(intervalBrush' realPart);                          if (hasTail)                          {                              Color[] colors = intervalBrush.LinearColors;                              colors[0] = Color.FromArgb(64' colors[0]);                              colors[1] = Color.FromArgb(64' colors[1]);                              intervalBrush.LinearColors = colors;                              RectangleF tailPart = new RectangleF(                                  realPart.Right'                                  bounds.Y'                                  bounds.Width - realPart.Width'                                  bounds.Height);                              c.Graphics.FillRectangle(intervalBrush' tailPart);                          }                      }                        Brush textBrush = SystemBrushes.WindowText;                      if ((int)color.R + (int)color.G + (int)color.B < 3 * 160)                          textBrush = SystemBrushes.HighlightText;                      c.Graphics.DrawString(interval.Name' c.Font' textBrush' bounds.Location);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillRectangle(brush' bounds);                          bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                          float x = showRight ? bounds.Right : bounds.Left;                          c.Graphics.DrawString(GetXPositionString(x' c)' c.Font' SystemBrushes.WindowText' x' bounds.Bottom - c.FontHeight);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                                            float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                        using (LinearGradientBrush intervalBrush =                          new LinearGradientBrush(realPart' color' endColor' LinearGradientMode.Vertical))                      {                          c.Graphics.FillRectangle(intervalBrush' realPart);                          if (hasTail)                          {                              Color[] colors = intervalBrush.LinearColors;                              colors[0] = Color.FromArgb(64' colors[0]);                              colors[1] = Color.FromArgb(64' colors[1]);                              intervalBrush.LinearColors = colors;                              RectangleF tailPart = new RectangleF(                                  realPart.Right'                                  bounds.Y'                                  bounds.Width - realPart.Width'                                  bounds.Height);                              c.Graphics.FillRectangle(intervalBrush' tailPart);                          }                      }                        Brush textBrush = SystemBrushes.WindowText;                      if ((int)color.R + (int)color.G + (int)color.B < 3 * 160)                          textBrush = SystemBrushes.HighlightText;                      c.Graphics.DrawString(interval.Name' c.Font' textBrush' bounds.Location);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillRectangle(brush' bounds);                          bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                          float x = showRight ? bounds.Right : bounds.Left;                          c.Graphics.DrawString(GetXPositionString(x' c)' c.Font' SystemBrushes.WindowText' x' bounds.Bottom - c.FontHeight);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                                            float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                        using (LinearGradientBrush intervalBrush =                          new LinearGradientBrush(realPart' color' endColor' LinearGradientMode.Vertical))                      {                          c.Graphics.FillRectangle(intervalBrush' realPart);                          if (hasTail)                          {                              Color[] colors = intervalBrush.LinearColors;                              colors[0] = Color.FromArgb(64' colors[0]);                              colors[1] = Color.FromArgb(64' colors[1]);                              intervalBrush.LinearColors = colors;                              RectangleF tailPart = new RectangleF(                                  realPart.Right'                                  bounds.Y'                                  bounds.Width - realPart.Width'                                  bounds.Height);                              c.Graphics.FillRectangle(intervalBrush' tailPart);                          }                      }                        Brush textBrush = SystemBrushes.WindowText;                      if ((int)color.R + (int)color.G + (int)color.B < 3 * 160)                          textBrush = SystemBrushes.HighlightText;                      c.Graphics.DrawString(interval.Name' c.Font' textBrush' bounds.Location);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillRectangle(brush' bounds);                          bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                          float x = showRight ? bounds.Right : bounds.Left;                          c.Graphics.DrawString(GetXPositionString(x' c)' c.Font' SystemBrushes.WindowText' x' bounds.Bottom - c.FontHeight);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                                            float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                        using (LinearGradientBrush intervalBrush =                          new LinearGradientBrush(realPart' color' endColor' LinearGradientMode.Vertical))                      {                          c.Graphics.FillRectangle(intervalBrush' realPart);                          if (hasTail)                          {                              Color[] colors = intervalBrush.LinearColors;                              colors[0] = Color.FromArgb(64' colors[0]);                              colors[1] = Color.FromArgb(64' colors[1]);                              intervalBrush.LinearColors = colors;                              RectangleF tailPart = new RectangleF(                                  realPart.Right'                                  bounds.Y'                                  bounds.Width - realPart.Width'                                  bounds.Height);                              c.Graphics.FillRectangle(intervalBrush' tailPart);                          }                      }                        Brush textBrush = SystemBrushes.WindowText;                      if ((int)color.R + (int)color.G + (int)color.B < 3 * 160)                          textBrush = SystemBrushes.HighlightText;                      c.Graphics.DrawString(interval.Name' c.Font' textBrush' bounds.Location);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillRectangle(brush' bounds);                          bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                          float x = showRight ? bounds.Right : bounds.Left;                          c.Graphics.DrawString(GetXPositionString(x' c)' c.Font' SystemBrushes.WindowText' x' bounds.Bottom - c.FontHeight);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                                            float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                        using (LinearGradientBrush intervalBrush =                          new LinearGradientBrush(realPart' color' endColor' LinearGradientMode.Vertical))                      {                          c.Graphics.FillRectangle(intervalBrush' realPart);                          if (hasTail)                          {                              Color[] colors = intervalBrush.LinearColors;                              colors[0] = Color.FromArgb(64' colors[0]);                              colors[1] = Color.FromArgb(64' colors[1]);                              intervalBrush.LinearColors = colors;                              RectangleF tailPart = new RectangleF(                                  realPart.Right'                                  bounds.Y'                                  bounds.Width - realPart.Width'                                  bounds.Height);                              c.Graphics.FillRectangle(intervalBrush' tailPart);                          }                      }                        Brush textBrush = SystemBrushes.WindowText;                      if ((int)color.R + (int)color.G + (int)color.B < 3 * 160)                          textBrush = SystemBrushes.HighlightText;                      c.Graphics.DrawString(interval.Name' c.Font' textBrush' bounds.Location);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillRectangle(brush' bounds);                          bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                          float x = showRight ? bounds.Right : bounds.Left;                          c.Graphics.DrawString(GetXPositionString(x' c)' c.Font' SystemBrushes.WindowText' x' bounds.Bottom - c.FontHeight);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      using (SolidBrush brush = new SolidBrush(color))                      {                          c.Graphics.FillEllipse(brush' bounds);                      }                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawEllipse(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillEllipse(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillEllipse(brush' bounds);                          c.Graphics.DrawString(GetXPositionString(bounds.Left + m_keySize / 2' c)' c.Font' SystemBrushes.WindowText' bounds.Right + 16' bounds.Y);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillEllipse(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      using (SolidBrush brush = new SolidBrush(color))                      {                          c.Graphics.FillEllipse(brush' bounds);                      }                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawEllipse(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillEllipse(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillEllipse(brush' bounds);                          c.Graphics.DrawString(GetXPositionString(bounds.Left + m_keySize / 2' c)' c.Font' SystemBrushes.WindowText' bounds.Right + 16' bounds.Y);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillEllipse(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      using (SolidBrush brush = new SolidBrush(color))                      {                          c.Graphics.FillEllipse(brush' bounds);                      }                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawEllipse(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillEllipse(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillEllipse(brush' bounds);                          c.Graphics.DrawString(GetXPositionString(bounds.Left + m_keySize / 2' c)' c.Font' SystemBrushes.WindowText' bounds.Right + 16' bounds.Y);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillEllipse(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      using (SolidBrush brush = new SolidBrush(color))                      {                          c.Graphics.FillEllipse(brush' bounds);                      }                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawEllipse(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillEllipse(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillEllipse(brush' bounds);                          c.Graphics.DrawString(GetXPositionString(bounds.Left + m_keySize / 2' c)' c.Font' SystemBrushes.WindowText' bounds.Right + 16' bounds.Y);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillEllipse(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      using (SolidBrush brush = new SolidBrush(color))                      {                          c.Graphics.FillEllipse(brush' bounds);                      }                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawEllipse(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillEllipse(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillEllipse(brush' bounds);                          c.Graphics.DrawString(GetXPositionString(bounds.Left + m_keySize / 2' c)' c.Font' SystemBrushes.WindowText' bounds.Right + 16' bounds.Y);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillEllipse(m_invalidBrush' bounds);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: float middle = bounds.X + bounds.Width / 2;
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      using (Pen pen = new Pen(color))                      {                          c.Graphics.DrawLine(pen' middle' bounds.Top' middle' bounds.Bottom);                      }                        bool selected = (drawMode & DrawMode.Selected) != 0;                      Color handleColor = selected ? Color.Tomato : color;                      using (Brush brush = new SolidBrush(handleColor))                      {                          RectangleF handleRect =                              new RectangleF(bounds.X' bounds.Y' bounds.Width' bounds.Width);                          c.Graphics.FillRectangle(brush' handleRect);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(m_collapsedBrush' middle' bounds.Y' 1' bounds.Height);                      break;                  case DrawMode.Ghost:                      using (Pen pen = new Pen(Color.FromArgb(128' color)))                      {                          c.Graphics.DrawLine(pen' middle' bounds.Top' middle' bounds.Bottom);                          c.Graphics.DrawString(GetXPositionString(middle' c)' c.Font' SystemBrushes.WindowText' bounds.Right + 16' bounds.Y);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.DrawRectangle(Pens.DimGray' bounds.X' bounds.Y' bounds.Width' bounds.Height);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following statement contains a magic number: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      using (Pen pen = new Pen(color))                      {                          c.Graphics.DrawLine(pen' middle' bounds.Top' middle' bounds.Bottom);                      }                        bool selected = (drawMode & DrawMode.Selected) != 0;                      Color handleColor = selected ? Color.Tomato : color;                      using (Brush brush = new SolidBrush(handleColor))                      {                          RectangleF handleRect =                              new RectangleF(bounds.X' bounds.Y' bounds.Width' bounds.Width);                          c.Graphics.FillRectangle(brush' handleRect);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(m_collapsedBrush' middle' bounds.Y' 1' bounds.Height);                      break;                  case DrawMode.Ghost:                      using (Pen pen = new Pen(Color.FromArgb(128' color)))                      {                          c.Graphics.DrawLine(pen' middle' bounds.Top' middle' bounds.Bottom);                          c.Graphics.DrawString(GetXPositionString(middle' c)' c.Font' SystemBrushes.WindowText' bounds.Right + 16' bounds.Y);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.DrawRectangle(Pens.DimGray' bounds.X' bounds.Y' bounds.Width' bounds.Height);                      break;              }
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,GetBounds,The following statement contains a magic number: return new RectangleF(                  key.Start - keyWidth / 2'                  trackTop'                  keyWidth'                  keyHeight);
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,GetBounds,The following statement contains a magic number: const float DefaultMarkerHandleSize = 10;
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,GetBounds,The following statement contains a magic number: return new RectangleF(                  marker.Start - handleSize / 2'                  c.Bounds.Top'                  handleSize'                  c.Bounds.Height);
Magic Number,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,GetXPositionString,The following statement contains a magic number: float frame = x * c.InverseTransform.Elements[0] + c.InverseTransform.Elements[4];
Magic Number,Sce.Atf.Controls.Timelines,MoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\MoveManipulator.cs,GetMoveGhostInfo,The following statement contains a magic number: List<float> movingPoints = new List<float>(2);
Magic Number,Sce.Atf.Controls.Timelines,MoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\MoveManipulator.cs,GetMoveGhostInfo,The following statement contains a magic number: float yOffset = dragOffset.Y * worldToView.Elements[3];
Magic Number,Sce.Atf.Controls.Timelines,ScaleManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScaleManipulator.cs,DrawManipulator,The following statement contains a magic number: const int penWidth = 3;
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: handleRect = new RectangleF(                  viewX - 5'                  clipRectangle.Top'                  10'                  7);
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: handleRect = new RectangleF(                  viewX - 5'                  clipRectangle.Top'                  10'                  7);
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: handleRect = new RectangleF(                  viewX - 5'                  clipRectangle.Top'                  10'                  7);
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,ScrubberManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\ScrubberManipulator.cs,DrawManipulator,The following statement contains a magic number: using (Brush brush = new SolidBrush(handle_color))              {                  int pos_x = Convert.ToInt32(viewX);                  int pos_y = Convert.ToInt32(clipRectangle.Top + 5);                  s_arrow[0] = new Point(pos_x - 4' pos_y - 5);                  s_arrow[1] = new Point(pos_x - 4' pos_y);                  s_arrow[2] = new Point(pos_x - 5' pos_y + 1);                  s_arrow[3] = new Point(pos_x - 5' pos_y + 2);                  s_arrow[4] = new Point(pos_x' pos_y + 7);                  s_arrow[5] = new Point(pos_x + 5' pos_y + 2);                  s_arrow[6] = new Point(pos_x + 5' pos_y + 1);                  s_arrow[7] = new Point(pos_x + 4' pos_y);                  s_arrow[8] = new Point(pos_x + 4' pos_y - 5);                  g.FillPolygon(brush' s_arrow);   // Fill arrow                  g.DrawPolygon(s_grayPen' s_arrow);  // Draw arrow border with gray                    string label = Position.ToString(CultureInfo.CurrentCulture);                  g.DrawString(label' Owner.Font' SystemBrushes.WindowText' pos_x + 6' clipRectangle.Top);              }
Magic Number,Sce.Atf.Controls.Timelines,SplitManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\SplitManipulator.cs,SplitSelectedIntervals,The following statement contains a magic number: m_owner.TransactionContext.DoTransaction(delegate                  {                      List<IInterval> newSelection = new List<IInterval>(m_owner.Selection.SelectionCount * 2);                      newSelection.AddRange(m_owner.Selection.GetSelection<IInterval>());                      foreach (IInterval interval in m_owner.Selection.GetSelection<IInterval>())                      {                          IInterval rightSide = DoSplit(interval' fraction);                          if (rightSide != null)                              newSelection.Add(rightSide);                      }                      m_owner.Selection.SetRange(newSelection);                  }'                  "Split Interval");
Magic Number,Sce.Atf.Controls.Timelines,TimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineControl.cs,TimelineControl,The following statement contains a magic number: m_toolTip.InitialDelay = 100;
Magic Number,Sce.Atf.Controls.Timelines,TimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineControl.cs,TimelineControl,The following statement contains a magic number: m_toolTip.ReshowDelay = 100;
Magic Number,Sce.Atf.Controls.Timelines,TimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineControl.cs,GetCanvasSize,The following statement contains a magic number: int canvasWidth = (int)Math.Ceiling(bounds.Right) - offset.X + Width / 2;
Magic Number,Sce.Atf.Controls.Timelines,TimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineControl.cs,GetCanvasSize,The following statement contains a magic number: int canvasHeight = (int)Math.Ceiling(bounds.Bottom) - offset.Y + Height / 2;
Magic Number,Sce.Atf.Controls.Timelines,TimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineControl.cs,TurnOffToolTip,The following statement contains a magic number: new System.Threading.Timer(                  delegate {                      InvalidateControl();                  }'                  m_toolTip' 20' Timeout.Infinite);
Magic Number,Sce.Atf.Controls.Timelines,TimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineControl.cs,OnMouseHover,The following statement contains a magic number: if (willDisplayToolTip)              {                  //Use Show() because SetToolTip() doesn't work reliably.                  m_toolTip.Show(GetToolTipText(hitObject)' this' m_lastMouseMove.X' m_lastMouseMove.Y + 20);                    //Show() can't seem to be undone. Use a timer to turn off the tooltip.                  m_timer = new System.Threading.Timer(                      delegate {                          TurnOffToolTip();                      }'                      m_toolTip' m_toolTipDuration' Timeout.Infinite);              }              else if (alreadyDisplayingToolTip)              {                  m_toolTip.SetToolTip(this' "");                  m_toolTip.Hide(this);              }
Magic Number,Sce.Atf.Controls.Timelines,TimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineControl.cs,GetPickingRectangle,The following statement contains a magic number: return new RectangleF(                  clientPoint.X - tolerance'                  clientPoint.Y - tolerance'                  2 * tolerance'                  2 * tolerance);
Magic Number,Sce.Atf.Controls.Timelines,TimelineControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineControl.cs,GetPickingRectangle,The following statement contains a magic number: return new RectangleF(                  clientPoint.X - tolerance'                  clientPoint.Y - tolerance'                  2 * tolerance'                  2 * tolerance);
Magic Number,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,TimelineRenderer,The following statement contains a magic number: m_gridPen = new Pen(Color.FromArgb(128' 128' 128' 128));
Magic Number,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,TimelineRenderer,The following statement contains a magic number: m_gridPen = new Pen(Color.FromArgb(128' 128' 128' 128));
Magic Number,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,TimelineRenderer,The following statement contains a magic number: m_gridPen = new Pen(Color.FromArgb(128' 128' 128' 128));
Magic Number,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,TimelineRenderer,The following statement contains a magic number: m_gridPen = new Pen(Color.FromArgb(128' 128' 128' 128));
Magic Number,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,PickSubTimeline,The following statement contains a magic number: if (pickRect.Left > HeaderWidth &&                  pickRect.Right < clientRectangle.Width &&                  pickRect.Bottom > 0 &&                  pickRect.Bottom < TimeScaleHeight)              {                  if ((result.Count == 0) && (pickRect.Height <= 2 * PickTolerance) && (pickRect.Width <= 2 * PickTolerance))                      result.Add(new HitRecord(HitType.TimeScale' null));                  return;              }
Magic Number,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,PickSubTimeline,The following statement contains a magic number: if (pickRect.Left > HeaderWidth &&                  pickRect.Right < clientRectangle.Width &&                  pickRect.Bottom > 0 &&                  pickRect.Bottom < TimeScaleHeight)              {                  if ((result.Count == 0) && (pickRect.Height <= 2 * PickTolerance) && (pickRect.Width <= 2 * PickTolerance))                      result.Add(new HitRecord(HitType.TimeScale' null));                  return;              }
Magic Number,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,DrawTimelineReference,The following statement contains a magic number: originRect.X = screenStart - 4;
Magic Number,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,DrawTimelineReference,The following statement contains a magic number: originRect.Width = 8;
Magic Number,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,DrawTimelineReference,The following statement contains a magic number: originRect.Height = 16;
Magic Number,Sce.Atf.Controls.Timelines,TimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,LayoutSubTimeline,The following statement contains a magic number: float docRowHeight = Math.Max(margin * 2' MinimumTrackSize);
Magic Number,Sce.Atf.Controls.Timelines,Context,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\TimelineRenderer.cs,Context,The following statement contains a magic number: PixelSize = new SizeF(1 / transform.Elements[0]' 1 / transform.Elements[3]);
Missing Default,Sce.Atf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ControlHostService.cs,CanDoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)                  {                      case StandardCommand.WindowTileHorizontal:                          canDo = true;                          break;                        case StandardCommand.WindowTileVertical:                          canDo = true;                          break;                        case StandardCommand.WindowTileTabbed:                          canDo = true;                          break;                      case StandardCommand.UILock:                          canDo = true;                          break;                  }
Missing Default,Sce.Atf.Applications,ControlHostService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\ControlHostService.cs,DoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)                  {                      case StandardCommand.WindowTileHorizontal:                          TileDocumentContent(DockStyle.Right);                          break;                        case StandardCommand.WindowTileVertical:                          TileDocumentContent(DockStyle.Bottom);                          break;                        case StandardCommand.WindowTileTabbed:                          TileDocumentContent(DockStyle.Fill);                          break;                      case StandardCommand.UILock:                          UILocked = m_dockPanel.AllowEndUserDocking;                          break;                  }
Missing Default,Sce.Atf.Applications,DefaultTabCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\DefaultTabCommands.cs,CanDoCommand,The following switch statement is missing a default case: switch ((Command)commandTag)                  {                      case Command.CloseCurrentTab:                          return ControlRegistry.ActiveControl.Group != StandardControlGroup.CenterPermanent;                        case Command.CloseOtherTabs:                          return docInfos.Length > 1;                        case Command.CopyFullPath:                      case Command.OpenContainingFolder:                          return m_documentExists; // Use a cached value to avoid file I/O spam.                  }
Missing Default,Sce.Atf.Applications,DefaultTabCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\DefaultTabCommands.cs,DoCommand,The following switch statement is missing a default case: switch ((Command)commandTag)              {                  case Command.CloseCurrentTab:                      Close(ControlRegistry.ActiveControl);                      break;                    case Command.CloseOtherTabs:                      CloseOthers(ControlRegistry.ActiveControl);                      break;                    case Command.CopyFullPath:                      Clipboard.SetDataObject(GetDocumentPath(ControlRegistry.ActiveControl)' true);                      break;                    case Command.OpenContainingFolder:                      // Open in Explorer and select the file. http://support.microsoft.com/kb/314853                      System.Diagnostics.Process.Start("explorer.exe"' "/e'/select'" + GetDocumentPath(ControlRegistry.ActiveControl));                      break;              }
Missing Default,Sce.Atf.Applications,ResourceLister,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\Listers\ResourceLister.cs,DoCommand,The following switch statement is missing a default case: switch ((Command)commandTag)                  {                      case Command.DetailsView:                          {                              m_thumbnailControl.Hide();                              m_listView.Show();                              RefreshThumbnails();                          }                          break;                        case Command.ThumbnailView:                          {                              m_listView.Hide();                              m_thumbnailControl.Show();                              RefreshThumbnails();                          }                          break;                  }
Missing Default,Sce.Atf.Applications,OutputService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\OutputService.cs,CanDoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)                  {                      case StandardCommand.EditCopy:                          canDo = m_textBox.Focused && (m_textBox.SelectionLength > 0);                          break;                        case StandardCommand.EditSelectAll:                          canDo = m_textBox.Focused && (m_textBox.TextLength > 0);                          break;                  }
Missing Default,Sce.Atf.Applications,OutputService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\OutputService.cs,DoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)                  {                      case StandardCommand.EditCopy:                          m_textBox.Copy();                          break;                        case StandardCommand.EditSelectAll:                          m_textBox.SelectAll();                          break;                  }
Missing Default,Sce.Atf.Applications,PropertyEditingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditingCommands.cs,CanDoCommand,The following switch statement is missing a default case: switch ((Command)commandTag)                  {                      case Command.CopyProperty:                          return m_descriptor != null                               && !(m_descriptor is ChildPropertyDescriptor)                              && !(m_descriptor is ChildAttributeCollectionPropertyDescriptor);                        case Command.PasteProperty:                          {                              var lastObject = editingContext.Items.LastOrDefault();                                return m_descriptor != null && CanPaste(m_copyValue' m_copyDescriptor' m_descriptor'                                  m_descriptor.GetValue(lastObject));                          }                        case Command.ResetProperty:                          return CanResetValue(editingContext.Items' m_descriptor);                                                case Command.CopyAll:                          {                              foreach (var descriptor in editingContext.PropertyDescriptors)                              {                                  if ( (descriptor is ChildPropertyDescriptor)                                      || (descriptor is ChildAttributeCollectionPropertyDescriptor))                                      continue;                                  AttributePropertyDescriptor attr = descriptor as AttributePropertyDescriptor;                                  if (attr != null && attr.AttributeInfo.IsIdAttribute)                                      continue;                                  return true;                              }                              break;                          }                                           case Command.PasteAll:                          return m_descriptorToValue.Count > 0;                        case Command.ResetAll:                          foreach (PropertyDescriptor descriptor in editingContext.PropertyDescriptors)                          {                              if (CanResetValue(editingContext.Items' descriptor))                                  return true;                          }                          break;                                               case Command.ViewInTextEditor:                          if (m_descriptor != null && m_descriptor.GetEditor(typeof(UITypeEditor)) is FileUriEditor)                              return true;                          break;                      case Command.CreateNewPropertyEditor:                          return editingContext == m_propertyEditor.PropertyGrid.PropertyGridView.EditingContext;                  }
Missing Default,Sce.Atf.Applications,PropertyEditingCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\PropertyEditingCommands.cs,DoCommand,The following switch statement is missing a default case: switch ((Command)commandTag)              {                  case Command.CopyProperty:                      {                          if (!(m_descriptor is ChildPropertyDescriptor))                          {                              var lastObject = editingContext.Items.LastOrDefault();                              m_copyDescriptor = m_descriptor;                              m_copyValue = m_descriptor.GetValue(lastObject);                          }                      }                      break;                    case Command.PasteProperty:                      {                          transactionContext.DoTransaction(delegate                          {                              foreach (object item in editingContext.Items)                              {                                  PropertyUtils.SetProperty(item' m_descriptor' m_copyValue);                              }                          }'                          string.Format("Paste: {0}".Localize("'Paste' is a verb and this is the name of a command")'                              m_descriptor.DisplayName));                      }                      break;                    case Command.ResetProperty:                      transactionContext.DoTransaction(delegate                          {                              PropertyUtils.ResetProperty(editingContext.Items' m_descriptor);                          }'                          string.Format("Reset: {0}".Localize("'Reset' is a verb and this is the name of a command")'                              m_descriptor.DisplayName));                      break;                                 case Command.CopyAll:                      {                          m_descriptorToValue.Clear();                          var lastObject = editingContext.Items.LastOrDefault();                                                foreach (var descriptor in editingContext.PropertyDescriptors)                          {                              if( (descriptor is ChildPropertyDescriptor))                                  continue;                                AttributePropertyDescriptor attr = descriptor as AttributePropertyDescriptor;                              if(attr != null && attr.AttributeInfo.IsIdAttribute)                                  continue;                                m_descriptorToValue.Add(descriptor.GetPropertyDescriptorKey()'                                  descriptor.GetValue(lastObject));                          }                                              }                      break;                    case Command.PasteAll:                      {                          transactionContext.DoTransaction(delegate                          {                                                          foreach (var descriptor in editingContext.PropertyDescriptors)                              {                                  if (descriptor.IsReadOnly) continue; ;                                  object value;                                  if (m_descriptorToValue.TryGetValue(descriptor.GetPropertyDescriptorKey()' out value))                                  {                                                                          foreach (object item in editingContext.Items)                                      {                                          PropertyUtils.SetProperty(item'                                              descriptor'                                              value);                                      }                                  }                              }                            }' "Paste All".Localize("'Paste' is a verb and this is the name of a command"));                                              }                      break;                    case Command.ResetAll:                      transactionContext.DoTransaction(delegate                      {                          foreach (PropertyDescriptor descriptor in editingContext.PropertyDescriptors)                          {                              foreach (object item in editingContext.Items)                              {                                  if (descriptor.CanResetValue(item))                                      descriptor.ResetValue(item);                              }                          }                      }'                          "Reset All Properties".Localize("'Reset' is a verb and this is the name of a command"));                      break;                                   case Command.ViewInTextEditor:                      {                          var fileUriEditor = m_descriptor.GetEditor(typeof(UITypeEditor)) as FileUriEditor;                          var fileUri = m_descriptor.GetValue(editingContext.Items.LastOrDefault()) as Uri;                          if (fileUri != null && File.Exists(fileUri.LocalPath))                              Process.Start(fileUriEditor.AssociatedTextEditor' fileUri.LocalPath);                      }                      break;                  case Command.CreateNewPropertyEditor:                      {                          m_propertyEditor.Duplicate();                      }                      break;              }
Missing Default,Sce.Atf.Applications,SettingsService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsService.cs,CanDoCommand,The following switch statement is missing a default case: switch ((CommandId)tag)                  {                      case CommandId.EditPreferences:                      case CommandId.EditImportExportSettings:                          enabled = true;                          break;                  }
Missing Default,Sce.Atf.Applications,SettingsService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SettingsService.cs,DoCommand,The following switch statement is missing a default case: switch ((CommandId)tag)                  {                      case CommandId.EditPreferences:                          PresentUserSettings(null);                          break;                        case CommandId.EditImportExportSettings:                          var settingsLoadSaveDialog = new SettingsLoadSaveDialog(this);                          settingsLoadSaveDialog.ShowDialog(MainWindow.DialogOwner);                          break;                  }
Missing Default,Sce.Atf.Applications,FormNcRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\FormNcRenderer.cs,WndProc,The following switch statement is missing a default case: switch ((uint)m.Msg)              {                  case WinMessages.WM_NCPAINT:                      handled = PaintTitleBar(m_active);                      if (handled) m.Result = IntPtr.Zero;                      break;                    case WinMessages.WM_ACTIVATEAPP:                      m_active = m.WParam != IntPtr.Zero;                      handled = PaintTitleBar(m_active);                      if (handled) m.Result = IntPtr.Zero;                      break;                    case WinMessages.WM_ACTIVATE:                      int lwp = LowWord(m.WParam.ToInt32());                      m_active = lwp != 0;                      handled = PaintTitleBar(m_active);                      if (handled) m.Result = IntPtr.Zero;                        // let the window process this message                       // so the form can raise activated and deactivate events.                      handled = false;                       break;                  case WinMessages.WM_NCACTIVATE:                      if (m.WParam != IntPtr.Zero)                          m.Result = IntPtr.Zero;                                              else                          m.Result = (IntPtr)1;                      handled = true;                                          PaintTitleBar(m.WParam != IntPtr.Zero);                      break;                  case WinMessages.WM_NCUAHDRAWCAPTION:                  case WinMessages.WM_NCUAHDRAWFRAME:                      handled = true; // ignore theme related messages.                      break;                                   case WinMessages.WM_SIZE:                      {                                                 if (m_paintOnResize)                          {                                                        m_paintOnResize = false;                              PaintTitleBar(m_active);                          }                      }                      break;                  case WinMessages.WM_SYSCOMMAND:                      uint flags = (uint)m.WParam & 0xFFF0;                      m_paintOnResize =                          (flags & SYSCOMMANDWPARAM.SC_RESTORE) != 0                              || (flags & SYSCOMMANDWPARAM.SC_MAXIMIZE) != 0;                      break;                  case WinMessages.WM_EXITSIZEMOVE:                      PaintTitleBar(m_active);                      break;                    case WinMessages.WM_STYLECHANGED:                      CreateCaptionButtons();                                         m.Result = IntPtr.Zero;                      handled = true;                      break;                    case WinMessages.WM_SETICON:                      CreateCaptionButtons();                                          break;                    case WinMessages.WM_SETTEXT:                      base.WndProc(ref m);                      PaintTitleBar(m_active);                      handled = true;                      break;                    case WinMessages.WM_NCHITTEST:                      handled = OnHitTest(ref m);                      break;                    case WinMessages.WM_NCMOUSELEAVE:                      SetHoverState(null);                      break;                  case WinMessages.WM_NCLBUTTONDOWN:                      handled = OnNcLButtonDown(ref m);                      break;                    case WinMessages.WM_NCLBUTTONUP:                      handled = OnNcLButtonUp(ref m);                      break;                    case WinMessages.WM_NCMOUSEMOVE:                      handled = OnNcMouseMove(ref m);                      break;                }
Missing Default,Sce.Atf.Applications,SkinService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinService.cs,CanDoCommand,The following switch statement is missing a default case: switch((SkinCommands)commandTag)              {                  case SkinCommands.SkinEdit:                      enabled = true;                      break;                                    case SkinCommands.SkinLoad:                      enabled = FileDialogService != null;                      break;                    case SkinCommands.SkinReset:                      enabled = ActiveSkin != null;                      break;              }
Missing Default,Sce.Atf.Applications,SkinService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinService.cs,DoCommand,The following switch statement is missing a default case: switch ((SkinCommands)commandTag)              {                  case SkinCommands.SkinEdit:                      if (m_skinEditor == null)                      {                          m_skinEditor = new SkinEditor();                          m_skinEditor.Show(MainForm);                          if (ActiveSkin != null)                          {                              m_skinEditor.OpenSkin(ActiveSkin.SkinFile);                          }                          m_skinEditor.FormClosed += SkinEditor_FormClosed;                          m_skinEditor.SkinChanged += SkinEditor_SkinChanged;                          m_mainForm.FormClosing += m_mainForm_FormClosing;                      }                      break;                    case SkinCommands.SkinLoad:                      string forcedDirectory =                          ActiveSkin == null ? SkinsDirectory :                          Directory.GetParent(ActiveSkin.SkinFile).FullName;                      string newSkinPath = null;                      var dlgResult = FileDialogService.OpenFileName(ref newSkinPath' Info.GetFilterString()' forcedDirectory);                      if (dlgResult == FileDialogResult.OK)                      {                          OpenAndApplySkin(newSkinPath);                          SkinsDirectory = Directory.GetParent(newSkinPath).FullName;                      }                      break;                                   case SkinCommands.SkinReset:                      ResetSkin();                      break;              }
Missing Default,Sce.Atf.Applications,SkinService,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\SkinService\SkinService.cs,GetTypeFromString,The following switch statement is missing a default case: switch(typeString)              {                  case "System.Drawing.Color": //very common                      return typeof(Color);                    case "string": //short for "System.String"                      return typeof(string);                    case "int": //short for "System.Int32"                      return typeof(int);                    case "float": //short for "System.Single"                      return typeof(float);                    case "char": //short for "System.Char"                      return typeof(char);                    case "byte": //short for "System.Byte"                      return typeof(byte);              }
Missing Default,Sce.Atf.Applications,StandardEditCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StandardEditCommands.cs,CanDoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)              {                  case StandardCommand.EditCut:                      canDo =                          instancingContext != null &&                          instancingContext.CanCopy() &&                          instancingContext.CanDelete();                      break;                    case StandardCommand.EditDelete:                      canDo =                          instancingContext != null &&                          instancingContext.CanDelete();                      break;                    case StandardCommand.EditCopy:                      canDo =                          instancingContext != null &&                          instancingContext.CanCopy();                      break;                    case StandardCommand.EditPaste:                      canDo =                          instancingContext != null &&                          CanPaste();                      break;              }
Missing Default,Sce.Atf.Applications,StandardEditCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StandardEditCommands.cs,DoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)              {                  case StandardCommand.EditCut:                      Cut();                      break;                    case StandardCommand.EditDelete:                      Delete();                      break;                    case StandardCommand.EditCopy:                      Copy();                      break;                    case StandardCommand.EditPaste:                      Paste();                      break;              }
Missing Default,Sce.Atf.Applications,StandardLayoutCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StandardLayoutCommands.cs,CanDoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)                      {                          case StandardCommand.FormatAlignLefts:                          case StandardCommand.FormatAlignCenters: //horizontal middle                          case StandardCommand.FormatAlignRights:                              canDo = (itemFlags & BoundsSpecified.X) != 0;                              break;                            case StandardCommand.FormatAlignTops:                          case StandardCommand.FormatAlignMiddles: //vertical middle                          case StandardCommand.FormatAlignBottoms:                              canDo = (itemFlags & BoundsSpecified.Y) != 0;                              break;                            case StandardCommand.FormatMakeWidthEqual:                              canDo = (itemFlags & BoundsSpecified.Width) != 0;                              break;                            case StandardCommand.FormatMakeHeightEqual:                              canDo = (itemFlags & BoundsSpecified.Height) != 0;                              break;                            case StandardCommand.FormatMakeSizeEqual:                              canDo = (itemFlags & BoundsSpecified.Size) == BoundsSpecified.Size;                              break;                      }
Missing Default,Sce.Atf.Applications,StandardLayoutCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StandardLayoutCommands.cs,DoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)                      {                          case StandardCommand.FormatAlignLefts:                              commandName = CommandInfo.FormatAlignLefts.MenuText;                              break;                            case StandardCommand.FormatAlignRights:                              commandName = CommandInfo.FormatAlignRights.MenuText;                              break;                            case StandardCommand.FormatAlignCenters: //horizontal middle                              commandName = CommandInfo.FormatAlignCenters.MenuText;                              break;                            case StandardCommand.FormatAlignTops: //horizontal middle                              commandName = CommandInfo.FormatAlignTops.MenuText;                              break;                            case StandardCommand.FormatAlignBottoms:                              commandName = CommandInfo.FormatAlignBottoms.MenuText;                              break;                            case StandardCommand.FormatAlignMiddles: //vertical middle                              commandName = CommandInfo.FormatAlignMiddles.MenuText;                              break;                            case StandardCommand.FormatMakeWidthEqual:                              commandName = CommandInfo.FormatMakeWidthEqual.MenuText;                              break;                            case StandardCommand.FormatMakeHeightEqual:                              commandName = CommandInfo.FormatMakeHeightEqual.MenuText;                              break;                            case StandardCommand.FormatMakeSizeEqual:                              commandName = CommandInfo.FormatMakeSizeEqual.MenuText;                              break;                      }
Missing Default,Sce.Atf.Applications,StandardLayoutCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StandardLayoutCommands.cs,DoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)                              {                                  case StandardCommand.FormatAlignLefts:                                      AlignLefts(items' layoutContext);                                      break;                                    case StandardCommand.FormatAlignRights:                                      AlignRights(items' layoutContext);                                      break;                                    case StandardCommand.FormatAlignCenters: // horizontal center                                      AlignCenters(items' layoutContext);                                      break;                                    case StandardCommand.FormatAlignTops:                                      AlignTops(items' layoutContext);                                      break;                                    case StandardCommand.FormatAlignBottoms:                                      AlignBottoms(items' layoutContext);                                      break;                                    case StandardCommand.FormatAlignMiddles: // vertical center                                      AlignMiddles(items' layoutContext);                                      break;                                    case StandardCommand.FormatMakeWidthEqual:                                      MakeWidthEqual(items' layoutContext);                                      break;                                    case StandardCommand.FormatMakeHeightEqual:                                      MakeHeightEqual(items' layoutContext);                                      break;                                    case StandardCommand.FormatMakeSizeEqual:                                      MakeSizeEqual(items' layoutContext);                                      break;                              }
Missing Default,Sce.Atf.Applications,StandardPrintCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StandardPrintCommands.cs,CanDoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)                  {                      case StandardCommand.PrintPreview:                      case StandardCommand.PageSetup:                      case StandardCommand.Print:                          IPrintableDocument printableDocument = m_contextRegistry.GetActiveContext<IPrintableDocument>();                          enabled = printableDocument != null;                          break;                  }
Missing Default,Sce.Atf.Applications,StandardPrintCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\StandardPrintCommands.cs,DoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)                  {                      case StandardCommand.PageSetup:                          ShowPageSettingsDialog();                          break;                        case StandardCommand.PrintPreview:                          ShowPrintPreviewDialog();                          break;                        case StandardCommand.Print:                          ShowPrintDialog();                          break;                  }
Missing Default,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,CanDoCommand,The following switch statement is missing a default case: switch ((Command)commandTag)                  {                      case Command.Refresh:                          canDo = WrapCommandFunction((Command)commandTag' DoRefresh' doing);                          break;                        case Command.Reconcile:                          canDo = WrapCommandFunction((Command)commandTag' DoReconcile' doing);                          break;                        case Command.CheckOut:                          canDo = WrapCommandFunction((Command)commandTag' DoCheckOut' doing);                          break;                        case Command.CheckIn:                          canDo = WrapCommandFunction((Command)commandTag' DoCheckIn' doing);                          break;                        case Command.Sync:                          canDo = WrapCommandFunction((Command)commandTag' DoSync' doing);                          break;                        case Command.Revert:                          canDo = WrapCommandFunction((Command)commandTag' DoRevert' doing);                          break;                  }
Missing Default,Sce.Atf.Applications,SourceControlCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Applications\VersionControl\SourceControlCommands.cs,DoCommand,The following switch statement is missing a default case: switch ((Command)commandTag)              {                  case Command.Refresh:                      WrapCommandFunction((Command)commandTag' DoRefresh' doing);                      break;                    case Command.Reconcile:                      WrapCommandFunction((Command)commandTag' DoReconcile' doing);                      break;                    case Command.Add:                      WrapCommandFunction((Command)commandTag' DoAdd' doing);                      break;                    case Command.CheckOut:                      WrapCommandFunction((Command)commandTag' DoCheckOut' doing);                      break;                    case Command.CheckIn:                      WrapCommandFunction((Command)commandTag' DoCheckIn' doing);                      break;                    case Command.Sync:                      WrapCommandFunction((Command)commandTag' DoSync' doing);                      break;                    case Command.Revert:                      WrapCommandFunction((Command)commandTag' DoRevert' doing);                      break;              }
Missing Default,Sce.Atf.Applications,ReplaceTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\SearchAndReplace\ReplaceTextBox.cs,textBox_KeyDown,The following switch statement is missing a default case: switch (e.KeyCode)              {                  case Keys.Enter:                      DoReplace();                      break;              }
Missing Default,Sce.Atf,FindFileResolver,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\FindFileResolver.cs,QueryUser,The following switch statement is missing a default case: switch (userAction)                  {                      case FindFileAction.AcceptSuggestion:                          newUri = suggestedUri;                          return true;                        case FindFileAction.AcceptAllSuggestions:                          s_acceptAll = true;                          newUri = suggestedUri;                          return true;                        case FindFileAction.SearchDirectory:                          if (SearchForFile(uri' out newUri' true))                              return true;                          continue;                        case FindFileAction.SearchDirectoryForAll:                          s_searchAll = true;                          if (SearchForFile(uri' out newUri' false))                              return true;                          continue;                        case FindFileAction.UserSpecify:                          if (UserFindFile(uri' out newUri))                              return true;                          continue;                        case FindFileAction.Ignore:                          newUri = uri;                          return false;                        case FindFileAction.IgnoreAll:                          s_ignoreAll = true;                          newUri = uri;                          return false;                  }
Missing Default,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawSubItem,The following switch statement is missing a default case: switch (e.Header.TextAlign)                      {                          case HorizontalAlignment.Center:                              sf.Alignment = StringAlignment.Center;                              break;                          case HorizontalAlignment.Right:                              sf.Alignment = StringAlignment.Far;                              break;                      }
Missing Default,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawSubItem,The following switch statement is missing a default case: switch (e.Header.TextAlign)                  {                      case HorizontalAlignment.Center:                          sf.Alignment = StringAlignment.Center;                          break;                      case HorizontalAlignment.Right:                          sf.Alignment = StringAlignment.Far;                          break;                  }
Missing Default,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,OnDrawColumnHeader,The following switch statement is missing a default case: switch (e.Header.TextAlign)                  {                      case HorizontalAlignment.Center:                          sf.Alignment = StringAlignment.Center;                          break;                      case HorizontalAlignment.Right:                          sf.Alignment = StringAlignment.Far;                          break;                  }
Missing Default,Sce.Atf.Controls,DataBoundListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\DataBoundListView.cs,activeEditingControl_KeyPress,The following switch statement is missing a default case: switch (e.KeyChar)              {                  case (char)(int)Keys.Escape:                      {                          // Reset to the original  value' and then hide the editing control.                          DisableEditingControl(false);                          break;                      }                    case (char)(int)Keys.Enter:                      {                          // Hide the editing control.                          DisableEditingControl(true);                          break;                      }              }
Missing Default,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnMouseDown,The following switch statement is missing a default case: switch (hitRecord.Type)              {                  case HitType.Expander:                      ToggleExpand(node);                      break;                    case HitType.CheckBox:                      if (node.CheckBoxEnabled)                      {                          CheckState checkState = (node.CheckState == CheckState.Checked) ? CheckState.Unchecked : CheckState.Checked;                          if (node.CheckState != checkState)                          {                              node.CheckState = checkState;                              OnNodeCheckStateEdited(new NodeEventArgs(node));                          }                      }                      break;                    case HitType.Item:                  case HitType.Label:                      // Selection logic table' mostly based on Visual Studio tree control:                      // Mouse Button    Modifier Keys   Result                      // -------------   -------------   -----------------------------                      // left            none            Not selected? SetSelection(node). Else' m_leftClickedSelectedNode = node.                      // left            alt             No selection change or label editing. Different than VS.                      // left            ctrl            toggle node's selected state. Shift key is ignored if it's pressed.                      // left            shift           ExtendSelection(node)                      // right           none'ctrl'shift Node is already selected? Then don't change selection set.                      //                                 Node is not selected? Then SetSelection(node).                      // right           alt             No selection change or label editing. Different than VS.                      // middle' etc.    any             No change.                      m_selecting = false;                      Keys modifiers = FilterModifiers();                      if ((modifiers & Keys.Alt) == 0)                      {                          if (e.Button == MouseButtons.Left)                          {                              m_selecting = true;                              OnSelectionChanging(EventArgs.Empty);                                if ((modifiers & Keys.Control) != 0)                              {                                  if (IsNodeMultiSelectable(node))                                  {                                      node.Selected = !node.Selected;                                  }                              }                              else if ((modifiers & Keys.Shift) != 0)                              {                                  ExtendSelection(node);                              }                              else                              {                                  if (node.Selected)                                  {                                      // even though selection set isn't changing' MouseUp expects m_selecting to be true.                                      m_leftClickedSelectedNode = node;                                  }                                  else                                  {                                      SetSelection(node);                                  }                                    if (ExpandOnSingleClick)                                  {                                      if (!node.IsLeaf && !node.Expanded)                                          node.Expanded = true;                                  }                              }                          }                          else if (e.Button == MouseButtons.Right)                          {                              if (!node.Selected)                              {                                  m_selecting = true;                                  OnSelectionChanging(EventArgs.Empty);                                  SetSelection(node);                              }                          }                      }                      break;              }
Missing Default,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,OnMouseDoubleClick,The following switch statement is missing a default case: switch (hitRecord.Type)              {                  case HitType.Item:                  case HitType.Label:                      if (ToggleOnDoubleClick)                          ToggleExpand(node);                      break;              }
Missing Default,Sce.Atf.Controls,TreeControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeControl.cs,ProcessDialogKey,The following switch statement is missing a default case: switch (keyData & Keys.KeyCode)              {                  case Keys.Down:                      nextNode = GetNextNode(m_currentKeyedNode);                      if (m_style == Style.CategorizedPalette && NavigationKeyBehaviorContains(KeyboardShortcuts.UpDownNav))                      {                          while (nextNode != null && nextNode.Parent == Root)                              nextNode = GetNextNode(nextNode);                      }                      handled = true;                      break;                  case Keys.Up:                      nextNode = GetPreviousNode(m_currentKeyedNode);                      if (m_style == Style.CategorizedPalette && NavigationKeyBehaviorContains(KeyboardShortcuts.UpDownNav))                      {                          while (nextNode != null && nextNode.Parent == Root)                              nextNode = GetPreviousNode(nextNode);                      }                      handled = true;                      break;                  case Keys.Left:                      // if node is expanded' collapse it; otherwise go to its parent                      if (NavigationKeyBehaviorContains(KeyboardShortcuts.LeftRightExpand) && m_currentKeyedNode != null)                      {                          if (m_currentKeyedNode.Expanded)                              ToggleExpand(m_currentKeyedNode);                          else                              nextNode = m_currentKeyedNode.Parent;                          handled = true;                      }                      break;                  case Keys.Right:                      if (NavigationKeyBehaviorContains(KeyboardShortcuts.LeftRightExpand) && m_currentKeyedNode != null)                      {                          // if node is expanded' go to 1st child; otherwise expand it                          if (m_currentKeyedNode.Expanded)                          {                              foreach (Node child in m_currentKeyedNode.Children)                              {                                  nextNode = child;                                  break;                              }                          }                          else if (!m_currentKeyedNode.IsLeaf)                              m_currentKeyedNode.Expanded = true;                          handled = true;                      }                      break;                  case Keys.Home:                      if (NavigationKeyBehaviorContains(KeyboardShortcuts.HomeEnd))                      {                          if (ShowRoot)                              nextNode = Root;                          else                          {                              foreach (Node child in Root.Children)                              {                                  nextNode = child;                                  break;                              }                          }                          handled = true;                      }                      break;                  case Keys.End:                      if (NavigationKeyBehaviorContains(KeyboardShortcuts.HomeEnd))                      {                          foreach (Node node in VisibleNodes)                              nextNode = node;                          handled = true;                      }                      break;                  case Keys.PageDown:                      if (NavigationKeyBehaviorContains(KeyboardShortcuts.PageUpDown))                      {                          int visibleHeight = Height - Margin.Top - Margin.Bottom;                          SetVerticalScroll(m_vScroll + visibleHeight - FontHeight);                          handled = true;                      }                      break;                  case Keys.PageUp:                      if (NavigationKeyBehaviorContains(KeyboardShortcuts.PageUpDown))                      {                          int visibleHeight = Height - Margin.Top - Margin.Bottom;                          SetVerticalScroll(m_vScroll - visibleHeight - FontHeight);                          handled = true;                      }                      break;              }
Missing Default,Sce.Atf.Controls,TheTreeListView,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\TreeListView.ListView.cs,WndProc,The following switch statement is missing a default case: switch (m.WParam.ToInt32())                              {                                  case (int)Keys.Down:                                      Scroll(this' new ScrollEventArgs(ScrollEventType.SmallIncrement' User32.GetScrollPos(Handle' SB_VERT)));                                      break;                                    case (int)Keys.Up:                                      Scroll(this' new ScrollEventArgs(ScrollEventType.SmallDecrement' User32.GetScrollPos(Handle' SB_VERT)));                                      break;                                    case (int)Keys.PageDown:                                      Scroll(this' new ScrollEventArgs(ScrollEventType.LargeIncrement' User32.GetScrollPos(Handle' SB_VERT)));                                      break;                                    case (int)Keys.PageUp:                                      Scroll(this' new ScrollEventArgs(ScrollEventType.LargeDecrement' User32.GetScrollPos(Handle' SB_VERT)));                                      break;                                    case (int)Keys.Home:                                      Scroll(this' new ScrollEventArgs(ScrollEventType.First' User32.GetScrollPos(Handle' SB_VERT)));                                      break;                                    case (int)Keys.End:                                      Scroll(this' new ScrollEventArgs(ScrollEventType.Last' User32.GetScrollPos(Handle' SB_VERT)));                                      break;                              }
Missing Default,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,ResizeAnnotation,The following switch statement is missing a default case: switch (diagramBorder.Border)              {                    case DiagramBorder.BorderType.LowerRightCorner:                      newBounds = new Rectangle(m_startBounds.X' m_startBounds.Y' m_startBounds.Width + delta.X' m_startBounds.Height + delta.Y);                      m_layoutContext.SetBounds(diagramBorder.Item' ConstrainBounds(newBounds)' BoundsSpecified.All);                      break;                  case DiagramBorder.BorderType.UpperLeftCorner:                      newBounds = new Rectangle(currentPoint.X' currentPoint.Y' m_startBounds.Width - delta.X' m_startBounds.Height - delta.Y);                      m_layoutContext.SetBounds(diagramBorder.Item' ConstrainBounds(newBounds)' BoundsSpecified.All);                      break;                  case DiagramBorder.BorderType.UpperRightCorner:                      newBounds = new Rectangle(m_startBounds.X' currentPoint.Y' m_startBounds.Width + delta.X' m_startBounds.Height - delta.Y);                      m_layoutContext.SetBounds(diagramBorder.Item' ConstrainBounds(newBounds)' BoundsSpecified.All);                      break;                  case DiagramBorder.BorderType.LowerLeftCorner:                      newBounds = new Rectangle(currentPoint.X' m_startBounds.Y' m_startBounds.Width - delta.X' m_startBounds.Height + delta.Y);                      m_layoutContext.SetBounds(diagramBorder.Item' ConstrainBounds(newBounds)' BoundsSpecified.All);                      break;                    case DiagramBorder.BorderType.Left:                      newBounds = new Rectangle(currentPoint.X' m_startBounds.Y' m_startBounds.Width - delta.X' m_startBounds.Height);                      m_layoutContext.SetBounds(diagramBorder.Item' ConstrainBounds(newBounds)' BoundsSpecified.All);                      break;                  case DiagramBorder.BorderType.Right:                      newBounds = new Rectangle(m_startBounds.X' m_startBounds.Y' m_startBounds.Width + delta.X' m_startBounds.Height);                      m_layoutContext.SetBounds(diagramBorder.Item' ConstrainBounds(newBounds)' BoundsSpecified.Size);                      break;                  case DiagramBorder.BorderType.Top:                      newBounds = new Rectangle(m_startBounds.X' currentPoint.Y' m_startBounds.Width' m_startBounds.Height - delta.Y);                      m_layoutContext.SetBounds(diagramBorder.Item' ConstrainBounds(newBounds)' BoundsSpecified.All);                      break;                  case DiagramBorder.BorderType.Bottom:                      newBounds = new Rectangle(m_startBounds.X' m_startBounds.Y' m_startBounds.Width' m_startBounds.Height + delta.Y);                      m_layoutContext.SetBounds(diagramBorder.Item' ConstrainBounds(newBounds)' BoundsSpecified.Size);                      break;                }
Missing Default,Sce.Atf.Controls.Adaptable,D2dAnnotationAdapter,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\D2dAnnotationAdapter.cs,control_PreviewKeyDown,The following switch statement is missing a default case: switch (key)              {                  case Keys.Delete:                      if (ctrlPressed)                      {                          annotationEditor.SetSelection(TextEditor.SelectionMode.RightWord' 1' true' false);                            transactionContext.DoTransaction(() =>                                {                                    DeleteTextSelection(annotation);                                }' EditAnnotation);                        }                      else                      {                          transactionContext.DoTransaction(() =>                              {                                  if (annotationEditor.CaretAbsolutePosition != annotationEditor.CaretAnchorPosition)                                      DeleteTextSelection(annotation); // delete all the selected text.                                  else                                  {                                      // get the size of the following cluster.                                      var hitTestMetrics =                                          annotationEditor.TextLayout.HitTestTextPosition(                                              annotationEditor.CaretAbsolutePosition' false);                                      string newText = annotationEditor.RemoveTextAt(annotation.Text'                                                                                     hitTestMetrics.TextPosition'                                                                                     hitTestMetrics.Length);                                      textProperty.SetValue(annotation' newText' null);                                      annotationEditor.SetSelection(TextEditor.SelectionMode.AbsoluteLeading'                                                                    hitTestMetrics.TextPosition' false' false);                                  }                              }' EditAnnotation);                      }                      AdaptedControl.Invalidate();                      break;                  case Keys.Tab:                      InsertChar(annotation' annotationEditor' '\t');                      AdaptedControl.Invalidate();                      break;                  // handle arrow keys                  case Keys.Left:                      annotationEditor.SetSelection(ctrlPressed ? TextEditor.SelectionMode.LeftWord : TextEditor.SelectionMode.Left' 1' shiftPressed' false);                      AdaptedControl.Invalidate();                      break;                  case Keys.Right:                      annotationEditor.SetSelection(ctrlPressed ? TextEditor.SelectionMode.RightWord : TextEditor.SelectionMode.Right' 1' shiftPressed' false);                      AdaptedControl.Invalidate();                      break;                  case Keys.Up: // up a line                      annotationEditor.SetSelection(TextEditor.SelectionMode.Up' 1' shiftPressed' false);                      AdaptedControl.Invalidate();                      break;                  case Keys.Down: // down a line                      annotationEditor.SetSelection(TextEditor.SelectionMode.Down' 1' shiftPressed' false);                      AdaptedControl.Invalidate();                      break;                  case Keys.Home: // beginning of line                      annotationEditor.SetSelection(ctrlPressed ? TextEditor.SelectionMode.First : TextEditor.SelectionMode.Home' 0' shiftPressed' false);                      AdaptedControl.Invalidate();                      break;                  case Keys.End: // end of line                      annotationEditor.SetSelection(ctrlPressed ? TextEditor.SelectionMode.Last : TextEditor.SelectionMode.End' 0' shiftPressed' false);                      AdaptedControl.Invalidate();                      break;                  case Keys.Insert:                      if (ctrlPressed)                          CopyToClipboard(annotation);                      else                          PasteFromClipboard(annotation);                      break;              }
Missing Default,Sce.Atf.Controls.Adaptable,TextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\LabelEditAdapter.cs,ProcessCmdKey,The following switch statement is missing a default case: switch (keyData)                  {                      case Keys.Control | Keys.A:                          SelectAll();                          return true;                        case Keys.Control | Keys.Z:                          Undo();                          return true;                  }
Missing Default,Sce.Atf.Controls.Adaptable,MouseLayoutManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseLayoutManipulator.cs,SetCursor,The following switch statement is missing a default case: switch (direction)              {                  case Direction.Left:                  case Direction.Right:                      AdaptedControl.Cursor = Cursors.SizeWE;                      break;                  case Direction.Top:                  case Direction.Bottom:                      AdaptedControl.Cursor = Cursors.SizeNS;                      break;                  case Direction.TopLeft:                  case Direction.BottomRight:                      AdaptedControl.Cursor = Cursors.SizeNWSE;                      break;                  case Direction.TopRight:                  case Direction.BottomLeft:                      AdaptedControl.Cursor = Cursors.SizeNESW;                      break;              }
Missing Default,Sce.Atf.Controls.Adaptable,MouseLayoutManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseLayoutManipulator.cs,GetTransform,The following switch statement is missing a default case: switch (m_direction)                  {                      case Direction.Left:                          dragDir = new PointF(1' 0);                          break;                      case Direction.Right:                          dragDir = new PointF(-1' 0);                          break;                      case Direction.Top:                          dragDir = new PointF(0' 1);                          break;                      case Direction.Bottom:                          dragDir = new PointF(0' -1);                          break;                      case Direction.TopLeft:                          dragDir = new PointF(.707f' .707f);                          break;                      case Direction.BottomRight:                          dragDir = new PointF(-.707f' -.707f);                          break;                      case Direction.TopRight:                          dragDir = new PointF(-.707f' .707f);                          break;                      case Direction.BottomLeft:                          dragDir = new PointF(.707f' -.707f);                          break;                  }
Missing Default,Sce.Atf.Controls.Adaptable,MouseLayoutManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\MouseLayoutManipulator.cs,GetTransform,The following switch statement is missing a default case: switch (m_direction)              {                  case Direction.Left:                      currentBounds.X += delta.X;                      currentBounds.Width -= delta.X;                      if (m_transformAdapter.UniformScale)                      {                          currentBounds.Y += delta.X * 0.5f;                          currentBounds.Height -= delta.X;                      }                      break;                  case Direction.Right:                      currentBounds.Width += delta.X;                      if (m_transformAdapter.UniformScale)                      {                          currentBounds.Y -= delta.X * 0.5f;                          currentBounds.Height += delta.X;                      }                      break;                  case Direction.Top:                      currentBounds.Y += delta.Y;                      currentBounds.Height -= delta.Y;                      if (m_transformAdapter.UniformScale)                      {                          currentBounds.X += delta.Y * 0.5f;                          currentBounds.Width -= delta.Y;                      }                      break;                  case Direction.Bottom:                      currentBounds.Height += delta.Y;                      if (m_transformAdapter.UniformScale)                      {                          currentBounds.X -= delta.Y * 0.5f;                          currentBounds.Width += delta.Y;                      }                      break;                  case Direction.TopLeft:                      currentBounds.X += delta.X;                      currentBounds.Width -= delta.X;                      currentBounds.Y += delta.Y;                      currentBounds.Height -= delta.Y;                      break;                  case Direction.BottomRight:                      currentBounds.Width += delta.X;                      currentBounds.Height += delta.Y;                      break;                  case Direction.TopRight:                      currentBounds.Width += delta.X;                      currentBounds.Y += delta.Y;                      currentBounds.Height -= delta.Y;                      break;                  case Direction.BottomLeft:                      currentBounds.X += delta.X;                      currentBounds.Width -= delta.X;                      currentBounds.Height += delta.Y;                      break;              }
Missing Default,Sce.Atf.Controls.Adaptable.Graphs,LayeringContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\Circuit\LayeringContext.cs,GetCheckState,The following switch statement is missing a default case: switch (subCheckState)                  {                      case CheckState.Checked:                          hasCheckedChild = true;                          break;                      case CheckState.Unchecked:                          hasUncheckedChild = true;                          break;                      case CheckState.Indeterminate:                          hasCheckedChild = true;                          hasUncheckedChild = true;                          break;                  }
Missing Default,Sce.Atf.Controls.Adaptable.Graphs,D2dStatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\D2dStatechartRenderer.cs,DrawPseudostate,The following switch statement is missing a default case: switch (state.Type)              {                  case StateType.Start:                                          g.FillEllipse(innerEllipse' m_theme.TextBrush);                      break;                  case StateType.Final:                      g.DrawEllipse(ellipse' m_theme.OutlineBrush' 3.0f);                      g.FillEllipse(innerEllipse' m_theme.TextBrush);                                          break;                  case StateType.ShallowHistory:                      g.DrawText("H"' m_centerText' bounds' m_theme.TextBrush);                      break;                  case StateType.DeepHistory:                                      g.DrawText("H*"' m_centerText' bounds' m_theme.TextBrush);                      break;                  case StateType.Conditional:                                          g.DrawText("C"' m_centerText' bounds' m_theme.TextBrush);                                          break;              }
Missing Default,Sce.Atf.Controls.Adaptable.Graphs,GraphViewCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\GraphViewCommands.cs,CanDoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)                  {                      case StandardCommand.ViewZoomIn:                      case StandardCommand.ViewZoomOut:                      case StandardCommand.ViewZoomReset:                          canDo = transformAdapter != null;                          break;                  }
Missing Default,Sce.Atf.Controls.Adaptable.Graphs,GraphViewCommands,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\GraphViewCommands.cs,DoCommand,The following switch statement is missing a default case: switch ((StandardCommand)commandTag)                  {                      case StandardCommand.ViewZoomIn:                          ZoomIn();                          break;                        case StandardCommand.ViewZoomOut:                          ZoomOut();                          break;                      case StandardCommand.ViewZoomReset:                          ZoomReset();                          break;                  }
Missing Default,Sce.Atf.Controls.Adaptable.Graphs,StatechartRenderer<TNode;TEdge>,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Adaptable\Graphs\StatechartRenderer.cs,DrawPseudostate,The following switch statement is missing a default case: switch (type)              {                  case StateType.Start:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.Final:                      using (Pen borderPen = new Pen(pen.Color' 3))                      {                          g.DrawEllipse(borderPen' p.X' p.Y' size' size);                      }                      g.FillEllipse(m_theme.TextBrush' c.X - 4' c.Y - 4' 8' 8);                      break;                    case StateType.ShallowHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;                    case StateType.DeepHistory:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("H*"' m_theme.Font' m_theme.TextBrush' c.X - 8' c.Y - 8);                      break;                    case StateType.Conditional:                      g.DrawEllipse(m_theme.OutlinePen' p.X' p.Y' size' size);                      g.DrawString("C"' m_theme.Font' m_theme.TextBrush' c.X - 7' c.Y - 8);                      break;              }
Missing Default,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ClearMarker,The following switch statement is missing a default case: switch (m_eDrawStyle)              {                      //          S=0'S=1'S=2'S=3.....S=100                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97           Hue                      //    ...                      //    L=0                  case eDrawStyle.Hue :                            hsl_start.H = m_hsl.H;    hsl_end.H = m_hsl.H;    //    Hue is constant                      hsl_start.S = (double)start_x/(Width - 4);        //    Because we're drawing horizontal lines' s will not change                      hsl_end.S = (double)end_x/(Width - 4);            //    from line to line                        for ( int i = start_y; i <= end_y; i++ )          //    For each horizontal line:                      {                          hsl_start.L = 1.0 - (double)i/(Height - 4);   //    Brightness (L) WILL change for each horizontal                          hsl_end.L = hsl_start.L;                      //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                                            break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    L=100                      //    L=99                      //    L=98        Drawstyle                      //    L=97        Saturation                      //    ...                      //    L=0                  case eDrawStyle.Saturation :                        hsl_start.S = m_hsl.S;    hsl_end.S = m_hsl.S;       //    Saturation is constant                      hsl_start.L = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' L will                       hsl_end.L = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                      break;                      //          H=0'H=1'H=2'H=3.....H=360                      //    S=100                      //    S=99                      //    S=98        Drawstyle                      //    S=97        Brightness                      //    ...                      //    S=0                  case eDrawStyle.Brightness :                                            hsl_start.L = m_hsl.L;    hsl_end.L = m_hsl.L;       //    Luminance is constant                      hsl_start.S = 1.0 - (double)start_y/(Height - 4);    //    Because we're drawing vertical lines' S will                       hsl_end.S = 1.0 - (double)end_y/(Height - 4);        //    not change from line to line                        for ( int i = start_x; i <= end_x; i++ )             //    For each vertical line:                      {                          hsl_start.H = (double)i/(Width - 4);             //    Hue (H) WILL change for each vertical                          hsl_end.H = hsl_start.H;                         //    line drawn                                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(i + 2'start_y + 1' 1' end_y - start_y + 2)' AdobeColors.HSL_to_RGB(hsl_start)' AdobeColors.HSL_to_RGB(hsl_end)' 90' false);                           g.FillRectangle(br'new Rectangle(i + 2' start_y + 2' 1' end_y - start_y + 1));                       }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Red                      //    ...                      //    G=0                  case eDrawStyle.Red :                                            red = m_rgb.R;                                             //    Red is constant                      int start_b = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b)' Color.FromArgb(red' green' end_b)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                        }                        break;                      //          B=0'B=1'B=2'B=3.....B=100                      //    R=100                      //    R=99                      //    R=98        Drawstyle                      //    R=97          Green                      //    ...                      //    R=0                  case eDrawStyle.Green :                                            green = m_rgb.G;;                                           //    Green is constant                      int start_b2 = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' B                      int end_b2 = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                    //    For each horizontal line:                      {                          red = Round(255 - (255 * (double)i/(Height - 4)));      //    red WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(red' green' start_b2)' Color.FromArgb(red' green' end_b2)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;                      //          R=0'R=1'R=2'R=3.....R=100                      //    G=100                      //    G=99                      //    G=98        Drawstyle                      //    G=97           Blue                      //    ...                      //    G=0                  case eDrawStyle.Blue :                                            blue = m_rgb.B;;                                           //    Blue is constant                      int start_r = Round(255 * (double)start_x/(Width - 4));    //    Because we're drawing horizontal lines' R                      int end_r = Round(255 * (double)end_x/(Width - 4));        //    will not change from line to line                        for ( int i = start_y; i <= end_y; i++ )                   //    For each horizontal line:                      {                          green = Round(255 - (255 * (double)i/(Height - 4)));   //    green WILL change for each horizontal line drawn                            LinearGradientBrush br = new LinearGradientBrush(new Rectangle(start_x + 1'i + 2' end_x - start_x + 1' 1)' Color.FromArgb(start_r' green' blue)' Color.FromArgb(end_r' green' blue)' 0' false);                           g.FillRectangle(br'new Rectangle(start_x + 2'i + 2' end_x - start_x + 1 ' 1));                       }                        break;              }
Missing Default,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Redraw_Control,The following switch statement is missing a default case: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      Draw_Style_Hue();                      break;                  case eDrawStyle.Saturation :                      Draw_Style_Saturation();                      break;                  case eDrawStyle.Brightness :                      Draw_Style_Luminance();                      break;                  case eDrawStyle.Red :                      Draw_Style_Red();                      break;                  case eDrawStyle.Green :                      Draw_Style_Green();                      break;                  case eDrawStyle.Blue :                      Draw_Style_Blue();                      break;              }
Missing Default,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,Reset_Marker,The following switch statement is missing a default case: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_X = Round((Width - 4) * m_hsl.S);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Saturation :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.L));                      break;                  case eDrawStyle.Brightness :                      m_iMarker_X = Round((Width - 4) * m_hsl.H);                      m_iMarker_Y = Round((Height - 4) * (1.0 - m_hsl.S));                      break;                  case eDrawStyle.Red :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;                  case eDrawStyle.Green :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.B/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.R/255));                      break;                  case eDrawStyle.Blue :                      m_iMarker_X = Round((Width - 4) * (double)m_rgb.R/255);                      m_iMarker_Y = Round((Height - 4) * (1.0 - (double)m_rgb.G/255));                      break;              }
Missing Default,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,ResetHSLRGB,The following switch statement is missing a default case: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.S = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.L = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.H = (double)m_iMarker_X/(Width - 4);                      m_hsl.S = 1.0 - (double)m_iMarker_Y/(Height - 4);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' green' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      blue = Round(255 * (double)m_iMarker_X/(Width - 4));                      red = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' m_rgb.G' blue);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      red = Round(255 * (double)m_iMarker_X/(Width - 4));                      green = Round(255 * (1.0 - (double)m_iMarker_Y/(Height - 4)));                      m_rgb = Color.FromArgb(m_rgb.A' red' green' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Missing Default,Sce.Atf.Controls.ColorEditing,ColorBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\ColorBox.cs,GetColor,The following switch statement is missing a default case: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      _hsl.H = m_hsl.H;                      _hsl.S = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Saturation :                      _hsl.S = m_hsl.S;                      _hsl.H = (double)x/(Width - 4);                      _hsl.L = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Brightness :                      _hsl.L = m_hsl.L;                      _hsl.H = (double)x/(Width - 4);                      _hsl.S = 1.0 - (double)y/(Height - 4);                      break;                  case eDrawStyle.Red :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(m_rgb.R' Round(255 * (1.0 - (double)y/(Height - 4)))' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Green :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.G' Round(255 * (double)x/(Width - 4))));                      break;                  case eDrawStyle.Blue :                      _hsl = AdobeColors.RGB_to_HSL(Color.FromArgb(Round(255 * (double)x/(Width - 4))' Round(255 * (1.0 - (double)y/(Height - 4)))' m_rgb.B));                      break;              }
Missing Default,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,DrawContent,The following switch statement is missing a default case: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      Draw_Style_Hue();                      break;                  case eDrawStyle.Saturation :                      Draw_Style_Saturation();                      break;                  case eDrawStyle.Brightness :                      Draw_Style_Luminance();                      break;                  case eDrawStyle.Red :                      Draw_Style_Red();                      break;                  case eDrawStyle.Green :                      Draw_Style_Green();                      break;                  case eDrawStyle.Blue :                      Draw_Style_Blue();                      break;              }
Missing Default,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Redraw_Control,The following switch statement is missing a default case: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      Draw_Style_Hue();                      break;                  case eDrawStyle.Saturation :                      Draw_Style_Saturation();                      break;                  case eDrawStyle.Brightness :                      Draw_Style_Luminance();                      break;                  case eDrawStyle.Red :                      Draw_Style_Red();                      break;                  case eDrawStyle.Green :                      Draw_Style_Green();                      break;                  case eDrawStyle.Blue :                      Draw_Style_Blue();                      break;              }
Missing Default,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,Reset_Slider,The following switch statement is missing a default case: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.H );                      break;                  case eDrawStyle.Saturation :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.S );                      break;                  case eDrawStyle.Brightness :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * m_hsl.L );                      break;                  case eDrawStyle.Red :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.R/255 );                      break;                  case eDrawStyle.Green :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.G/255 );                      break;                  case eDrawStyle.Blue :                      m_iMarker_Start_Y = (Height - 8) - Round( (Height - 8) * (double)m_rgb.B/255 );                      break;              }
Missing Default,Sce.Atf.Controls.ColorEditing,VerticalColorSlider,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ColorPicker\VerticalColorSlider.cs,ResetHSLRGB,The following switch statement is missing a default case: switch (m_eDrawStyle)              {                  case eDrawStyle.Hue :                      m_hsl.H = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Saturation :                      m_hsl.S = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Brightness :                      m_hsl.L = 1.0 - (double)m_iMarker_Start_Y/(Height - 9);                      m_rgb = AdobeColors.HSL_to_RGB(m_hsl);                      break;                  case eDrawStyle.Red :                      m_rgb = Color.FromArgb(m_rgb.A' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.G' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Green :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) )' m_rgb.B);                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;                  case eDrawStyle.Blue :                      m_rgb = Color.FromArgb(m_rgb.A' m_rgb.R' m_rgb.G' 255 - Round( 255 * (double)m_iMarker_Start_Y/(Height - 9) ));                      m_hsl = AdobeColors.RGB_to_HSL(m_rgb);                      break;              }
Missing Default,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,OnKeyPress,The following switch statement is missing a default case: switch (e.KeyChar)              {                  case (char)Keys.Back:                      e.Handled = true;                        if (SelectionLength > 0)                          RemoveSelection();                      else                          PrevChar(RemoveTextBeforeCaret);                      break;                    case (char)Keys.Return:                      e.Handled = true;                        string command = GetTextAtPrompt();                      AppendText(Environment.NewLine);                      SubmitCommand(command);                      break;              }
Missing Default,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,ProcessCmdKey,The following switch statement is missing a default case: switch (keyData)                  {                      case Keys.Control | Keys.Back:                      {                          m_suggestionListBox.Hide();                            PrevWord(RemoveTextBeforeCaret);                          return true;                      }                        case Keys.Delete:                      {                          m_suggestionListBox.Hide();                            if (SelectionLength > 0)                              RemoveSelection();                          else                              NextChar(RemoveTextAfterCaret);                          return true;                      }                        case Keys.Control | Keys.Delete:                      {                          m_suggestionListBox.Hide();                            NextWord(RemoveTextAfterCaret);                          return true;                      }                        case Keys.Control | Keys.End:                      case Keys.Control | Keys.Shift | Keys.End:                      {                          m_suggestionListBox.Hide();                            MoveRight(TextLength - CaretIndex);                          return true;                      }                        case Keys.Control | Keys.Enter:                      {                          m_suggestionListBox.Hide();                            string lastLine = GetCurrentLine();                            // Split line                          InsertTextAtCaret(Environment.NewLine);                          Indent(lastLine);                          break;                      }                        case Keys.Control | Keys.Home:                      case Keys.Control | Keys.Shift | Keys.Home:                      {                          m_suggestionListBox.Hide();                            MoveLeft(CaretOffsetFromPrompt);                          return true;                      }                        case Keys.Control | Keys.Left:                      case Keys.Control | Keys.Shift | Keys.Left:                      {                          m_suggestionListBox.Hide();                            PrevWord(MoveLeft);                          return true;                      }                        case Keys.Control | Keys.Right:                      case Keys.Control | Keys.Shift | Keys.Right:                      {                          m_suggestionListBox.Hide();                            NextWord(MoveRight);                          return true;                      }                        case Keys.Control | Keys.Space:                      {                          Suggest();                          return true;                      }                  }
Missing Default,Sce.Atf.Controls.ConsoleBox,ConsoleTextBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,WndProc,The following switch statement is missing a default case: switch (m.Msg)              {                  case User32.WM_CUT:                      Cut();                      return;                    case User32.WM_COPY:                      Copy();                      return;                    case User32.WM_PASTE:                      string text = Clipboard.GetText();                      InsertTextAtCaret(text);                      return;                    case User32.WM_SETTEXT:                      if (!IsCaretAtWritablePosition)                          MoveCaretToEnd();                      break;                    case User32.WM_CLEAR:                      return;              }
Missing Default,Sce.Atf.Controls.ConsoleBox,SuggestionListBox,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\ConsoleBox\ConsoleTextBox.cs,OnKeyDown,The following switch statement is missing a default case: switch (e.KeyData)                  {                      case Keys.Back:                          RemoveText(1);                          Suggest(); // TODO: Hide if there was nothing to remove                          break;                        case Keys.Down:                          // Wrap selection around to first                          if (SelectedIndex == Items.Count - 1)                          {                              SelectedIndex = 0;                              e.Handled = true;                          }                          break;                        case Keys.Up:                          // Wrap selection around to last                          if (SelectedIndex == 0)                          {                              SelectedIndex = Items.Count - 1;                              e.Handled = true;                          }                          break;                        case Keys.Enter:                      case Keys.Tab:                          Complete();                          break;                        case Keys.Escape:                      case Keys.Left:                      case Keys.Right:                          Hide();                          break;                  }
Missing Default,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,Frame,The following switch statement is missing a default case: switch(m_lockorg)              {                  case OriginLockMode.Free:                      {                          Zoom = new Vec2F(w / rect.Width' h / rect.Height);                          Vec2F center = new Vec2F(rect.X + rect.Width / 2' rect.Y + rect.Height / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          break;                      }                  case OriginLockMode.Center:                      {                          float absleft = Math.Abs(rect.Left);                          float absright = Math.Abs(rect.Right);                          float fx = Math.Max(absleft' absright);                          float abstop = Math.Abs(rect.Top);                          float absbottom = Math.Abs(rect.Bottom);                          float fy = Math.Max(abstop' absbottom);                          Zoom = new Vec2F(hw / fx' hh / fy);                          break;                      }                  case OriginLockMode.Left:                      {                                                  if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              Zoom = new Vec2F(w / fx' h / rect.Height);                              Vec2F center = new Vec2F(left + fx / 2' rect.Y + rect.Height / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftTop:                        if (rect.Right > 0 && rect.Bottom > 0)                      {                          float left = Math.Max(0' rect.Left);                          float fx = (left > 0) ? rect.Width : rect.Right;                            float top = Math.Max(0' rect.Top);                          float fy = (top > 0) ? rect.Height : rect.Bottom;                          Zoom = new Vec2F(w / fx' h / fy);                          Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                          Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                      }                                   break;                  case OriginLockMode.LeftBottom:                      {                          if (rect.Right > 0 && rect.Bottom > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                                float top = Math.Max(0' rect.Top);                              float fy = (top > 0) ? rect.Height : rect.Bottom;                              Zoom = new Vec2F(w / fx' h / fy);                              Vec2F center = new Vec2F(left + fx / 2' top + fy / 2);                              Pan = new Vec2F(hw - center.X * Zoom.X' hh + center.Y * Zoom.Y);                          }                                                  break;                      }                  case OriginLockMode.LeftMiddle:                      {                          if (rect.Right > 0)                          {                              float left = Math.Max(0' rect.Left);                              float fx = (left > 0) ? rect.Width : rect.Right;                              float abstop = Math.Abs(rect.Top);                              float absbottom = Math.Abs(rect.Bottom);                              float fy = Math.Max(abstop' absbottom);                              Zoom = new Vec2F(w / fx' hh / fy);                              Vec2F center = new Vec2F(left + fx / 2' 0);                              Pan = new Vec2F(hw - center.X * Zoom.X' Pan.Y);                          }                          break;                      }              }
Missing Default,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,PanToOrigin,The following switch statement is missing a default case: switch(m_lockorg)              {                  case OriginLockMode.Free:                      Pan_d = new PointD(ClientSize.Width / 2' ClientSize.Height / 2);                      break;                  case OriginLockMode.LeftTop:                      Pan_d = new PointD(1' 1);                      break;                  case OriginLockMode.Left:                                      case OriginLockMode.LeftMiddle:                      Pan_d = new PointD(1' ClientSize.Height / 2);                      break;                  case OriginLockMode.LeftBottom:                      Pan_d = new PointD(1' ClientSize.Height);                      break;                                  }
Missing Default,Sce.Atf.Controls.CurveEditing,Cartesian2dCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\Cartesian2dCanvas.cs,UpdatePan,The following switch statement is missing a default case: switch (m_lockorg)              {                  case OriginLockMode.Free:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = float.MaxValue;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.Center:                      m_minOffsetX = w / 2;                                          m_maxOffsetX = w / 2;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.Left:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = float.MinValue;                                          m_maxOffsetY = float.MaxValue;                      break;                  case OriginLockMode.LeftTop:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = -float.MaxValue;                      m_maxOffsetY = 1;                      break;                  case OriginLockMode.LeftMiddle:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h / 2;                      m_maxOffsetY = h / 2;                      break;                  case OriginLockMode.LeftBottom:                      m_minOffsetX = float.MinValue;                      m_maxOffsetX = 1;                      m_minOffsetY = h - 1;                      m_maxOffsetY = float.MaxValue;                      break;              }
Missing Default,Sce.Atf.Controls.CurveEditing,CurveCanvas,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveCanvas.cs,ValidateCurveLimits,The following switch statement is missing a default case: switch (side)              {                  case CurveLimitSides.Left:                      {                          IControlPoint firstPt = curve.ControlPoints.Count > 0 ? curve.ControlPoints[0] : null;                          float left = firstPt != null ? firstPt.X : curve.MaxX - CurveUtils.Epsilone;                          if (curve.MinX > left)                              curve.MinX = left;                      }                      break;                  case CurveLimitSides.Right:                      {                          IControlPoint lastPt = curve.ControlPoints.Count > 0 ? curve.ControlPoints[curve.ControlPoints.Count-1] : null;                          float right = lastPt != null ? lastPt.X : curve.MinX + CurveUtils.Epsilone;                          if (curve.MaxX < right)                              curve.MaxX = right;                      }                      break;                  case CurveLimitSides.Top:                      {                          float top = curve.MinY + CurveUtils.Epsilone;                          foreach (var cpt in curve.ControlPoints)                              if (cpt.Y > top) top = cpt.Y;                            if (curve.MaxY < top)                              curve.MaxY = top;                      }                      break;                  case CurveLimitSides.Bottom:                      {                          float bottom = curve.MaxY - CurveUtils.Epsilone;                          foreach (var cpt in curve.ControlPoints)                              if (cpt.Y < bottom) bottom = cpt.Y;                          if (curve.MinY > bottom)                              curve.MinY = bottom;                      }                      break;              }
Missing Default,Sce.Atf.Controls.CurveEditing,CurveEditingControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\CurveEditing\CurveEditingControl.cs,IsImplemented,The following switch statement is missing a default case: switch (tanType)              {                  case CurveTangentTypes.Linear:                  case CurveTangentTypes.Spline:                  case CurveTangentTypes.Flat:                  case CurveTangentTypes.Clamped:                  case CurveTangentTypes.Stepped:                      result = true;                      break;              }
Missing Default,Sce.Atf.Controls.PropertyEditing,ColumnHeaders,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\PropertyEditing\GridView.cs,OnMouseDown,The following switch statement is missing a default case: switch (hit.Type)                  {                      case HitType.ColumnHeader:                            // TODO: Why does hitting the column header select a property?                          m_gridView.SelectedProperty = hit.Property;                            s_columnHeaderMouseDown = true;                          s_columnHeaderMouseDownProperty = hit.Property;                          break;                        case HitType.ColumnHeaderRightEdge:                          m_gridView.SelectedProperty = hit.Property;                            m_gridView.Select();                            if (!hit.Property.DisableResize)                          {                              s_sizing = true;                              s_sizingProperty = hit.Property;                              s_sizingOriginalWidth = m_gridView.GetColumnInfo(s_sizingProperty).Width;                              Cursor = Cursors.VSplit;                          }                          break;                        case HitType.CategoryExpander:                          hit.Category.Expanded = !hit.Category.Expanded;                          m_gridView.Invalidate();                           break;                  }
Missing Default,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following switch statement is missing a default case: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                  case DrawMode.Collapsed:                      GroupBrush.StartPoint = new PointF(0' bounds.Top);                      GroupBrush.EndPoint = new PointF(0' bounds.Bottom);                      c.Graphics.FillRectangle(bounds' GroupBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.FillRectangle(bounds' GhostGroupBrush);                      break;              }
Missing Default,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following switch statement is missing a default case: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      c.Graphics.DrawRectangle(bounds' TrackBrush);                      break;                  case DrawMode.Collapsed:                      break;                  case DrawMode.Ghost:                      c.Graphics.FillRectangle(bounds' GhostTrackBrush);                      break;              }
Missing Default,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following switch statement is missing a default case: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                        float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                      c.Graphics.FillRectangle(                          realPart'                          new PointF(0' realPart.Top)'new PointF(0' realPart.Bottom)'                          color' endColor);                        if (hasTail)                      {                          endColor = ColorUtil.FromAhsb(64' h' s * 0.3f' b);                          RectangleF tailPart = new RectangleF(                              realPart.Right'                              bounds.Y'                              bounds.Width - realPart.Width'                              bounds.Height);                          c.Graphics.FillRectangle(tailPart' endColor);                      }                        if (color.R + color.G + color.B < 3 * 160)                          TextBrush.Color = SystemColors.HighlightText;                      else                          TextBrush.Color = SystemColors.WindowText;                        c.Graphics.DrawText(interval.Name' c.TextFormat' bounds.Location' TextBrush);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(                              new RectangleF(bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2)'                              SelectedBrush' 3.0f);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(bounds' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.FillRectangle(bounds' Color.FromArgb(128' color));                      bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                      float x = showRight ? bounds.Right : bounds.Left;                      c.Graphics.DrawText(                          GetXPositionString(x' c)'                          c.TextFormat'                          new PointF(x' bounds.Bottom - c.FontHeight)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(bounds' InvalidBrush);                      break;              }
Missing Default,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following switch statement is missing a default case: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      c.Graphics.FillEllipse(bounds' color);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          D2dAntialiasMode originalAntiAliasMode = c.Graphics.AntialiasMode;                          c.Graphics.AntialiasMode = D2dAntialiasMode.PerPrimitive;                          c.Graphics.DrawEllipse(                              new D2dEllipse(                                  new PointF(bounds.X + bounds.Width * 0.5f' bounds.Y + bounds.Height * 0.5f)'                                  bounds.Width * 0.5f' bounds.Height * 0.5f)'                              SelectedBrush' 3.0f);                          c.Graphics.AntialiasMode = originalAntiAliasMode;                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillEllipse(bounds' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.FillEllipse(bounds' Color.FromArgb(128' color));                      c.Graphics.DrawText(                          GetXPositionString(bounds.Left + KeySize * 0.5f' c)'                          c.TextFormat'                          new PointF(bounds.Right + 16' bounds.Y)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.FillEllipse(bounds' InvalidBrush);                      break;              }
Missing Default,Sce.Atf.Controls.Timelines.Direct2D,D2dDefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dDefaultTimelineRenderer.cs,Draw,The following switch statement is missing a default case: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      c.Graphics.DrawLine(middle' bounds.Top' middle' bounds.Bottom' color' 1.0f' null);                        bool selected = (drawMode & DrawMode.Selected) != 0;                      Color handleColor = selected ? Color.Tomato : color;                      RectangleF handleRect =                          new RectangleF(bounds.X' bounds.Y' bounds.Width' bounds.Width);                      c.Graphics.FillRectangle(handleRect' handleColor);                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(                          new RectangleF(middle' bounds.Y' 1' bounds.Height)' CollapsedBrush);                      break;                  case DrawMode.Ghost:                      c.Graphics.DrawLine(middle' bounds.Top' middle' bounds.Bottom' Color.FromArgb(128' color)' 1.0f' null);                      c.Graphics.DrawText(                          GetXPositionString(middle' c)'                          c.TextFormat'                          new PointF(bounds.Right + 16' bounds.Y)'                          TextBrush);                      break;                  case DrawMode.Invalid:                      c.Graphics.DrawRectangle(bounds' Color.DimGray' 1.0f' null);                      break;              }
Missing Default,Sce.Atf.Controls.Timelines.Direct2D,D2dMoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Direct2D\D2dMoveManipulator.cs,owner_MouseDownPicked,The following switch statement is missing a default case: switch (e.HitRecord.Type)                      {                          case HitType.GroupMove:                          case HitType.TrackMove:                          case HitType.Interval:                          case HitType.Key:                          case HitType.Marker:                              m_mouseMoveHitRecord = hitRecord;                              break;                      }
Missing Default,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following switch statement is missing a default case: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                  case DrawMode.Collapsed:                      using (Brush brush = new LinearGradientBrush(                          bounds' Color.LightGoldenrodYellow' Color.Khaki' LinearGradientMode.Vertical))                      {                          c.Graphics.FillRectangle(brush' bounds);                      }                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' Color.Gray)))                      {                          c.Graphics.FillRectangle(brush' bounds);                      }                      break;              }
Missing Default,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following switch statement is missing a default case: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      c.Graphics.DrawRectangle(Pens.LightGray' bounds.X' bounds.Y' bounds.Width' bounds.Height);                      break;                  case DrawMode.Collapsed:                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' Color.Gray)))                      {                          c.Graphics.FillRectangle(brush' bounds);                      }                      break;              }
Missing Default,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following switch statement is missing a default case: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      RectangleF realPart = new RectangleF(                          bounds.X'                          bounds.Y'                          GdiUtil.TransformVector(c.Transform' interval.Length)'                          bounds.Height);                      bool hasTail = realPart.Width < MinimumDrawnIntervalLength;                                            float h = color.GetHue();                      float s = color.GetSaturation();                      float b = color.GetBrightness();                      Color endColor = ColorUtil.FromAhsb(color.A' h' s * 0.3f' b);                        using (LinearGradientBrush intervalBrush =                          new LinearGradientBrush(realPart' color' endColor' LinearGradientMode.Vertical))                      {                          c.Graphics.FillRectangle(intervalBrush' realPart);                          if (hasTail)                          {                              Color[] colors = intervalBrush.LinearColors;                              colors[0] = Color.FromArgb(64' colors[0]);                              colors[1] = Color.FromArgb(64' colors[1]);                              intervalBrush.LinearColors = colors;                              RectangleF tailPart = new RectangleF(                                  realPart.Right'                                  bounds.Y'                                  bounds.Width - realPart.Width'                                  bounds.Height);                              c.Graphics.FillRectangle(intervalBrush' tailPart);                          }                      }                        Brush textBrush = SystemBrushes.WindowText;                      if ((int)color.R + (int)color.G + (int)color.B < 3 * 160)                          textBrush = SystemBrushes.HighlightText;                      c.Graphics.DrawString(interval.Name' c.Font' textBrush' bounds.Location);                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawRectangle(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillRectangle(brush' bounds);                          bool showRight = (drawMode & DrawMode.ResizeRight) != 0;                          float x = showRight ? bounds.Right : bounds.Left;                          c.Graphics.DrawString(GetXPositionString(x' c)' c.Font' SystemBrushes.WindowText' x' bounds.Bottom - c.FontHeight);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillRectangle(m_invalidBrush' bounds);                      break;              }
Missing Default,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following switch statement is missing a default case: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      using (SolidBrush brush = new SolidBrush(color))                      {                          c.Graphics.FillEllipse(brush' bounds);                      }                        if ((drawMode & DrawMode.Selected) != 0)                      {                          c.Graphics.DrawEllipse(m_selectedPen' bounds.X + 1' bounds.Y + 1' bounds.Width - 2' bounds.Height - 2);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillEllipse(m_collapsedBrush' bounds);                      break;                  case DrawMode.Ghost:                      using (Brush brush = new SolidBrush(Color.FromArgb(128' color)))                      {                          c.Graphics.FillEllipse(brush' bounds);                          c.Graphics.DrawString(GetXPositionString(bounds.Left + m_keySize / 2' c)' c.Font' SystemBrushes.WindowText' bounds.Right + 16' bounds.Y);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.FillEllipse(m_invalidBrush' bounds);                      break;              }
Missing Default,Sce.Atf.Controls.Timelines,DefaultTimelineRenderer,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\DefaultTimelineRenderer.cs,Draw,The following switch statement is missing a default case: switch (drawMode & DrawMode.States)              {                  case DrawMode.Normal:                      using (Pen pen = new Pen(color))                      {                          c.Graphics.DrawLine(pen' middle' bounds.Top' middle' bounds.Bottom);                      }                        bool selected = (drawMode & DrawMode.Selected) != 0;                      Color handleColor = selected ? Color.Tomato : color;                      using (Brush brush = new SolidBrush(handleColor))                      {                          RectangleF handleRect =                              new RectangleF(bounds.X' bounds.Y' bounds.Width' bounds.Width);                          c.Graphics.FillRectangle(brush' handleRect);                      }                      break;                  case DrawMode.Collapsed:                      c.Graphics.FillRectangle(m_collapsedBrush' middle' bounds.Y' 1' bounds.Height);                      break;                  case DrawMode.Ghost:                      using (Pen pen = new Pen(Color.FromArgb(128' color)))                      {                          c.Graphics.DrawLine(pen' middle' bounds.Top' middle' bounds.Bottom);                          c.Graphics.DrawString(GetXPositionString(middle' c)' c.Font' SystemBrushes.WindowText' bounds.Right + 16' bounds.Y);                      }                      break;                  case DrawMode.Invalid:                      c.Graphics.DrawRectangle(Pens.DimGray' bounds.X' bounds.Y' bounds.Width' bounds.Height);                      break;              }
Missing Default,Sce.Atf.Controls.Timelines,MoveManipulator,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.WinForms\Controls\Timelines\Gdi\MoveManipulator.cs,owner_MouseDownPicked,The following switch statement is missing a default case: switch (e.HitRecord.Type)                      {                          case HitType.GroupMove:                          case HitType.TrackMove:                          case HitType.Interval:                          case HitType.Key:                          case HitType.Marker:                              m_mouseMoveHitRecord = hitRecord;                              break;                      }
