Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,DispatchTraverseList,The method has 109 lines of code.
Complex Method,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,Init,Cyclomatic complexity of the method is 10
Complex Method,Sce.Atf.Rendering.OpenGL,OpenGlCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\OpenGlCore.cs,InitOpenGl,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,TryCreateOpenGlTextureFromImage,Cyclomatic complexity of the method is 9
Complex Method,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelDataCUBEMAP,Cyclomatic complexity of the method is 8
Complex Method,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,_BuildTraverseList,Cyclomatic complexity of the method is 9
Long Parameter List,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The method has 5 parameters. Parameters: ddsd' compressionFactor' glPixelFormat' elementsPerPixel' converter
Long Parameter List,Sce.Atf.Rendering,Image,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Image.cs,Image,The method has 6 parameters. Parameters: width' height' pixels' levels' pixelFormat' elementsPerPixel
Long Parameter List,Sce.Atf.Rendering,Image,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Image.cs,Image,The method has 6 parameters. Parameters: width' height' pixels' levels' pixelFormat' elementsPerPixel
Long Parameter List,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,CreateProgram,The method has 6 parameters. Parameters: id' type' file' profile' entry' fromfile
Long Parameter List,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCone,The method has 5 parameters. Parameters: baseRadius' height' slices' stacks' renderStyle
Long Parameter List,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCylinder,The method has 5 parameters. Parameters: radius' height' slices' stacks' renderStyle
Long Parameter List,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,Init,The method has 7 parameters. Parameters: camera' x1' y1' x2' y2' multiPick' usePickingFrustum
Long Parameter List,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,Intersect,The method has 5 parameters. Parameters: camera' x' y' scene' point
Long Parameter List,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,Intersect,The method has 6 parameters. Parameters: camera' x' y' scene' point' surfaceNormal
Long Parameter List,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,Intersect,The method has 6 parameters. Parameters: camera' x' y' scene' traverseList' point
Long Parameter List,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,Intersect,The method has 6 parameters. Parameters: camera' x' y' scene' point' firstHit
Long Parameter List,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,Intersect,The method has 5 parameters. Parameters: x' y' hits' pt' surfaceNormal
Long Parameter List,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,GetWorldIntersectionFromScreen,The method has 6 parameters. Parameters: screenX' screenY' screenZ' viewMat' projectionMat' viewport
Long Parameter List,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,OnHit,The method has 6 parameters. Parameters: hit' x' y' action' camera' transform
Long Parameter List,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,OnDrag,The method has 6 parameters. Parameters: hit' x' y' action' camera' transform
Long Parameter List,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,CalcAxisLengths,The method has 5 parameters. Parameters: camera' globalTransform' s1' s2' s3
Long Parameter List,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,DecideArrowDrawing,The method has 5 parameters. Parameters: localToWorld' camera' drawX' drawY' drawZ
Long Identifier,Sce.Atf.Rendering.OpenGL,RenderStateGuardianUtils,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderStateGuardianUtils.cs,CommitWire,The length of the parameter previousRsHadDifferentThickness is 31.
Long Statement,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,ReadPixels,The length of the statement  "                        throw new NotSupportedException("please request support for DDS textures with pitch specified and more than one mipmap"); " is 121.
Long Statement,Sce.Atf.Rendering,MsBitmapImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\MsBitmapImageLoader.cs,LoadImage,The length of the statement  "            if (bitmap.PixelFormat != System.Drawing.Imaging.PixelFormat.Format32bppArgb && bitmap.PixelFormat != System.Drawing.Imaging.PixelFormat.Format24bppRgb) " is 152.
Long Statement,Sce.Atf.Rendering.OpenGL,BitmapContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\BitmapContext.cs,CreateBitmap,The length of the statement  "                Gl.glFramebufferRenderbufferEXT(Gl.GL_FRAMEBUFFER_EXT' Gl.GL_COLOR_ATTACHMENT0_EXT' Gl.GL_RENDERBUFFER_EXT' m_renderbuffer); " is 124.
Long Statement,Sce.Atf.Rendering.OpenGL,BitmapContext,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\BitmapContext.cs,CreateBitmap,The length of the statement  "                Gl.glFramebufferRenderbufferEXT(Gl.GL_FRAMEBUFFER_EXT' Gl.GL_DEPTH_ATTACHMENT_EXT' Gl.GL_RENDERBUFFER_EXT' m_depthBuffer); " is 122.
Long Statement,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,CreateProgram,The length of the statement  "//                System.Console.WriteLine("  Cg CreateProgram Counter  '" + m_cg_context + "'" + m_cg_program_counter + " id=" + id); " is 134.
Long Statement,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,BindProgram,The length of the statement  "//            System.Console.WriteLine("  Cg BindProgram  '" + m_cg_context + "'" + m_cg_program_counter + " id=" + id); " is 120.
Long Statement,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,UnBindProgram,The length of the statement  "//            System.Console.WriteLine("  Cg UnBindProgram  '" + m_cg_context + "'" + m_cg_program_counter + " profile=" + profile); " is 132.
Long Statement,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,GetParameter,The length of the statement  "//            System.Console.WriteLine("Cg GetParameter " + gl_context + "'" + m_cg_context + "'" + m_cg_program_counter); " is 122.
Complex Conditional,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,ReadPixels,The conditional expression  "ddsd.HasLinearSize && ddsd.dwLinearSize > 0 && (mipMapCount == 1 || compressionFactor > 0)"  is complex.
Complex Conditional,Sce.Atf.Rendering,DDSURFACEDESC2,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Load,The conditional expression  "header[0] != 'D' || header[1] != 'D' || header[2] != 'S' || header[3] != ' '"  is complex.
Complex Conditional,Sce.Atf.Rendering.OpenGL,CanvasControl3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CanvasControl3D.cs,IsInputKey,The conditional expression  "keyData == KeysInterop.ToWf(s_controlScheme.Left1) ||                  keyData == KeysInterop.ToWf(s_controlScheme.Left2) ||                  keyData == KeysInterop.ToWf(s_controlScheme.Right1) ||                  keyData == KeysInterop.ToWf(s_controlScheme.Right2) ||                  keyData == KeysInterop.ToWf(s_controlScheme.Forward1) ||                  keyData == KeysInterop.ToWf(s_controlScheme.Forward2) ||                  keyData == KeysInterop.ToWf(s_controlScheme.Back1) ||                  keyData == KeysInterop.ToWf(s_controlScheme.Back2)"  is complex.
Complex Conditional,Sce.Atf.Rendering.OpenGL,CanvasControl3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CanvasControl3D.cs,ProcessCmdKey,The conditional expression  "m_cameraController.HandlesWASD && (keyData == s_controlScheme.Left1 ||                  keyData == s_controlScheme.Left2 ||                  keyData == s_controlScheme.Right1 ||                  keyData == s_controlScheme.Right2 ||                  keyData == s_controlScheme.Forward1 ||                  keyData == s_controlScheme.Forward2 ||                  keyData == s_controlScheme.Back1 ||                  keyData == s_controlScheme.Back2)"  is complex.
Virtual Method Call from Constructor,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,RenderAction,The constructor "RenderAction" calls a virtual method "Clear".
Empty Catch Block,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,CreateProgram,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,EnableTexture,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,DisableTexture,The method has an empty catch block.
Empty Catch Block,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,SetMatrixParameter,The method has an empty catch block.
Magic Number,Sce.Atf.Rendering,ArcBallCameraController,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\ArcBallCameraController.cs,ProjectToArcball,The following statement contains a magic number: float x = (float)point.X / (m_width / 2);
Magic Number,Sce.Atf.Rendering,ArcBallCameraController,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\ArcBallCameraController.cs,ProjectToArcball,The following statement contains a magic number: float y = (float)point.Y / (m_height / 2);
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,ReadPixels,The following statement contains a magic number: if (isCubeMap)              {   // image is a cubemap                  bufferSize = 0;                  for (int face = 0; face < 6; face++)                  {                      int width = ddsd.dwWidth;                      int height = ddsd.dwHeight;                        for (int level = 0; level < mipMapCount; level++)                      {                          //calculate the bufferSize we are going to read                          bufferSize += ((width + 3) >> 2) * ((height + 3) >> 2) * 8;                          width = width >> 1;                          if (width < 1)                              width = 1;                          height = height >> 1;                          if (height < 1)                              height = 1;                      }                  }                  //read the data into pixels: note that all faces and mipmaps are being read                  pixels = reader.ReadBytes(bufferSize);              }              else              {   // image is not a cubemap                  if (ddsd.HasPitch)                  {                      if (mipMapCount > 1)                          throw new NotSupportedException("please request support for DDS textures with pitch specified and more than one mipmap");                      bufferSize = ddsd.lPitch * ddsd.dwHeight;                  }                  else if (ddsd.HasLinearSize && ddsd.dwLinearSize > 0 && (mipMapCount == 1 || compressionFactor > 0))                  {                      if (mipMapCount > 1)                          bufferSize = ddsd.dwLinearSize * compressionFactor;                      else                          bufferSize = ddsd.dwLinearSize;                  }                  else                  {                      // Read until end of file. DDS files with multiple mipmaps come through here.                      long cur = reader.BaseStream.Position;                      long eof = reader.BaseStream.Length;                      bufferSize = (int)(eof - cur);                  }                  pixels = reader.ReadBytes(bufferSize);              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,ReadPixels,The following statement contains a magic number: if (isCubeMap)              {   // image is a cubemap                  bufferSize = 0;                  for (int face = 0; face < 6; face++)                  {                      int width = ddsd.dwWidth;                      int height = ddsd.dwHeight;                        for (int level = 0; level < mipMapCount; level++)                      {                          //calculate the bufferSize we are going to read                          bufferSize += ((width + 3) >> 2) * ((height + 3) >> 2) * 8;                          width = width >> 1;                          if (width < 1)                              width = 1;                          height = height >> 1;                          if (height < 1)                              height = 1;                      }                  }                  //read the data into pixels: note that all faces and mipmaps are being read                  pixels = reader.ReadBytes(bufferSize);              }              else              {   // image is not a cubemap                  if (ddsd.HasPitch)                  {                      if (mipMapCount > 1)                          throw new NotSupportedException("please request support for DDS textures with pitch specified and more than one mipmap");                      bufferSize = ddsd.lPitch * ddsd.dwHeight;                  }                  else if (ddsd.HasLinearSize && ddsd.dwLinearSize > 0 && (mipMapCount == 1 || compressionFactor > 0))                  {                      if (mipMapCount > 1)                          bufferSize = ddsd.dwLinearSize * compressionFactor;                      else                          bufferSize = ddsd.dwLinearSize;                  }                  else                  {                      // Read until end of file. DDS files with multiple mipmaps come through here.                      long cur = reader.BaseStream.Position;                      long eof = reader.BaseStream.Length;                      bufferSize = (int)(eof - cur);                  }                  pixels = reader.ReadBytes(bufferSize);              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,ReadPixels,The following statement contains a magic number: if (isCubeMap)              {   // image is a cubemap                  bufferSize = 0;                  for (int face = 0; face < 6; face++)                  {                      int width = ddsd.dwWidth;                      int height = ddsd.dwHeight;                        for (int level = 0; level < mipMapCount; level++)                      {                          //calculate the bufferSize we are going to read                          bufferSize += ((width + 3) >> 2) * ((height + 3) >> 2) * 8;                          width = width >> 1;                          if (width < 1)                              width = 1;                          height = height >> 1;                          if (height < 1)                              height = 1;                      }                  }                  //read the data into pixels: note that all faces and mipmaps are being read                  pixels = reader.ReadBytes(bufferSize);              }              else              {   // image is not a cubemap                  if (ddsd.HasPitch)                  {                      if (mipMapCount > 1)                          throw new NotSupportedException("please request support for DDS textures with pitch specified and more than one mipmap");                      bufferSize = ddsd.lPitch * ddsd.dwHeight;                  }                  else if (ddsd.HasLinearSize && ddsd.dwLinearSize > 0 && (mipMapCount == 1 || compressionFactor > 0))                  {                      if (mipMapCount > 1)                          bufferSize = ddsd.dwLinearSize * compressionFactor;                      else                          bufferSize = ddsd.dwLinearSize;                  }                  else                  {                      // Read until end of file. DDS files with multiple mipmaps come through here.                      long cur = reader.BaseStream.Position;                      long eof = reader.BaseStream.Length;                      bufferSize = (int)(eof - cur);                  }                  pixels = reader.ReadBytes(bufferSize);              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,ReadPixels,The following statement contains a magic number: if (isCubeMap)              {   // image is a cubemap                  bufferSize = 0;                  for (int face = 0; face < 6; face++)                  {                      int width = ddsd.dwWidth;                      int height = ddsd.dwHeight;                        for (int level = 0; level < mipMapCount; level++)                      {                          //calculate the bufferSize we are going to read                          bufferSize += ((width + 3) >> 2) * ((height + 3) >> 2) * 8;                          width = width >> 1;                          if (width < 1)                              width = 1;                          height = height >> 1;                          if (height < 1)                              height = 1;                      }                  }                  //read the data into pixels: note that all faces and mipmaps are being read                  pixels = reader.ReadBytes(bufferSize);              }              else              {   // image is not a cubemap                  if (ddsd.HasPitch)                  {                      if (mipMapCount > 1)                          throw new NotSupportedException("please request support for DDS textures with pitch specified and more than one mipmap");                      bufferSize = ddsd.lPitch * ddsd.dwHeight;                  }                  else if (ddsd.HasLinearSize && ddsd.dwLinearSize > 0 && (mipMapCount == 1 || compressionFactor > 0))                  {                      if (mipMapCount > 1)                          bufferSize = ddsd.dwLinearSize * compressionFactor;                      else                          bufferSize = ddsd.dwLinearSize;                  }                  else                  {                      // Read until end of file. DDS files with multiple mipmaps come through here.                      long cur = reader.BaseStream.Position;                      long eof = reader.BaseStream.Length;                      bufferSize = (int)(eof - cur);                  }                  pixels = reader.ReadBytes(bufferSize);              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,ReadPixels,The following statement contains a magic number: if (isCubeMap)              {   // image is a cubemap                  bufferSize = 0;                  for (int face = 0; face < 6; face++)                  {                      int width = ddsd.dwWidth;                      int height = ddsd.dwHeight;                        for (int level = 0; level < mipMapCount; level++)                      {                          //calculate the bufferSize we are going to read                          bufferSize += ((width + 3) >> 2) * ((height + 3) >> 2) * 8;                          width = width >> 1;                          if (width < 1)                              width = 1;                          height = height >> 1;                          if (height < 1)                              height = 1;                      }                  }                  //read the data into pixels: note that all faces and mipmaps are being read                  pixels = reader.ReadBytes(bufferSize);              }              else              {   // image is not a cubemap                  if (ddsd.HasPitch)                  {                      if (mipMapCount > 1)                          throw new NotSupportedException("please request support for DDS textures with pitch specified and more than one mipmap");                      bufferSize = ddsd.lPitch * ddsd.dwHeight;                  }                  else if (ddsd.HasLinearSize && ddsd.dwLinearSize > 0 && (mipMapCount == 1 || compressionFactor > 0))                  {                      if (mipMapCount > 1)                          bufferSize = ddsd.dwLinearSize * compressionFactor;                      else                          bufferSize = ddsd.dwLinearSize;                  }                  else                  {                      // Read until end of file. DDS files with multiple mipmaps come through here.                      long cur = reader.BaseStream.Position;                      long eof = reader.BaseStream.Length;                      bufferSize = (int)(eof - cur);                  }                  pixels = reader.ReadBytes(bufferSize);              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,ReadPixels,The following statement contains a magic number: if (isCubeMap)              {   // image is a cubemap                  bufferSize = 0;                  for (int face = 0; face < 6; face++)                  {                      int width = ddsd.dwWidth;                      int height = ddsd.dwHeight;                        for (int level = 0; level < mipMapCount; level++)                      {                          //calculate the bufferSize we are going to read                          bufferSize += ((width + 3) >> 2) * ((height + 3) >> 2) * 8;                          width = width >> 1;                          if (width < 1)                              width = 1;                          height = height >> 1;                          if (height < 1)                              height = 1;                      }                  }                  //read the data into pixels: note that all faces and mipmaps are being read                  pixels = reader.ReadBytes(bufferSize);              }              else              {   // image is not a cubemap                  if (ddsd.HasPitch)                  {                      if (mipMapCount > 1)                          throw new NotSupportedException("please request support for DDS textures with pitch specified and more than one mipmap");                      bufferSize = ddsd.lPitch * ddsd.dwHeight;                  }                  else if (ddsd.HasLinearSize && ddsd.dwLinearSize > 0 && (mipMapCount == 1 || compressionFactor > 0))                  {                      if (mipMapCount > 1)                          bufferSize = ddsd.dwLinearSize * compressionFactor;                      else                          bufferSize = ddsd.dwLinearSize;                  }                  else                  {                      // Read until end of file. DDS files with multiple mipmaps come through here.                      long cur = reader.BaseStream.Position;                      long eof = reader.BaseStream.Length;                      bufferSize = (int)(eof - cur);                  }                  pixels = reader.ReadBytes(bufferSize);              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: if ((pixelFormat.dwFlags & DDPIXELFORMAT.DDPF_RGB) != 0)              {                  // Uncompressed DXT                  switch (pixelFormat.dwRGBBitCount)                  {                      case 32:                          elementsPerPixel = 4;                          if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGRA; //OpenGl's format tag is the reverse order                          }                          else if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGB;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          break;                      case 24:                          elementsPerPixel = 3;                          if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                          }                          else                          {                              glPixelFormat = Gl.GL_RGB;                          }                          break;                      default:                          throw new NotSupportedException("unhandled pixel format in dds file");                  }                  compressionFactor = 0;                  return;              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: if ((pixelFormat.dwFlags & DDPIXELFORMAT.DDPF_RGB) != 0)              {                  // Uncompressed DXT                  switch (pixelFormat.dwRGBBitCount)                  {                      case 32:                          elementsPerPixel = 4;                          if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGRA; //OpenGl's format tag is the reverse order                          }                          else if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGB;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          break;                      case 24:                          elementsPerPixel = 3;                          if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                          }                          else                          {                              glPixelFormat = Gl.GL_RGB;                          }                          break;                      default:                          throw new NotSupportedException("unhandled pixel format in dds file");                  }                  compressionFactor = 0;                  return;              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: if ((pixelFormat.dwFlags & DDPIXELFORMAT.DDPF_RGB) != 0)              {                  // Uncompressed DXT                  switch (pixelFormat.dwRGBBitCount)                  {                      case 32:                          elementsPerPixel = 4;                          if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGRA; //OpenGl's format tag is the reverse order                          }                          else if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGB;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          break;                      case 24:                          elementsPerPixel = 3;                          if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                          }                          else                          {                              glPixelFormat = Gl.GL_RGB;                          }                          break;                      default:                          throw new NotSupportedException("unhandled pixel format in dds file");                  }                  compressionFactor = 0;                  return;              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: if ((pixelFormat.dwFlags & DDPIXELFORMAT.DDPF_RGB) != 0)              {                  // Uncompressed DXT                  switch (pixelFormat.dwRGBBitCount)                  {                      case 32:                          elementsPerPixel = 4;                          if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGRA; //OpenGl's format tag is the reverse order                          }                          else if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGB;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          break;                      case 24:                          elementsPerPixel = 3;                          if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                          }                          else                          {                              glPixelFormat = Gl.GL_RGB;                          }                          break;                      default:                          throw new NotSupportedException("unhandled pixel format in dds file");                  }                  compressionFactor = 0;                  return;              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: if ((pixelFormat.dwFlags & DDPIXELFORMAT.DDPF_RGB) != 0)              {                  // Uncompressed DXT                  switch (pixelFormat.dwRGBBitCount)                  {                      case 32:                          elementsPerPixel = 4;                          if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGRA; //OpenGl's format tag is the reverse order                          }                          else if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGB;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          break;                      case 24:                          elementsPerPixel = 3;                          if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                          }                          else                          {                              glPixelFormat = Gl.GL_RGB;                          }                          break;                      default:                          throw new NotSupportedException("unhandled pixel format in dds file");                  }                  compressionFactor = 0;                  return;              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: if ((pixelFormat.dwFlags & DDPIXELFORMAT.DDPF_RGB) != 0)              {                  // Uncompressed DXT                  switch (pixelFormat.dwRGBBitCount)                  {                      case 32:                          elementsPerPixel = 4;                          if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGRA; //OpenGl's format tag is the reverse order                          }                          else if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGB;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          break;                      case 24:                          elementsPerPixel = 3;                          if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                          }                          else                          {                              glPixelFormat = Gl.GL_RGB;                          }                          break;                      default:                          throw new NotSupportedException("unhandled pixel format in dds file");                  }                  compressionFactor = 0;                  return;              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: if ((pixelFormat.dwFlags & DDPIXELFORMAT.DDPF_RGB) != 0)              {                  // Uncompressed DXT                  switch (pixelFormat.dwRGBBitCount)                  {                      case 32:                          elementsPerPixel = 4;                          if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGRA; //OpenGl's format tag is the reverse order                          }                          else if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGB;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          break;                      case 24:                          elementsPerPixel = 3;                          if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                          }                          else                          {                              glPixelFormat = Gl.GL_RGB;                          }                          break;                      default:                          throw new NotSupportedException("unhandled pixel format in dds file");                  }                  compressionFactor = 0;                  return;              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: if ((pixelFormat.dwFlags & DDPIXELFORMAT.DDPF_RGB) != 0)              {                  // Uncompressed DXT                  switch (pixelFormat.dwRGBBitCount)                  {                      case 32:                          elementsPerPixel = 4;                          if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGRA; //OpenGl's format tag is the reverse order                          }                          else if (pixelFormat.HasAlphaRedGreenBlueMasks(                              0xFF000000'                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else if (pixelFormat.HasRedGreenBlueMasks(                              0x000000FF'                              0x0000FF00'                              0x00FF0000))                          {                              glPixelFormat = Gl.GL_RGB;                              converter = Create32BitTo24BitConverter(0' 1' 2);                              elementsPerPixel = 3;                          }                          else                          {                              glPixelFormat = Gl.GL_RGBA;                          }                          break;                      case 24:                          elementsPerPixel = 3;                          if (pixelFormat.HasRedGreenBlueMasks(                              0x00FF0000'                              0x0000FF00'                              0x000000FF))                          {                              glPixelFormat = Gl.GL_BGR;                          }                          else                          {                              glPixelFormat = Gl.GL_RGB;                          }                          break;                      default:                          throw new NotSupportedException("unhandled pixel format in dds file");                  }                  compressionFactor = 0;                  return;              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: switch (pixelFormat.dwFourCC)              {                  case DDPIXELFORMAT.FOURCC_DXT1:                      // DXT1's compression ratio is 8:1                      compressionFactor = 2;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;                      elementsPerPixel = 3;                      break;                    case DDPIXELFORMAT.FOURCC_DXT3:                      // DXT3's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;                      elementsPerPixel = 4;                      break;                    case DDPIXELFORMAT.FOURCC_DXT5:                      // DXT5's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;                      elementsPerPixel = 4;                      break;                    default:                      throw new NotSupportedException("Unsupported DXT format");              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: switch (pixelFormat.dwFourCC)              {                  case DDPIXELFORMAT.FOURCC_DXT1:                      // DXT1's compression ratio is 8:1                      compressionFactor = 2;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;                      elementsPerPixel = 3;                      break;                    case DDPIXELFORMAT.FOURCC_DXT3:                      // DXT3's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;                      elementsPerPixel = 4;                      break;                    case DDPIXELFORMAT.FOURCC_DXT5:                      // DXT5's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;                      elementsPerPixel = 4;                      break;                    default:                      throw new NotSupportedException("Unsupported DXT format");              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: switch (pixelFormat.dwFourCC)              {                  case DDPIXELFORMAT.FOURCC_DXT1:                      // DXT1's compression ratio is 8:1                      compressionFactor = 2;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;                      elementsPerPixel = 3;                      break;                    case DDPIXELFORMAT.FOURCC_DXT3:                      // DXT3's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;                      elementsPerPixel = 4;                      break;                    case DDPIXELFORMAT.FOURCC_DXT5:                      // DXT5's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;                      elementsPerPixel = 4;                      break;                    default:                      throw new NotSupportedException("Unsupported DXT format");              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: switch (pixelFormat.dwFourCC)              {                  case DDPIXELFORMAT.FOURCC_DXT1:                      // DXT1's compression ratio is 8:1                      compressionFactor = 2;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;                      elementsPerPixel = 3;                      break;                    case DDPIXELFORMAT.FOURCC_DXT3:                      // DXT3's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;                      elementsPerPixel = 4;                      break;                    case DDPIXELFORMAT.FOURCC_DXT5:                      // DXT5's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;                      elementsPerPixel = 4;                      break;                    default:                      throw new NotSupportedException("Unsupported DXT format");              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: switch (pixelFormat.dwFourCC)              {                  case DDPIXELFORMAT.FOURCC_DXT1:                      // DXT1's compression ratio is 8:1                      compressionFactor = 2;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;                      elementsPerPixel = 3;                      break;                    case DDPIXELFORMAT.FOURCC_DXT3:                      // DXT3's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;                      elementsPerPixel = 4;                      break;                    case DDPIXELFORMAT.FOURCC_DXT5:                      // DXT5's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;                      elementsPerPixel = 4;                      break;                    default:                      throw new NotSupportedException("Unsupported DXT format");              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,CalculateImageSettings,The following statement contains a magic number: switch (pixelFormat.dwFourCC)              {                  case DDPIXELFORMAT.FOURCC_DXT1:                      // DXT1's compression ratio is 8:1                      compressionFactor = 2;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT1_EXT;                      elementsPerPixel = 3;                      break;                    case DDPIXELFORMAT.FOURCC_DXT3:                      // DXT3's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT3_EXT;                      elementsPerPixel = 4;                      break;                    case DDPIXELFORMAT.FOURCC_DXT5:                      // DXT5's compression ratio is 4:1                      compressionFactor = 4;                      glPixelFormat = Gl.GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;                      elementsPerPixel = 4;                      break;                    default:                      throw new NotSupportedException("Unsupported DXT format");              }
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Create32BitConverter,The following statement contains a magic number: return delegate(byte[] source)              {                  for (int i = 0; i < source.Length; i += 4)                  {                      byte c1 = source[i + sourceColor1];                      byte c2 = source[i + sourceColor2];                      byte c3 = source[i + sourceColor3];                      byte c4 = source[i + sourceColor4];                      source[i] = c1;                      source[i + 1] = c2;                      source[i + 2] = c3;                      source[i + 3] = c4;                  }                  return source;              };
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Create32BitConverter,The following statement contains a magic number: return delegate(byte[] source)              {                  for (int i = 0; i < source.Length; i += 4)                  {                      byte c1 = source[i + sourceColor1];                      byte c2 = source[i + sourceColor2];                      byte c3 = source[i + sourceColor3];                      byte c4 = source[i + sourceColor4];                      source[i] = c1;                      source[i + 1] = c2;                      source[i + 2] = c3;                      source[i + 3] = c4;                  }                  return source;              };
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Create32BitConverter,The following statement contains a magic number: return delegate(byte[] source)              {                  for (int i = 0; i < source.Length; i += 4)                  {                      byte c1 = source[i + sourceColor1];                      byte c2 = source[i + sourceColor2];                      byte c3 = source[i + sourceColor3];                      byte c4 = source[i + sourceColor4];                      source[i] = c1;                      source[i + 1] = c2;                      source[i + 2] = c3;                      source[i + 3] = c4;                  }                  return source;              };
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Create32BitTo24BitConverter,The following statement contains a magic number: return delegate(byte[] source)              {                  int pixels = source.Length / 4;                  byte[] dest = new byte[pixels * 3];                    int sourceIndex = 0;                  int destIndex = 0;                  while (sourceIndex < source.Length)                  {                      dest[destIndex] = source[sourceIndex + sourceColor1];                      dest[destIndex + 1] = source[sourceIndex + sourceColor2];                      dest[destIndex + 2] = source[sourceIndex + sourceColor3];                        sourceIndex += 4;                      destIndex += 3;                  }                  return dest;              };
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Create32BitTo24BitConverter,The following statement contains a magic number: return delegate(byte[] source)              {                  int pixels = source.Length / 4;                  byte[] dest = new byte[pixels * 3];                    int sourceIndex = 0;                  int destIndex = 0;                  while (sourceIndex < source.Length)                  {                      dest[destIndex] = source[sourceIndex + sourceColor1];                      dest[destIndex + 1] = source[sourceIndex + sourceColor2];                      dest[destIndex + 2] = source[sourceIndex + sourceColor3];                        sourceIndex += 4;                      destIndex += 3;                  }                  return dest;              };
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Create32BitTo24BitConverter,The following statement contains a magic number: return delegate(byte[] source)              {                  int pixels = source.Length / 4;                  byte[] dest = new byte[pixels * 3];                    int sourceIndex = 0;                  int destIndex = 0;                  while (sourceIndex < source.Length)                  {                      dest[destIndex] = source[sourceIndex + sourceColor1];                      dest[destIndex + 1] = source[sourceIndex + sourceColor2];                      dest[destIndex + 2] = source[sourceIndex + sourceColor3];                        sourceIndex += 4;                      destIndex += 3;                  }                  return dest;              };
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Create32BitTo24BitConverter,The following statement contains a magic number: return delegate(byte[] source)              {                  int pixels = source.Length / 4;                  byte[] dest = new byte[pixels * 3];                    int sourceIndex = 0;                  int destIndex = 0;                  while (sourceIndex < source.Length)                  {                      dest[destIndex] = source[sourceIndex + sourceColor1];                      dest[destIndex + 1] = source[sourceIndex + sourceColor2];                      dest[destIndex + 2] = source[sourceIndex + sourceColor3];                        sourceIndex += 4;                      destIndex += 3;                  }                  return dest;              };
Magic Number,Sce.Atf.Rendering,DdsImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Create32BitTo24BitConverter,The following statement contains a magic number: return delegate(byte[] source)              {                  int pixels = source.Length / 4;                  byte[] dest = new byte[pixels * 3];                    int sourceIndex = 0;                  int destIndex = 0;                  while (sourceIndex < source.Length)                  {                      dest[destIndex] = source[sourceIndex + sourceColor1];                      dest[destIndex + 1] = source[sourceIndex + sourceColor2];                      dest[destIndex + 2] = source[sourceIndex + sourceColor3];                        sourceIndex += 4;                      destIndex += 3;                  }                  return dest;              };
Magic Number,Sce.Atf.Rendering,DDPIXELFORMAT,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Load,The following statement contains a magic number: if (dwSize != 32)                      throw new InvalidDataException("DDPIXELFORMAT must be 32 bytes in DDS file specification");
Magic Number,Sce.Atf.Rendering,DDSURFACEDESC2,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Load,The following statement contains a magic number: byte[] header = reader.ReadBytes(4);
Magic Number,Sce.Atf.Rendering,DDSURFACEDESC2,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Load,The following statement contains a magic number: if (header[0] != 'D' || header[1] != 'D' || header[2] != 'S' || header[3] != ' ')                      throw new InvalidDataException("Not a DDS file");
Magic Number,Sce.Atf.Rendering,DDSURFACEDESC2,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Load,The following statement contains a magic number: if (header[0] != 'D' || header[1] != 'D' || header[2] != 'S' || header[3] != ' ')                      throw new InvalidDataException("Not a DDS file");
Magic Number,Sce.Atf.Rendering,DDSURFACEDESC2,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsImageLoader.cs,Load,The following statement contains a magic number: if (m_dwSize != 124)                      throw new InvalidDataException("DDSURFACEDESC2 must be 124 bytes in DDS file specification");
Magic Number,Sce.Atf.Rendering,DevilImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DevilImageLoader.cs,GetBytesFromDxt,The following statement contains a magic number: targetNumElements = 4;
Magic Number,Sce.Atf.Rendering,DevilImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DevilImageLoader.cs,GetUncompressedBytes,The following statement contains a magic number: if (targetNumElements != 3)                  targetNumElements = 4;
Magic Number,Sce.Atf.Rendering,DevilImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DevilImageLoader.cs,GetUncompressedBytes,The following statement contains a magic number: if (targetNumElements != 3)                  targetNumElements = 4;
Magic Number,Sce.Atf.Rendering,DevilImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DevilImageLoader.cs,GetUncompressedBytes,The following statement contains a magic number: if (targetNumElements == 3)              {                  targetFormat = Il.IL_BGR;                  targetOpenGlFormat = Gl.GL_BGR;              }              else              {                  targetFormat = Il.IL_BGRA;                  targetOpenGlFormat = Gl.GL_BGRA;              }
Magic Number,Sce.Atf.Rendering,Image,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Image.cs,CreateBitmap,The following statement contains a magic number: int bitmapStride = (((ElementsPerPixel * Width) + 3) >> 2) << 2;
Magic Number,Sce.Atf.Rendering,Image,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Image.cs,CreateBitmap,The following statement contains a magic number: int bitmapStride = (((ElementsPerPixel * Width) + 3) >> 2) << 2;
Magic Number,Sce.Atf.Rendering,Image,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Image.cs,CreateBitmap,The following statement contains a magic number: int bitmapStride = (((ElementsPerPixel * Width) + 3) >> 2) << 2;
Magic Number,Sce.Atf.Rendering,MsBitmapImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\MsBitmapImageLoader.cs,LoadImage,The following statement contains a magic number: using (bitmap)              {                      int glPixelFormat = CalculateGlPixelFormat(bitmap);                  int pixelDepth = (glPixelFormat == Gl.GL_BGRA) ? 4 : 3;                                    System.Drawing.Rectangle rect = new System.Drawing.Rectangle(0' 0' bitmap.Width' bitmap.Height);                  System.Drawing.Imaging.BitmapData bitmapData =                       bitmap.LockBits(rect' System.Drawing.Imaging.ImageLockMode.ReadOnly' bitmap.PixelFormat);                    int byteCount = bitmap.Width*bitmap.Height*pixelDepth;                  byte[] pixels = new byte[byteCount];                    Marshal.Copy(bitmapData.Scan0' pixels' 0' byteCount);                                    bitmap.UnlockBits(bitmapData);                                    image = new Image(bitmap.Width' bitmap.Height' pixels' 1' glPixelFormat' pixelDepth);              }
Magic Number,Sce.Atf.Rendering,MsBitmapImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\MsBitmapImageLoader.cs,LoadImage,The following statement contains a magic number: using (bitmap)              {                      int glPixelFormat = CalculateGlPixelFormat(bitmap);                  int pixelDepth = (glPixelFormat == Gl.GL_BGRA) ? 4 : 3;                                    System.Drawing.Rectangle rect = new System.Drawing.Rectangle(0' 0' bitmap.Width' bitmap.Height);                  System.Drawing.Imaging.BitmapData bitmapData =                       bitmap.LockBits(rect' System.Drawing.Imaging.ImageLockMode.ReadOnly' bitmap.PixelFormat);                    int byteCount = bitmap.Width*bitmap.Height*pixelDepth;                  byte[] pixels = new byte[byteCount];                    Marshal.Copy(bitmapData.Scan0' pixels' 0' byteCount);                                    bitmap.UnlockBits(bitmapData);                                    image = new Image(bitmap.Width' bitmap.Height' pixels' 1' glPixelFormat' pixelDepth);              }
Magic Number,Sce.Atf.Rendering,RenderStats,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderStats.cs,ResetFrame,The following statement contains a magic number: while (m_updateTimes.Count > 0)              {                  DateTime oldest = m_updateTimes.Peek();                  TimeSpan age = now - oldest;                  if (age.TotalMilliseconds > AverageFrameRateTime * 1000)                      m_updateTimes.Dequeue();                  else                      break;              }
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,LoadImage,The following statement contains a magic number: int elementsPerPixel = GetPixelDepth(header) / 8;
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,ReadColorMap,The following statement contains a magic number: int bytesPerEntry = header.colorMapDepth/8;
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,ReadPixels,The following statement contains a magic number: if (header.bitsPerPixel == 16)                  throw new NotImplementedException("16bpp RGB unpacking is not supported yet.");
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,ReadPixels,The following statement contains a magic number: int bytesPerPixel = header.bitsPerPixel / 8;
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,DecompressRle,The following statement contains a magic number: int bytesPerPixel = GetPixelDepth(header) / 8;
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,ExpandPayloadToUnmappedPixels,The following statement contains a magic number: int mappedPixelSize = header.bitsPerPixel/8;
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,ExpandPayloadToUnmappedPixels,The following statement contains a magic number: int unmappedPixelSize = header.colorMapDepth/8;
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,ExpandPayloadToUnmappedPixels,The following statement contains a magic number: if (unmappedPixelSize != 3 && unmappedPixelSize != 4)                  throw new NotSupportedException("Unmapped pixel elements other than 24bpp and 32bpp are not supported yet.");
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,ExpandPayloadToUnmappedPixels,The following statement contains a magic number: if (unmappedPixelSize != 3 && unmappedPixelSize != 4)                  throw new NotSupportedException("Unmapped pixel elements other than 24bpp and 32bpp are not supported yet.");
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,ExpandPayloadToUnmappedPixels,The following statement contains a magic number: for (int i = 0; i < pixelCount; ++i)              {                  int index = pixelPayload[i];                  int mapEntry = index*unmappedPixelSize;                                    if (unmappedPixelSize == 3)                  {                      unmappedPixelStream.WriteByte(colorMap[mapEntry]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 1]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 2]);                  }                  else                  {                      unmappedPixelStream.WriteByte(colorMap[mapEntry]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 1]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 2]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 3]);                  }              }
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,ExpandPayloadToUnmappedPixels,The following statement contains a magic number: for (int i = 0; i < pixelCount; ++i)              {                  int index = pixelPayload[i];                  int mapEntry = index*unmappedPixelSize;                                    if (unmappedPixelSize == 3)                  {                      unmappedPixelStream.WriteByte(colorMap[mapEntry]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 1]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 2]);                  }                  else                  {                      unmappedPixelStream.WriteByte(colorMap[mapEntry]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 1]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 2]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 3]);                  }              }
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,ExpandPayloadToUnmappedPixels,The following statement contains a magic number: for (int i = 0; i < pixelCount; ++i)              {                  int index = pixelPayload[i];                  int mapEntry = index*unmappedPixelSize;                                    if (unmappedPixelSize == 3)                  {                      unmappedPixelStream.WriteByte(colorMap[mapEntry]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 1]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 2]);                  }                  else                  {                      unmappedPixelStream.WriteByte(colorMap[mapEntry]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 1]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 2]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 3]);                  }              }
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,ExpandPayloadToUnmappedPixels,The following statement contains a magic number: for (int i = 0; i < pixelCount; ++i)              {                  int index = pixelPayload[i];                  int mapEntry = index*unmappedPixelSize;                                    if (unmappedPixelSize == 3)                  {                      unmappedPixelStream.WriteByte(colorMap[mapEntry]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 1]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 2]);                  }                  else                  {                      unmappedPixelStream.WriteByte(colorMap[mapEntry]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 1]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 2]);                      unmappedPixelStream.WriteByte(colorMap[mapEntry + 3]);                  }              }
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,InvertImageAroundY,The following statement contains a magic number: int bytesPerPixel = GetPixelDepth(header) / 8;
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,InvertImageAroundY,The following statement contains a magic number: int totalRowsToReflect = header.imageHeight / 2;
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,CalculateOpenGlPixelFormat,The following statement contains a magic number: switch (bpp)              {                  case 24:                      return Gl.GL_BGR;                                        case 32:                      return Gl.GL_BGRA;                                        default:                      throw new InvalidOperationException("Unknown pixel depth.");              }
Magic Number,Sce.Atf.Rendering,TargaImageLoader,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TargaImageLoader.cs,CalculateOpenGlPixelFormat,The following statement contains a magic number: switch (bpp)              {                  case 24:                      return Gl.GL_BGR;                                        case 32:                      return Gl.GL_BGRA;                                        default:                      throw new InvalidOperationException("Unknown pixel depth.");              }
Magic Number,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,Init,The following statement contains a magic number: const int FP40 = 6151;
Magic Number,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,SetParameter,The following statement contains a magic number: try {                  m_cg_parameters.TryGetValue(parameter' out param);                  if (param == (IntPtr)0) return false;                  int length = array.Length;                  switch (length)                  {                      case 1:                          Cg.cgSetParameter1f(param' array[0]);                          break;                      case 2:                          Cg.cgSetParameter2f(param' array[0]' array[1]);                          break;                      case 3:                          Cg.cgSetParameter3f(param' array[0]' array[1]' array[2]);                          break;                      case 4:                          Cg.cgSetParameter4f(param' array[0]' array[1]' array[2]' array[3]);                          break;                      case 16:                          CgGl.cgGLSetMatrixParameterfc(param' array);                          break;                      default:                          break;                  }              }              catch { return false; }
Magic Number,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,SetParameter,The following statement contains a magic number: try {                  m_cg_parameters.TryGetValue(parameter' out param);                  if (param == (IntPtr)0) return false;                  int length = array.Length;                  switch (length)                  {                      case 1:                          Cg.cgSetParameter1f(param' array[0]);                          break;                      case 2:                          Cg.cgSetParameter2f(param' array[0]' array[1]);                          break;                      case 3:                          Cg.cgSetParameter3f(param' array[0]' array[1]' array[2]);                          break;                      case 4:                          Cg.cgSetParameter4f(param' array[0]' array[1]' array[2]' array[3]);                          break;                      case 16:                          CgGl.cgGLSetMatrixParameterfc(param' array);                          break;                      default:                          break;                  }              }              catch { return false; }
Magic Number,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,SetParameter,The following statement contains a magic number: try {                  m_cg_parameters.TryGetValue(parameter' out param);                  if (param == (IntPtr)0) return false;                  int length = array.Length;                  switch (length)                  {                      case 1:                          Cg.cgSetParameter1f(param' array[0]);                          break;                      case 2:                          Cg.cgSetParameter2f(param' array[0]' array[1]);                          break;                      case 3:                          Cg.cgSetParameter3f(param' array[0]' array[1]' array[2]);                          break;                      case 4:                          Cg.cgSetParameter4f(param' array[0]' array[1]' array[2]' array[3]);                          break;                      case 16:                          CgGl.cgGLSetMatrixParameterfc(param' array);                          break;                      default:                          break;                  }              }              catch { return false; }
Magic Number,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,SetParameter,The following statement contains a magic number: try {                  m_cg_parameters.TryGetValue(parameter' out param);                  if (param == (IntPtr)0) return false;                  int length = array.Length;                  switch (length)                  {                      case 1:                          Cg.cgSetParameter1f(param' array[0]);                          break;                      case 2:                          Cg.cgSetParameter2f(param' array[0]' array[1]);                          break;                      case 3:                          Cg.cgSetParameter3f(param' array[0]' array[1]' array[2]);                          break;                      case 4:                          Cg.cgSetParameter4f(param' array[0]' array[1]' array[2]' array[3]);                          break;                      case 16:                          CgGl.cgGLSetMatrixParameterfc(param' array);                          break;                      default:                          break;                  }              }              catch { return false; }
Magic Number,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,SetParameter,The following statement contains a magic number: try {                  m_cg_parameters.TryGetValue(parameter' out param);                  if (param == (IntPtr)0) return false;                  int length = array.Length;                  switch (length)                  {                      case 1:                          Cg.cgSetParameter1f(param' array[0]);                          break;                      case 2:                          Cg.cgSetParameter2f(param' array[0]' array[1]);                          break;                      case 3:                          Cg.cgSetParameter3f(param' array[0]' array[1]' array[2]);                          break;                      case 4:                          Cg.cgSetParameter4f(param' array[0]' array[1]' array[2]' array[3]);                          break;                      case 16:                          CgGl.cgGLSetMatrixParameterfc(param' array);                          break;                      default:                          break;                  }              }              catch { return false; }
Magic Number,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,SetParameter,The following statement contains a magic number: try {                  m_cg_parameters.TryGetValue(parameter' out param);                  if (param == (IntPtr)0) return false;                  int length = array.Length;                  switch (length)                  {                      case 1:                          Cg.cgSetParameter1f(param' array[0]);                          break;                      case 2:                          Cg.cgSetParameter2f(param' array[0]' array[1]);                          break;                      case 3:                          Cg.cgSetParameter3f(param' array[0]' array[1]' array[2]);                          break;                      case 4:                          Cg.cgSetParameter4f(param' array[0]' array[1]' array[2]' array[3]);                          break;                      case 16:                          CgGl.cgGLSetMatrixParameterfc(param' array);                          break;                      default:                          break;                  }              }              catch { return false; }
Magic Number,Sce.Atf.Rendering.OpenGL,CgfxCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\CgfxCore.cs,SetParameter,The following statement contains a magic number: try {                  m_cg_parameters.TryGetValue(parameter' out param);                  if (param == (IntPtr)0) return false;                  int length = array.Length;                  switch (length)                  {                      case 1:                          Cg.cgSetParameter1f(param' array[0]);                          break;                      case 2:                          Cg.cgSetParameter2f(param' array[0]' array[1]);                          break;                      case 3:                          Cg.cgSetParameter3f(param' array[0]' array[1]' array[2]);                          break;                      case 4:                          Cg.cgSetParameter4f(param' array[0]' array[1]' array[2]' array[3]);                          break;                      case 16:                          CgGl.cgGLSetMatrixParameterfc(param' array);                          break;                      default:                          break;                  }              }              catch { return false; }
Magic Number,Sce.Atf.Rendering.OpenGL,OpenGlCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\OpenGlCore.cs,PopulatePixelFormatDescriptor,The following statement contains a magic number: pfd.cColorBits = (byte)32;
Magic Number,Sce.Atf.Rendering.OpenGL,OpenGlCore,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\OpenGlCore.cs,PopulatePixelFormatDescriptor,The following statement contains a magic number: pfd.cDepthBits = 32;
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,BuildImage,The following statement contains a magic number: try              {                  string filename = uri.Replace(@"file:\\\"' "");                    string ext = Path.GetExtension(filename);                  IImageLoader loader = m_imageLoaderRegistry.GetLoader(ext);                  Image image;                    using (Stream stream = new FileStream(filename' FileMode.Open' FileAccess.Read))                      image = loader.LoadImage(stream);                    name = TryCreateOpenGlTextureFromImage(image' textureInfo);              }              catch (System.IO.IOException e)              {                  // excessive error messages adds minutes to a large level that is missing textures                  if (m_missingTextureReports++ < 10)                      Outputs.WriteLine(OutputMessageType.Error'e.Message);              }              catch (Exception e)              {                  Outputs.WriteLine(OutputMessageType.Error' e.Message);                  Outputs.WriteLine(OutputMessageType.Info' e.StackTrace);              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureContainsAllMipmaps,The following statement contains a magic number: while (longestSide != 1)              {                  longestSide /= 2;                  levelsInFullChain++;              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelData,The following statement contains a magic number: if (image.OpenGlPixelFormat == Gl.GL_COMPRESSED_RGBA_S3TC_DXT1_EXT)                  nBlockSize = 8;              else                  nBlockSize = 16;
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelData,The following statement contains a magic number: if (image.OpenGlPixelFormat == Gl.GL_COMPRESSED_RGBA_S3TC_DXT1_EXT)                  nBlockSize = 8;              else                  nBlockSize = 16;
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelData,The following statement contains a magic number: fixed (byte* pixels = image.Pixels)              {                  for (int i = 0; i < levels; ++i)                  {                      if (nWidth == 0)                          nWidth = 1;                      if (nHeight == 0)                          nHeight = 1;                        nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * nBlockSize;                        Gl.glCompressedTexImage2DARB(                          Gl.GL_TEXTURE_2D'                          i'                          image.OpenGlPixelFormat'                          nWidth'                          nHeight'                          0'                          nSize'                          new IntPtr(pixels + nOffset));                        nOffset += nSize;                        // Half the image size for the next mip-map level...                      nWidth = (nWidth / 2);                      nHeight = (nHeight / 2);                  }              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelData,The following statement contains a magic number: fixed (byte* pixels = image.Pixels)              {                  for (int i = 0; i < levels; ++i)                  {                      if (nWidth == 0)                          nWidth = 1;                      if (nHeight == 0)                          nHeight = 1;                        nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * nBlockSize;                        Gl.glCompressedTexImage2DARB(                          Gl.GL_TEXTURE_2D'                          i'                          image.OpenGlPixelFormat'                          nWidth'                          nHeight'                          0'                          nSize'                          new IntPtr(pixels + nOffset));                        nOffset += nSize;                        // Half the image size for the next mip-map level...                      nWidth = (nWidth / 2);                      nHeight = (nHeight / 2);                  }              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelData,The following statement contains a magic number: fixed (byte* pixels = image.Pixels)              {                  for (int i = 0; i < levels; ++i)                  {                      if (nWidth == 0)                          nWidth = 1;                      if (nHeight == 0)                          nHeight = 1;                        nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * nBlockSize;                        Gl.glCompressedTexImage2DARB(                          Gl.GL_TEXTURE_2D'                          i'                          image.OpenGlPixelFormat'                          nWidth'                          nHeight'                          0'                          nSize'                          new IntPtr(pixels + nOffset));                        nOffset += nSize;                        // Half the image size for the next mip-map level...                      nWidth = (nWidth / 2);                      nHeight = (nHeight / 2);                  }              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelData,The following statement contains a magic number: fixed (byte* pixels = image.Pixels)              {                  for (int i = 0; i < levels; ++i)                  {                      if (nWidth == 0)                          nWidth = 1;                      if (nHeight == 0)                          nHeight = 1;                        nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * nBlockSize;                        Gl.glCompressedTexImage2DARB(                          Gl.GL_TEXTURE_2D'                          i'                          image.OpenGlPixelFormat'                          nWidth'                          nHeight'                          0'                          nSize'                          new IntPtr(pixels + nOffset));                        nOffset += nSize;                        // Half the image size for the next mip-map level...                      nWidth = (nWidth / 2);                      nHeight = (nHeight / 2);                  }              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelData,The following statement contains a magic number: fixed (byte* pixels = image.Pixels)              {                  for (int i = 0; i < levels; ++i)                  {                      if (nWidth == 0)                          nWidth = 1;                      if (nHeight == 0)                          nHeight = 1;                        nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * nBlockSize;                        Gl.glCompressedTexImage2DARB(                          Gl.GL_TEXTURE_2D'                          i'                          image.OpenGlPixelFormat'                          nWidth'                          nHeight'                          0'                          nSize'                          new IntPtr(pixels + nOffset));                        nOffset += nSize;                        // Half the image size for the next mip-map level...                      nWidth = (nWidth / 2);                      nHeight = (nHeight / 2);                  }              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelData,The following statement contains a magic number: fixed (byte* pixels = image.Pixels)              {                  for (int i = 0; i < levels; ++i)                  {                      if (nWidth == 0)                          nWidth = 1;                      if (nHeight == 0)                          nHeight = 1;                        nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * nBlockSize;                        Gl.glCompressedTexImage2DARB(                          Gl.GL_TEXTURE_2D'                          i'                          image.OpenGlPixelFormat'                          nWidth'                          nHeight'                          0'                          nSize'                          new IntPtr(pixels + nOffset));                        nOffset += nSize;                        // Half the image size for the next mip-map level...                      nWidth = (nWidth / 2);                      nHeight = (nHeight / 2);                  }              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelDataCUBEMAP,The following statement contains a magic number: if (image.OpenGlPixelFormat == Gl.GL_COMPRESSED_RGBA_S3TC_DXT1_EXT)                  nBlockSize = 8;              else                  nBlockSize = 16;
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelDataCUBEMAP,The following statement contains a magic number: if (image.OpenGlPixelFormat == Gl.GL_COMPRESSED_RGBA_S3TC_DXT1_EXT)                  nBlockSize = 8;              else                  nBlockSize = 16;
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelDataCUBEMAP,The following statement contains a magic number: for (int face = 0; face < 6; face++)              {                  int nWidth = image.Width;                  int nHeight = image.Height;                  for (int i = 0; i < levels; ++i)                  {                      if (nWidth == 0)                          nWidth = 1;                      if (nHeight == 0)                          nHeight = 1;                        //                    nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * nBlockSize;                                          int nSize = ((nWidth + 3) >> 2) * ((nHeight + 3) >> 2) * nBlockSize;                        byte[] pixel = new byte[nSize];                      for (int o = offset' j=0; o < offset + nSize; o++' j++)                      {                          pixel[j] = image.Pixels[o];                      }                      Gl.glCompressedTexImage2DARB(                          Gl.GL_TEXTURE_CUBE_MAP_POSITIVE_X + face'                          i'                          image.OpenGlPixelFormat'                          nWidth'                          nHeight'                          0'                          nSize'                          pixel);                        offset += nSize;                        // Half the image size for the next mip-map level...                      nWidth = (nWidth >> 1);                      nHeight = (nHeight >> 1);                  }              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelDataCUBEMAP,The following statement contains a magic number: for (int face = 0; face < 6; face++)              {                  int nWidth = image.Width;                  int nHeight = image.Height;                  for (int i = 0; i < levels; ++i)                  {                      if (nWidth == 0)                          nWidth = 1;                      if (nHeight == 0)                          nHeight = 1;                        //                    nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * nBlockSize;                                          int nSize = ((nWidth + 3) >> 2) * ((nHeight + 3) >> 2) * nBlockSize;                        byte[] pixel = new byte[nSize];                      for (int o = offset' j=0; o < offset + nSize; o++' j++)                      {                          pixel[j] = image.Pixels[o];                      }                      Gl.glCompressedTexImage2DARB(                          Gl.GL_TEXTURE_CUBE_MAP_POSITIVE_X + face'                          i'                          image.OpenGlPixelFormat'                          nWidth'                          nHeight'                          0'                          nSize'                          pixel);                        offset += nSize;                        // Half the image size for the next mip-map level...                      nWidth = (nWidth >> 1);                      nHeight = (nHeight >> 1);                  }              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelDataCUBEMAP,The following statement contains a magic number: for (int face = 0; face < 6; face++)              {                  int nWidth = image.Width;                  int nHeight = image.Height;                  for (int i = 0; i < levels; ++i)                  {                      if (nWidth == 0)                          nWidth = 1;                      if (nHeight == 0)                          nHeight = 1;                        //                    nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * nBlockSize;                                          int nSize = ((nWidth + 3) >> 2) * ((nHeight + 3) >> 2) * nBlockSize;                        byte[] pixel = new byte[nSize];                      for (int o = offset' j=0; o < offset + nSize; o++' j++)                      {                          pixel[j] = image.Pixels[o];                      }                      Gl.glCompressedTexImage2DARB(                          Gl.GL_TEXTURE_CUBE_MAP_POSITIVE_X + face'                          i'                          image.OpenGlPixelFormat'                          nWidth'                          nHeight'                          0'                          nSize'                          pixel);                        offset += nSize;                        // Half the image size for the next mip-map level...                      nWidth = (nWidth >> 1);                      nHeight = (nHeight >> 1);                  }              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelDataCUBEMAP,The following statement contains a magic number: for (int face = 0; face < 6; face++)              {                  int nWidth = image.Width;                  int nHeight = image.Height;                  for (int i = 0; i < levels; ++i)                  {                      if (nWidth == 0)                          nWidth = 1;                      if (nHeight == 0)                          nHeight = 1;                        //                    nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * nBlockSize;                                          int nSize = ((nWidth + 3) >> 2) * ((nHeight + 3) >> 2) * nBlockSize;                        byte[] pixel = new byte[nSize];                      for (int o = offset' j=0; o < offset + nSize; o++' j++)                      {                          pixel[j] = image.Pixels[o];                      }                      Gl.glCompressedTexImage2DARB(                          Gl.GL_TEXTURE_CUBE_MAP_POSITIVE_X + face'                          i'                          image.OpenGlPixelFormat'                          nWidth'                          nHeight'                          0'                          nSize'                          pixel);                        offset += nSize;                        // Half the image size for the next mip-map level...                      nWidth = (nWidth >> 1);                      nHeight = (nHeight >> 1);                  }              }
Magic Number,Sce.Atf.Rendering.OpenGL,TextureManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TextureManager.cs,CompressedTextureLoadPixelDataCUBEMAP,The following statement contains a magic number: for (int face = 0; face < 6; face++)              {                  int nWidth = image.Width;                  int nHeight = image.Height;                  for (int i = 0; i < levels; ++i)                  {                      if (nWidth == 0)                          nWidth = 1;                      if (nHeight == 0)                          nHeight = 1;                        //                    nSize = ((nWidth + 3) / 4) * ((nHeight + 3) / 4) * nBlockSize;                                          int nSize = ((nWidth + 3) >> 2) * ((nHeight + 3) >> 2) * nBlockSize;                        byte[] pixel = new byte[nSize];                      for (int o = offset' j=0; o < offset + nSize; o++' j++)                      {                          pixel[j] = image.Pixels[o];                      }                      Gl.glCompressedTexImage2DARB(                          Gl.GL_TEXTURE_CUBE_MAP_POSITIVE_X + face'                          i'                          image.OpenGlPixelFormat'                          nWidth'                          nHeight'                          0'                          nSize'                          pixel);                        offset += nSize;                        // Half the image size for the next mip-map level...                      nWidth = (nWidth >> 1);                      nHeight = (nHeight >> 1);                  }              }
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawLine,The following statement contains a magic number: Util3D.RenderStats.VertexCount += 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawLine,The following statement contains a magic number: Util3D.RenderStats.VertexCount += 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawArrow,The following statement contains a magic number: DrawCone((double)coneSize' (double)coneSize * 2' 8' 1' RenderStyle.Solid);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawArrow,The following statement contains a magic number: DrawCone((double)coneSize' (double)coneSize * 2' 8' 1' RenderStyle.Solid);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawArrow,The following statement contains a magic number: Util3D.RenderStats.VertexCount += 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawArrowDisplayList,The following statement contains a magic number: DrawConeDisplayList(coneSize' coneSize * 2' RenderStyle.Solid);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawArrowDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount += 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCube,The following statement contains a magic number: Util3D.RenderStats.VertexCount += 6 * 4;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCube,The following statement contains a magic number: Util3D.RenderStats.VertexCount += 6 * 4;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCube,The following statement contains a magic number: Util3D.RenderStats.PrimCount += 6;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCubeDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount += 6 * 4;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCubeDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount += 6 * 4;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCubeDisplayList,The following statement contains a magic number: Util3D.RenderStats.PrimCount += 6;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawSphere,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=       //each stack is a separate tri fan / quad strip?                  (2 + slices) * 2 +                  //the two triangle fans at top and bottom of sphere.                  (2 + slices * 2) * (stacks - 2);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawSphere,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=       //each stack is a separate tri fan / quad strip?                  (2 + slices) * 2 +                  //the two triangle fans at top and bottom of sphere.                  (2 + slices * 2) * (stacks - 2);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawSphere,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=       //each stack is a separate tri fan / quad strip?                  (2 + slices) * 2 +                  //the two triangle fans at top and bottom of sphere.                  (2 + slices * 2) * (stacks - 2);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawSphere,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=       //each stack is a separate tri fan / quad strip?                  (2 + slices) * 2 +                  //the two triangle fans at top and bottom of sphere.                  (2 + slices * 2) * (stacks - 2);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawSphere,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=       //each stack is a separate tri fan / quad strip?                  (2 + slices) * 2 +                  //the two triangle fans at top and bottom of sphere.                  (2 + slices * 2) * (stacks - 2);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawSphereDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=       //each stack is a separate tri fan / quad strip?                  (2 + FAST_SPHERE_SLICES) * 2 +                  //the two triangle fans at top and bottom of sphere.                  (2 + FAST_SPHERE_SLICES * 2) * (FAST_SPHERE_STACKS - 2);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawSphereDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=       //each stack is a separate tri fan / quad strip?                  (2 + FAST_SPHERE_SLICES) * 2 +                  //the two triangle fans at top and bottom of sphere.                  (2 + FAST_SPHERE_SLICES * 2) * (FAST_SPHERE_STACKS - 2);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawSphereDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=       //each stack is a separate tri fan / quad strip?                  (2 + FAST_SPHERE_SLICES) * 2 +                  //the two triangle fans at top and bottom of sphere.                  (2 + FAST_SPHERE_SLICES * 2) * (FAST_SPHERE_STACKS - 2);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawSphereDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=       //each stack is a separate tri fan / quad strip?                  (2 + FAST_SPHERE_SLICES) * 2 +                  //the two triangle fans at top and bottom of sphere.                  (2 + FAST_SPHERE_SLICES * 2) * (FAST_SPHERE_STACKS - 2);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawSphereDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=       //each stack is a separate tri fan / quad strip?                  (2 + FAST_SPHERE_SLICES) * 2 +                  //the two triangle fans at top and bottom of sphere.                  (2 + FAST_SPHERE_SLICES * 2) * (FAST_SPHERE_STACKS - 2);
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCone,The following statement contains a magic number: Util3D.RenderStats.VertexCount += (2 + slices * 2) * stacks;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCone,The following statement contains a magic number: Util3D.RenderStats.VertexCount += (2 + slices * 2) * stacks;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawConeDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount += (2 + FAST_CONE_SLICES * 2) * FAST_CONE_STACKS;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawConeDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount += (2 + FAST_CONE_SLICES * 2) * FAST_CONE_STACKS;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCylinder,The following statement contains a magic number: Util3D.RenderStats.PrimCount += slices * stacks + 2 * slices;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCylinder,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=                  (2 + slices * 2) * stacks + //quad strips for the sides of the cylinder                  (2 + slices) * 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCylinder,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=                  (2 + slices * 2) * stacks + //quad strips for the sides of the cylinder                  (2 + slices) * 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCylinder,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=                  (2 + slices * 2) * stacks + //quad strips for the sides of the cylinder                  (2 + slices) * 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCylinder,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=                  (2 + slices * 2) * stacks + //quad strips for the sides of the cylinder                  (2 + slices) * 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCylinderDisplayList,The following statement contains a magic number: Util3D.RenderStats.PrimCount +=                  FAST_CYLINDER_SLICES * FAST_CYLINDER_STACKS + 2 * FAST_CYLINDER_SLICES;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCylinderDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=                  (2 + FAST_CYLINDER_SLICES * 2) * FAST_CYLINDER_STACKS + //quad strips for the sides                  (2 + FAST_CYLINDER_SLICES) * 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCylinderDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=                  (2 + FAST_CYLINDER_SLICES * 2) * FAST_CYLINDER_STACKS + //quad strips for the sides                  (2 + FAST_CYLINDER_SLICES) * 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCylinderDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=                  (2 + FAST_CYLINDER_SLICES * 2) * FAST_CYLINDER_STACKS + //quad strips for the sides                  (2 + FAST_CYLINDER_SLICES) * 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawCylinderDisplayList,The following statement contains a magic number: Util3D.RenderStats.VertexCount +=                  (2 + FAST_CYLINDER_SLICES * 2) * FAST_CYLINDER_STACKS + //quad strips for the sides                  (2 + FAST_CYLINDER_SLICES) * 2;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawHatchedFrame,The following statement contains a magic number: unchecked { Gl.glLineStipple(4' (short)0xAAAA); }
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawHatchedFrame,The following statement contains a magic number: float x1 = first.X * ooWidth * 2 - 1;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawHatchedFrame,The following statement contains a magic number: float x2 = current.X * ooWidth * 2 - 1;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawHatchedFrame,The following statement contains a magic number: float y1 = first.Y * ooHeight * -2 + 1;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawHatchedFrame,The following statement contains a magic number: float y2 = current.Y * ooHeight * -2 + 1;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawHatchedFrame,The following statement contains a magic number: Util3D.RenderStats.VertexCount += 4;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,LookAtMatrix,The following statement contains a magic number: if (Math.Abs(Vec3F.Dot(yAxis' viewDirection)) < 0.98)              {                  s = Vec3F.Cross(yAxis' viewDirection); //x' = y X z              }              else              {                  // viewDirection == yAxis                  s = Vec3F.Cross(viewDirection' xAxis); //x' = y X x              }
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[0][0] = v[1][0] = v[2][0] = v[3][0] = -0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[0][0] = v[1][0] = v[2][0] = v[3][0] = -0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[4][0] = v[5][0] = v[6][0] = v[7][0] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[4][0] = v[5][0] = v[6][0] = v[7][0] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[4][0] = v[5][0] = v[6][0] = v[7][0] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[4][0] = v[5][0] = v[6][0] = v[7][0] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[0][1] = v[1][1] = v[4][1] = v[5][1] = -0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[0][1] = v[1][1] = v[4][1] = v[5][1] = -0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[2][1] = v[3][1] = v[6][1] = v[7][1] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[2][1] = v[3][1] = v[6][1] = v[7][1] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[2][1] = v[3][1] = v[6][1] = v[7][1] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[2][1] = v[3][1] = v[6][1] = v[7][1] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[0][2] = v[3][2] = v[4][2] = v[7][2] = -0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[0][2] = v[3][2] = v[4][2] = v[7][2] = -0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[0][2] = v[3][2] = v[4][2] = v[7][2] = -0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[0][2] = v[3][2] = v[4][2] = v[7][2] = -0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[0][2] = v[3][2] = v[4][2] = v[7][2] = -0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[0][2] = v[3][2] = v[4][2] = v[7][2] = -0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[0][2] = v[3][2] = v[4][2] = v[7][2] = -0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[1][2] = v[2][2] = v[5][2] = v[6][2] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[1][2] = v[2][2] = v[5][2] = v[6][2] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[1][2] = v[2][2] = v[5][2] = v[6][2] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[1][2] = v[2][2] = v[5][2] = v[6][2] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[1][2] = v[2][2] = v[5][2] = v[6][2] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[1][2] = v[2][2] = v[5][2] = v[6][2] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: v[1][2] = v[2][2] = v[5][2] = v[6][2] = 0.5f;
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: for (int i = 5; i >= 0; i--)              {                  Gl.glBegin(type);                  Gl.glNormal3fv(n[i]);                  Gl.glVertex3fv(v[faces[i' 0]]);                  Gl.glVertex3fv(v[faces[i' 1]]);                  Gl.glVertex3fv(v[faces[i' 2]]);                  Gl.glVertex3fv(v[faces[i' 3]]);                  Gl.glEnd();              }
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: for (int i = 5; i >= 0; i--)              {                  Gl.glBegin(type);                  Gl.glNormal3fv(n[i]);                  Gl.glVertex3fv(v[faces[i' 0]]);                  Gl.glVertex3fv(v[faces[i' 1]]);                  Gl.glVertex3fv(v[faces[i' 2]]);                  Gl.glVertex3fv(v[faces[i' 3]]);                  Gl.glEnd();              }
Magic Number,Sce.Atf.Rendering.OpenGL,Util3D,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\Util3D.cs,DrawUnitBox,The following statement contains a magic number: for (int i = 5; i >= 0; i--)              {                  Gl.glBegin(type);                  Gl.glNormal3fv(n[i]);                  Gl.glVertex3fv(v[faces[i' 0]]);                  Gl.glVertex3fv(v[faces[i' 1]]);                  Gl.glVertex3fv(v[faces[i' 2]]);                  Gl.glVertex3fv(v[faces[i' 3]]);                  Gl.glEnd();              }
Magic Number,Sce.Atf.Rendering.OpenGL,VboManager,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\VboManager.cs,CreateVbo,The following statement contains a magic number: if (!m_vboMap.TryGetValue(dataId' out name))              {                  Gl.glGenBuffersARB(1' out name);                  Gl.glBindBufferARB(Gl.GL_ARRAY_BUFFER_ARB' name);                  Gl.glBufferDataARB(Gl.GL_ARRAY_BUFFER_ARB' new IntPtr(data.Length * 4)'                      data' Gl.GL_STATIC_DRAW_ARB);                    m_vboMap[dataId] = name;                    List<Binding> vboList;                  if (!m_vboContexts.TryGetValue(contextId' out vboList))                  {                      vboList = new List<Binding>();                      m_vboContexts[contextId] = vboList;                  }                  vboList.Add(new Binding(dataId' name));                                }
Magic Number,Sce.Atf.Rendering.Dom,DesignControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DesignControl.cs,RenderAxisSystem,The following statement contains a magic number: if (Camera.Frustum.IsOrtho)              {                  width = (Camera.Frustum.Right - Camera.Frustum.Left) / 2 * 0.95f;                  height = (Camera.Frustum.Top - Camera.Frustum.Bottom) / 2 * 0.90f;              }              else              {                  //  Set the projection to orthogonal for perspective views                  float h = (float)Height / (float)Width;                    Gl.glMatrixMode(Gl.GL_PROJECTION);                  Gl.glLoadIdentity();                    Gl.glOrtho(-1' 1' -h' h' 1'1000);                  nearP = 1.1f;                  width = 0.92f;                  height = h * 0.90f;              }
Magic Number,Sce.Atf.Rendering.Dom,DesignControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DesignControl.cs,RenderAxisSystem,The following statement contains a magic number: if (Camera.Frustum.IsOrtho)              {                  width = (Camera.Frustum.Right - Camera.Frustum.Left) / 2 * 0.95f;                  height = (Camera.Frustum.Top - Camera.Frustum.Bottom) / 2 * 0.90f;              }              else              {                  //  Set the projection to orthogonal for perspective views                  float h = (float)Height / (float)Width;                    Gl.glMatrixMode(Gl.GL_PROJECTION);                  Gl.glLoadIdentity();                    Gl.glOrtho(-1' 1' -h' h' 1'1000);                  nearP = 1.1f;                  width = 0.92f;                  height = h * 0.90f;              }
Magic Number,Sce.Atf.Rendering.Dom,DesignControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DesignControl.cs,RenderAxisSystem,The following statement contains a magic number: if (Camera.Frustum.IsOrtho)              {                  width = (Camera.Frustum.Right - Camera.Frustum.Left) / 2 * 0.95f;                  height = (Camera.Frustum.Top - Camera.Frustum.Bottom) / 2 * 0.90f;              }              else              {                  //  Set the projection to orthogonal for perspective views                  float h = (float)Height / (float)Width;                    Gl.glMatrixMode(Gl.GL_PROJECTION);                  Gl.glLoadIdentity();                    Gl.glOrtho(-1' 1' -h' h' 1'1000);                  nearP = 1.1f;                  width = 0.92f;                  height = h * 0.90f;              }
Magic Number,Sce.Atf.Rendering.Dom,DesignControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DesignControl.cs,RenderAxisSystem,The following statement contains a magic number: RenderAxis(width/15);
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,PickAction,The following statement contains a magic number: m_selectionBuffer = new int[65536];
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,Init,The following statement contains a magic number: Gl.glSelectBuffer(65536' m_selectionBuffer);
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,Init,The following statement contains a magic number: int[] viewPort = new int[4];
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,Init,The following statement contains a magic number: viewPort[2] = m_width;
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,Init,The following statement contains a magic number: viewPort[3] = m_height;
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,SetupProjection,The following statement contains a magic number: if (camera.Frustum.IsOrtho)              {                  Gl.glOrtho(                      camera.Frustum.Left'                      camera.Frustum.Right'                      camera.Frustum.Bottom'                      camera.Frustum.Top'                      camera.Frustum.Near'                      camera.Frustum.Far);                }              else              {                  Glu.gluPerspective(                      camera.Frustum.FovY * 180 / Math.PI'                      (double)m_width / (double)m_height'                      camera.Frustum.Near'                      camera.Frustum.Far);              }
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,GetWorldIntersectionFromScreen,The following statement contains a magic number: double winY = (double)viewport[3] - (double)screenY;
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,PopulateOpenGlSelection,The following statement contains a magic number: if (m_frustumPick == false)              {                  Gl.glViewport(0' 0' m_width' m_height);                  Gl.glMatrixMode(Gl.GL_PROJECTION);                  Gl.glLoadIdentity();                  Util3D.glMultMatrixf(m_projectionMatrix);                    Gl.glMatrixMode(Gl.GL_MODELVIEW);                  Gl.glLoadIdentity();                  Util3D.glMultMatrixf(m_viewMatrix);                    viewMat = new double[16];                  Gl.glGetDoublev(Gl.GL_MODELVIEW_MATRIX' viewMat);                    projectionMat = new double[16];                  Gl.glGetDoublev(Gl.GL_PROJECTION_MATRIX' projectionMat);                    viewport = new int[4];                  viewport[0] = viewport[1] = 0;                  viewport[2] = m_width;                  viewport[3] = m_height;              }
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,PopulateOpenGlSelection,The following statement contains a magic number: if (m_frustumPick == false)              {                  Gl.glViewport(0' 0' m_width' m_height);                  Gl.glMatrixMode(Gl.GL_PROJECTION);                  Gl.glLoadIdentity();                  Util3D.glMultMatrixf(m_projectionMatrix);                    Gl.glMatrixMode(Gl.GL_MODELVIEW);                  Gl.glLoadIdentity();                  Util3D.glMultMatrixf(m_viewMatrix);                    viewMat = new double[16];                  Gl.glGetDoublev(Gl.GL_MODELVIEW_MATRIX' viewMat);                    projectionMat = new double[16];                  Gl.glGetDoublev(Gl.GL_PROJECTION_MATRIX' projectionMat);                    viewport = new int[4];                  viewport[0] = viewport[1] = 0;                  viewport[2] = m_width;                  viewport[3] = m_height;              }
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,PopulateOpenGlSelection,The following statement contains a magic number: if (m_frustumPick == false)              {                  Gl.glViewport(0' 0' m_width' m_height);                  Gl.glMatrixMode(Gl.GL_PROJECTION);                  Gl.glLoadIdentity();                  Util3D.glMultMatrixf(m_projectionMatrix);                    Gl.glMatrixMode(Gl.GL_MODELVIEW);                  Gl.glLoadIdentity();                  Util3D.glMultMatrixf(m_viewMatrix);                    viewMat = new double[16];                  Gl.glGetDoublev(Gl.GL_MODELVIEW_MATRIX' viewMat);                    projectionMat = new double[16];                  Gl.glGetDoublev(Gl.GL_PROJECTION_MATRIX' projectionMat);                    viewport = new int[4];                  viewport[0] = viewport[1] = 0;                  viewport[2] = m_width;                  viewport[3] = m_height;              }
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,PopulateOpenGlSelection,The following statement contains a magic number: if (m_frustumPick == false)              {                  Gl.glViewport(0' 0' m_width' m_height);                  Gl.glMatrixMode(Gl.GL_PROJECTION);                  Gl.glLoadIdentity();                  Util3D.glMultMatrixf(m_projectionMatrix);                    Gl.glMatrixMode(Gl.GL_MODELVIEW);                  Gl.glLoadIdentity();                  Util3D.glMultMatrixf(m_viewMatrix);                    viewMat = new double[16];                  Gl.glGetDoublev(Gl.GL_MODELVIEW_MATRIX' viewMat);                    projectionMat = new double[16];                  Gl.glGetDoublev(Gl.GL_PROJECTION_MATRIX' projectionMat);                    viewport = new int[4];                  viewport[0] = viewport[1] = 0;                  viewport[2] = m_width;                  viewport[3] = m_height;              }
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,PopulateOpenGlSelection,The following statement contains a magic number: if (m_frustumPick == false)              {                  Gl.glViewport(0' 0' m_width' m_height);                  Gl.glMatrixMode(Gl.GL_PROJECTION);                  Gl.glLoadIdentity();                  Util3D.glMultMatrixf(m_projectionMatrix);                    Gl.glMatrixMode(Gl.GL_MODELVIEW);                  Gl.glLoadIdentity();                  Util3D.glMultMatrixf(m_viewMatrix);                    viewMat = new double[16];                  Gl.glGetDoublev(Gl.GL_MODELVIEW_MATRIX' viewMat);                    projectionMat = new double[16];                  Gl.glGetDoublev(Gl.GL_PROJECTION_MATRIX' projectionMat);                    viewport = new int[4];                  viewport[0] = viewport[1] = 0;                  viewport[2] = m_width;                  viewport[3] = m_height;              }
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,PopulateOpenGlSelection,The following statement contains a magic number: for (int i = 0; i < m_openGlHits; ++i)              {                  uint nameCount = (uint)m_selectionBuffer[start];                    if (nameCount > 0)                  {                      uint travNodeIndex = (uint)m_selectionBuffer[start + 3];                      TraverseNode travNode = travArray[travNodeIndex];                      HitRecord hitRecord;                      if (m_frustumPick)                      {                          hitRecord = new HitRecord(                              travNode.GraphPath'                              travNode.RenderObject'                              new Matrix4F(travNode.Transform)'                              new uint[nameCount - 1]);                      }                      else                      {                          hitRecord = new HitRecord(                              travNode.GraphPath'                              travNode.RenderObject'                              new Matrix4F(travNode.Transform)'                              new uint[nameCount - 1]);                            // Transform screen to world and record world-space intersection point.                          float zMin = ((float)((uint)m_selectionBuffer[start + 1])) / 0xFFFFFFFF;                          Vec3F intersectionPt = GetWorldIntersectionFromScreen(                              m_x' m_y' zMin'                              viewMat' projectionMat' viewport);                          hitRecord.WorldIntersection = intersectionPt;                      }                        // Populate object data                      for (uint j = 0; j < nameCount - 1; j++)                      {                          hitRecord.RenderObjectData[j] = (uint)m_selectionBuffer[start + 4 + j];                      }                        selectionList.Add(hitRecord);                        start += 3 + nameCount;                  }              }
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,PopulateOpenGlSelection,The following statement contains a magic number: for (int i = 0; i < m_openGlHits; ++i)              {                  uint nameCount = (uint)m_selectionBuffer[start];                    if (nameCount > 0)                  {                      uint travNodeIndex = (uint)m_selectionBuffer[start + 3];                      TraverseNode travNode = travArray[travNodeIndex];                      HitRecord hitRecord;                      if (m_frustumPick)                      {                          hitRecord = new HitRecord(                              travNode.GraphPath'                              travNode.RenderObject'                              new Matrix4F(travNode.Transform)'                              new uint[nameCount - 1]);                      }                      else                      {                          hitRecord = new HitRecord(                              travNode.GraphPath'                              travNode.RenderObject'                              new Matrix4F(travNode.Transform)'                              new uint[nameCount - 1]);                            // Transform screen to world and record world-space intersection point.                          float zMin = ((float)((uint)m_selectionBuffer[start + 1])) / 0xFFFFFFFF;                          Vec3F intersectionPt = GetWorldIntersectionFromScreen(                              m_x' m_y' zMin'                              viewMat' projectionMat' viewport);                          hitRecord.WorldIntersection = intersectionPt;                      }                        // Populate object data                      for (uint j = 0; j < nameCount - 1; j++)                      {                          hitRecord.RenderObjectData[j] = (uint)m_selectionBuffer[start + 4 + j];                      }                        selectionList.Add(hitRecord);                        start += 3 + nameCount;                  }              }
Magic Number,Sce.Atf.Rendering.Dom,PickAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\PickAction.cs,PopulateOpenGlSelection,The following statement contains a magic number: for (int i = 0; i < m_openGlHits; ++i)              {                  uint nameCount = (uint)m_selectionBuffer[start];                    if (nameCount > 0)                  {                      uint travNodeIndex = (uint)m_selectionBuffer[start + 3];                      TraverseNode travNode = travArray[travNodeIndex];                      HitRecord hitRecord;                      if (m_frustumPick)                      {                          hitRecord = new HitRecord(                              travNode.GraphPath'                              travNode.RenderObject'                              new Matrix4F(travNode.Transform)'                              new uint[nameCount - 1]);                      }                      else                      {                          hitRecord = new HitRecord(                              travNode.GraphPath'                              travNode.RenderObject'                              new Matrix4F(travNode.Transform)'                              new uint[nameCount - 1]);                            // Transform screen to world and record world-space intersection point.                          float zMin = ((float)((uint)m_selectionBuffer[start + 1])) / 0xFFFFFFFF;                          Vec3F intersectionPt = GetWorldIntersectionFromScreen(                              m_x' m_y' zMin'                              viewMat' projectionMat' viewport);                          hitRecord.WorldIntersection = intersectionPt;                      }                        // Populate object data                      for (uint j = 0; j < nameCount - 1; j++)                      {                          hitRecord.RenderObjectData[j] = (uint)m_selectionBuffer[start + 4 + j];                      }                        selectionList.Add(hitRecord);                        start += 3 + nameCount;                  }              }
Magic Number,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,PreDispatch,The following statement contains a magic number: Gl.glClearColor(                  backgroundColor.R * (1.0f / 255)'                  backgroundColor.G * (1.0f / 255)'                  backgroundColor.B * (1.0f / 255)'                  0);
Magic Number,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,PreDispatch,The following statement contains a magic number: Gl.glClearColor(                  backgroundColor.R * (1.0f / 255)'                  backgroundColor.G * (1.0f / 255)'                  backgroundColor.B * (1.0f / 255)'                  0);
Magic Number,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,PreDispatch,The following statement contains a magic number: Gl.glClearColor(                  backgroundColor.R * (1.0f / 255)'                  backgroundColor.G * (1.0f / 255)'                  backgroundColor.B * (1.0f / 255)'                  0);
Magic Number,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,DrawStats,The following statement contains a magic number: double nearP = camera.Frustum.Near + Math.Abs(camera.Frustum.Near * 0.05);
Magic Number,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,DrawStats,The following statement contains a magic number: if (camera.Frustum.IsOrtho)              {                  width = (camera.Frustum.Right - camera.Frustum.Left) / 2 * 0.95f;                  height = (camera.Frustum.Top - camera.Frustum.Bottom) / 2 * 0.95f;              }              else              {                  width = nearP * Math.Tan(camera.Frustum.FovX / 2) * 0.95;                  height = nearP * Math.Tan(camera.Frustum.FovY / 2) * 0.95;              }
Magic Number,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,DrawStats,The following statement contains a magic number: if (camera.Frustum.IsOrtho)              {                  width = (camera.Frustum.Right - camera.Frustum.Left) / 2 * 0.95f;                  height = (camera.Frustum.Top - camera.Frustum.Bottom) / 2 * 0.95f;              }              else              {                  width = nearP * Math.Tan(camera.Frustum.FovX / 2) * 0.95;                  height = nearP * Math.Tan(camera.Frustum.FovY / 2) * 0.95;              }
Magic Number,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,DrawStats,The following statement contains a magic number: if (camera.Frustum.IsOrtho)              {                  width = (camera.Frustum.Right - camera.Frustum.Left) / 2 * 0.95f;                  height = (camera.Frustum.Top - camera.Frustum.Bottom) / 2 * 0.95f;              }              else              {                  width = nearP * Math.Tan(camera.Frustum.FovX / 2) * 0.95;                  height = nearP * Math.Tan(camera.Frustum.FovY / 2) * 0.95;              }
Magic Number,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,DrawStats,The following statement contains a magic number: if (camera.Frustum.IsOrtho)              {                  width = (camera.Frustum.Right - camera.Frustum.Left) / 2 * 0.95f;                  height = (camera.Frustum.Top - camera.Frustum.Bottom) / 2 * 0.95f;              }              else              {                  width = nearP * Math.Tan(camera.Frustum.FovX / 2) * 0.95;                  height = nearP * Math.Tan(camera.Frustum.FovY / 2) * 0.95;              }
Magic Number,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,DrawStats,The following statement contains a magic number: if (camera.Frustum.IsOrtho)              {                  width = (camera.Frustum.Right - camera.Frustum.Left) / 2 * 0.95f;                  height = (camera.Frustum.Top - camera.Frustum.Bottom) / 2 * 0.95f;              }              else              {                  width = nearP * Math.Tan(camera.Frustum.FovX / 2) * 0.95;                  height = nearP * Math.Tan(camera.Frustum.FovY / 2) * 0.95;              }
Magic Number,Sce.Atf.Rendering.Dom,RenderAction,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\RenderAction.cs,DrawStats,The following statement contains a magic number: if (camera.Frustum.IsOrtho)              {                  width = (camera.Frustum.Right - camera.Frustum.Left) / 2 * 0.95f;                  height = (camera.Frustum.Top - camera.Frustum.Bottom) / 2 * 0.95f;              }              else              {                  width = nearP * Math.Tan(camera.Frustum.FovX / 2) * 0.95;                  height = nearP * Math.Tan(camera.Frustum.FovY / 2) * 0.95;              }
Magic Number,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,RenderXArrow,The following statement contains a magic number: Gl.glRotatef(90' 0' 1' 0);
Magic Number,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,RenderXArrow,The following statement contains a magic number: Util3D.DrawConeDisplayList(s / 20' s / 8' Util3D.RenderStyle.Solid);
Magic Number,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,RenderXArrow,The following statement contains a magic number: Util3D.DrawConeDisplayList(s / 20' s / 8' Util3D.RenderStyle.Solid);
Magic Number,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,RenderYArrow,The following statement contains a magic number: Gl.glRotatef(-90' 1' 0' 0);
Magic Number,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,RenderYArrow,The following statement contains a magic number: Util3D.DrawConeDisplayList(s / 20' s / 8' Util3D.RenderStyle.Solid);
Magic Number,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,RenderYArrow,The following statement contains a magic number: Util3D.DrawConeDisplayList(s / 20' s / 8' Util3D.RenderStyle.Solid);
Magic Number,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,RenderZArrow,The following statement contains a magic number: Util3D.DrawConeDisplayList(s / 20' s / 8' Util3D.RenderStyle.Solid);
Magic Number,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,RenderZArrow,The following statement contains a magic number: Util3D.DrawConeDisplayList(s / 20' s / 8' Util3D.RenderStyle.Solid);
Magic Number,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,CalcAxisLengths,The following statement contains a magic number: if (camera.Frustum.IsOrtho)              {                  worldHeight = (camera.Frustum.Top - camera.Frustum.Bottom) / 2;              }              else              {                  worldHeight = -V.ZTranslation * (float)Math.Tan(camera.Frustum.FovY / 2.0f);              }
Missing Default,Sce.Atf.Rendering,DdsCompressor,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\DdsCompressor.cs,Compress,The following switch statement is missing a default case: switch (type)              {                  case CompressionType.DXT1:                      format = DDSUtils.TextureFormat.kDXT1;                      break;                    case CompressionType.DXT3:                      format = DDSUtils.TextureFormat.kDXT3;                      break;                    case CompressionType.DXT5:                      format = DDSUtils.TextureFormat.kDXT5;                      break;              }
Missing Default,Sce.Atf.Rendering.Dom,TranslatorControl,C:\repos\SonyWWS_ATF\Framework\Atf.Gui.OpenGL\TranslatorControl.cs,OnDrag,The following switch statement is missing a default case: switch ((HitElement)hit.RenderObjectData[1])              {                  case HitElement.X_ARROW:                      {                          a1 = Math.Abs(Vec3F.Dot(ray0.Direction' yAxis));                          a2 = Math.Abs(Vec3F.Dot(ray0.Direction' zAxis));                          Vec3F axis = (a1 > a2 ? yAxis : zAxis);                          Vec3F p0 = ray0.IntersectPlane(axis' -Vec3F.Dot(axis' origin));                          Vec3F p1 = ray.IntersectPlane(axis' -Vec3F.Dot(axis' origin));                          float dragAmount = Vec3F.Dot(xAxis' p1 - p0);                          Vec3F xLocal = transform.XAxis;                          trans = dragAmount * xLocal;                      }                      break;                    case HitElement.Y_ARROW:                      {                          a1 = Math.Abs(Vec3F.Dot(ray0.Direction' zAxis));                          a2 = Math.Abs(Vec3F.Dot(ray0.Direction' xAxis));                          Vec3F axis = (a1 > a2 ? zAxis : xAxis);                          Vec3F p0 = ray0.IntersectPlane(axis' -Vec3F.Dot(axis' origin));                          Vec3F p1 = ray.IntersectPlane(axis' -Vec3F.Dot(axis' origin));                          float dragAmount = Vec3F.Dot(yAxis' p1 - p0);                          Vec3F yLocal = transform.YAxis;                          trans = dragAmount * yLocal;                      }                      break;                    case HitElement.Z_ARROW:                      {                          a1 = Math.Abs(Vec3F.Dot(ray0.Direction' xAxis));                          a2 = Math.Abs(Vec3F.Dot(ray0.Direction' yAxis));                          Vec3F axis = (a1 > a2 ? xAxis : yAxis);                          Vec3F p0 = ray0.IntersectPlane(axis' -Vec3F.Dot(axis' origin));                          Vec3F p1 = ray.IntersectPlane(axis' -Vec3F.Dot(axis' origin));                          float dragAmount = Vec3F.Dot(zAxis' p1 - p0);                          Vec3F zLocal = transform.ZAxis;                          trans = dragAmount * zLocal;                      }                      break;                                    case HitElement.XY_SQUARE:                      {                          Vec3F p0 = ray0.IntersectPlane(zAxis' -Vec3F.Dot(zAxis' origin));                          Vec3F p1 = ray.IntersectPlane(zAxis' -Vec3F.Dot(zAxis' origin));                          Vec3F deltaLocal = p1 - p0;                          float dragX = Vec3F.Dot(xAxis' deltaLocal);                          float dragY = Vec3F.Dot(yAxis' deltaLocal);                          Vec3F xLocal = transform.XAxis;                          Vec3F yLocal = transform.YAxis;                          trans = dragX * xLocal + dragY * yLocal;                      }                      break;                    case HitElement.YZ_SQUARE:                      {                          Vec3F p0 = ray0.IntersectPlane(xAxis' -Vec3F.Dot(xAxis' origin));                          Vec3F p1 = ray.IntersectPlane(xAxis' -Vec3F.Dot(xAxis' origin));                          Vec3F deltaLocal = p1 - p0;                          float dragY = Vec3F.Dot(yAxis' deltaLocal);                          float dragZ = Vec3F.Dot(zAxis' deltaLocal);                          Vec3F yLocal = transform.YAxis;                          Vec3F zLocal = transform.ZAxis;                          trans = dragY * yLocal + dragZ * zLocal;                      }                      break;                    case HitElement.XZ_SQUARE:                      {                          Vec3F p0 = ray0.IntersectPlane(yAxis' -Vec3F.Dot(yAxis' origin));                          Vec3F p1 = ray.IntersectPlane(yAxis' -Vec3F.Dot(yAxis' origin));                          Vec3F deltaLocal = p1 - p0;                          float dragX = Vec3F.Dot(xAxis' deltaLocal);                          float dragZ = Vec3F.Dot(zAxis' deltaLocal);                          Vec3F xLocal = transform.XAxis;                          Vec3F zLocal = transform.ZAxis;                          trans = dragX * xLocal + dragZ * zLocal;                      }                      break;              }
